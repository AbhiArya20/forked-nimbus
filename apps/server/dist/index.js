// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var util4 = __require("util");
  module.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util4.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message2));
  };
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var util4 = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util4.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message2 = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message2));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types3) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types3[extension2]) {
          var from = preference.indexOf(db[types3[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types3[extension2] !== "application/octet-stream" && (from > to || from === to && types3[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types3[extension2] = type;
      }
    });
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
  module.exports = defer;
  function defer(fn) {
    var nextTick2 = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick2) {
      nextTick2(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports, module) => {
  var defer = require_defer();
  module.exports = async;
  function async(callback) {
    var isAsync3 = false;
    defer(function() {
      isAsync3 = true;
    });
    return function async_callback(err, result) {
      if (isAsync3) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  module.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean2.bind(state));
    state.jobs = {};
  }
  function clean2(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var async = require_async();
  var abort = require_abort();
  module.exports = iterate;
  function iterate(list, iterator2, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator2, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator2, key, item, callback) {
    var aborter;
    if (iterator2.length == 2) {
      aborter = iterator2(item, async(callback));
    } else {
      aborter = iterator2(item, key, async(callback));
    }
    return aborter;
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  module.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var abort = require_abort();
  var async = require_async();
  module.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
  function parallel(list, iterator2, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator2, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
  function serialOrdered(list, iterator2, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator2, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator2, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serialOrdered = require_serialOrdered();
  module.exports = serial2;
  function serial2(list, iterator2, callback) {
    return serialOrdered(list, iterator2, null, callback);
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind2 = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind2.call($call, $apply);
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind2 = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc2 = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc2 && typeof desc2.get === "function" ? callBind([desc2.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = require_function_bind();
  module.exports = bind2.call(call, $hasOwn);
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign2 = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc2 = $gOPD(value, part);
          isOwn = !!desc2;
          if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
            value = desc2.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// ../../node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = require_shams2()();
  var hasOwn = require_hasown();
  var $TypeError = require_type();
  var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
  module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag2, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag2] = value;
      }
    }
  };
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var CombinedStream = require_combined_stream();
  var util4 = __require("util");
  var path = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs = __require("fs");
  var Stream = __require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var setToStringTag = require_es_set_tostringtag();
  var hasOwn = require_hasown();
  var populate = require_populate();
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  util4.inherits(FormData2, CombinedStream);
  FormData2.LINE_BREAK = `\r
`;
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options === "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value === "number" || value == null) {
      value = String(value);
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, "fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          if (err) {
            callback(err);
            return;
          }
          var fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (hasOwn(value, "httpVersion")) {
      callback(null, Number(value.headers["content-length"]));
    } else if (hasOwn(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, Number(response.headers["content-length"]));
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header === "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header === "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (hasOwn(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value && (value.name || value.path)) {
      filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, "httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      return 'filename="' + filename + '"';
    }
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && value && typeof value === "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (hasOwn(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== "string") {
      throw new TypeError("FormData boundary must be a string");
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length;i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0;i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = { method: "post" };
    if (typeof params === "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol === "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol === "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
  module.exports = FormData2;
});

// ../../node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
  var parseUrl = __require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url2) {
    var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  exports.getProxyForUrl = getProxyForUrl;
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign2) => (sign2 in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util4 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util4.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util4.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util4.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util4.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug;
  module.exports = function() {
    if (!debug) {
      try {
        debug = require_src()("follow-redirects");
      } catch (error) {}
      if (typeof debug !== "function") {
        debug = function() {};
      }
    }
    debug.apply(null, arguments);
  };
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports, module) => {
  var url2 = __require("url");
  var URL2 = url2.URL;
  var http = __require("http");
  var https = __require("https");
  var Writable = __require("stream").Writable;
  var assert = __require("assert");
  var debug = require_debug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError;
    }
    if (!isString2(data) && !isBuffer2(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError);
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction2(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : this._options.path;
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError;
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports2 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports2.maxRedirects,
          maxBodyLength: exports2.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports2;
  }
  function noop2() {}
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url2.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
  }
  function createErrorType(code, message2, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message2 + ": " + this.cause.message : message2;
    }
    CustomError.prototype = new (baseClass || Error);
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop2);
    request.destroy(error);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  module.exports = wrap({ http, https });
  module.exports.wrap = wrap;
});

// ../../node_modules/kysely/dist/esm/util/object-utils.js
function isUndefined2(obj) {
  return typeof obj === "undefined" || obj === undefined;
}
function isString2(obj) {
  return typeof obj === "string";
}
function isNumber2(obj) {
  return typeof obj === "number";
}
function isBoolean2(obj) {
  return typeof obj === "boolean";
}
function isNull2(obj) {
  return obj === null;
}
function isDate2(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isBuffer2(obj) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(obj);
}
function isFunction3(obj) {
  return typeof obj === "function";
}
function isObject3(obj) {
  return typeof obj === "object" && obj !== null;
}
function isPlainObject3(obj) {
  if (!isObject3(obj) || getTag(obj) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(obj) === null) {
    return true;
  }
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function getLast(arr) {
  return arr[arr.length - 1];
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop2(obj) {
  return obj;
}
function compare(obj1, obj2) {
  if (isReadonlyArray(obj1) && isReadonlyArray(obj2)) {
    return compareArrays(obj1, obj2);
  } else if (isObject3(obj1) && isObject3(obj2)) {
    return compareObjects(obj1, obj2);
  }
  return obj1 === obj2;
}
function compareArrays(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0;i < arr1.length; ++i) {
    if (!compare(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
function compareObjects(obj1, obj2) {
  if (isBuffer2(obj1) && isBuffer2(obj2)) {
    return compareBuffers(obj1, obj2);
  } else if (isDate2(obj1) && isDate2(obj2)) {
    return compareDates(obj1, obj2);
  }
  return compareGenericObjects(obj1, obj2);
}
function compareBuffers(buf1, buf2) {
  return Buffer.compare(buf1, buf2) === 0;
}
function compareDates(date1, date2) {
  return date1.getTime() === date2.getTime();
}
function compareGenericObjects(obj1, obj2) {
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    if (!compare(obj1[key], obj2[key])) {
      return false;
    }
  }
  return true;
}
function getTag(value) {
  if (value == null) {
    return value === undefined ? "[object Undefined]" : "[object Null]";
  }
  return toString3.call(value);
}
var toString3;
var init_object_utils = __esm(() => {
  toString3 = Object.prototype.toString;
});

// ../../node_modules/kysely/dist/esm/operation-node/alter-table-node.js
var AlterTableNode;
var init_alter_table_node = __esm(() => {
  init_object_utils();
  AlterTableNode = freeze({
    is(node) {
      return node.kind === "AlterTableNode";
    },
    create(table) {
      return freeze({
        kind: "AlterTableNode",
        table
      });
    },
    cloneWithTableProps(node, props) {
      return freeze({
        ...node,
        ...props
      });
    },
    cloneWithColumnAlteration(node, columnAlteration) {
      return freeze({
        ...node,
        columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/identifier-node.js
var IdentifierNode;
var init_identifier_node = __esm(() => {
  init_object_utils();
  IdentifierNode = freeze({
    is(node) {
      return node.kind === "IdentifierNode";
    },
    create(name) {
      return freeze({
        kind: "IdentifierNode",
        name
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/create-index-node.js
var CreateIndexNode;
var init_create_index_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  CreateIndexNode = freeze({
    is(node) {
      return node.kind === "CreateIndexNode";
    },
    create(name) {
      return freeze({
        kind: "CreateIndexNode",
        name: IdentifierNode.create(name)
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    },
    cloneWithColumns(node, columns) {
      return freeze({
        ...node,
        columns: [...node.columns || [], ...columns]
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/create-schema-node.js
var CreateSchemaNode;
var init_create_schema_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  CreateSchemaNode = freeze({
    is(node) {
      return node.kind === "CreateSchemaNode";
    },
    create(schema2, params) {
      return freeze({
        kind: "CreateSchemaNode",
        schema: IdentifierNode.create(schema2),
        ...params
      });
    },
    cloneWith(createSchema, params) {
      return freeze({
        ...createSchema,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/create-table-node.js
var ON_COMMIT_ACTIONS, CreateTableNode;
var init_create_table_node = __esm(() => {
  init_object_utils();
  ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
  CreateTableNode = freeze({
    is(node) {
      return node.kind === "CreateTableNode";
    },
    create(table) {
      return freeze({
        kind: "CreateTableNode",
        table,
        columns: freeze([])
      });
    },
    cloneWithColumn(createTable, column) {
      return freeze({
        ...createTable,
        columns: freeze([...createTable.columns, column])
      });
    },
    cloneWithConstraint(createTable, constraint) {
      return freeze({
        ...createTable,
        constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
      });
    },
    cloneWithFrontModifier(createTable, modifier) {
      return freeze({
        ...createTable,
        frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
      });
    },
    cloneWithEndModifier(createTable, modifier) {
      return freeze({
        ...createTable,
        endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
      });
    },
    cloneWith(createTable, params) {
      return freeze({
        ...createTable,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/schemable-identifier-node.js
var SchemableIdentifierNode;
var init_schemable_identifier_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  SchemableIdentifierNode = freeze({
    is(node) {
      return node.kind === "SchemableIdentifierNode";
    },
    create(identifier) {
      return freeze({
        kind: "SchemableIdentifierNode",
        identifier: IdentifierNode.create(identifier)
      });
    },
    createWithSchema(schema2, identifier) {
      return freeze({
        kind: "SchemableIdentifierNode",
        schema: IdentifierNode.create(schema2),
        identifier: IdentifierNode.create(identifier)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-index-node.js
var DropIndexNode;
var init_drop_index_node = __esm(() => {
  init_object_utils();
  init_schemable_identifier_node();
  DropIndexNode = freeze({
    is(node) {
      return node.kind === "DropIndexNode";
    },
    create(name, params) {
      return freeze({
        kind: "DropIndexNode",
        name: SchemableIdentifierNode.create(name),
        ...params
      });
    },
    cloneWith(dropIndex, props) {
      return freeze({
        ...dropIndex,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-schema-node.js
var DropSchemaNode;
var init_drop_schema_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  DropSchemaNode = freeze({
    is(node) {
      return node.kind === "DropSchemaNode";
    },
    create(schema2, params) {
      return freeze({
        kind: "DropSchemaNode",
        schema: IdentifierNode.create(schema2),
        ...params
      });
    },
    cloneWith(dropSchema, params) {
      return freeze({
        ...dropSchema,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-table-node.js
var DropTableNode;
var init_drop_table_node = __esm(() => {
  init_object_utils();
  DropTableNode = freeze({
    is(node) {
      return node.kind === "DropTableNode";
    },
    create(table, params) {
      return freeze({
        kind: "DropTableNode",
        table,
        ...params
      });
    },
    cloneWith(dropIndex, params) {
      return freeze({
        ...dropIndex,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/alias-node.js
var AliasNode;
var init_alias_node = __esm(() => {
  init_object_utils();
  AliasNode = freeze({
    is(node) {
      return node.kind === "AliasNode";
    },
    create(node, alias) {
      return freeze({
        kind: "AliasNode",
        node,
        alias
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/table-node.js
var TableNode;
var init_table_node = __esm(() => {
  init_object_utils();
  init_schemable_identifier_node();
  TableNode = freeze({
    is(node) {
      return node.kind === "TableNode";
    },
    create(table) {
      return freeze({
        kind: "TableNode",
        table: SchemableIdentifierNode.create(table)
      });
    },
    createWithSchema(schema2, table) {
      return freeze({
        kind: "TableNode",
        table: SchemableIdentifierNode.createWithSchema(schema2, table)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/operation-node-source.js
function isOperationNodeSource(obj) {
  return isObject3(obj) && isFunction3(obj.toOperationNode);
}
var init_operation_node_source = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/expression/expression.js
function isExpression(obj) {
  return isObject3(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject3(obj) && "expression" in obj && isString2(obj.alias) && isOperationNodeSource(obj);
}
var init_expression = __esm(() => {
  init_operation_node_source();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/select-modifier-node.js
var SelectModifierNode;
var init_select_modifier_node = __esm(() => {
  init_object_utils();
  SelectModifierNode = freeze({
    is(node) {
      return node.kind === "SelectModifierNode";
    },
    create(modifier, of) {
      return freeze({
        kind: "SelectModifierNode",
        modifier,
        of
      });
    },
    createWithExpression(modifier) {
      return freeze({
        kind: "SelectModifierNode",
        rawModifier: modifier
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/and-node.js
var AndNode;
var init_and_node = __esm(() => {
  init_object_utils();
  AndNode = freeze({
    is(node) {
      return node.kind === "AndNode";
    },
    create(left, right) {
      return freeze({
        kind: "AndNode",
        left,
        right
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/or-node.js
var OrNode;
var init_or_node = __esm(() => {
  init_object_utils();
  OrNode = freeze({
    is(node) {
      return node.kind === "OrNode";
    },
    create(left, right) {
      return freeze({
        kind: "OrNode",
        left,
        right
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/on-node.js
var OnNode;
var init_on_node = __esm(() => {
  init_object_utils();
  init_and_node();
  init_or_node();
  OnNode = freeze({
    is(node) {
      return node.kind === "OnNode";
    },
    create(filter2) {
      return freeze({
        kind: "OnNode",
        on: filter2
      });
    },
    cloneWithOperation(onNode, operator, operation) {
      return freeze({
        ...onNode,
        on: operator === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/join-node.js
var JoinNode;
var init_join_node = __esm(() => {
  init_object_utils();
  init_on_node();
  JoinNode = freeze({
    is(node) {
      return node.kind === "JoinNode";
    },
    create(joinType, table) {
      return freeze({
        kind: "JoinNode",
        joinType,
        table,
        on: undefined
      });
    },
    createWithOn(joinType, table, on) {
      return freeze({
        kind: "JoinNode",
        joinType,
        table,
        on: OnNode.create(on)
      });
    },
    cloneWithOn(joinNode, operation) {
      return freeze({
        ...joinNode,
        on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/binary-operation-node.js
var BinaryOperationNode;
var init_binary_operation_node = __esm(() => {
  init_object_utils();
  BinaryOperationNode = freeze({
    is(node) {
      return node.kind === "BinaryOperationNode";
    },
    create(leftOperand, operator, rightOperand) {
      return freeze({
        kind: "BinaryOperationNode",
        leftOperand,
        operator,
        rightOperand
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/operator-node.js
function isJSONOperator(op) {
  return isString2(op) && JSON_OPERATORS.includes(op);
}
var COMPARISON_OPERATORS, ARITHMETIC_OPERATORS, JSON_OPERATORS, BINARY_OPERATORS, UNARY_FILTER_OPERATORS, UNARY_OPERATORS, OPERATORS, OperatorNode;
var init_operator_node = __esm(() => {
  init_object_utils();
  COMPARISON_OPERATORS = [
    "=",
    "==",
    "!=",
    "<>",
    ">",
    ">=",
    "<",
    "<=",
    "in",
    "not in",
    "is",
    "is not",
    "like",
    "not like",
    "match",
    "ilike",
    "not ilike",
    "@>",
    "<@",
    "^@",
    "&&",
    "?",
    "?&",
    "?|",
    "!<",
    "!>",
    "<=>",
    "!~",
    "~",
    "~*",
    "!~*",
    "@@",
    "@@@",
    "!!",
    "<->",
    "regexp",
    "is distinct from",
    "is not distinct from"
  ];
  ARITHMETIC_OPERATORS = [
    "+",
    "-",
    "*",
    "/",
    "%",
    "^",
    "&",
    "|",
    "#",
    "<<",
    ">>"
  ];
  JSON_OPERATORS = ["->", "->>"];
  BINARY_OPERATORS = [
    ...COMPARISON_OPERATORS,
    ...ARITHMETIC_OPERATORS,
    "&&",
    "||"
  ];
  UNARY_FILTER_OPERATORS = ["exists", "not exists"];
  UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
  OPERATORS = [
    ...BINARY_OPERATORS,
    ...JSON_OPERATORS,
    ...UNARY_OPERATORS,
    "between",
    "between symmetric"
  ];
  OperatorNode = freeze({
    is(node) {
      return node.kind === "OperatorNode";
    },
    create(operator) {
      return freeze({
        kind: "OperatorNode",
        operator
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/column-node.js
var ColumnNode;
var init_column_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  ColumnNode = freeze({
    is(node) {
      return node.kind === "ColumnNode";
    },
    create(column) {
      return freeze({
        kind: "ColumnNode",
        column: IdentifierNode.create(column)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/select-all-node.js
var SelectAllNode;
var init_select_all_node = __esm(() => {
  init_object_utils();
  SelectAllNode = freeze({
    is(node) {
      return node.kind === "SelectAllNode";
    },
    create() {
      return freeze({
        kind: "SelectAllNode"
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/reference-node.js
var ReferenceNode;
var init_reference_node = __esm(() => {
  init_select_all_node();
  init_object_utils();
  ReferenceNode = freeze({
    is(node) {
      return node.kind === "ReferenceNode";
    },
    create(column, table) {
      return freeze({
        kind: "ReferenceNode",
        table,
        column
      });
    },
    createSelectAll(table) {
      return freeze({
        kind: "ReferenceNode",
        table,
        column: SelectAllNode.create()
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/dynamic/dynamic-reference-builder.js
class DynamicReferenceBuilder {
  #dynamicReference;
  get dynamicReference() {
    return this.#dynamicReference;
  }
  get refType() {
    return;
  }
  constructor(reference) {
    this.#dynamicReference = reference;
  }
  toOperationNode() {
    return parseSimpleReferenceExpression(this.#dynamicReference);
  }
}
function isDynamicReferenceBuilder(obj) {
  return isObject3(obj) && isOperationNodeSource(obj) && isString2(obj.dynamicReference);
}
var init_dynamic_reference_builder = __esm(() => {
  init_operation_node_source();
  init_reference_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/order-by-item-node.js
var OrderByItemNode;
var init_order_by_item_node = __esm(() => {
  init_object_utils();
  OrderByItemNode = freeze({
    is(node) {
      return node.kind === "OrderByItemNode";
    },
    create(orderBy, direction) {
      return freeze({
        kind: "OrderByItemNode",
        orderBy,
        direction
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/raw-node.js
var RawNode;
var init_raw_node = __esm(() => {
  init_object_utils();
  RawNode = freeze({
    is(node) {
      return node.kind === "RawNode";
    },
    create(sqlFragments, parameters) {
      return freeze({
        kind: "RawNode",
        sqlFragments: freeze(sqlFragments),
        parameters: freeze(parameters)
      });
    },
    createWithSql(sql2) {
      return RawNode.create([sql2], []);
    },
    createWithChild(child) {
      return RawNode.create(["", ""], [child]);
    },
    createWithChildren(children) {
      return RawNode.create(new Array(children.length + 1).fill(""), children);
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/collate-node.js
var CollateNode;
var init_collate_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  CollateNode = {
    is(node) {
      return node.kind === "CollateNode";
    },
    create(collation) {
      return freeze({
        kind: "CollateNode",
        collation: IdentifierNode.create(collation)
      });
    }
  };
});

// ../../node_modules/kysely/dist/esm/query-builder/order-by-item-builder.js
class OrderByItemBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  desc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("desc")
      })
    });
  }
  asc() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        direction: RawNode.createWithSql("asc")
      })
    });
  }
  nullsLast() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "last" })
    });
  }
  nullsFirst() {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, { nulls: "first" })
    });
  }
  collate(collation) {
    return new OrderByItemBuilder({
      node: OrderByItemNode.cloneWith(this.#props.node, {
        collation: CollateNode.create(collation)
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}
var init_order_by_item_builder = __esm(() => {
  init_collate_node();
  init_order_by_item_node();
  init_raw_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/util/log-once.js
function logOnce(message2) {
  if (LOGGED_MESSAGES.has(message2)) {
    return;
  }
  LOGGED_MESSAGES.add(message2);
  console.log(message2);
}
var LOGGED_MESSAGES;
var init_log_once = __esm(() => {
  LOGGED_MESSAGES = new Set;
});

// ../../node_modules/kysely/dist/esm/parser/order-by-parser.js
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      logOnce("orderBy(array) is deprecated, use multiple orderBy calls instead.");
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(expr, modifiers) {
  const parsedRef = parseOrderByExpression(expr);
  if (OrderByItemNode.is(parsedRef)) {
    if (modifiers) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return parseOrderByWithModifiers(parsedRef, modifiers);
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref, direction] = expr.split(" ");
  if (direction) {
    logOnce("`orderBy('column asc')` is deprecated. Use `orderBy('column', 'asc')` instead.");
    return parseOrderByWithModifiers(parseStringReference(ref), direction);
  }
  return parseStringReference(expr);
}
function parseOrderByWithModifiers(expr, modifiers) {
  if (typeof modifiers === "string") {
    if (!isOrderByDirection(modifiers)) {
      throw new Error(`Invalid order by direction: ${modifiers}`);
    }
    return OrderByItemNode.create(expr, RawNode.createWithSql(modifiers));
  }
  if (isExpression(modifiers)) {
    logOnce("`orderBy(..., expr)` is deprecated. Use `orderBy(..., 'asc')` or `orderBy(..., (ob) => ...)` instead.");
    return OrderByItemNode.create(expr, modifiers.toOperationNode());
  }
  const node = OrderByItemNode.create(expr);
  if (!modifiers) {
    return node;
  }
  return modifiers(new OrderByItemBuilder({ node })).toOperationNode();
}
var init_order_by_parser = __esm(() => {
  init_dynamic_reference_builder();
  init_expression();
  init_order_by_item_node();
  init_raw_node();
  init_order_by_item_builder();
  init_log_once();
  init_expression_parser();
  init_reference_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/json-reference-node.js
var JSONReferenceNode;
var init_json_reference_node = __esm(() => {
  init_object_utils();
  JSONReferenceNode = freeze({
    is(node) {
      return node.kind === "JSONReferenceNode";
    },
    create(reference, traversal) {
      return freeze({
        kind: "JSONReferenceNode",
        reference,
        traversal
      });
    },
    cloneWithTraversal(node, traversal) {
      return freeze({
        ...node,
        traversal
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/json-operator-chain-node.js
var JSONOperatorChainNode;
var init_json_operator_chain_node = __esm(() => {
  init_object_utils();
  JSONOperatorChainNode = freeze({
    is(node) {
      return node.kind === "JSONOperatorChainNode";
    },
    create(operator) {
      return freeze({
        kind: "JSONOperatorChainNode",
        operator,
        values: freeze([])
      });
    },
    cloneWithValue(node, value) {
      return freeze({
        ...node,
        values: freeze([...node.values, value])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/json-path-node.js
var JSONPathNode;
var init_json_path_node = __esm(() => {
  init_object_utils();
  JSONPathNode = freeze({
    is(node) {
      return node.kind === "JSONPathNode";
    },
    create(inOperator) {
      return freeze({
        kind: "JSONPathNode",
        inOperator,
        pathLegs: freeze([])
      });
    },
    cloneWithLeg(jsonPathNode, pathLeg) {
      return freeze({
        ...jsonPathNode,
        pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/reference-parser.js
function parseSimpleReferenceExpression(exp) {
  if (isString2(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref, op) {
  const referenceNode = parseStringReference(ref);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref) {
  const COLUMN_SEPARATOR = ".";
  if (!ref.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref));
  }
  const parts = ref.split(COLUMN_SEPARATOR).map(trim2);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref}`);
}
function parseAliasedStringReference(ref) {
  const ALIAS_SEPARATOR = " as ";
  if (ref.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias] = ref.split(ALIAS_SEPARATOR).map(trim2);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
  } else {
    return parseStringReference(ref);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim2);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema2, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema2, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim2(str) {
  return str.trim();
}
var init_reference_parser = __esm(() => {
  init_alias_node();
  init_column_node();
  init_reference_node();
  init_table_node();
  init_object_utils();
  init_expression_parser();
  init_identifier_node();
  init_order_by_parser();
  init_operator_node();
  init_json_reference_node();
  init_json_operator_chain_node();
  init_json_path_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/primitive-value-list-node.js
var PrimitiveValueListNode;
var init_primitive_value_list_node = __esm(() => {
  init_object_utils();
  PrimitiveValueListNode = freeze({
    is(node) {
      return node.kind === "PrimitiveValueListNode";
    },
    create(values) {
      return freeze({
        kind: "PrimitiveValueListNode",
        values: freeze([...values])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/value-list-node.js
var ValueListNode;
var init_value_list_node = __esm(() => {
  init_object_utils();
  ValueListNode = freeze({
    is(node) {
      return node.kind === "ValueListNode";
    },
    create(values) {
      return freeze({
        kind: "ValueListNode",
        values: freeze(values)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/value-node.js
var ValueNode;
var init_value_node = __esm(() => {
  init_object_utils();
  ValueNode = freeze({
    is(node) {
      return node.kind === "ValueNode";
    },
    create(value) {
      return freeze({
        kind: "ValueNode",
        value
      });
    },
    createImmediate(value) {
      return freeze({
        kind: "ValueNode",
        value,
        immediate: true
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/value-parser.js
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber2(value) || isBoolean2(value) || isNull2(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}
var init_value_parser = __esm(() => {
  init_primitive_value_list_node();
  init_value_list_node();
  init_value_node();
  init_object_utils();
  init_expression_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/parens-node.js
var ParensNode;
var init_parens_node = __esm(() => {
  init_object_utils();
  ParensNode = freeze({
    is(node) {
      return node.kind === "ParensNode";
    },
    create(node) {
      return freeze({
        kind: "ParensNode",
        node
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/binary-operation-parser.js
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
  if (isIsOperator(operator) && needsIsOperator(right)) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v]) => !isUndefined2(v)).map(([k, v]) => parseValueBinaryOperation(k, needsIsOperator(v) ? "is" : "=", v)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node = toOperationNode(list[0]);
  for (let i = 1;i < list.length; ++i) {
    node = combine(node, toOperationNode(list[i]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node);
  }
  return node;
}
function isIsOperator(operator) {
  return operator === "is" || operator === "is not";
}
function needsIsOperator(value) {
  return isNull2(value) || isBoolean2(value);
}
function parseOperator(operator) {
  if (isString2(operator) && OPERATORS.includes(operator)) {
    return OperatorNode.create(operator);
  }
  if (isOperationNodeSource(operator)) {
    return operator.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}
var init_binary_operation_parser = __esm(() => {
  init_binary_operation_node();
  init_object_utils();
  init_operation_node_source();
  init_operator_node();
  init_reference_parser();
  init_value_parser();
  init_value_node();
  init_and_node();
  init_parens_node();
  init_or_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/order-by-node.js
var OrderByNode;
var init_order_by_node = __esm(() => {
  init_object_utils();
  OrderByNode = freeze({
    is(node) {
      return node.kind === "OrderByNode";
    },
    create(items) {
      return freeze({
        kind: "OrderByNode",
        items: freeze([...items])
      });
    },
    cloneWithItems(orderBy, items) {
      return freeze({
        ...orderBy,
        items: freeze([...orderBy.items, ...items])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/partition-by-node.js
var PartitionByNode;
var init_partition_by_node = __esm(() => {
  init_object_utils();
  PartitionByNode = freeze({
    is(node) {
      return node.kind === "PartitionByNode";
    },
    create(items) {
      return freeze({
        kind: "PartitionByNode",
        items: freeze(items)
      });
    },
    cloneWithItems(partitionBy, items) {
      return freeze({
        ...partitionBy,
        items: freeze([...partitionBy.items, ...items])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/over-node.js
var OverNode;
var init_over_node = __esm(() => {
  init_object_utils();
  init_order_by_node();
  init_partition_by_node();
  OverNode = freeze({
    is(node) {
      return node.kind === "OverNode";
    },
    create() {
      return freeze({
        kind: "OverNode"
      });
    },
    cloneWithOrderByItems(overNode, items) {
      return freeze({
        ...overNode,
        orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)
      });
    },
    cloneWithPartitionByItems(overNode, items) {
      return freeze({
        ...overNode,
        partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/from-node.js
var FromNode;
var init_from_node = __esm(() => {
  init_object_utils();
  FromNode = freeze({
    is(node) {
      return node.kind === "FromNode";
    },
    create(froms) {
      return freeze({
        kind: "FromNode",
        froms: freeze(froms)
      });
    },
    cloneWithFroms(from, froms) {
      return freeze({
        ...from,
        froms: freeze([...from.froms, ...froms])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/group-by-node.js
var GroupByNode;
var init_group_by_node = __esm(() => {
  init_object_utils();
  GroupByNode = freeze({
    is(node) {
      return node.kind === "GroupByNode";
    },
    create(items) {
      return freeze({
        kind: "GroupByNode",
        items: freeze(items)
      });
    },
    cloneWithItems(groupBy, items) {
      return freeze({
        ...groupBy,
        items: freeze([...groupBy.items, ...items])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/having-node.js
var HavingNode;
var init_having_node = __esm(() => {
  init_object_utils();
  init_and_node();
  init_or_node();
  HavingNode = freeze({
    is(node) {
      return node.kind === "HavingNode";
    },
    create(filter2) {
      return freeze({
        kind: "HavingNode",
        having: filter2
      });
    },
    cloneWithOperation(havingNode, operator, operation) {
      return freeze({
        ...havingNode,
        having: operator === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/insert-query-node.js
var InsertQueryNode;
var init_insert_query_node = __esm(() => {
  init_object_utils();
  InsertQueryNode = freeze({
    is(node) {
      return node.kind === "InsertQueryNode";
    },
    create(into, withNode, replace) {
      return freeze({
        kind: "InsertQueryNode",
        into,
        ...withNode && { with: withNode },
        replace
      });
    },
    createWithoutInto() {
      return freeze({
        kind: "InsertQueryNode"
      });
    },
    cloneWith(insertQuery, props) {
      return freeze({
        ...insertQuery,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/list-node.js
var ListNode;
var init_list_node = __esm(() => {
  init_object_utils();
  ListNode = freeze({
    is(node) {
      return node.kind === "ListNode";
    },
    create(items) {
      return freeze({
        kind: "ListNode",
        items: freeze(items)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/update-query-node.js
var UpdateQueryNode;
var init_update_query_node = __esm(() => {
  init_object_utils();
  init_from_node();
  init_list_node();
  UpdateQueryNode = freeze({
    is(node) {
      return node.kind === "UpdateQueryNode";
    },
    create(tables, withNode) {
      return freeze({
        kind: "UpdateQueryNode",
        table: tables.length === 1 ? tables[0] : ListNode.create(tables),
        ...withNode && { with: withNode }
      });
    },
    createWithoutTable() {
      return freeze({
        kind: "UpdateQueryNode"
      });
    },
    cloneWithFromItems(updateQuery, fromItems) {
      return freeze({
        ...updateQuery,
        from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
      });
    },
    cloneWithUpdates(updateQuery, updates) {
      return freeze({
        ...updateQuery,
        updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
      });
    },
    cloneWithLimit(updateQuery, limit) {
      return freeze({
        ...updateQuery,
        limit
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/using-node.js
var UsingNode;
var init_using_node = __esm(() => {
  init_object_utils();
  UsingNode = freeze({
    is(node) {
      return node.kind === "UsingNode";
    },
    create(tables) {
      return freeze({
        kind: "UsingNode",
        tables: freeze(tables)
      });
    },
    cloneWithTables(using, tables) {
      return freeze({
        ...using,
        tables: freeze([...using.tables, ...tables])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/delete-query-node.js
var DeleteQueryNode;
var init_delete_query_node = __esm(() => {
  init_object_utils();
  init_from_node();
  init_using_node();
  init_query_node();
  DeleteQueryNode = freeze({
    is(node) {
      return node.kind === "DeleteQueryNode";
    },
    create(fromItems, withNode) {
      return freeze({
        kind: "DeleteQueryNode",
        from: FromNode.create(fromItems),
        ...withNode && { with: withNode }
      });
    },
    cloneWithOrderByItems: (node, items) => QueryNode.cloneWithOrderByItems(node, items),
    cloneWithoutOrderBy: (node) => QueryNode.cloneWithoutOrderBy(node),
    cloneWithLimit(deleteNode, limit) {
      return freeze({
        ...deleteNode,
        limit
      });
    },
    cloneWithoutLimit(deleteNode) {
      return freeze({
        ...deleteNode,
        limit: undefined
      });
    },
    cloneWithUsing(deleteNode, tables) {
      return freeze({
        ...deleteNode,
        using: deleteNode.using !== undefined ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/where-node.js
var WhereNode;
var init_where_node = __esm(() => {
  init_object_utils();
  init_and_node();
  init_or_node();
  WhereNode = freeze({
    is(node) {
      return node.kind === "WhereNode";
    },
    create(filter2) {
      return freeze({
        kind: "WhereNode",
        where: filter2
      });
    },
    cloneWithOperation(whereNode, operator, operation) {
      return freeze({
        ...whereNode,
        where: operator === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/returning-node.js
var ReturningNode;
var init_returning_node = __esm(() => {
  init_object_utils();
  ReturningNode = freeze({
    is(node) {
      return node.kind === "ReturningNode";
    },
    create(selections) {
      return freeze({
        kind: "ReturningNode",
        selections: freeze(selections)
      });
    },
    cloneWithSelections(returning, selections) {
      return freeze({
        ...returning,
        selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/explain-node.js
var ExplainNode;
var init_explain_node = __esm(() => {
  init_object_utils();
  ExplainNode = freeze({
    is(node) {
      return node.kind === "ExplainNode";
    },
    create(format, options) {
      return freeze({
        kind: "ExplainNode",
        format,
        options
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/when-node.js
var WhenNode;
var init_when_node = __esm(() => {
  init_object_utils();
  WhenNode = freeze({
    is(node) {
      return node.kind === "WhenNode";
    },
    create(condition) {
      return freeze({
        kind: "WhenNode",
        condition
      });
    },
    cloneWithResult(whenNode, result) {
      return freeze({
        ...whenNode,
        result
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/merge-query-node.js
var MergeQueryNode;
var init_merge_query_node = __esm(() => {
  init_object_utils();
  init_when_node();
  MergeQueryNode = freeze({
    is(node) {
      return node.kind === "MergeQueryNode";
    },
    create(into, withNode) {
      return freeze({
        kind: "MergeQueryNode",
        into,
        ...withNode && { with: withNode }
      });
    },
    cloneWithUsing(mergeNode, using) {
      return freeze({
        ...mergeNode,
        using
      });
    },
    cloneWithWhen(mergeNode, when) {
      return freeze({
        ...mergeNode,
        whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
      });
    },
    cloneWithThen(mergeNode, then) {
      return freeze({
        ...mergeNode,
        whens: mergeNode.whens ? freeze([
          ...mergeNode.whens.slice(0, -1),
          WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
        ]) : undefined
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/output-node.js
var OutputNode;
var init_output_node = __esm(() => {
  init_object_utils();
  OutputNode = freeze({
    is(node) {
      return node.kind === "OutputNode";
    },
    create(selections) {
      return freeze({
        kind: "OutputNode",
        selections: freeze(selections)
      });
    },
    cloneWithSelections(output, selections) {
      return freeze({
        ...output,
        selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/query-node.js
var QueryNode;
var init_query_node = __esm(() => {
  init_insert_query_node();
  init_select_query_node();
  init_update_query_node();
  init_delete_query_node();
  init_where_node();
  init_object_utils();
  init_returning_node();
  init_explain_node();
  init_merge_query_node();
  init_output_node();
  init_order_by_node();
  QueryNode = freeze({
    is(node) {
      return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);
    },
    cloneWithEndModifier(node, modifier) {
      return freeze({
        ...node,
        endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : freeze([modifier])
      });
    },
    cloneWithWhere(node, operation) {
      return freeze({
        ...node,
        where: node.where ? WhereNode.cloneWithOperation(node.where, "And", operation) : WhereNode.create(operation)
      });
    },
    cloneWithJoin(node, join) {
      return freeze({
        ...node,
        joins: node.joins ? freeze([...node.joins, join]) : freeze([join])
      });
    },
    cloneWithReturning(node, selections) {
      return freeze({
        ...node,
        returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)
      });
    },
    cloneWithoutReturning(node) {
      return freeze({
        ...node,
        returning: undefined
      });
    },
    cloneWithoutWhere(node) {
      return freeze({
        ...node,
        where: undefined
      });
    },
    cloneWithExplain(node, format, options) {
      return freeze({
        ...node,
        explain: ExplainNode.create(format, options?.toOperationNode())
      });
    },
    cloneWithTop(node, top) {
      return freeze({
        ...node,
        top
      });
    },
    cloneWithOutput(node, selections) {
      return freeze({
        ...node,
        output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)
      });
    },
    cloneWithOrderByItems(node, items) {
      return freeze({
        ...node,
        orderBy: node.orderBy ? OrderByNode.cloneWithItems(node.orderBy, items) : OrderByNode.create(items)
      });
    },
    cloneWithoutOrderBy(node) {
      return freeze({
        ...node,
        orderBy: undefined
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/select-query-node.js
var SelectQueryNode;
var init_select_query_node = __esm(() => {
  init_object_utils();
  init_from_node();
  init_group_by_node();
  init_having_node();
  init_query_node();
  SelectQueryNode = freeze({
    is(node) {
      return node.kind === "SelectQueryNode";
    },
    create(withNode) {
      return freeze({
        kind: "SelectQueryNode",
        ...withNode && { with: withNode }
      });
    },
    createFrom(fromItems, withNode) {
      return freeze({
        kind: "SelectQueryNode",
        from: FromNode.create(fromItems),
        ...withNode && { with: withNode }
      });
    },
    cloneWithSelections(select, selections) {
      return freeze({
        ...select,
        selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
      });
    },
    cloneWithDistinctOn(select, expressions) {
      return freeze({
        ...select,
        distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
      });
    },
    cloneWithFrontModifier(select, modifier) {
      return freeze({
        ...select,
        frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
      });
    },
    cloneWithOrderByItems: (node, items) => QueryNode.cloneWithOrderByItems(node, items),
    cloneWithGroupByItems(selectNode, items) {
      return freeze({
        ...selectNode,
        groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)
      });
    },
    cloneWithLimit(selectNode, limit) {
      return freeze({
        ...selectNode,
        limit
      });
    },
    cloneWithOffset(selectNode, offset) {
      return freeze({
        ...selectNode,
        offset
      });
    },
    cloneWithFetch(selectNode, fetch2) {
      return freeze({
        ...selectNode,
        fetch: fetch2
      });
    },
    cloneWithHaving(selectNode, operation) {
      return freeze({
        ...selectNode,
        having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
      });
    },
    cloneWithSetOperations(selectNode, setOperations) {
      return freeze({
        ...selectNode,
        setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
      });
    },
    cloneWithoutSelections(select) {
      return freeze({
        ...select,
        selections: []
      });
    },
    cloneWithoutLimit(select) {
      return freeze({
        ...select,
        limit: undefined
      });
    },
    cloneWithoutOffset(select) {
      return freeze({
        ...select,
        offset: undefined
      });
    },
    cloneWithoutOrderBy: (node) => QueryNode.cloneWithoutOrderBy(node),
    cloneWithoutGroupBy(select) {
      return freeze({
        ...select,
        groupBy: undefined
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/join-builder.js
class JoinBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(...args) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  onRef(lhs, op, rhs) {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  onTrue() {
    return new JoinBuilder({
      ...this.#props,
      joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql("true"))
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.joinNode;
  }
}
var init_join_builder = __esm(() => {
  init_join_node();
  init_raw_node();
  init_binary_operation_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/partition-by-item-node.js
var PartitionByItemNode;
var init_partition_by_item_node = __esm(() => {
  init_object_utils();
  PartitionByItemNode = freeze({
    is(node) {
      return node.kind === "PartitionByItemNode";
    },
    create(partitionBy) {
      return freeze({
        kind: "PartitionByItemNode",
        partitionBy
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/partition-by-parser.js
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}
var init_partition_by_parser = __esm(() => {
  init_partition_by_item_node();
  init_reference_parser();
});

// ../../node_modules/kysely/dist/esm/query-builder/over-builder.js
class OverBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  orderBy(...args) {
    return new OverBuilder({
      overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new OverBuilder({
      overNode: QueryNode.cloneWithoutOrderBy(this.#props.overNode)
    });
  }
  partitionBy(partitionBy) {
    return new OverBuilder({
      overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.overNode;
  }
}
var init_over_builder = __esm(() => {
  init_over_node();
  init_query_node();
  init_order_by_parser();
  init_partition_by_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/selection-node.js
var SelectionNode;
var init_selection_node = __esm(() => {
  init_object_utils();
  init_reference_node();
  init_select_all_node();
  SelectionNode = freeze({
    is(node) {
      return node.kind === "SelectionNode";
    },
    create(selection) {
      return freeze({
        kind: "SelectionNode",
        selection
      });
    },
    createSelectAll() {
      return freeze({
        kind: "SelectionNode",
        selection: SelectAllNode.create()
      });
    },
    createSelectAllFromTable(table) {
      return freeze({
        kind: "SelectionNode",
        selection: ReferenceNode.createSelectAll(table)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/select-parser.js
function parseSelectArg(selection) {
  if (isFunction3(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString2(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString2(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}
var init_select_parser = __esm(() => {
  init_object_utils();
  init_selection_node();
  init_reference_parser();
  init_dynamic_reference_builder();
  init_expression_parser();
  init_table_parser();
  init_expression_builder();
});

// ../../node_modules/kysely/dist/esm/operation-node/values-node.js
var ValuesNode;
var init_values_node = __esm(() => {
  init_object_utils();
  ValuesNode = freeze({
    is(node) {
      return node.kind === "ValuesNode";
    },
    create(values) {
      return freeze({
        kind: "ValuesNode",
        values: freeze(values)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/default-insert-value-node.js
var DefaultInsertValueNode;
var init_default_insert_value_node = __esm(() => {
  init_object_utils();
  DefaultInsertValueNode = freeze({
    is(node) {
      return node.kind === "DefaultInsertValueNode";
    },
    create() {
      return freeze({
        kind: "DefaultInsertValueNode"
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/insert-values-parser.js
function parseInsertExpression(arg) {
  const objectOrList = isFunction3(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = new Map;
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== undefined) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  let indexedRowColumns = rowColumns.length;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined2(columnIdx)) {
      indexedRowColumns--;
      continue;
    }
    const value = row[col];
    if (isUndefined2(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = indexedRowColumns < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined2(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}
var init_insert_values_parser = __esm(() => {
  init_column_node();
  init_primitive_value_list_node();
  init_value_list_node();
  init_object_utils();
  init_value_parser();
  init_values_node();
  init_expression_parser();
  init_default_insert_value_node();
  init_expression_builder();
});

// ../../node_modules/kysely/dist/esm/operation-node/column-update-node.js
var ColumnUpdateNode;
var init_column_update_node = __esm(() => {
  init_object_utils();
  ColumnUpdateNode = freeze({
    is(node) {
      return node.kind === "ColumnUpdateNode";
    },
    create(column, value) {
      return freeze({
        kind: "ColumnUpdateNode",
        column,
        value
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/update-set-parser.js
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction3(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_, value]) => value !== undefined).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}
var init_update_set_parser = __esm(() => {
  init_column_node();
  init_column_update_node();
  init_expression_builder();
  init_object_utils();
  init_value_parser();
  init_reference_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/on-duplicate-key-node.js
var OnDuplicateKeyNode;
var init_on_duplicate_key_node = __esm(() => {
  init_object_utils();
  OnDuplicateKeyNode = freeze({
    is(node) {
      return node.kind === "OnDuplicateKeyNode";
    },
    create(updates) {
      return freeze({
        kind: "OnDuplicateKeyNode",
        updates
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/insert-result.js
class InsertResult {
  insertId;
  numInsertedOrUpdatedRows;
  constructor(insertId, numInsertedOrUpdatedRows) {
    this.insertId = insertId;
    this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
  }
}

// ../../node_modules/kysely/dist/esm/query-builder/no-result-error.js
function isNoResultErrorConstructor(fn) {
  return Object.prototype.hasOwnProperty.call(fn, "prototype");
}
var NoResultError;
var init_no_result_error = __esm(() => {
  NoResultError = class NoResultError extends Error {
    node;
    constructor(node) {
      super("no result");
      this.node = node;
    }
  };
});

// ../../node_modules/kysely/dist/esm/operation-node/on-conflict-node.js
var OnConflictNode;
var init_on_conflict_node = __esm(() => {
  init_object_utils();
  init_where_node();
  OnConflictNode = freeze({
    is(node) {
      return node.kind === "OnConflictNode";
    },
    create() {
      return freeze({
        kind: "OnConflictNode"
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    },
    cloneWithIndexWhere(node, operation) {
      return freeze({
        ...node,
        indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "And", operation) : WhereNode.create(operation)
      });
    },
    cloneWithIndexOrWhere(node, operation) {
      return freeze({
        ...node,
        indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "Or", operation) : WhereNode.create(operation)
      });
    },
    cloneWithUpdateWhere(node, operation) {
      return freeze({
        ...node,
        updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "And", operation) : WhereNode.create(operation)
      });
    },
    cloneWithUpdateOrWhere(node, operation) {
      return freeze({
        ...node,
        updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "Or", operation) : WhereNode.create(operation)
      });
    },
    cloneWithoutIndexWhere(node) {
      return freeze({
        ...node,
        indexWhere: undefined
      });
    },
    cloneWithoutUpdateWhere(node) {
      return freeze({
        ...node,
        updateWhere: undefined
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js
class OnConflictBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  column(column) {
    const columnNode = ColumnNode.create(column);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])
      })
    });
  }
  columns(columns) {
    const columnNodes = columns.map(ColumnNode.create);
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
      })
    });
  }
  constraint(constraintName) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        constraint: IdentifierNode.create(constraintName)
      })
    });
  }
  expression(expression) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        indexExpression: expression.toOperationNode()
      })
    });
  }
  where(...args) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)
    });
  }
  doNothing() {
    return new OnConflictDoNothingBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        doNothing: true
      })
    });
  }
  doUpdateSet(update) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
        updates: parseUpdateObjectExpression(update)
      })
    });
  }
  $call(func) {
    return func(this);
  }
}

class OnConflictDoNothingBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}

class OnConflictUpdateBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new OnConflictUpdateBuilder({
      ...this.#props,
      onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.onConflictNode;
  }
}
var init_on_conflict_builder = __esm(() => {
  init_column_node();
  init_identifier_node();
  init_on_conflict_node();
  init_binary_operation_parser();
  init_update_set_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/top-node.js
var TopNode;
var init_top_node = __esm(() => {
  init_object_utils();
  TopNode = freeze({
    is(node) {
      return node.kind === "TopNode";
    },
    create(expression, modifiers) {
      return freeze({
        kind: "TopNode",
        expression,
        modifiers
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/top-parser.js
function parseTop(expression, modifiers) {
  if (!isNumber2(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined2(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}
var init_top_parser = __esm(() => {
  init_top_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/or-action-node.js
var OrActionNode;
var init_or_action_node = __esm(() => {
  init_object_utils();
  OrActionNode = freeze({
    is(node) {
      return node.kind === "OrActionNode";
    },
    create(action) {
      return freeze({
        kind: "OrActionNode",
        action
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/insert-query-builder.js
class InsertQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  values(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns,
        values
      })
    });
  }
  columns(columns) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        columns: freeze(columns.map(ColumnNode.create))
      })
    });
  }
  expression(expression) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        values: parseExpression(expression)
      })
    });
  }
  defaultValues() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        defaultValues: true
      })
    });
  }
  modifyEnd(modifier) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  ignore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  orIgnore() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("ignore")
      })
    });
  }
  orAbort() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("abort")
      })
    });
  }
  orFail() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("fail")
      })
    });
  }
  orReplace() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("replace")
      })
    });
  }
  orRollback() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        orAction: OrActionNode.create("rollback")
      })
    });
  }
  top(expression, modifiers) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  onConflict(callback) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onConflict: callback(new OnConflictBuilder({
          onConflictNode: OnConflictNode.create()
        })).toOperationNode()
      })
    });
  }
  onDuplicateKeyUpdate(update) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
        onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
      })
    });
  }
  returning(selection) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())
    });
  }
  output(args) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  clearReturning() {
    return new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new InsertQueryBuilder({
      ...this.#props
    });
  }
  $castTo() {
    return new InsertQueryBuilder(this.#props);
  }
  $narrowType() {
    return new InsertQueryBuilder(this.#props);
  }
  $assertType() {
    return new InsertQueryBuilder(this.#props);
  }
  withPlugin(plugin) {
    return new InsertQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new InsertResult(result.insertId, result.numAffectedRows ?? BigInt(0))
    ];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream4 = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream4) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new InsertQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}
var init_insert_query_builder = __esm(() => {
  init_select_parser();
  init_insert_values_parser();
  init_insert_query_node();
  init_query_node();
  init_update_set_parser();
  init_object_utils();
  init_on_duplicate_key_node();
  init_no_result_error();
  init_expression_parser();
  init_column_node();
  init_on_conflict_builder();
  init_on_conflict_node();
  init_top_parser();
  init_or_action_node();
});

// ../../node_modules/kysely/dist/esm/query-builder/delete-result.js
class DeleteResult {
  numDeletedRows;
  constructor(numDeletedRows) {
    this.numDeletedRows = numDeletedRows;
  }
}

// ../../node_modules/kysely/dist/esm/operation-node/limit-node.js
var LimitNode;
var init_limit_node = __esm(() => {
  init_object_utils();
  LimitNode = freeze({
    is(node) {
      return node.kind === "LimitNode";
    },
    create(limit) {
      return freeze({
        kind: "LimitNode",
        limit
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/delete-query-builder.js
class DeleteQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  top(expression, modifiers) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(tables) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  returning(selection) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  clearReturning() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  orderBy(...args) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  limit(limit) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  modifyEnd(modifier) {
    return new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new DeleteQueryBuilder({
      ...this.#props
    });
  }
  $castTo() {
    return new DeleteQueryBuilder(this.#props);
  }
  $narrowType() {
    return new DeleteQueryBuilder(this.#props);
  }
  $assertType() {
    return new DeleteQueryBuilder(this.#props);
  }
  withPlugin(plugin) {
    return new DeleteQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [new DeleteResult(result.numAffectedRows ?? BigInt(0))];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream4 = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream4) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new DeleteQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}
var init_delete_query_builder = __esm(() => {
  init_join_parser();
  init_table_parser();
  init_select_parser();
  init_query_node();
  init_object_utils();
  init_no_result_error();
  init_delete_query_node();
  init_limit_node();
  init_order_by_parser();
  init_binary_operation_parser();
  init_value_parser();
  init_top_parser();
});

// ../../node_modules/kysely/dist/esm/query-builder/update-result.js
class UpdateResult {
  numUpdatedRows;
  numChangedRows;
  constructor(numUpdatedRows, numChangedRows) {
    this.numUpdatedRows = numUpdatedRows;
    this.numChangedRows = numChangedRows;
  }
}

// ../../node_modules/kysely/dist/esm/query-builder/update-query-builder.js
class UpdateQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  where(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  clearWhere() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  top(expression, modifiers) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  from(from) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  #join(joinType, args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  limit(limit) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  set(...args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))
    });
  }
  returning(selection) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  returningAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  modifyEnd(modifier) {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  clearReturning() {
    return new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new UpdateQueryBuilder({
      ...this.#props
    });
  }
  $castTo() {
    return new UpdateQueryBuilder(this.#props);
  }
  $narrowType() {
    return new UpdateQueryBuilder(this.#props);
  }
  $assertType() {
    return new UpdateQueryBuilder(this.#props);
  }
  withPlugin(plugin) {
    return new UpdateQueryBuilder({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [
      new UpdateResult(result.numAffectedRows ?? BigInt(0), result.numChangedRows)
    ];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream4 = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream4) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new UpdateQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}
var init_update_query_builder = __esm(() => {
  init_join_parser();
  init_table_parser();
  init_select_parser();
  init_query_node();
  init_update_query_node();
  init_update_set_parser();
  init_object_utils();
  init_no_result_error();
  init_binary_operation_parser();
  init_value_parser();
  init_limit_node();
  init_top_parser();
  init_order_by_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/common-table-expression-name-node.js
var CommonTableExpressionNameNode;
var init_common_table_expression_name_node = __esm(() => {
  init_object_utils();
  init_column_node();
  init_table_node();
  CommonTableExpressionNameNode = freeze({
    is(node) {
      return node.kind === "CommonTableExpressionNameNode";
    },
    create(tableName, columnNames) {
      return freeze({
        kind: "CommonTableExpressionNameNode",
        table: TableNode.create(tableName),
        columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : undefined
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/common-table-expression-node.js
var CommonTableExpressionNode;
var init_common_table_expression_node = __esm(() => {
  init_object_utils();
  CommonTableExpressionNode = freeze({
    is(node) {
      return node.kind === "CommonTableExpressionNode";
    },
    create(name, expression) {
      return freeze({
        kind: "CommonTableExpressionNode",
        name,
        expression
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/cte-builder.js
class CTEBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  notMaterialized() {
    return new CTEBuilder({
      ...this.#props,
      node: CommonTableExpressionNode.cloneWith(this.#props.node, {
        materialized: false
      })
    });
  }
  toOperationNode() {
    return this.#props.node;
  }
}
var init_cte_builder = __esm(() => {
  init_common_table_expression_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/parser/with-parser.js
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction3(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name) {
  if (name.includes("(")) {
    const parts = name.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name);
  }
}
var init_with_parser = __esm(() => {
  init_common_table_expression_name_node();
  init_parse_utils();
  init_object_utils();
  init_cte_builder();
  init_common_table_expression_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/with-node.js
var WithNode;
var init_with_node = __esm(() => {
  init_object_utils();
  WithNode = freeze({
    is(node) {
      return node.kind === "WithNode";
    },
    create(expression, params) {
      return freeze({
        kind: "WithNode",
        expressions: freeze([expression]),
        ...params
      });
    },
    cloneWithExpression(withNode, expression) {
      return freeze({
        ...withNode,
        expressions: freeze([...withNode.expressions, expression])
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/util/random-string.js
function randomString(length) {
  let chars = "";
  for (let i = 0;i < length; ++i) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}
var CHARS;
var init_random_string = __esm(() => {
  CHARS = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
});

// ../../node_modules/kysely/dist/esm/util/query-id.js
function createQueryId() {
  return new LazyQueryId;
}

class LazyQueryId {
  #queryId;
  get queryId() {
    if (this.#queryId === undefined) {
      this.#queryId = randomString(8);
    }
    return this.#queryId;
  }
}
var init_query_id = __esm(() => {
  init_random_string();
});

// ../../node_modules/kysely/dist/esm/util/require-all-props.js
function requireAllProps(obj) {
  return obj;
}

// ../../node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js
class OperationNodeTransformer {
  nodeStack = [];
  #transformers = freeze({
    AliasNode: this.transformAlias.bind(this),
    ColumnNode: this.transformColumn.bind(this),
    IdentifierNode: this.transformIdentifier.bind(this),
    SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
    RawNode: this.transformRaw.bind(this),
    ReferenceNode: this.transformReference.bind(this),
    SelectQueryNode: this.transformSelectQuery.bind(this),
    SelectionNode: this.transformSelection.bind(this),
    TableNode: this.transformTable.bind(this),
    FromNode: this.transformFrom.bind(this),
    SelectAllNode: this.transformSelectAll.bind(this),
    AndNode: this.transformAnd.bind(this),
    OrNode: this.transformOr.bind(this),
    ValueNode: this.transformValue.bind(this),
    ValueListNode: this.transformValueList.bind(this),
    PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
    ParensNode: this.transformParens.bind(this),
    JoinNode: this.transformJoin.bind(this),
    OperatorNode: this.transformOperator.bind(this),
    WhereNode: this.transformWhere.bind(this),
    InsertQueryNode: this.transformInsertQuery.bind(this),
    DeleteQueryNode: this.transformDeleteQuery.bind(this),
    ReturningNode: this.transformReturning.bind(this),
    CreateTableNode: this.transformCreateTable.bind(this),
    AddColumnNode: this.transformAddColumn.bind(this),
    ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
    DropTableNode: this.transformDropTable.bind(this),
    DataTypeNode: this.transformDataType.bind(this),
    OrderByNode: this.transformOrderBy.bind(this),
    OrderByItemNode: this.transformOrderByItem.bind(this),
    GroupByNode: this.transformGroupBy.bind(this),
    GroupByItemNode: this.transformGroupByItem.bind(this),
    UpdateQueryNode: this.transformUpdateQuery.bind(this),
    ColumnUpdateNode: this.transformColumnUpdate.bind(this),
    LimitNode: this.transformLimit.bind(this),
    OffsetNode: this.transformOffset.bind(this),
    OnConflictNode: this.transformOnConflict.bind(this),
    OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
    CreateIndexNode: this.transformCreateIndex.bind(this),
    DropIndexNode: this.transformDropIndex.bind(this),
    ListNode: this.transformList.bind(this),
    PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
    ReferencesNode: this.transformReferences.bind(this),
    CheckConstraintNode: this.transformCheckConstraint.bind(this),
    WithNode: this.transformWith.bind(this),
    CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
    HavingNode: this.transformHaving.bind(this),
    CreateSchemaNode: this.transformCreateSchema.bind(this),
    DropSchemaNode: this.transformDropSchema.bind(this),
    AlterTableNode: this.transformAlterTable.bind(this),
    DropColumnNode: this.transformDropColumn.bind(this),
    RenameColumnNode: this.transformRenameColumn.bind(this),
    AlterColumnNode: this.transformAlterColumn.bind(this),
    ModifyColumnNode: this.transformModifyColumn.bind(this),
    AddConstraintNode: this.transformAddConstraint.bind(this),
    DropConstraintNode: this.transformDropConstraint.bind(this),
    RenameConstraintNode: this.transformRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
    CreateViewNode: this.transformCreateView.bind(this),
    RefreshMaterializedViewNode: this.transformRefreshMaterializedView.bind(this),
    DropViewNode: this.transformDropView.bind(this),
    GeneratedNode: this.transformGenerated.bind(this),
    DefaultValueNode: this.transformDefaultValue.bind(this),
    OnNode: this.transformOn.bind(this),
    ValuesNode: this.transformValues.bind(this),
    SelectModifierNode: this.transformSelectModifier.bind(this),
    CreateTypeNode: this.transformCreateType.bind(this),
    DropTypeNode: this.transformDropType.bind(this),
    ExplainNode: this.transformExplain.bind(this),
    DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.transformAggregateFunction.bind(this),
    OverNode: this.transformOver.bind(this),
    PartitionByNode: this.transformPartitionBy.bind(this),
    PartitionByItemNode: this.transformPartitionByItem.bind(this),
    SetOperationNode: this.transformSetOperation.bind(this),
    BinaryOperationNode: this.transformBinaryOperation.bind(this),
    UnaryOperationNode: this.transformUnaryOperation.bind(this),
    UsingNode: this.transformUsing.bind(this),
    FunctionNode: this.transformFunction.bind(this),
    CaseNode: this.transformCase.bind(this),
    WhenNode: this.transformWhen.bind(this),
    JSONReferenceNode: this.transformJSONReference.bind(this),
    JSONPathNode: this.transformJSONPath.bind(this),
    JSONPathLegNode: this.transformJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
    TupleNode: this.transformTuple.bind(this),
    MergeQueryNode: this.transformMergeQuery.bind(this),
    MatchedNode: this.transformMatched.bind(this),
    AddIndexNode: this.transformAddIndex.bind(this),
    CastNode: this.transformCast.bind(this),
    FetchNode: this.transformFetch.bind(this),
    TopNode: this.transformTop.bind(this),
    OutputNode: this.transformOutput.bind(this),
    OrActionNode: this.transformOrAction.bind(this),
    CollateNode: this.transformCollate.bind(this)
  });
  transformNode(node, queryId) {
    if (!node) {
      return node;
    }
    this.nodeStack.push(node);
    const out = this.transformNodeImpl(node, queryId);
    this.nodeStack.pop();
    return freeze(out);
  }
  transformNodeImpl(node, queryId) {
    return this.#transformers[node.kind](node, queryId);
  }
  transformNodeList(list, queryId) {
    if (!list) {
      return list;
    }
    return freeze(list.map((node) => this.transformNode(node, queryId)));
  }
  transformSelectQuery(node, queryId) {
    return requireAllProps({
      kind: "SelectQueryNode",
      from: this.transformNode(node.from, queryId),
      selections: this.transformNodeList(node.selections, queryId),
      distinctOn: this.transformNodeList(node.distinctOn, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      groupBy: this.transformNode(node.groupBy, queryId),
      orderBy: this.transformNode(node.orderBy, queryId),
      where: this.transformNode(node.where, queryId),
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      limit: this.transformNode(node.limit, queryId),
      offset: this.transformNode(node.offset, queryId),
      with: this.transformNode(node.with, queryId),
      having: this.transformNode(node.having, queryId),
      explain: this.transformNode(node.explain, queryId),
      setOperations: this.transformNodeList(node.setOperations, queryId),
      fetch: this.transformNode(node.fetch, queryId),
      top: this.transformNode(node.top, queryId)
    });
  }
  transformSelection(node, queryId) {
    return requireAllProps({
      kind: "SelectionNode",
      selection: this.transformNode(node.selection, queryId)
    });
  }
  transformColumn(node, queryId) {
    return requireAllProps({
      kind: "ColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformAlias(node, queryId) {
    return requireAllProps({
      kind: "AliasNode",
      node: this.transformNode(node.node, queryId),
      alias: this.transformNode(node.alias, queryId)
    });
  }
  transformTable(node, queryId) {
    return requireAllProps({
      kind: "TableNode",
      table: this.transformNode(node.table, queryId)
    });
  }
  transformFrom(node, queryId) {
    return requireAllProps({
      kind: "FromNode",
      froms: this.transformNodeList(node.froms, queryId)
    });
  }
  transformReference(node, queryId) {
    return requireAllProps({
      kind: "ReferenceNode",
      column: this.transformNode(node.column, queryId),
      table: this.transformNode(node.table, queryId)
    });
  }
  transformAnd(node, queryId) {
    return requireAllProps({
      kind: "AndNode",
      left: this.transformNode(node.left, queryId),
      right: this.transformNode(node.right, queryId)
    });
  }
  transformOr(node, queryId) {
    return requireAllProps({
      kind: "OrNode",
      left: this.transformNode(node.left, queryId),
      right: this.transformNode(node.right, queryId)
    });
  }
  transformValueList(node, queryId) {
    return requireAllProps({
      kind: "ValueListNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformParens(node, queryId) {
    return requireAllProps({
      kind: "ParensNode",
      node: this.transformNode(node.node, queryId)
    });
  }
  transformJoin(node, queryId) {
    return requireAllProps({
      kind: "JoinNode",
      joinType: node.joinType,
      table: this.transformNode(node.table, queryId),
      on: this.transformNode(node.on, queryId)
    });
  }
  transformRaw(node, queryId) {
    return requireAllProps({
      kind: "RawNode",
      sqlFragments: freeze([...node.sqlFragments]),
      parameters: this.transformNodeList(node.parameters, queryId)
    });
  }
  transformWhere(node, queryId) {
    return requireAllProps({
      kind: "WhereNode",
      where: this.transformNode(node.where, queryId)
    });
  }
  transformInsertQuery(node, queryId) {
    return requireAllProps({
      kind: "InsertQueryNode",
      into: this.transformNode(node.into, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      values: this.transformNode(node.values, queryId),
      returning: this.transformNode(node.returning, queryId),
      onConflict: this.transformNode(node.onConflict, queryId),
      onDuplicateKey: this.transformNode(node.onDuplicateKey, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      ignore: node.ignore,
      orAction: this.transformNode(node.orAction, queryId),
      replace: node.replace,
      explain: this.transformNode(node.explain, queryId),
      defaultValues: node.defaultValues,
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId)
    });
  }
  transformValues(node, queryId) {
    return requireAllProps({
      kind: "ValuesNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformDeleteQuery(node, queryId) {
    return requireAllProps({
      kind: "DeleteQueryNode",
      from: this.transformNode(node.from, queryId),
      using: this.transformNode(node.using, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      where: this.transformNode(node.where, queryId),
      returning: this.transformNode(node.returning, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      orderBy: this.transformNode(node.orderBy, queryId),
      limit: this.transformNode(node.limit, queryId),
      explain: this.transformNode(node.explain, queryId),
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId)
    });
  }
  transformReturning(node, queryId) {
    return requireAllProps({
      kind: "ReturningNode",
      selections: this.transformNodeList(node.selections, queryId)
    });
  }
  transformCreateTable(node, queryId) {
    return requireAllProps({
      kind: "CreateTableNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      constraints: this.transformNodeList(node.constraints, queryId),
      temporary: node.temporary,
      ifNotExists: node.ifNotExists,
      onCommit: node.onCommit,
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      selectQuery: this.transformNode(node.selectQuery, queryId)
    });
  }
  transformColumnDefinition(node, queryId) {
    return requireAllProps({
      kind: "ColumnDefinitionNode",
      column: this.transformNode(node.column, queryId),
      dataType: this.transformNode(node.dataType, queryId),
      references: this.transformNode(node.references, queryId),
      primaryKey: node.primaryKey,
      autoIncrement: node.autoIncrement,
      unique: node.unique,
      notNull: node.notNull,
      unsigned: node.unsigned,
      defaultTo: this.transformNode(node.defaultTo, queryId),
      check: this.transformNode(node.check, queryId),
      generated: this.transformNode(node.generated, queryId),
      frontModifiers: this.transformNodeList(node.frontModifiers, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      nullsNotDistinct: node.nullsNotDistinct,
      identity: node.identity,
      ifNotExists: node.ifNotExists
    });
  }
  transformAddColumn(node, queryId) {
    return requireAllProps({
      kind: "AddColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformDropTable(node, queryId) {
    return requireAllProps({
      kind: "DropTableNode",
      table: this.transformNode(node.table, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformOrderBy(node, queryId) {
    return requireAllProps({
      kind: "OrderByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformOrderByItem(node, queryId) {
    return requireAllProps({
      kind: "OrderByItemNode",
      orderBy: this.transformNode(node.orderBy, queryId),
      direction: this.transformNode(node.direction, queryId),
      collation: this.transformNode(node.collation, queryId),
      nulls: node.nulls
    });
  }
  transformGroupBy(node, queryId) {
    return requireAllProps({
      kind: "GroupByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformGroupByItem(node, queryId) {
    return requireAllProps({
      kind: "GroupByItemNode",
      groupBy: this.transformNode(node.groupBy, queryId)
    });
  }
  transformUpdateQuery(node, queryId) {
    return requireAllProps({
      kind: "UpdateQueryNode",
      table: this.transformNode(node.table, queryId),
      from: this.transformNode(node.from, queryId),
      joins: this.transformNodeList(node.joins, queryId),
      where: this.transformNode(node.where, queryId),
      updates: this.transformNodeList(node.updates, queryId),
      returning: this.transformNode(node.returning, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      with: this.transformNode(node.with, queryId),
      explain: this.transformNode(node.explain, queryId),
      limit: this.transformNode(node.limit, queryId),
      top: this.transformNode(node.top, queryId),
      output: this.transformNode(node.output, queryId),
      orderBy: this.transformNode(node.orderBy, queryId)
    });
  }
  transformColumnUpdate(node, queryId) {
    return requireAllProps({
      kind: "ColumnUpdateNode",
      column: this.transformNode(node.column, queryId),
      value: this.transformNode(node.value, queryId)
    });
  }
  transformLimit(node, queryId) {
    return requireAllProps({
      kind: "LimitNode",
      limit: this.transformNode(node.limit, queryId)
    });
  }
  transformOffset(node, queryId) {
    return requireAllProps({
      kind: "OffsetNode",
      offset: this.transformNode(node.offset, queryId)
    });
  }
  transformOnConflict(node, queryId) {
    return requireAllProps({
      kind: "OnConflictNode",
      columns: this.transformNodeList(node.columns, queryId),
      constraint: this.transformNode(node.constraint, queryId),
      indexExpression: this.transformNode(node.indexExpression, queryId),
      indexWhere: this.transformNode(node.indexWhere, queryId),
      updates: this.transformNodeList(node.updates, queryId),
      updateWhere: this.transformNode(node.updateWhere, queryId),
      doNothing: node.doNothing
    });
  }
  transformOnDuplicateKey(node, queryId) {
    return requireAllProps({
      kind: "OnDuplicateKeyNode",
      updates: this.transformNodeList(node.updates, queryId)
    });
  }
  transformCreateIndex(node, queryId) {
    return requireAllProps({
      kind: "CreateIndexNode",
      name: this.transformNode(node.name, queryId),
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      unique: node.unique,
      using: this.transformNode(node.using, queryId),
      ifNotExists: node.ifNotExists,
      where: this.transformNode(node.where, queryId),
      nullsNotDistinct: node.nullsNotDistinct
    });
  }
  transformList(node, queryId) {
    return requireAllProps({
      kind: "ListNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformDropIndex(node, queryId) {
    return requireAllProps({
      kind: "DropIndexNode",
      name: this.transformNode(node.name, queryId),
      table: this.transformNode(node.table, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformPrimaryKeyConstraint(node, queryId) {
    return requireAllProps({
      kind: "PrimaryKeyConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      name: this.transformNode(node.name, queryId),
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformUniqueConstraint(node, queryId) {
    return requireAllProps({
      kind: "UniqueConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      name: this.transformNode(node.name, queryId),
      nullsNotDistinct: node.nullsNotDistinct,
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformForeignKeyConstraint(node, queryId) {
    return requireAllProps({
      kind: "ForeignKeyConstraintNode",
      columns: this.transformNodeList(node.columns, queryId),
      references: this.transformNode(node.references, queryId),
      name: this.transformNode(node.name, queryId),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate,
      deferrable: node.deferrable,
      initiallyDeferred: node.initiallyDeferred
    });
  }
  transformSetOperation(node, queryId) {
    return requireAllProps({
      kind: "SetOperationNode",
      operator: node.operator,
      expression: this.transformNode(node.expression, queryId),
      all: node.all
    });
  }
  transformReferences(node, queryId) {
    return requireAllProps({
      kind: "ReferencesNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      onDelete: node.onDelete,
      onUpdate: node.onUpdate
    });
  }
  transformCheckConstraint(node, queryId) {
    return requireAllProps({
      kind: "CheckConstraintNode",
      expression: this.transformNode(node.expression, queryId),
      name: this.transformNode(node.name, queryId)
    });
  }
  transformWith(node, queryId) {
    return requireAllProps({
      kind: "WithNode",
      expressions: this.transformNodeList(node.expressions, queryId),
      recursive: node.recursive
    });
  }
  transformCommonTableExpression(node, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNode",
      name: this.transformNode(node.name, queryId),
      materialized: node.materialized,
      expression: this.transformNode(node.expression, queryId)
    });
  }
  transformCommonTableExpressionName(node, queryId) {
    return requireAllProps({
      kind: "CommonTableExpressionNameNode",
      table: this.transformNode(node.table, queryId),
      columns: this.transformNodeList(node.columns, queryId)
    });
  }
  transformHaving(node, queryId) {
    return requireAllProps({
      kind: "HavingNode",
      having: this.transformNode(node.having, queryId)
    });
  }
  transformCreateSchema(node, queryId) {
    return requireAllProps({
      kind: "CreateSchemaNode",
      schema: this.transformNode(node.schema, queryId),
      ifNotExists: node.ifNotExists
    });
  }
  transformDropSchema(node, queryId) {
    return requireAllProps({
      kind: "DropSchemaNode",
      schema: this.transformNode(node.schema, queryId),
      ifExists: node.ifExists,
      cascade: node.cascade
    });
  }
  transformAlterTable(node, queryId) {
    return requireAllProps({
      kind: "AlterTableNode",
      table: this.transformNode(node.table, queryId),
      renameTo: this.transformNode(node.renameTo, queryId),
      setSchema: this.transformNode(node.setSchema, queryId),
      columnAlterations: this.transformNodeList(node.columnAlterations, queryId),
      addConstraint: this.transformNode(node.addConstraint, queryId),
      dropConstraint: this.transformNode(node.dropConstraint, queryId),
      renameConstraint: this.transformNode(node.renameConstraint, queryId),
      addIndex: this.transformNode(node.addIndex, queryId),
      dropIndex: this.transformNode(node.dropIndex, queryId)
    });
  }
  transformDropColumn(node, queryId) {
    return requireAllProps({
      kind: "DropColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformRenameColumn(node, queryId) {
    return requireAllProps({
      kind: "RenameColumnNode",
      column: this.transformNode(node.column, queryId),
      renameTo: this.transformNode(node.renameTo, queryId)
    });
  }
  transformAlterColumn(node, queryId) {
    return requireAllProps({
      kind: "AlterColumnNode",
      column: this.transformNode(node.column, queryId),
      dataType: this.transformNode(node.dataType, queryId),
      dataTypeExpression: this.transformNode(node.dataTypeExpression, queryId),
      setDefault: this.transformNode(node.setDefault, queryId),
      dropDefault: node.dropDefault,
      setNotNull: node.setNotNull,
      dropNotNull: node.dropNotNull
    });
  }
  transformModifyColumn(node, queryId) {
    return requireAllProps({
      kind: "ModifyColumnNode",
      column: this.transformNode(node.column, queryId)
    });
  }
  transformAddConstraint(node, queryId) {
    return requireAllProps({
      kind: "AddConstraintNode",
      constraint: this.transformNode(node.constraint, queryId)
    });
  }
  transformDropConstraint(node, queryId) {
    return requireAllProps({
      kind: "DropConstraintNode",
      constraintName: this.transformNode(node.constraintName, queryId),
      ifExists: node.ifExists,
      modifier: node.modifier
    });
  }
  transformRenameConstraint(node, queryId) {
    return requireAllProps({
      kind: "RenameConstraintNode",
      oldName: this.transformNode(node.oldName, queryId),
      newName: this.transformNode(node.newName, queryId)
    });
  }
  transformCreateView(node, queryId) {
    return requireAllProps({
      kind: "CreateViewNode",
      name: this.transformNode(node.name, queryId),
      temporary: node.temporary,
      orReplace: node.orReplace,
      ifNotExists: node.ifNotExists,
      materialized: node.materialized,
      columns: this.transformNodeList(node.columns, queryId),
      as: this.transformNode(node.as, queryId)
    });
  }
  transformRefreshMaterializedView(node, queryId) {
    return requireAllProps({
      kind: "RefreshMaterializedViewNode",
      name: this.transformNode(node.name, queryId),
      concurrently: node.concurrently,
      withNoData: node.withNoData
    });
  }
  transformDropView(node, queryId) {
    return requireAllProps({
      kind: "DropViewNode",
      name: this.transformNode(node.name, queryId),
      ifExists: node.ifExists,
      materialized: node.materialized,
      cascade: node.cascade
    });
  }
  transformGenerated(node, queryId) {
    return requireAllProps({
      kind: "GeneratedNode",
      byDefault: node.byDefault,
      always: node.always,
      identity: node.identity,
      stored: node.stored,
      expression: this.transformNode(node.expression, queryId)
    });
  }
  transformDefaultValue(node, queryId) {
    return requireAllProps({
      kind: "DefaultValueNode",
      defaultValue: this.transformNode(node.defaultValue, queryId)
    });
  }
  transformOn(node, queryId) {
    return requireAllProps({
      kind: "OnNode",
      on: this.transformNode(node.on, queryId)
    });
  }
  transformSelectModifier(node, queryId) {
    return requireAllProps({
      kind: "SelectModifierNode",
      modifier: node.modifier,
      rawModifier: this.transformNode(node.rawModifier, queryId),
      of: this.transformNodeList(node.of, queryId)
    });
  }
  transformCreateType(node, queryId) {
    return requireAllProps({
      kind: "CreateTypeNode",
      name: this.transformNode(node.name, queryId),
      enum: this.transformNode(node.enum, queryId)
    });
  }
  transformDropType(node, queryId) {
    return requireAllProps({
      kind: "DropTypeNode",
      name: this.transformNode(node.name, queryId),
      ifExists: node.ifExists
    });
  }
  transformExplain(node, queryId) {
    return requireAllProps({
      kind: "ExplainNode",
      format: node.format,
      options: this.transformNode(node.options, queryId)
    });
  }
  transformSchemableIdentifier(node, queryId) {
    return requireAllProps({
      kind: "SchemableIdentifierNode",
      schema: this.transformNode(node.schema, queryId),
      identifier: this.transformNode(node.identifier, queryId)
    });
  }
  transformAggregateFunction(node, queryId) {
    return requireAllProps({
      kind: "AggregateFunctionNode",
      func: node.func,
      aggregated: this.transformNodeList(node.aggregated, queryId),
      distinct: node.distinct,
      orderBy: this.transformNode(node.orderBy, queryId),
      withinGroup: this.transformNode(node.withinGroup, queryId),
      filter: this.transformNode(node.filter, queryId),
      over: this.transformNode(node.over, queryId)
    });
  }
  transformOver(node, queryId) {
    return requireAllProps({
      kind: "OverNode",
      orderBy: this.transformNode(node.orderBy, queryId),
      partitionBy: this.transformNode(node.partitionBy, queryId)
    });
  }
  transformPartitionBy(node, queryId) {
    return requireAllProps({
      kind: "PartitionByNode",
      items: this.transformNodeList(node.items, queryId)
    });
  }
  transformPartitionByItem(node, queryId) {
    return requireAllProps({
      kind: "PartitionByItemNode",
      partitionBy: this.transformNode(node.partitionBy, queryId)
    });
  }
  transformBinaryOperation(node, queryId) {
    return requireAllProps({
      kind: "BinaryOperationNode",
      leftOperand: this.transformNode(node.leftOperand, queryId),
      operator: this.transformNode(node.operator, queryId),
      rightOperand: this.transformNode(node.rightOperand, queryId)
    });
  }
  transformUnaryOperation(node, queryId) {
    return requireAllProps({
      kind: "UnaryOperationNode",
      operator: this.transformNode(node.operator, queryId),
      operand: this.transformNode(node.operand, queryId)
    });
  }
  transformUsing(node, queryId) {
    return requireAllProps({
      kind: "UsingNode",
      tables: this.transformNodeList(node.tables, queryId)
    });
  }
  transformFunction(node, queryId) {
    return requireAllProps({
      kind: "FunctionNode",
      func: node.func,
      arguments: this.transformNodeList(node.arguments, queryId)
    });
  }
  transformCase(node, queryId) {
    return requireAllProps({
      kind: "CaseNode",
      value: this.transformNode(node.value, queryId),
      when: this.transformNodeList(node.when, queryId),
      else: this.transformNode(node.else, queryId),
      isStatement: node.isStatement
    });
  }
  transformWhen(node, queryId) {
    return requireAllProps({
      kind: "WhenNode",
      condition: this.transformNode(node.condition, queryId),
      result: this.transformNode(node.result, queryId)
    });
  }
  transformJSONReference(node, queryId) {
    return requireAllProps({
      kind: "JSONReferenceNode",
      reference: this.transformNode(node.reference, queryId),
      traversal: this.transformNode(node.traversal, queryId)
    });
  }
  transformJSONPath(node, queryId) {
    return requireAllProps({
      kind: "JSONPathNode",
      inOperator: this.transformNode(node.inOperator, queryId),
      pathLegs: this.transformNodeList(node.pathLegs, queryId)
    });
  }
  transformJSONPathLeg(node, _queryId) {
    return requireAllProps({
      kind: "JSONPathLegNode",
      type: node.type,
      value: node.value
    });
  }
  transformJSONOperatorChain(node, queryId) {
    return requireAllProps({
      kind: "JSONOperatorChainNode",
      operator: this.transformNode(node.operator, queryId),
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformTuple(node, queryId) {
    return requireAllProps({
      kind: "TupleNode",
      values: this.transformNodeList(node.values, queryId)
    });
  }
  transformMergeQuery(node, queryId) {
    return requireAllProps({
      kind: "MergeQueryNode",
      into: this.transformNode(node.into, queryId),
      using: this.transformNode(node.using, queryId),
      whens: this.transformNodeList(node.whens, queryId),
      with: this.transformNode(node.with, queryId),
      top: this.transformNode(node.top, queryId),
      endModifiers: this.transformNodeList(node.endModifiers, queryId),
      output: this.transformNode(node.output, queryId),
      returning: this.transformNode(node.returning, queryId)
    });
  }
  transformMatched(node, _queryId) {
    return requireAllProps({
      kind: "MatchedNode",
      not: node.not,
      bySource: node.bySource
    });
  }
  transformAddIndex(node, queryId) {
    return requireAllProps({
      kind: "AddIndexNode",
      name: this.transformNode(node.name, queryId),
      columns: this.transformNodeList(node.columns, queryId),
      unique: node.unique,
      using: this.transformNode(node.using, queryId),
      ifNotExists: node.ifNotExists
    });
  }
  transformCast(node, queryId) {
    return requireAllProps({
      kind: "CastNode",
      expression: this.transformNode(node.expression, queryId),
      dataType: this.transformNode(node.dataType, queryId)
    });
  }
  transformFetch(node, queryId) {
    return requireAllProps({
      kind: "FetchNode",
      rowCount: this.transformNode(node.rowCount, queryId),
      modifier: node.modifier
    });
  }
  transformTop(node, _queryId) {
    return requireAllProps({
      kind: "TopNode",
      expression: node.expression,
      modifiers: node.modifiers
    });
  }
  transformOutput(node, queryId) {
    return requireAllProps({
      kind: "OutputNode",
      selections: this.transformNodeList(node.selections, queryId)
    });
  }
  transformDataType(node, _queryId) {
    return node;
  }
  transformSelectAll(node, _queryId) {
    return node;
  }
  transformIdentifier(node, _queryId) {
    return node;
  }
  transformValue(node, _queryId) {
    return node;
  }
  transformPrimitiveValueList(node, _queryId) {
    return node;
  }
  transformOperator(node, _queryId) {
    return node;
  }
  transformDefaultInsertValue(node, _queryId) {
    return node;
  }
  transformOrAction(node, _queryId) {
    return node;
  }
  transformCollate(node, _queryId) {
    return node;
  }
}
var init_operation_node_transformer = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js
var ROOT_OPERATION_NODES, SCHEMALESS_FUNCTIONS, WithSchemaTransformer;
var init_with_schema_transformer = __esm(() => {
  init_alias_node();
  init_identifier_node();
  init_list_node();
  init_operation_node_transformer();
  init_schemable_identifier_node();
  init_table_node();
  init_object_utils();
  ROOT_OPERATION_NODES = freeze({
    AlterTableNode: true,
    CreateIndexNode: true,
    CreateSchemaNode: true,
    CreateTableNode: true,
    CreateTypeNode: true,
    CreateViewNode: true,
    RefreshMaterializedViewNode: true,
    DeleteQueryNode: true,
    DropIndexNode: true,
    DropSchemaNode: true,
    DropTableNode: true,
    DropTypeNode: true,
    DropViewNode: true,
    InsertQueryNode: true,
    RawNode: true,
    SelectQueryNode: true,
    UpdateQueryNode: true,
    MergeQueryNode: true
  });
  SCHEMALESS_FUNCTIONS = {
    json_agg: true,
    to_json: true
  };
  WithSchemaTransformer = class WithSchemaTransformer extends OperationNodeTransformer {
    #schema;
    #schemableIds = new Set;
    #ctes = new Set;
    constructor(schema2) {
      super();
      this.#schema = schema2;
    }
    transformNodeImpl(node, queryId) {
      if (!this.#isRootOperationNode(node)) {
        return super.transformNodeImpl(node, queryId);
      }
      const ctes = this.#collectCTEs(node);
      for (const cte of ctes) {
        this.#ctes.add(cte);
      }
      const tables = this.#collectSchemableIds(node);
      for (const table of tables) {
        this.#schemableIds.add(table);
      }
      const transformed = super.transformNodeImpl(node, queryId);
      for (const table of tables) {
        this.#schemableIds.delete(table);
      }
      for (const cte of ctes) {
        this.#ctes.delete(cte);
      }
      return transformed;
    }
    transformSchemableIdentifier(node, queryId) {
      const transformed = super.transformSchemableIdentifier(node, queryId);
      if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {
        return transformed;
      }
      return {
        ...transformed,
        schema: IdentifierNode.create(this.#schema)
      };
    }
    transformReferences(node, queryId) {
      const transformed = super.transformReferences(node, queryId);
      if (transformed.table.table.schema) {
        return transformed;
      }
      return {
        ...transformed,
        table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)
      };
    }
    transformAggregateFunction(node, queryId) {
      return {
        ...super.transformAggregateFunction({ ...node, aggregated: [] }, queryId),
        aggregated: this.#transformTableArgsWithoutSchemas(node, queryId, "aggregated")
      };
    }
    transformFunction(node, queryId) {
      return {
        ...super.transformFunction({ ...node, arguments: [] }, queryId),
        arguments: this.#transformTableArgsWithoutSchemas(node, queryId, "arguments")
      };
    }
    #transformTableArgsWithoutSchemas(node, queryId, argsKey) {
      return SCHEMALESS_FUNCTIONS[node.func] ? node[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg, queryId) : {
        ...arg,
        table: this.transformIdentifier(arg.table.identifier, queryId)
      }) : this.transformNodeList(node[argsKey], queryId);
    }
    #isRootOperationNode(node) {
      return node.kind in ROOT_OPERATION_NODES;
    }
    #collectSchemableIds(node) {
      const schemableIds = new Set;
      if ("name" in node && node.name && SchemableIdentifierNode.is(node.name)) {
        this.#collectSchemableId(node.name, schemableIds);
      }
      if ("from" in node && node.from) {
        for (const from of node.from.froms) {
          this.#collectSchemableIdsFromTableExpr(from, schemableIds);
        }
      }
      if ("into" in node && node.into) {
        this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);
      }
      if ("table" in node && node.table) {
        this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);
      }
      if ("joins" in node && node.joins) {
        for (const join of node.joins) {
          this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);
        }
      }
      if ("using" in node && node.using) {
        this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);
      }
      return schemableIds;
    }
    #collectCTEs(node) {
      const ctes = new Set;
      if ("with" in node && node.with) {
        this.#collectCTEIds(node.with, ctes);
      }
      return ctes;
    }
    #collectSchemableIdsFromTableExpr(node, schemableIds) {
      if (TableNode.is(node)) {
        this.#collectSchemableId(node.table, schemableIds);
      } else if (AliasNode.is(node) && TableNode.is(node.node)) {
        this.#collectSchemableId(node.node.table, schemableIds);
      } else if (ListNode.is(node)) {
        for (const table of node.items) {
          this.#collectSchemableIdsFromTableExpr(table, schemableIds);
        }
      }
    }
    #collectSchemableId(node, schemableIds) {
      const id = node.identifier.name;
      if (!this.#schemableIds.has(id) && !this.#ctes.has(id)) {
        schemableIds.add(id);
      }
    }
    #collectCTEIds(node, ctes) {
      for (const expr of node.expressions) {
        const cteId = expr.name.table.table.identifier.name;
        if (!this.#ctes.has(cteId)) {
          ctes.add(cteId);
        }
      }
    }
  };
});

// ../../node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js
class WithSchemaPlugin {
  #transformer;
  constructor(schema2) {
    this.#transformer = new WithSchemaTransformer(schema2);
  }
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  async transformResult(args) {
    return args.result;
  }
}
var init_with_schema_plugin = __esm(() => {
  init_with_schema_transformer();
});

// ../../node_modules/kysely/dist/esm/operation-node/matched-node.js
var MatchedNode;
var init_matched_node = __esm(() => {
  init_object_utils();
  MatchedNode = freeze({
    is(node) {
      return node.kind === "MatchedNode";
    },
    create(not2, bySource = false) {
      return freeze({
        kind: "MatchedNode",
        not: not2,
        bySource
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/merge-parser.js
function parseMergeWhen(type, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type.isMatched, type.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result) {
  if (isString2(result)) {
    return RawNode.create([result], []);
  }
  if (isOperationNodeSource(result)) {
    return result.toOperationNode();
  }
  return result;
}
var init_merge_parser = __esm(() => {
  init_matched_node();
  init_operation_node_source();
  init_raw_node();
  init_when_node();
  init_object_utils();
  init_binary_operation_parser();
});

// ../../node_modules/kysely/dist/esm/util/deferred.js
class Deferred {
  #promise;
  #resolve;
  #reject;
  constructor() {
    this.#promise = new Promise((resolve, reject) => {
      this.#reject = reject;
      this.#resolve = resolve;
    });
  }
  get promise() {
    return this.#promise;
  }
  resolve = (value) => {
    if (this.#resolve) {
      this.#resolve(value);
    }
  };
  reject = (reason) => {
    if (this.#reject) {
      this.#reject(reason);
    }
  };
}

// ../../node_modules/kysely/dist/esm/util/provide-controlled-connection.js
async function provideControlledConnection(connectionProvider) {
  const connectionDefer = new Deferred;
  const connectionReleaseDefer = new Deferred;
  connectionProvider.provideConnection(async (connection) => {
    connectionDefer.resolve(connection);
    return await connectionReleaseDefer.promise;
  }).catch((ex) => connectionDefer.reject(ex));
  return freeze({
    connection: await connectionDefer.promise,
    release: connectionReleaseDefer.resolve
  });
}
var init_provide_controlled_connection = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/query-executor/query-executor-base.js
class QueryExecutorBase {
  #plugins;
  constructor(plugins = NO_PLUGINS) {
    this.#plugins = plugins;
  }
  get plugins() {
    return this.#plugins;
  }
  transformQuery(node, queryId) {
    for (const plugin of this.#plugins) {
      const transformedNode = plugin.transformQuery({ node, queryId });
      if (transformedNode.kind === node.kind) {
        node = transformedNode;
      } else {
        throw new Error([
          `KyselyPlugin.transformQuery must return a node`,
          `of the same kind that was given to it.`,
          `The plugin was given a ${node.kind}`,
          `but it returned a ${transformedNode.kind}`
        ].join(" "));
      }
    }
    return node;
  }
  async executeQuery(compiledQuery, queryId) {
    return await this.provideConnection(async (connection) => {
      const result = await connection.executeQuery(compiledQuery);
      if ("numUpdatedOrDeletedRows" in result) {
        logOnce("kysely:warning: outdated driver/plugin detected! `QueryResult.numUpdatedOrDeletedRows` has been replaced with `QueryResult.numAffectedRows`.");
      }
      return await this.#transformResult(result, queryId);
    });
  }
  async* stream(compiledQuery, chunkSize, queryId) {
    const { connection, release } = await provideControlledConnection(this);
    try {
      for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
        yield await this.#transformResult(result, queryId);
      }
    } finally {
      release();
    }
  }
  async#transformResult(result, queryId) {
    for (const plugin of this.#plugins) {
      result = await plugin.transformResult({ result, queryId });
    }
    return result;
  }
}
var NO_PLUGINS;
var init_query_executor_base = __esm(() => {
  init_object_utils();
  init_provide_controlled_connection();
  init_log_once();
  NO_PLUGINS = freeze([]);
});

// ../../node_modules/kysely/dist/esm/query-executor/noop-query-executor.js
var NoopQueryExecutor, NOOP_QUERY_EXECUTOR;
var init_noop_query_executor = __esm(() => {
  init_query_executor_base();
  NoopQueryExecutor = class NoopQueryExecutor extends QueryExecutorBase {
    get adapter() {
      throw new Error("this query cannot be compiled to SQL");
    }
    compileQuery() {
      throw new Error("this query cannot be compiled to SQL");
    }
    provideConnection() {
      throw new Error("this query cannot be executed");
    }
    withConnectionProvider() {
      throw new Error("this query cannot have a connection provider");
    }
    withPlugin(plugin) {
      return new NoopQueryExecutor([...this.plugins, plugin]);
    }
    withPlugins(plugins) {
      return new NoopQueryExecutor([...this.plugins, ...plugins]);
    }
    withPluginAtFront(plugin) {
      return new NoopQueryExecutor([plugin, ...this.plugins]);
    }
    withoutPlugins() {
      return new NoopQueryExecutor([]);
    }
  };
  NOOP_QUERY_EXECUTOR = new NoopQueryExecutor;
});

// ../../node_modules/kysely/dist/esm/query-builder/merge-result.js
class MergeResult {
  numChangedRows;
  constructor(numChangedRows) {
    this.numChangedRows = numChangedRows;
  }
}

// ../../node_modules/kysely/dist/esm/query-builder/merge-query-builder.js
class MergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  modifyEnd(modifier) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  top(expression, modifiers) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  using(...args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin("Using", args))
    });
  }
  returning(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new MergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
}

class WheneableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  modifyEnd(modifier) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
    });
  }
  top(expression, modifiers) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  whenMatched() {
    return this.#whenMatched([]);
  }
  whenMatchedAnd(...args) {
    return this.#whenMatched(args);
  }
  whenMatchedAndRef(lhs, op, rhs) {
    return this.#whenMatched([lhs, op, rhs], true);
  }
  #whenMatched(args, refRight) {
    return new MatchedThenableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
    });
  }
  whenNotMatched() {
    return this.#whenNotMatched([]);
  }
  whenNotMatchedAnd(...args) {
    return this.#whenNotMatched(args);
  }
  whenNotMatchedAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true);
  }
  whenNotMatchedBySource() {
    return this.#whenNotMatched([], false, true);
  }
  whenNotMatchedBySourceAnd(...args) {
    return this.#whenNotMatched(args, false, true);
  }
  whenNotMatchedBySourceAndRef(lhs, op, rhs) {
    return this.#whenNotMatched([lhs, op, rhs], true, true);
  }
  returning(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(args))
    });
  }
  returningAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
    });
  }
  output(args) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
    });
  }
  outputAll(table) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
    });
  }
  #whenNotMatched(args, refRight = false, bySource = false) {
    const props = {
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
    };
    const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
    return new Builder(props);
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new WheneableMergeQueryBuilder({
      ...this.#props
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    const { adapter } = this.#props.executor;
    const query = compiledQuery.query;
    if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
      return result.rows;
    }
    return [new MergeResult(result.numAffectedRows)];
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
}

class MatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  thenDelete() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("delete"))
    });
  }
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenUpdate(set) {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
        queryId: this.#props.queryId,
        executor: NOOP_QUERY_EXECUTOR,
        queryNode: UpdateQueryNode.createWithoutTable()
      }))))
    });
  }
  thenUpdateSet(...args) {
    return this.thenUpdate((ub) => ub.set(...args));
  }
}

class NotMatchedThenableMergeQueryBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  thenDoNothing() {
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
    });
  }
  thenInsertValues(insert) {
    const [columns, values] = parseInsertExpression(insert);
    return new WheneableMergeQueryBuilder({
      ...this.#props,
      queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
        columns,
        values
      })))
    });
  }
}
var init_merge_query_builder = __esm(() => {
  init_insert_query_node();
  init_merge_query_node();
  init_query_node();
  init_update_query_node();
  init_insert_values_parser();
  init_join_parser();
  init_merge_parser();
  init_select_parser();
  init_top_parser();
  init_noop_query_executor();
  init_object_utils();
  init_no_result_error();
  init_update_query_builder();
});

// ../../node_modules/kysely/dist/esm/query-creator.js
class QueryCreator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  selectFrom(from) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  selectNoFrom(selection) {
    return createSelectQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))
    });
  }
  insertInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode)
    });
  }
  replaceInto(table) {
    return new InsertQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true)
    });
  }
  deleteFrom(from) {
    return new DeleteQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: DeleteQueryNode.create(parseTableExpressionOrList(from), this.#props.withNode)
    });
  }
  updateTable(tables) {
    return new UpdateQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: UpdateQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)
    });
  }
  mergeInto(targetTable) {
    return new MergeQueryBuilder({
      queryId: createQueryId(),
      executor: this.#props.executor,
      queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)
    });
  }
  with(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)
    });
  }
  withRecursive(nameOrBuilder, expression) {
    const cte = parseCommonTableExpression(nameOrBuilder, expression);
    return new QueryCreator({
      ...this.#props,
      withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })
    });
  }
  withPlugin(plugin) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  withoutPlugins() {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withoutPlugins()
    });
  }
  withSchema(schema2) {
    return new QueryCreator({
      ...this.#props,
      executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
    });
  }
}
var init_query_creator = __esm(() => {
  init_select_query_builder();
  init_insert_query_builder();
  init_delete_query_builder();
  init_update_query_builder();
  init_delete_query_node();
  init_insert_query_node();
  init_select_query_node();
  init_update_query_node();
  init_table_parser();
  init_with_parser();
  init_with_node();
  init_query_id();
  init_with_schema_plugin();
  init_object_utils();
  init_select_parser();
  init_merge_query_builder();
  init_merge_query_node();
});

// ../../node_modules/kysely/dist/esm/parser/parse-utils.js
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}
var init_parse_utils = __esm(() => {
  init_join_node();
  init_over_node();
  init_select_query_node();
  init_join_builder();
  init_over_builder();
  init_select_query_builder();
  init_query_creator();
  init_noop_query_executor();
  init_query_id();
  init_table_parser();
});

// ../../node_modules/kysely/dist/esm/parser/join-parser.js
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else if (args.length === 1) {
    return parseOnlessJoin(joinType, args[0]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}
function parseOnlessJoin(joinType, from) {
  return JoinNode.create(joinType, parseTableExpression(from));
}
var init_join_parser = __esm(() => {
  init_join_node();
  init_binary_operation_parser();
  init_parse_utils();
  init_table_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/offset-node.js
var OffsetNode;
var init_offset_node = __esm(() => {
  init_object_utils();
  OffsetNode = freeze({
    is(node) {
      return node.kind === "OffsetNode";
    },
    create(offset) {
      return freeze({
        kind: "OffsetNode",
        offset
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/group-by-item-node.js
var GroupByItemNode;
var init_group_by_item_node = __esm(() => {
  init_object_utils();
  GroupByItemNode = freeze({
    is(node) {
      return node.kind === "GroupByItemNode";
    },
    create(groupBy) {
      return freeze({
        kind: "GroupByItemNode",
        groupBy
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/group-by-parser.js
function parseGroupBy(groupBy) {
  groupBy = isFunction3(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}
var init_group_by_parser = __esm(() => {
  init_group_by_item_node();
  init_expression_builder();
  init_object_utils();
  init_reference_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/set-operation-node.js
var SetOperationNode;
var init_set_operation_node = __esm(() => {
  init_object_utils();
  SetOperationNode = freeze({
    is(node) {
      return node.kind === "SetOperationNode";
    },
    create(operator, expression, all2) {
      return freeze({
        kind: "SetOperationNode",
        operator,
        expression,
        all: all2
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/set-operation-parser.js
function parseSetOperations(operator, expression, all2) {
  if (isFunction3(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all2));
}
var init_set_operation_parser = __esm(() => {
  init_expression_builder();
  init_set_operation_node();
  init_object_utils();
  init_expression_parser();
});

// ../../node_modules/kysely/dist/esm/expression/expression-wrapper.js
class ExpressionWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  $castTo() {
    return new ExpressionWrapper(this.#node);
  }
  $notNull() {
    return new ExpressionWrapper(this.#node);
  }
  toOperationNode() {
    return this.#node;
  }
}

class AliasedExpressionWrapper {
  #expr;
  #alias;
  constructor(expr, alias) {
    this.#expr = expr;
    this.#alias = alias;
  }
  get expression() {
    return this.#expr;
  }
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}

class OrWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  or(...args) {
    return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  $castTo() {
    return new OrWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}

class AndWrapper {
  #node;
  constructor(node) {
    this.#node = node;
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedExpressionWrapper(this, alias);
  }
  and(...args) {
    return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
  }
  $castTo() {
    return new AndWrapper(this.#node);
  }
  toOperationNode() {
    return ParensNode.create(this.#node);
  }
}
var init_expression_wrapper = __esm(() => {
  init_alias_node();
  init_and_node();
  init_identifier_node();
  init_operation_node_source();
  init_or_node();
  init_parens_node();
  init_binary_operation_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/fetch-node.js
var FetchNode;
var init_fetch_node = __esm(() => {
  init_value_node();
  FetchNode = {
    is(node) {
      return node.kind === "FetchNode";
    },
    create(rowCount, modifier) {
      return {
        kind: "FetchNode",
        rowCount: ValueNode.create(rowCount),
        modifier
      };
    }
  };
});

// ../../node_modules/kysely/dist/esm/parser/fetch-parser.js
function parseFetch(rowCount, modifier) {
  if (!isNumber2(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}
var init_fetch_parser = __esm(() => {
  init_fetch_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/query-builder/select-query-builder.js
class SelectQueryBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return;
  }
  get isSelectQueryBuilder() {
    return true;
  }
  where(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  whereRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  having(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  havingRef(lhs, op, rhs) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  select(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))
    });
  }
  distinctOn(selection) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))
    });
  }
  modifyFront(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  modifyEnd(modifier) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
    });
  }
  distinct() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create("Distinct"))
    });
  }
  forUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  forShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  forKeyShare(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  forNoKeyUpdate(of) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : undefined))
    });
  }
  skipLocked() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("SkipLocked"))
    });
  }
  noWait() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("NoWait"))
    });
  }
  selectAll(table) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table))
    });
  }
  innerJoin(...args) {
    return this.#join("InnerJoin", args);
  }
  leftJoin(...args) {
    return this.#join("LeftJoin", args);
  }
  rightJoin(...args) {
    return this.#join("RightJoin", args);
  }
  fullJoin(...args) {
    return this.#join("FullJoin", args);
  }
  crossJoin(...args) {
    return this.#join("CrossJoin", args);
  }
  innerJoinLateral(...args) {
    return this.#join("LateralInnerJoin", args);
  }
  leftJoinLateral(...args) {
    return this.#join("LateralLeftJoin", args);
  }
  crossJoinLateral(...args) {
    return this.#join("LateralCrossJoin", args);
  }
  crossApply(...args) {
    return this.#join("CrossApply", args);
  }
  outerApply(...args) {
    return this.#join("OuterApply", args);
  }
  #join(joinType, args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(joinType, args))
    });
  }
  orderBy(...args) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
    });
  }
  groupBy(groupBy) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))
    });
  }
  limit(limit) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
    });
  }
  offset(offset) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset)))
    });
  }
  fetch(rowCount, modifier = "only") {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))
    });
  }
  top(expression, modifiers) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
    });
  }
  union(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, false))
    });
  }
  unionAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, true))
    });
  }
  intersect(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, false))
    });
  }
  intersectAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, true))
    });
  }
  except(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, false))
    });
  }
  exceptAll(expression) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, true))
    });
  }
  as(alias) {
    return new AliasedSelectQueryBuilderImpl(this, alias);
  }
  clearSelect() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)
    });
  }
  clearWhere() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
    });
  }
  clearLimit() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)
    });
  }
  clearOffset() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)
    });
  }
  clearOrderBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithoutOrderBy(this.#props.queryNode)
    });
  }
  clearGroupBy() {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)
    });
  }
  $call(func) {
    return func(this);
  }
  $if(condition, func) {
    if (condition) {
      return func(this);
    }
    return new SelectQueryBuilderImpl({
      ...this.#props
    });
  }
  $castTo() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $narrowType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $assertType() {
    return new SelectQueryBuilderImpl(this.#props);
  }
  $asTuple() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  $asScalar() {
    return new ExpressionWrapper(this.toOperationNode());
  }
  withPlugin(plugin) {
    return new SelectQueryBuilderImpl({
      ...this.#props,
      executor: this.#props.executor.withPlugin(plugin)
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    const compiledQuery = this.compile();
    const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
    return result.rows;
  }
  async executeTakeFirst() {
    const [result] = await this.execute();
    return result;
  }
  async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
    const result = await this.executeTakeFirst();
    if (result === undefined) {
      const error2 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
      throw error2;
    }
    return result;
  }
  async* stream(chunkSize = 100) {
    const compiledQuery = this.compile();
    const stream4 = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
    for await (const item of stream4) {
      yield* item.rows;
    }
  }
  async explain(format, options) {
    const builder = new SelectQueryBuilderImpl({
      ...this.#props,
      queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
    });
    return await builder.execute();
  }
}
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}

class AliasedSelectQueryBuilderImpl {
  #queryBuilder;
  #alias;
  constructor(queryBuilder, alias) {
    this.#queryBuilder = queryBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#queryBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get isAliasedSelectQueryBuilder() {
    return true;
  }
  toOperationNode() {
    return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}
var init_select_query_builder = __esm(() => {
  init_alias_node();
  init_select_modifier_node();
  init_join_parser();
  init_table_parser();
  init_select_parser();
  init_reference_parser();
  init_select_query_node();
  init_query_node();
  init_order_by_parser();
  init_limit_node();
  init_offset_node();
  init_object_utils();
  init_group_by_parser();
  init_no_result_error();
  init_identifier_node();
  init_set_operation_parser();
  init_binary_operation_parser();
  init_expression_wrapper();
  init_value_parser();
  init_fetch_parser();
  init_top_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/aggregate-function-node.js
var AggregateFunctionNode;
var init_aggregate_function_node = __esm(() => {
  init_object_utils();
  init_where_node();
  init_order_by_node();
  AggregateFunctionNode = freeze({
    is(node) {
      return node.kind === "AggregateFunctionNode";
    },
    create(aggregateFunction, aggregated = []) {
      return freeze({
        kind: "AggregateFunctionNode",
        func: aggregateFunction,
        aggregated
      });
    },
    cloneWithDistinct(aggregateFunctionNode) {
      return freeze({
        ...aggregateFunctionNode,
        distinct: true
      });
    },
    cloneWithOrderBy(aggregateFunctionNode, orderItems, withinGroup = false) {
      const prop = withinGroup ? "withinGroup" : "orderBy";
      return freeze({
        ...aggregateFunctionNode,
        [prop]: aggregateFunctionNode[prop] ? OrderByNode.cloneWithItems(aggregateFunctionNode[prop], orderItems) : OrderByNode.create(orderItems)
      });
    },
    cloneWithFilter(aggregateFunctionNode, filter2) {
      return freeze({
        ...aggregateFunctionNode,
        filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter2) : WhereNode.create(filter2)
      });
    },
    cloneWithOrFilter(aggregateFunctionNode, filter2) {
      return freeze({
        ...aggregateFunctionNode,
        filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter2) : WhereNode.create(filter2)
      });
    },
    cloneWithOver(aggregateFunctionNode, over) {
      return freeze({
        ...aggregateFunctionNode,
        over
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/function-node.js
var FunctionNode;
var init_function_node = __esm(() => {
  init_object_utils();
  FunctionNode = freeze({
    is(node) {
      return node.kind === "FunctionNode";
    },
    create(func, args) {
      return freeze({
        kind: "FunctionNode",
        func,
        arguments: args
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/aggregate-function-builder.js
class AggregateFunctionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return;
  }
  as(alias) {
    return new AliasedAggregateFunctionBuilder(this, alias);
  }
  distinct() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)
    });
  }
  orderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithOrderByItems(this.#props.aggregateFunctionNode, parseOrderBy(args))
    });
  }
  clearOrderBy() {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: QueryNode.cloneWithoutOrderBy(this.#props.aggregateFunctionNode)
    });
  }
  withinGroupOrderBy(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(this.#props.aggregateFunctionNode, parseOrderBy(args), true)
    });
  }
  filterWhere(...args) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
    });
  }
  filterWhereRef(lhs, op, rhs) {
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
    });
  }
  over(over) {
    const builder = createOverBuilder();
    return new AggregateFunctionBuilder({
      ...this.#props,
      aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
    });
  }
  $call(func) {
    return func(this);
  }
  $castTo() {
    return new AggregateFunctionBuilder(this.#props);
  }
  $notNull() {
    return new AggregateFunctionBuilder(this.#props);
  }
  toOperationNode() {
    return this.#props.aggregateFunctionNode;
  }
}

class AliasedAggregateFunctionBuilder {
  #aggregateFunctionBuilder;
  #alias;
  constructor(aggregateFunctionBuilder, alias) {
    this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#aggregateFunctionBuilder;
  }
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
  }
}
var init_aggregate_function_builder = __esm(() => {
  init_object_utils();
  init_aggregate_function_node();
  init_alias_node();
  init_identifier_node();
  init_parse_utils();
  init_binary_operation_parser();
  init_order_by_parser();
  init_query_node();
});

// ../../node_modules/kysely/dist/esm/query-builder/function-module.js
function createFunctionModule() {
  const fn = (name, args) => {
    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));
  };
  const agg = (name, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : undefined)
    });
  };
  return Object.assign(fn, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values) {
      return fn("coalesce", values);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString2(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString2(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}
var init_function_module = __esm(() => {
  init_expression_wrapper();
  init_aggregate_function_node();
  init_function_node();
  init_reference_parser();
  init_select_parser();
  init_aggregate_function_builder();
  init_object_utils();
  init_table_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/unary-operation-node.js
var UnaryOperationNode;
var init_unary_operation_node = __esm(() => {
  init_object_utils();
  UnaryOperationNode = freeze({
    is(node) {
      return node.kind === "UnaryOperationNode";
    },
    create(operator, operand) {
      return freeze({
        kind: "UnaryOperationNode",
        operator,
        operand
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/unary-operation-parser.js
function parseUnaryOperation(operator, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}
var init_unary_operation_parser = __esm(() => {
  init_operator_node();
  init_unary_operation_node();
  init_reference_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/case-node.js
var CaseNode;
var init_case_node = __esm(() => {
  init_object_utils();
  init_when_node();
  CaseNode = freeze({
    is(node) {
      return node.kind === "CaseNode";
    },
    create(value) {
      return freeze({
        kind: "CaseNode",
        value
      });
    },
    cloneWithWhen(caseNode, when) {
      return freeze({
        ...caseNode,
        when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
      });
    },
    cloneWithThen(caseNode, then) {
      return freeze({
        ...caseNode,
        when: caseNode.when ? freeze([
          ...caseNode.when.slice(0, -1),
          WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
        ]) : undefined
      });
    },
    cloneWith(caseNode, props) {
      return freeze({
        ...caseNode,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/case-builder.js
class CaseBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
}

class CaseThenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  then(valueExpression) {
    return new CaseWhenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
    });
  }
}

class CaseWhenBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  when(...args) {
    return new CaseThenBuilder({
      ...this.#props,
      node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
    });
  }
  else(valueExpression) {
    return new CaseEndBuilder({
      ...this.#props,
      node: CaseNode.cloneWith(this.#props.node, {
        else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
      })
    });
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}

class CaseEndBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  end() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
  }
  endCase() {
    return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
  }
}
var init_case_builder = __esm(() => {
  init_expression_wrapper();
  init_object_utils();
  init_case_node();
  init_when_node();
  init_binary_operation_parser();
  init_value_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/json-path-leg-node.js
var JSONPathLegNode;
var init_json_path_leg_node = __esm(() => {
  init_object_utils();
  JSONPathLegNode = freeze({
    is(node) {
      return node.kind === "JSONPathLegNode";
    },
    create(type, value) {
      return freeze({
        kind: "JSONPathLegNode",
        type,
        value
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-builder/json-path-builder.js
class JSONPathBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  at(index) {
    return this.#createBuilderWithPathLeg("ArrayLocation", index);
  }
  key(key) {
    return this.#createBuilderWithPathLeg("Member", key);
  }
  #createBuilderWithPathLeg(legType, value) {
    if (JSONReferenceNode.is(this.#node)) {
      return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
    }
    return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
  }
}

class AliasedJSONPathBuilder {
  #jsonPath;
  #alias;
  constructor(jsonPath, alias) {
    this.#jsonPath = jsonPath;
    this.#alias = alias;
  }
  get expression() {
    return this.#jsonPath;
  }
  get alias() {
    return this.#alias;
  }
  toOperationNode() {
    return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
var TraversedJSONPathBuilder;
var init_json_path_builder = __esm(() => {
  init_alias_node();
  init_identifier_node();
  init_json_operator_chain_node();
  init_json_path_leg_node();
  init_json_path_node();
  init_json_reference_node();
  init_operation_node_source();
  init_value_node();
  TraversedJSONPathBuilder = class TraversedJSONPathBuilder extends JSONPathBuilder {
    #node;
    constructor(node) {
      super(node);
      this.#node = node;
    }
    get expressionType() {
      return;
    }
    as(alias) {
      return new AliasedJSONPathBuilder(this, alias);
    }
    $castTo() {
      return new TraversedJSONPathBuilder(this.#node);
    }
    $notNull() {
      return new TraversedJSONPathBuilder(this.#node);
    }
    toOperationNode() {
      return this.#node;
    }
  };
});

// ../../node_modules/kysely/dist/esm/operation-node/tuple-node.js
var TupleNode;
var init_tuple_node = __esm(() => {
  init_object_utils();
  TupleNode = freeze({
    is(node) {
      return node.kind === "TupleNode";
    },
    create(values) {
      return freeze({
        kind: "TupleNode",
        values: freeze(values)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/data-type-node.js
function isColumnDataType(dataType) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r) => r.test(dataType))) {
    return true;
  }
  return false;
}
var SIMPLE_COLUMN_DATA_TYPES, COLUMN_DATA_TYPE_REGEX, DataTypeNode;
var init_data_type_node = __esm(() => {
  init_object_utils();
  SIMPLE_COLUMN_DATA_TYPES = [
    "varchar",
    "char",
    "text",
    "integer",
    "int2",
    "int4",
    "int8",
    "smallint",
    "bigint",
    "boolean",
    "real",
    "double precision",
    "float4",
    "float8",
    "decimal",
    "numeric",
    "binary",
    "bytea",
    "date",
    "datetime",
    "time",
    "timetz",
    "timestamp",
    "timestamptz",
    "serial",
    "bigserial",
    "uuid",
    "json",
    "jsonb",
    "blob",
    "varbinary",
    "int4range",
    "int4multirange",
    "int8range",
    "int8multirange",
    "numrange",
    "nummultirange",
    "tsrange",
    "tsmultirange",
    "tstzrange",
    "tstzmultirange",
    "daterange",
    "datemultirange"
  ];
  COLUMN_DATA_TYPE_REGEX = [
    /^varchar\(\d+\)$/,
    /^char\(\d+\)$/,
    /^decimal\(\d+, \d+\)$/,
    /^numeric\(\d+, \d+\)$/,
    /^binary\(\d+\)$/,
    /^datetime\(\d+\)$/,
    /^time\(\d+\)$/,
    /^timetz\(\d+\)$/,
    /^timestamp\(\d+\)$/,
    /^timestamptz\(\d+\)$/,
    /^varbinary\(\d+\)$/
  ];
  DataTypeNode = freeze({
    is(node) {
      return node.kind === "DataTypeNode";
    },
    create(dataType) {
      return freeze({
        kind: "DataTypeNode",
        dataType
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/data-type-parser.js
function parseDataTypeExpression(dataType) {
  if (isOperationNodeSource(dataType)) {
    return dataType.toOperationNode();
  }
  if (isColumnDataType(dataType)) {
    return DataTypeNode.create(dataType);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}
var init_data_type_parser = __esm(() => {
  init_data_type_node();
  init_operation_node_source();
});

// ../../node_modules/kysely/dist/esm/operation-node/cast-node.js
var CastNode;
var init_cast_node = __esm(() => {
  init_object_utils();
  CastNode = freeze({
    is(node) {
      return node.kind === "CastNode";
    },
    create(expression, dataType) {
      return freeze({
        kind: "CastNode",
        expression,
        dataType
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/expression/expression-builder.js
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary2(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  const eb = Object.assign(binary2, {
    fn: undefined,
    eb: undefined,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined2(reference) ? undefined : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined2(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
    },
    tuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node)) {
        return new ExpressionWrapper(node);
      } else {
        return new ExpressionWrapper(ParensNode.create(node));
      }
    },
    cast(expr, dataType) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
    },
    withSchema(schema2) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema2)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_) {
  return createExpressionBuilder();
}
var init_expression_builder = __esm(() => {
  init_select_query_builder();
  init_select_query_node();
  init_table_parser();
  init_with_schema_plugin();
  init_query_id();
  init_function_module();
  init_reference_parser();
  init_binary_operation_parser();
  init_parens_node();
  init_expression_wrapper();
  init_operator_node();
  init_unary_operation_parser();
  init_value_parser();
  init_noop_query_executor();
  init_case_builder();
  init_case_node();
  init_object_utils();
  init_json_path_builder();
  init_binary_operation_node();
  init_and_node();
  init_tuple_node();
  init_json_path_node();
  init_data_type_parser();
  init_cast_node();
});

// ../../node_modules/kysely/dist/esm/parser/expression-parser.js
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction3(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction3(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction3(obj);
}
var init_expression_parser = __esm(() => {
  init_expression();
  init_operation_node_source();
  init_expression_builder();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/dynamic/dynamic-table-builder.js
class DynamicTableBuilder {
  #table;
  get table() {
    return this.#table;
  }
  constructor(table) {
    this.#table = table;
  }
  as(alias) {
    return new AliasedDynamicTableBuilder(this.#table, alias);
  }
}

class AliasedDynamicTableBuilder {
  #table;
  #alias;
  get table() {
    return this.#table;
  }
  get alias() {
    return this.#alias;
  }
  constructor(table, alias) {
    this.#table = table;
    this.#alias = alias;
  }
  toOperationNode() {
    return AliasNode.create(parseTable(this.#table), IdentifierNode.create(this.#alias));
  }
}
function isAliasedDynamicTableBuilder(obj) {
  return isObject3(obj) && isOperationNodeSource(obj) && isString2(obj.table) && isString2(obj.alias);
}
var init_dynamic_table_builder = __esm(() => {
  init_alias_node();
  init_identifier_node();
  init_operation_node_source();
  init_table_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/parser/table-parser.js
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString2(table)) {
    return parseAliasedTable(table);
  } else if (isAliasedDynamicTableBuilder(table)) {
    return table.toOperationNode();
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim3);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema2, table] = from.split(SCHEMA_SEPARATOR).map(trim3);
    return TableNode.createWithSchema(schema2, table);
  } else {
    return TableNode.create(from);
  }
}
function trim3(str) {
  return str.trim();
}
var init_table_parser = __esm(() => {
  init_object_utils();
  init_alias_node();
  init_table_node();
  init_expression_parser();
  init_identifier_node();
  init_dynamic_table_builder();
});

// ../../node_modules/kysely/dist/esm/operation-node/add-column-node.js
var AddColumnNode;
var init_add_column_node = __esm(() => {
  init_object_utils();
  AddColumnNode = freeze({
    is(node) {
      return node.kind === "AddColumnNode";
    },
    create(column) {
      return freeze({
        kind: "AddColumnNode",
        column
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/column-definition-node.js
var ColumnDefinitionNode;
var init_column_definition_node = __esm(() => {
  init_object_utils();
  init_column_node();
  ColumnDefinitionNode = freeze({
    is(node) {
      return node.kind === "ColumnDefinitionNode";
    },
    create(column, dataType) {
      return freeze({
        kind: "ColumnDefinitionNode",
        column: ColumnNode.create(column),
        dataType
      });
    },
    cloneWithFrontModifier(node, modifier) {
      return freeze({
        ...node,
        frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]
      });
    },
    cloneWithEndModifier(node, modifier) {
      return freeze({
        ...node,
        endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-column-node.js
var DropColumnNode;
var init_drop_column_node = __esm(() => {
  init_object_utils();
  init_column_node();
  DropColumnNode = freeze({
    is(node) {
      return node.kind === "DropColumnNode";
    },
    create(column) {
      return freeze({
        kind: "DropColumnNode",
        column: ColumnNode.create(column)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/rename-column-node.js
var RenameColumnNode;
var init_rename_column_node = __esm(() => {
  init_object_utils();
  init_column_node();
  RenameColumnNode = freeze({
    is(node) {
      return node.kind === "RenameColumnNode";
    },
    create(column, newColumn) {
      return freeze({
        kind: "RenameColumnNode",
        column: ColumnNode.create(column),
        renameTo: ColumnNode.create(newColumn)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/check-constraint-node.js
var CheckConstraintNode;
var init_check_constraint_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  CheckConstraintNode = freeze({
    is(node) {
      return node.kind === "CheckConstraintNode";
    },
    create(expression, constraintName) {
      return freeze({
        kind: "CheckConstraintNode",
        expression,
        name: constraintName ? IdentifierNode.create(constraintName) : undefined
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/references-node.js
var ON_MODIFY_FOREIGN_ACTIONS, ReferencesNode;
var init_references_node = __esm(() => {
  init_object_utils();
  ON_MODIFY_FOREIGN_ACTIONS = [
    "no action",
    "restrict",
    "cascade",
    "set null",
    "set default"
  ];
  ReferencesNode = freeze({
    is(node) {
      return node.kind === "ReferencesNode";
    },
    create(table, columns) {
      return freeze({
        kind: "ReferencesNode",
        table,
        columns: freeze([...columns])
      });
    },
    cloneWithOnDelete(references, onDelete) {
      return freeze({
        ...references,
        onDelete
      });
    },
    cloneWithOnUpdate(references, onUpdate) {
      return freeze({
        ...references,
        onUpdate
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/default-value-parser.js
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}
var init_default_value_parser = __esm(() => {
  init_operation_node_source();
  init_value_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/generated-node.js
var GeneratedNode;
var init_generated_node = __esm(() => {
  init_object_utils();
  GeneratedNode = freeze({
    is(node) {
      return node.kind === "GeneratedNode";
    },
    create(params) {
      return freeze({
        kind: "GeneratedNode",
        ...params
      });
    },
    createWithExpression(expression) {
      return freeze({
        kind: "GeneratedNode",
        always: true,
        expression
      });
    },
    cloneWith(node, params) {
      return freeze({
        ...node,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/default-value-node.js
var DefaultValueNode;
var init_default_value_node = __esm(() => {
  init_object_utils();
  DefaultValueNode = freeze({
    is(node) {
      return node.kind === "DefaultValueNode";
    },
    create(defaultValue) {
      return freeze({
        kind: "DefaultValueNode",
        defaultValue
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/parser/on-modify-action-parser.js
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}
var init_on_modify_action_parser = __esm(() => {
  init_references_node();
});

// ../../node_modules/kysely/dist/esm/schema/column-definition-builder.js
class ColumnDefinitionBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  autoIncrement() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
  }
  identity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
  }
  primaryKey() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
  }
  references(ref) {
    const references = parseStringReference(ref);
    if (!references.table || SelectAllNode.is(references.column)) {
      throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.create(references.table, [
        references.column
      ])
    }));
  }
  onDelete(onDelete) {
    if (!this.#node.references) {
      throw new Error("on delete constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))
    }));
  }
  onUpdate(onUpdate) {
    if (!this.#node.references) {
      throw new Error("on update constraint can only be added for foreign keys");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))
    }));
  }
  unique() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
  }
  notNull() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
  }
  unsigned() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
  }
  defaultTo(value) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
    }));
  }
  check(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      check: CheckConstraintNode.create(expression.toOperationNode())
    }));
  }
  generatedAlwaysAs(expression) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.createWithExpression(expression.toOperationNode())
    }));
  }
  generatedAlwaysAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, always: true })
    }));
  }
  generatedByDefaultAsIdentity() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.create({ identity: true, byDefault: true })
    }));
  }
  stored() {
    if (!this.#node.generated) {
      throw new Error("stored() can only be called after generatedAlwaysAs");
    }
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
      generated: GeneratedNode.cloneWith(this.#node.generated, {
        stored: true
      })
    }));
  }
  modifyFront(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
  }
  nullsNotDistinct() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  ifNotExists() {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
  }
  modifyEnd(modifier) {
    return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
var init_column_definition_builder = __esm(() => {
  init_check_constraint_node();
  init_references_node();
  init_select_all_node();
  init_reference_parser();
  init_column_definition_node();
  init_default_value_parser();
  init_generated_node();
  init_default_value_node();
  init_on_modify_action_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/modify-column-node.js
var ModifyColumnNode;
var init_modify_column_node = __esm(() => {
  init_object_utils();
  ModifyColumnNode = freeze({
    is(node) {
      return node.kind === "ModifyColumnNode";
    },
    create(column) {
      return freeze({
        kind: "ModifyColumnNode",
        column
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/foreign-key-constraint-node.js
var ForeignKeyConstraintNode;
var init_foreign_key_constraint_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  init_references_node();
  ForeignKeyConstraintNode = freeze({
    is(node) {
      return node.kind === "ForeignKeyConstraintNode";
    },
    create(sourceColumns, targetTable, targetColumns, constraintName) {
      return freeze({
        kind: "ForeignKeyConstraintNode",
        columns: sourceColumns,
        references: ReferencesNode.create(targetTable, targetColumns),
        name: constraintName ? IdentifierNode.create(constraintName) : undefined
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js
class ForeignKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  onDelete(onDelete) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onDelete: parseOnModifyForeignAction(onDelete)
    }));
  }
  onUpdate(onUpdate) {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      onUpdate: parseOnModifyForeignAction(onUpdate)
    }));
  }
  deferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
var init_foreign_key_constraint_builder = __esm(() => {
  init_foreign_key_constraint_node();
  init_on_modify_action_parser();
});

// ../../node_modules/kysely/dist/esm/operation-node/add-constraint-node.js
var AddConstraintNode;
var init_add_constraint_node = __esm(() => {
  init_object_utils();
  AddConstraintNode = freeze({
    is(node) {
      return node.kind === "AddConstraintNode";
    },
    create(constraint) {
      return freeze({
        kind: "AddConstraintNode",
        constraint
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/unique-constraint-node.js
var UniqueConstraintNode;
var init_unique_constraint_node = __esm(() => {
  init_object_utils();
  init_column_node();
  init_identifier_node();
  UniqueConstraintNode = freeze({
    is(node) {
      return node.kind === "UniqueConstraintNode";
    },
    create(columns, constraintName, nullsNotDistinct) {
      return freeze({
        kind: "UniqueConstraintNode",
        columns: freeze(columns.map(ColumnNode.create)),
        name: constraintName ? IdentifierNode.create(constraintName) : undefined,
        nullsNotDistinct
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-constraint-node.js
var DropConstraintNode;
var init_drop_constraint_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  DropConstraintNode = freeze({
    is(node) {
      return node.kind === "DropConstraintNode";
    },
    create(constraintName) {
      return freeze({
        kind: "DropConstraintNode",
        constraintName: IdentifierNode.create(constraintName)
      });
    },
    cloneWith(dropConstraint, props) {
      return freeze({
        ...dropConstraint,
        ...props
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/alter-column-node.js
var AlterColumnNode;
var init_alter_column_node = __esm(() => {
  init_object_utils();
  init_column_node();
  AlterColumnNode = freeze({
    is(node) {
      return node.kind === "AlterColumnNode";
    },
    create(column, prop, value) {
      return freeze({
        kind: "AlterColumnNode",
        column: ColumnNode.create(column),
        [prop]: value
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/alter-column-builder.js
class AlterColumnBuilder {
  #column;
  constructor(column) {
    this.#column = column;
  }
  setDataType(dataType) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dataType", parseDataTypeExpression(dataType)));
  }
  setDefault(value) {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setDefault", parseDefaultValueExpression(value)));
  }
  dropDefault() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropDefault", true));
  }
  setNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setNotNull", true));
  }
  dropNotNull() {
    return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropNotNull", true));
  }
  $call(func) {
    return func(this);
  }
}

class AlteredColumnBuilder {
  #alterColumnNode;
  constructor(alterColumnNode) {
    this.#alterColumnNode = alterColumnNode;
  }
  toOperationNode() {
    return this.#alterColumnNode;
  }
}
var init_alter_column_builder = __esm(() => {
  init_alter_column_node();
  init_data_type_parser();
  init_default_value_parser();
});

// ../../node_modules/kysely/dist/esm/schema/alter-table-executor.js
class AlterTableExecutor {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_alter_table_executor = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/schema/alter-table-add-foreign-key-constraint-builder.js
class AlterTableAddForeignKeyConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  onDelete(onDelete) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)
    });
  }
  onUpdate(onUpdate) {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)
    });
  }
  deferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.deferrable()
    });
  }
  notDeferrable() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.notDeferrable()
    });
  }
  initiallyDeferred() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyDeferred()
    });
  }
  initiallyImmediate() {
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder: this.#props.constraintBuilder.initiallyImmediate()
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
      addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())
    }), this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_alter_table_add_foreign_key_constraint_builder = __esm(() => {
  init_add_constraint_node();
  init_alter_table_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/schema/alter-table-drop-constraint-builder.js
class AlterTableDropConstraintBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          ifExists: true
        })
      })
    });
  }
  cascade() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "cascade"
        })
      })
    });
  }
  restrict() {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
          modifier: "restrict"
        })
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_alter_table_drop_constraint_builder = __esm(() => {
  init_alter_table_node();
  init_drop_constraint_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/primary-key-constraint-node.js
var PrimaryKeyConstraintNode;
var init_primary_key_constraint_node = __esm(() => {
  init_object_utils();
  init_column_node();
  init_identifier_node();
  PrimaryKeyConstraintNode = freeze({
    is(node) {
      return node.kind === "PrimaryKeyConstraintNode";
    },
    create(columns, constraintName) {
      return freeze({
        kind: "PrimaryKeyConstraintNode",
        columns: freeze(columns.map(ColumnNode.create)),
        name: constraintName ? IdentifierNode.create(constraintName) : undefined
      });
    },
    cloneWith(node, props) {
      return freeze({ ...node, ...props });
    }
  });
});

// ../../node_modules/kysely/dist/esm/operation-node/add-index-node.js
var AddIndexNode;
var init_add_index_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  AddIndexNode = freeze({
    is(node) {
      return node.kind === "AddIndexNode";
    },
    create(name) {
      return freeze({
        kind: "AddIndexNode",
        name: IdentifierNode.create(name)
      });
    },
    cloneWith(node, props) {
      return freeze({
        ...node,
        ...props
      });
    },
    cloneWithColumns(node, columns) {
      return freeze({
        ...node,
        columns: [...node.columns || [], ...columns]
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/alter-table-add-index-builder.js
class AlterTableAddIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  unique() {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          unique: true
        })
      })
    });
  }
  column(column) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          parseOrderedColumnName(column)
        ])
      })
    });
  }
  columns(columns) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))
      })
    });
  }
  expression(expression) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
          expression.toOperationNode()
        ])
      })
    });
  }
  using(indexType) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
          using: RawNode.createWithSql(indexType)
        })
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_alter_table_add_index_builder = __esm(() => {
  init_add_index_node();
  init_alter_table_node();
  init_raw_node();
  init_reference_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/schema/unique-constraint-builder.js
class UniqueConstraintNodeBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  nullsNotDistinct() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
  }
  deferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
var init_unique_constraint_builder = __esm(() => {
  init_unique_constraint_node();
});

// ../../node_modules/kysely/dist/esm/schema/primary-key-constraint-builder.js
class PrimaryKeyConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  deferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: true }));
  }
  notDeferrable() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, { deferrable: false }));
  }
  initiallyDeferred() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: true
    }));
  }
  initiallyImmediate() {
    return new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.cloneWith(this.#node, {
      initiallyDeferred: false
    }));
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}
var init_primary_key_constraint_builder = __esm(() => {
  init_primary_key_constraint_node();
});

// ../../node_modules/kysely/dist/esm/schema/check-constraint-builder.js
class CheckConstraintBuilder {
  #node;
  constructor(node) {
    this.#node = node;
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#node;
  }
}

// ../../node_modules/kysely/dist/esm/operation-node/rename-constraint-node.js
var RenameConstraintNode;
var init_rename_constraint_node = __esm(() => {
  init_object_utils();
  init_identifier_node();
  RenameConstraintNode = freeze({
    is(node) {
      return node.kind === "RenameConstraintNode";
    },
    create(oldName, newName) {
      return freeze({
        kind: "RenameConstraintNode",
        oldName: IdentifierNode.create(oldName),
        newName: IdentifierNode.create(newName)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/alter-table-builder.js
class AlterTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  renameTo(newTableName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameTo: parseTable(newTableName)
      })
    });
  }
  setSchema(newSchema) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        setSchema: IdentifierNode.create(newSchema)
      })
    });
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop2) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop2) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  addUniqueConstraint(constraintName, columns, build = noop2) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
      })
    });
  }
  addCheckConstraint(constraintName, checkExpression, build = noop2) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop2) {
    const constraintBuilder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new AlterTableAddForeignKeyConstraintBuilder({
      ...this.#props,
      constraintBuilder
    });
  }
  addPrimaryKeyConstraint(constraintName, columns, build = noop2) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addConstraint: AddConstraintNode.create(constraintBuilder.toOperationNode())
      })
    });
  }
  dropConstraint(constraintName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropConstraint: DropConstraintNode.create(constraintName)
      })
    });
  }
  renameConstraint(oldName, newName) {
    return new AlterTableDropConstraintBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        renameConstraint: RenameConstraintNode.create(oldName, newName)
      })
    });
  }
  addIndex(indexName) {
    return new AlterTableAddIndexBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        addIndex: AddIndexNode.create(indexName)
      })
    });
  }
  dropIndex(indexName) {
    return new AlterTableExecutor({
      ...this.#props,
      node: AlterTableNode.cloneWithTableProps(this.#props.node, {
        dropIndex: DropIndexNode.create(indexName)
      })
    });
  }
  $call(func) {
    return func(this);
  }
}

class AlterTableColumnAlteringBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  alterColumn(column, alteration) {
    const builder = alteration(new AlterColumnBuilder(column));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
    });
  }
  dropColumn(column) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
    });
  }
  renameColumn(column, newColumn) {
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
    });
  }
  addColumn(columnName, dataType, build = noop2) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
    });
  }
  modifyColumn(columnName, dataType, build = noop2) {
    const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new AlterTableColumnAlteringBuilder({
      ...this.#props,
      node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
    });
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_alter_table_builder = __esm(() => {
  init_add_column_node();
  init_alter_table_node();
  init_column_definition_node();
  init_drop_column_node();
  init_identifier_node();
  init_rename_column_node();
  init_object_utils();
  init_column_definition_builder();
  init_modify_column_node();
  init_data_type_parser();
  init_foreign_key_constraint_builder();
  init_add_constraint_node();
  init_unique_constraint_node();
  init_check_constraint_node();
  init_foreign_key_constraint_node();
  init_column_node();
  init_table_parser();
  init_drop_constraint_node();
  init_alter_column_builder();
  init_alter_table_executor();
  init_alter_table_add_foreign_key_constraint_builder();
  init_alter_table_drop_constraint_builder();
  init_primary_key_constraint_node();
  init_drop_index_node();
  init_add_index_node();
  init_alter_table_add_index_builder();
  init_unique_constraint_builder();
  init_primary_key_constraint_builder();
  init_rename_constraint_node();
});

// ../../node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-transformer.js
var ImmediateValueTransformer;
var init_immediate_value_transformer = __esm(() => {
  init_operation_node_transformer();
  init_value_list_node();
  init_value_node();
  ImmediateValueTransformer = class ImmediateValueTransformer extends OperationNodeTransformer {
    transformPrimitiveValueList(node) {
      return ValueListNode.create(node.values.map(ValueNode.createImmediate));
    }
    transformValue(node) {
      return ValueNode.createImmediate(node.value);
    }
  };
});

// ../../node_modules/kysely/dist/esm/schema/create-index-builder.js
class CreateIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  unique() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        unique: true
      })
    });
  }
  nullsNotDistinct() {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        nullsNotDistinct: true
      })
    });
  }
  on(table) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  column(column) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        parseOrderedColumnName(column)
      ])
    });
  }
  columns(columns) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))
    });
  }
  expression(expression) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWithColumns(this.#props.node, [
        expression.toOperationNode()
      ])
    });
  }
  using(indexType) {
    return new CreateIndexBuilder({
      ...this.#props,
      node: CreateIndexNode.cloneWith(this.#props.node, {
        using: RawNode.createWithSql(indexType)
      })
    });
  }
  where(...args) {
    const transformer = new ImmediateValueTransformer;
    return new CreateIndexBuilder({
      ...this.#props,
      node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args), this.#props.queryId))
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_create_index_builder = __esm(() => {
  init_create_index_node();
  init_raw_node();
  init_reference_parser();
  init_table_parser();
  init_object_utils();
  init_binary_operation_parser();
  init_query_node();
  init_immediate_value_transformer();
});

// ../../node_modules/kysely/dist/esm/schema/create-schema-builder.js
class CreateSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifNotExists() {
    return new CreateSchemaBuilder({
      ...this.#props,
      node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_create_schema_builder = __esm(() => {
  init_create_schema_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/parser/on-commit-action-parse.js
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}
var init_on_commit_action_parse = __esm(() => {
  init_create_table_node();
});

// ../../node_modules/kysely/dist/esm/schema/create-table-builder.js
class CreateTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  temporary() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  onCommit(onCommit) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        onCommit: parseOnCommitAction(onCommit)
      })
    });
  }
  ifNotExists() {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  addColumn(columnName, dataType, build = noop2) {
    const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())
    });
  }
  addPrimaryKeyConstraint(constraintName, columns, build = noop2) {
    const constraintBuilder = build(new PrimaryKeyConstraintBuilder(PrimaryKeyConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  addUniqueConstraint(constraintName, columns, build = noop2) {
    const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())
    });
  }
  addCheckConstraint(constraintName, checkExpression, build = noop2) {
    const constraintBuilder = build(new CheckConstraintBuilder(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, constraintBuilder.toOperationNode())
    });
  }
  addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop2) {
    const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())
    });
  }
  modifyFront(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  modifyEnd(modifier) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())
    });
  }
  as(expression) {
    return new CreateTableBuilder({
      ...this.#props,
      node: CreateTableNode.cloneWith(this.#props.node, {
        selectQuery: parseExpression(expression)
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_create_table_builder = __esm(() => {
  init_column_definition_node();
  init_create_table_node();
  init_column_definition_builder();
  init_object_utils();
  init_foreign_key_constraint_node();
  init_column_node();
  init_foreign_key_constraint_builder();
  init_data_type_parser();
  init_primary_key_constraint_node();
  init_unique_constraint_node();
  init_check_constraint_node();
  init_table_parser();
  init_on_commit_action_parse();
  init_unique_constraint_builder();
  init_expression_parser();
  init_primary_key_constraint_builder();
});

// ../../node_modules/kysely/dist/esm/schema/drop-index-builder.js
class DropIndexBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  on(table) {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        table: parseTable(table)
      })
    });
  }
  ifExists() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropIndexBuilder({
      ...this.#props,
      node: DropIndexNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_drop_index_builder = __esm(() => {
  init_drop_index_node();
  init_table_parser();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/schema/drop-schema-builder.js
class DropSchemaBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropSchemaBuilder({
      ...this.#props,
      node: DropSchemaNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_drop_schema_builder = __esm(() => {
  init_drop_schema_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/schema/drop-table-builder.js
class DropTableBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropTableBuilder({
      ...this.#props,
      node: DropTableNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_drop_table_builder = __esm(() => {
  init_drop_table_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/create-view-node.js
var CreateViewNode;
var init_create_view_node = __esm(() => {
  init_object_utils();
  init_schemable_identifier_node();
  CreateViewNode = freeze({
    is(node) {
      return node.kind === "CreateViewNode";
    },
    create(name) {
      return freeze({
        kind: "CreateViewNode",
        name: SchemableIdentifierNode.create(name)
      });
    },
    cloneWith(createView2, params) {
      return freeze({
        ...createView2,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-plugin.js
class ImmediateValuePlugin {
  #transformer = new ImmediateValueTransformer;
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
}
var init_immediate_value_plugin = __esm(() => {
  init_immediate_value_transformer();
});

// ../../node_modules/kysely/dist/esm/schema/create-view-builder.js
class CreateViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  temporary() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        temporary: true
      })
    });
  }
  materialized() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifNotExists() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        ifNotExists: true
      })
    });
  }
  orReplace() {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        orReplace: true
      })
    });
  }
  columns(columns) {
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        columns: columns.map(parseColumnName)
      })
    });
  }
  as(query) {
    const queryNode = query.withPlugin(new ImmediateValuePlugin).toOperationNode();
    return new CreateViewBuilder({
      ...this.#props,
      node: CreateViewNode.cloneWith(this.#props.node, {
        as: queryNode
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_create_view_builder = __esm(() => {
  init_object_utils();
  init_create_view_node();
  init_reference_parser();
  init_immediate_value_plugin();
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-view-node.js
var DropViewNode;
var init_drop_view_node = __esm(() => {
  init_object_utils();
  init_schemable_identifier_node();
  DropViewNode = freeze({
    is(node) {
      return node.kind === "DropViewNode";
    },
    create(name) {
      return freeze({
        kind: "DropViewNode",
        name: SchemableIdentifierNode.create(name)
      });
    },
    cloneWith(dropView, params) {
      return freeze({
        ...dropView,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/drop-view-builder.js
class DropViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  materialized() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        materialized: true
      })
    });
  }
  ifExists() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  cascade() {
    return new DropViewBuilder({
      ...this.#props,
      node: DropViewNode.cloneWith(this.#props.node, {
        cascade: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_drop_view_builder = __esm(() => {
  init_object_utils();
  init_drop_view_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/create-type-node.js
var CreateTypeNode;
var init_create_type_node = __esm(() => {
  init_object_utils();
  init_value_list_node();
  init_value_node();
  CreateTypeNode = freeze({
    is(node) {
      return node.kind === "CreateTypeNode";
    },
    create(name) {
      return freeze({
        kind: "CreateTypeNode",
        name
      });
    },
    cloneWithEnum(createType, values) {
      return freeze({
        ...createType,
        enum: ValueListNode.create(values.map(ValueNode.createImmediate))
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/create-type-builder.js
class CreateTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  asEnum(values) {
    return new CreateTypeBuilder({
      ...this.#props,
      node: CreateTypeNode.cloneWithEnum(this.#props.node, values)
    });
  }
  $call(func) {
    return func(this);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_create_type_builder = __esm(() => {
  init_object_utils();
  init_create_type_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/drop-type-node.js
var DropTypeNode;
var init_drop_type_node = __esm(() => {
  init_object_utils();
  DropTypeNode = freeze({
    is(node) {
      return node.kind === "DropTypeNode";
    },
    create(name) {
      return freeze({
        kind: "DropTypeNode",
        name
      });
    },
    cloneWith(dropType, params) {
      return freeze({
        ...dropType,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/drop-type-builder.js
class DropTypeBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  ifExists() {
    return new DropTypeBuilder({
      ...this.#props,
      node: DropTypeNode.cloneWith(this.#props.node, {
        ifExists: true
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_drop_type_builder = __esm(() => {
  init_drop_type_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/parser/identifier-parser.js
function parseSchemableIdentifier(id) {
  const SCHEMA_SEPARATOR = ".";
  if (id.includes(SCHEMA_SEPARATOR)) {
    const parts = id.split(SCHEMA_SEPARATOR).map(trim4);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id}`);
    }
  } else {
    return SchemableIdentifierNode.create(id);
  }
}
function trim4(str) {
  return str.trim();
}
var init_identifier_parser = __esm(() => {
  init_schemable_identifier_node();
});

// ../../node_modules/kysely/dist/esm/operation-node/refresh-materialized-view-node.js
var RefreshMaterializedViewNode;
var init_refresh_materialized_view_node = __esm(() => {
  init_object_utils();
  init_schemable_identifier_node();
  RefreshMaterializedViewNode = freeze({
    is(node) {
      return node.kind === "RefreshMaterializedViewNode";
    },
    create(name) {
      return freeze({
        kind: "RefreshMaterializedViewNode",
        name: SchemableIdentifierNode.create(name)
      });
    },
    cloneWith(createView2, params) {
      return freeze({
        ...createView2,
        ...params
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/schema/refresh-materialized-view-builder.js
class RefreshMaterializedViewBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  concurrently() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        concurrently: true,
        withNoData: false
      })
    });
  }
  withData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: false
      })
    });
  }
  withNoData() {
    return new RefreshMaterializedViewBuilder({
      ...this.#props,
      node: RefreshMaterializedViewNode.cloneWith(this.#props.node, {
        withNoData: true,
        concurrently: false
      })
    });
  }
  $call(func) {
    return func(this);
  }
  toOperationNode() {
    return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
  }
  compile() {
    return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
  }
  async execute() {
    await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
  }
}
var init_refresh_materialized_view_builder = __esm(() => {
  init_object_utils();
  init_refresh_materialized_view_node();
});

// ../../node_modules/kysely/dist/esm/schema/schema.js
class SchemaModule {
  #executor;
  constructor(executor) {
    this.#executor = executor;
  }
  createTable(table) {
    return new CreateTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTableNode.create(parseTable(table))
    });
  }
  dropTable(table) {
    return new DropTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTableNode.create(parseTable(table))
    });
  }
  createIndex(indexName) {
    return new CreateIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateIndexNode.create(indexName)
    });
  }
  dropIndex(indexName) {
    return new DropIndexBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropIndexNode.create(indexName)
    });
  }
  createSchema(schema2) {
    return new CreateSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateSchemaNode.create(schema2)
    });
  }
  dropSchema(schema2) {
    return new DropSchemaBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropSchemaNode.create(schema2)
    });
  }
  alterTable(table) {
    return new AlterTableBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: AlterTableNode.create(parseTable(table))
    });
  }
  createView(viewName) {
    return new CreateViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateViewNode.create(viewName)
    });
  }
  refreshMaterializedView(viewName) {
    return new RefreshMaterializedViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: RefreshMaterializedViewNode.create(viewName)
    });
  }
  dropView(viewName) {
    return new DropViewBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropViewNode.create(viewName)
    });
  }
  createType(typeName) {
    return new CreateTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  dropType(typeName) {
    return new DropTypeBuilder({
      queryId: createQueryId(),
      executor: this.#executor,
      node: DropTypeNode.create(parseSchemableIdentifier(typeName))
    });
  }
  withPlugin(plugin) {
    return new SchemaModule(this.#executor.withPlugin(plugin));
  }
  withoutPlugins() {
    return new SchemaModule(this.#executor.withoutPlugins());
  }
  withSchema(schema2) {
    return new SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema2)));
  }
}
var init_schema = __esm(() => {
  init_alter_table_node();
  init_create_index_node();
  init_create_schema_node();
  init_create_table_node();
  init_drop_index_node();
  init_drop_schema_node();
  init_drop_table_node();
  init_table_parser();
  init_alter_table_builder();
  init_create_index_builder();
  init_create_schema_builder();
  init_create_table_builder();
  init_drop_index_builder();
  init_drop_schema_builder();
  init_drop_table_builder();
  init_query_id();
  init_with_schema_plugin();
  init_create_view_builder();
  init_create_view_node();
  init_drop_view_builder();
  init_drop_view_node();
  init_create_type_builder();
  init_drop_type_builder();
  init_create_type_node();
  init_drop_type_node();
  init_identifier_parser();
  init_refresh_materialized_view_builder();
  init_refresh_materialized_view_node();
});

// ../../node_modules/kysely/dist/esm/dynamic/dynamic.js
class DynamicModule {
  ref(reference) {
    return new DynamicReferenceBuilder(reference);
  }
  table(table) {
    return new DynamicTableBuilder(table);
  }
}
var init_dynamic = __esm(() => {
  init_dynamic_reference_builder();
  init_dynamic_table_builder();
});

// ../../node_modules/kysely/dist/esm/driver/default-connection-provider.js
class DefaultConnectionProvider {
  #driver;
  constructor(driver) {
    this.#driver = driver;
  }
  async provideConnection(consumer) {
    const connection = await this.#driver.acquireConnection();
    try {
      return await consumer(connection);
    } finally {
      await this.#driver.releaseConnection(connection);
    }
  }
}

// ../../node_modules/kysely/dist/esm/query-executor/default-query-executor.js
var DefaultQueryExecutor;
var init_default_query_executor = __esm(() => {
  init_query_executor_base();
  DefaultQueryExecutor = class DefaultQueryExecutor extends QueryExecutorBase {
    #compiler;
    #adapter;
    #connectionProvider;
    constructor(compiler, adapter, connectionProvider, plugins = []) {
      super(plugins);
      this.#compiler = compiler;
      this.#adapter = adapter;
      this.#connectionProvider = connectionProvider;
    }
    get adapter() {
      return this.#adapter;
    }
    compileQuery(node, queryId) {
      return this.#compiler.compileQuery(node, queryId);
    }
    provideConnection(consumer) {
      return this.#connectionProvider.provideConnection(consumer);
    }
    withPlugins(plugins) {
      return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
    }
    withPlugin(plugin) {
      return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin]);
    }
    withPluginAtFront(plugin) {
      return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin, ...this.plugins]);
    }
    withConnectionProvider(connectionProvider) {
      return new DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
    }
    withoutPlugins() {
      return new DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
    }
  };
});

// ../../node_modules/kysely/dist/esm/util/performance-now.js
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction3(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}
var init_performance_now = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/driver/runtime-driver.js
class RuntimeDriver {
  #driver;
  #log;
  #initPromise;
  #initDone;
  #destroyPromise;
  #connections = new WeakSet;
  constructor(driver, log) {
    this.#initDone = false;
    this.#driver = driver;
    this.#log = log;
  }
  async init() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initPromise) {
      this.#initPromise = this.#driver.init().then(() => {
        this.#initDone = true;
      }).catch((err) => {
        this.#initPromise = undefined;
        return Promise.reject(err);
      });
    }
    await this.#initPromise;
  }
  async acquireConnection() {
    if (this.#destroyPromise) {
      throw new Error("driver has already been destroyed");
    }
    if (!this.#initDone) {
      await this.init();
    }
    const connection = await this.#driver.acquireConnection();
    if (!this.#connections.has(connection)) {
      if (this.#needsLogging()) {
        this.#addLogging(connection);
      }
      this.#connections.add(connection);
    }
    return connection;
  }
  async releaseConnection(connection) {
    await this.#driver.releaseConnection(connection);
  }
  beginTransaction(connection, settings) {
    return this.#driver.beginTransaction(connection, settings);
  }
  commitTransaction(connection) {
    return this.#driver.commitTransaction(connection);
  }
  rollbackTransaction(connection) {
    return this.#driver.rollbackTransaction(connection);
  }
  savepoint(connection, savepointName, compileQuery) {
    if (this.#driver.savepoint) {
      return this.#driver.savepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `savepoint` method is not supported by this driver");
  }
  rollbackToSavepoint(connection, savepointName, compileQuery) {
    if (this.#driver.rollbackToSavepoint) {
      return this.#driver.rollbackToSavepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `rollbackToSavepoint` method is not supported by this driver");
  }
  releaseSavepoint(connection, savepointName, compileQuery) {
    if (this.#driver.releaseSavepoint) {
      return this.#driver.releaseSavepoint(connection, savepointName, compileQuery);
    }
    throw new Error("The `releaseSavepoint` method is not supported by this driver");
  }
  async destroy() {
    if (!this.#initPromise) {
      return;
    }
    await this.#initPromise;
    if (!this.#destroyPromise) {
      this.#destroyPromise = this.#driver.destroy().catch((err) => {
        this.#destroyPromise = undefined;
        return Promise.reject(err);
      });
    }
    await this.#destroyPromise;
  }
  #needsLogging() {
    return this.#log.isLevelEnabled("query") || this.#log.isLevelEnabled("error");
  }
  #addLogging(connection) {
    const executeQuery = connection.executeQuery;
    const streamQuery = connection.streamQuery;
    const dis = this;
    connection.executeQuery = async (compiledQuery) => {
      let caughtError;
      const startTime = performanceNow();
      try {
        return await executeQuery.call(connection, compiledQuery);
      } catch (error2) {
        caughtError = error2;
        await dis.#logError(error2, compiledQuery, startTime);
        throw error2;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime);
        }
      }
    };
    connection.streamQuery = async function* (compiledQuery, chunkSize) {
      let caughtError;
      const startTime = performanceNow();
      try {
        for await (const result of streamQuery.call(connection, compiledQuery, chunkSize)) {
          yield result;
        }
      } catch (error2) {
        caughtError = error2;
        await dis.#logError(error2, compiledQuery, startTime);
        throw error2;
      } finally {
        if (!caughtError) {
          await dis.#logQuery(compiledQuery, startTime, true);
        }
      }
    };
  }
  async#logError(error2, compiledQuery, startTime) {
    await this.#log.error(() => ({
      level: "error",
      error: error2,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  async#logQuery(compiledQuery, startTime, isStream2 = false) {
    await this.#log.query(() => ({
      level: "query",
      isStream: isStream2,
      query: compiledQuery,
      queryDurationMillis: this.#calculateDurationMillis(startTime)
    }));
  }
  #calculateDurationMillis(startTime) {
    return performanceNow() - startTime;
  }
}
var init_runtime_driver = __esm(() => {
  init_performance_now();
});

// ../../node_modules/kysely/dist/esm/driver/single-connection-provider.js
class SingleConnectionProvider {
  #connection;
  #runningPromise;
  constructor(connection) {
    this.#connection = connection;
  }
  async provideConnection(consumer) {
    while (this.#runningPromise) {
      await this.#runningPromise.catch(ignoreError);
    }
    this.#runningPromise = this.#run(consumer).finally(() => {
      this.#runningPromise = undefined;
    });
    return this.#runningPromise;
  }
  async#run(runner) {
    return await runner(this.#connection);
  }
}
var ignoreError = () => {};

// ../../node_modules/kysely/dist/esm/driver/driver.js
function validateTransactionSettings(settings) {
  if (settings.accessMode && !TRANSACTION_ACCESS_MODES.includes(settings.accessMode)) {
    throw new Error(`invalid transaction access mode ${settings.accessMode}`);
  }
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}
var TRANSACTION_ACCESS_MODES, TRANSACTION_ISOLATION_LEVELS;
var init_driver = __esm(() => {
  TRANSACTION_ACCESS_MODES = ["read only", "read write"];
  TRANSACTION_ISOLATION_LEVELS = [
    "read uncommitted",
    "read committed",
    "repeatable read",
    "serializable",
    "snapshot"
  ];
});

// ../../node_modules/kysely/dist/esm/util/log.js
class Log {
  #levels;
  #logger;
  constructor(config2) {
    if (isFunction3(config2)) {
      this.#logger = config2;
      this.#levels = freeze({
        query: true,
        error: true
      });
    } else {
      this.#logger = defaultLogger;
      this.#levels = freeze({
        query: config2.includes("query"),
        error: config2.includes("error")
      });
    }
  }
  isLevelEnabled(level) {
    return this.#levels[level];
  }
  async query(getEvent) {
    if (this.#levels.query) {
      await this.#logger(getEvent());
    }
  }
  async error(getEvent) {
    if (this.#levels.error) {
      await this.#logger(getEvent());
    }
  }
}
function defaultLogger(event) {
  if (event.level === "query") {
    const prefix = `kysely:query:${event.isStream ? "stream:" : ""}`;
    console.log(`${prefix} ${event.query.sql}`);
    console.log(`${prefix} duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}
var LOG_LEVELS;
var init_log = __esm(() => {
  init_object_utils();
  LOG_LEVELS = freeze(["query", "error"]);
});

// ../../node_modules/kysely/dist/esm/util/compilable.js
function isCompilable(value) {
  return isObject3(value) && isFunction3(value.compile);
}
var init_compilable = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/kysely.js
function isKyselyProps(obj) {
  return isObject3(obj) && isObject3(obj.config) && isObject3(obj.driver) && isObject3(obj.executor) && isObject3(obj.dialect);
}

class ConnectionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async execute(callback) {
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const db = new Kysely({
        ...this.#props,
        executor
      });
      return await callback(db);
    });
  }
}

class TransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new TransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new TransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute(callback) {
    const { isolationLevel, accessMode, ...kyselyProps } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    return this.#props.executor.provideConnection(async (connection) => {
      const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
      const transaction = new Transaction({
        ...kyselyProps,
        executor
      });
      try {
        await this.#props.driver.beginTransaction(connection, settings);
        const result = await callback(transaction);
        await this.#props.driver.commitTransaction(connection);
        return result;
      } catch (error2) {
        await this.#props.driver.rollbackTransaction(connection);
        throw error2;
      }
    });
  }
}

class ControlledTransactionBuilder {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  setAccessMode(accessMode) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      accessMode
    });
  }
  setIsolationLevel(isolationLevel) {
    return new ControlledTransactionBuilder({
      ...this.#props,
      isolationLevel
    });
  }
  async execute() {
    const { isolationLevel, accessMode, ...props } = this.#props;
    const settings = { isolationLevel, accessMode };
    validateTransactionSettings(settings);
    const connection = await provideControlledConnection(this.#props.executor);
    await this.#props.driver.beginTransaction(connection.connection, settings);
    return new ControlledTransaction({
      ...props,
      connection,
      executor: this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection.connection))
    });
  }
}

class Command {
  #cb;
  constructor(cb) {
    this.#cb = cb;
  }
  async execute() {
    return await this.#cb();
  }
}
function assertNotCommittedOrRolledBack(state) {
  if (state.isCommitted) {
    throw new Error("Transaction is already committed");
  }
  if (state.isRolledBack) {
    throw new Error("Transaction is already rolled back");
  }
}

class NotCommittedOrRolledBackAssertingExecutor {
  #executor;
  #state;
  constructor(executor, state) {
    if (executor instanceof NotCommittedOrRolledBackAssertingExecutor) {
      this.#executor = executor.#executor;
    } else {
      this.#executor = executor;
    }
    this.#state = state;
  }
  get adapter() {
    return this.#executor.adapter;
  }
  get plugins() {
    return this.#executor.plugins;
  }
  transformQuery(node, queryId) {
    return this.#executor.transformQuery(node, queryId);
  }
  compileQuery(node, queryId) {
    return this.#executor.compileQuery(node, queryId);
  }
  provideConnection(consumer) {
    return this.#executor.provideConnection(consumer);
  }
  executeQuery(compiledQuery, queryId) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.executeQuery(compiledQuery, queryId);
  }
  stream(compiledQuery, chunkSize, queryId) {
    assertNotCommittedOrRolledBack(this.#state);
    return this.#executor.stream(compiledQuery, chunkSize, queryId);
  }
  withConnectionProvider(connectionProvider) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withConnectionProvider(connectionProvider), this.#state);
  }
  withPlugin(plugin) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugin(plugin), this.#state);
  }
  withPlugins(plugins) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPlugins(plugins), this.#state);
  }
  withPluginAtFront(plugin) {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withPluginAtFront(plugin), this.#state);
  }
  withoutPlugins() {
    return new NotCommittedOrRolledBackAssertingExecutor(this.#executor.withoutPlugins(), this.#state);
  }
}
var Kysely, Transaction, ControlledTransaction;
var init_kysely = __esm(() => {
  init_schema();
  init_dynamic();
  init_query_creator();
  init_default_query_executor();
  init_object_utils();
  init_runtime_driver();
  init_driver();
  init_function_module();
  init_log();
  init_query_id();
  init_compilable();
  init_case_builder();
  init_case_node();
  init_expression_parser();
  init_with_schema_plugin();
  init_provide_controlled_connection();
  Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
  Kysely = class Kysely extends QueryCreator {
    #props;
    constructor(args) {
      let superProps;
      let props;
      if (isKyselyProps(args)) {
        superProps = { executor: args.executor };
        props = { ...args };
      } else {
        const dialect = args.dialect;
        const driver = dialect.createDriver();
        const compiler = dialect.createQueryCompiler();
        const adapter = dialect.createAdapter();
        const log = new Log(args.log ?? []);
        const runtimeDriver = new RuntimeDriver(driver, log);
        const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
        const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
        superProps = { executor };
        props = {
          config: args,
          executor,
          dialect,
          driver: runtimeDriver
        };
      }
      super(superProps);
      this.#props = freeze(props);
    }
    get schema() {
      return new SchemaModule(this.#props.executor);
    }
    get dynamic() {
      return new DynamicModule;
    }
    get introspection() {
      return this.#props.dialect.createIntrospector(this.withoutPlugins());
    }
    case(value) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined2(value) ? undefined : parseExpression(value))
      });
    }
    get fn() {
      return createFunctionModule();
    }
    transaction() {
      return new TransactionBuilder({ ...this.#props });
    }
    startTransaction() {
      return new ControlledTransactionBuilder({ ...this.#props });
    }
    connection() {
      return new ConnectionBuilder({ ...this.#props });
    }
    withPlugin(plugin) {
      return new Kysely({
        ...this.#props,
        executor: this.#props.executor.withPlugin(plugin)
      });
    }
    withoutPlugins() {
      return new Kysely({
        ...this.#props,
        executor: this.#props.executor.withoutPlugins()
      });
    }
    withSchema(schema2) {
      return new Kysely({
        ...this.#props,
        executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
      });
    }
    withTables() {
      return new Kysely({ ...this.#props });
    }
    async destroy() {
      await this.#props.driver.destroy();
    }
    get isTransaction() {
      return false;
    }
    getExecutor() {
      return this.#props.executor;
    }
    executeQuery(query, queryId = createQueryId()) {
      const compiledQuery = isCompilable(query) ? query.compile() : query;
      return this.getExecutor().executeQuery(compiledQuery, queryId);
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  };
  Transaction = class Transaction extends Kysely {
    #props;
    constructor(props) {
      super(props);
      this.#props = props;
    }
    get isTransaction() {
      return true;
    }
    transaction() {
      throw new Error("calling the transaction method for a Transaction is not supported");
    }
    connection() {
      throw new Error("calling the connection method for a Transaction is not supported");
    }
    async destroy() {
      throw new Error("calling the destroy method for a Transaction is not supported");
    }
    withPlugin(plugin) {
      return new Transaction({
        ...this.#props,
        executor: this.#props.executor.withPlugin(plugin)
      });
    }
    withoutPlugins() {
      return new Transaction({
        ...this.#props,
        executor: this.#props.executor.withoutPlugins()
      });
    }
    withSchema(schema2) {
      return new Transaction({
        ...this.#props,
        executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
      });
    }
    withTables() {
      return new Transaction({ ...this.#props });
    }
  };
  ControlledTransaction = class ControlledTransaction extends Transaction {
    #props;
    #compileQuery;
    #state;
    constructor(props) {
      const state = { isCommitted: false, isRolledBack: false };
      props = {
        ...props,
        executor: new NotCommittedOrRolledBackAssertingExecutor(props.executor, state)
      };
      const { connection, ...transactionProps } = props;
      super(transactionProps);
      this.#props = freeze(props);
      this.#state = state;
      const queryId = createQueryId();
      this.#compileQuery = (node) => props.executor.compileQuery(node, queryId);
    }
    get isCommitted() {
      return this.#state.isCommitted;
    }
    get isRolledBack() {
      return this.#state.isRolledBack;
    }
    commit() {
      assertNotCommittedOrRolledBack(this.#state);
      return new Command(async () => {
        await this.#props.driver.commitTransaction(this.#props.connection.connection);
        this.#state.isCommitted = true;
        this.#props.connection.release();
      });
    }
    rollback() {
      assertNotCommittedOrRolledBack(this.#state);
      return new Command(async () => {
        await this.#props.driver.rollbackTransaction(this.#props.connection.connection);
        this.#state.isRolledBack = true;
        this.#props.connection.release();
      });
    }
    savepoint(savepointName) {
      assertNotCommittedOrRolledBack(this.#state);
      return new Command(async () => {
        await this.#props.driver.savepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
        return new ControlledTransaction({ ...this.#props });
      });
    }
    rollbackToSavepoint(savepointName) {
      assertNotCommittedOrRolledBack(this.#state);
      return new Command(async () => {
        await this.#props.driver.rollbackToSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
        return new ControlledTransaction({ ...this.#props });
      });
    }
    releaseSavepoint(savepointName) {
      assertNotCommittedOrRolledBack(this.#state);
      return new Command(async () => {
        await this.#props.driver.releaseSavepoint?.(this.#props.connection.connection, savepointName, this.#compileQuery);
        return new ControlledTransaction({ ...this.#props });
      });
    }
    withPlugin(plugin) {
      return new ControlledTransaction({
        ...this.#props,
        executor: this.#props.executor.withPlugin(plugin)
      });
    }
    withoutPlugins() {
      return new ControlledTransaction({
        ...this.#props,
        executor: this.#props.executor.withoutPlugins()
      });
    }
    withSchema(schema2) {
      return new ControlledTransaction({
        ...this.#props,
        executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))
      });
    }
    withTables() {
      return new ControlledTransaction({ ...this.#props });
    }
  };
});

// ../../node_modules/kysely/dist/esm/query-builder/where-interface.js
var init_where_interface = () => {};

// ../../node_modules/kysely/dist/esm/query-builder/returning-interface.js
var init_returning_interface = () => {};

// ../../node_modules/kysely/dist/esm/query-builder/output-interface.js
var init_output_interface = () => {};

// ../../node_modules/kysely/dist/esm/query-builder/having-interface.js
var init_having_interface = () => {};

// ../../node_modules/kysely/dist/esm/query-builder/order-by-interface.js
var init_order_by_interface = () => {};

// ../../node_modules/kysely/dist/esm/raw-builder/raw-builder.js
class RawBuilderImpl {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  get expressionType() {
    return;
  }
  get isRawBuilder() {
    return true;
  }
  as(alias) {
    return new AliasedRawBuilderImpl(this, alias);
  }
  $castTo() {
    return new RawBuilderImpl({ ...this.#props });
  }
  $notNull() {
    return new RawBuilderImpl(this.#props);
  }
  withPlugin(plugin) {
    return new RawBuilderImpl({
      ...this.#props,
      plugins: this.#props.plugins !== undefined ? freeze([...this.#props.plugins, plugin]) : freeze([plugin])
    });
  }
  toOperationNode() {
    return this.#toOperationNode(this.#getExecutor());
  }
  compile(executorProvider) {
    return this.#compile(this.#getExecutor(executorProvider));
  }
  async execute(executorProvider) {
    const executor = this.#getExecutor(executorProvider);
    return executor.executeQuery(this.#compile(executor), this.#props.queryId);
  }
  #getExecutor(executorProvider) {
    const executor = executorProvider !== undefined ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
    return this.#props.plugins !== undefined ? executor.withPlugins(this.#props.plugins) : executor;
  }
  #toOperationNode(executor) {
    return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
  }
  #compile(executor) {
    return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
  }
}
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}

class AliasedRawBuilderImpl {
  #rawBuilder;
  #alias;
  constructor(rawBuilder, alias) {
    this.#rawBuilder = rawBuilder;
    this.#alias = alias;
  }
  get expression() {
    return this.#rawBuilder;
  }
  get alias() {
    return this.#alias;
  }
  get rawBuilder() {
    return this.#rawBuilder;
  }
  toOperationNode() {
    return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
  }
}
var init_raw_builder = __esm(() => {
  init_alias_node();
  init_object_utils();
  init_noop_query_executor();
  init_identifier_node();
  init_operation_node_source();
});

// ../../node_modules/kysely/dist/esm/raw-builder/sql.js
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}
var sql2;
var init_sql = __esm(() => {
  init_identifier_node();
  init_operation_node_source();
  init_raw_node();
  init_value_node();
  init_reference_parser();
  init_table_parser();
  init_value_parser();
  init_query_id();
  init_raw_builder();
  sql2 = Object.assign((sqlFragments, ...parameters) => {
    return createRawBuilder({
      queryId: createQueryId(),
      rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? [])
    });
  }, {
    ref(columnReference) {
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.createWithChild(parseStringReference(columnReference))
      });
    },
    val(value) {
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.createWithChild(parseValueExpression(value))
      });
    },
    value(value) {
      return this.val(value);
    },
    table(tableReference) {
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.createWithChild(parseTable(tableReference))
      });
    },
    id(...ids) {
      const fragments = new Array(ids.length + 1).fill(".");
      fragments[0] = "";
      fragments[fragments.length - 1] = "";
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
      });
    },
    lit(value) {
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
      });
    },
    literal(value) {
      return this.lit(value);
    },
    raw(sql3) {
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.createWithSql(sql3)
      });
    },
    join(array, separator = sql2`, `) {
      const nodes = new Array(Math.max(2 * array.length - 1, 0));
      const sep = separator.toOperationNode();
      for (let i = 0;i < array.length; ++i) {
        nodes[2 * i] = parseParameter(array[i]);
        if (i !== array.length - 1) {
          nodes[2 * i + 1] = sep;
        }
      }
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.createWithChildren(nodes)
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/query-executor/query-executor.js
var init_query_executor = () => {};

// ../../node_modules/kysely/dist/esm/query-executor/query-executor-provider.js
var init_query_executor_provider = () => {};

// ../../node_modules/kysely/dist/esm/operation-node/operation-node-visitor.js
class OperationNodeVisitor {
  nodeStack = [];
  get parentNode() {
    return this.nodeStack[this.nodeStack.length - 2];
  }
  #visitors = freeze({
    AliasNode: this.visitAlias.bind(this),
    ColumnNode: this.visitColumn.bind(this),
    IdentifierNode: this.visitIdentifier.bind(this),
    SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
    RawNode: this.visitRaw.bind(this),
    ReferenceNode: this.visitReference.bind(this),
    SelectQueryNode: this.visitSelectQuery.bind(this),
    SelectionNode: this.visitSelection.bind(this),
    TableNode: this.visitTable.bind(this),
    FromNode: this.visitFrom.bind(this),
    SelectAllNode: this.visitSelectAll.bind(this),
    AndNode: this.visitAnd.bind(this),
    OrNode: this.visitOr.bind(this),
    ValueNode: this.visitValue.bind(this),
    ValueListNode: this.visitValueList.bind(this),
    PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
    ParensNode: this.visitParens.bind(this),
    JoinNode: this.visitJoin.bind(this),
    OperatorNode: this.visitOperator.bind(this),
    WhereNode: this.visitWhere.bind(this),
    InsertQueryNode: this.visitInsertQuery.bind(this),
    DeleteQueryNode: this.visitDeleteQuery.bind(this),
    ReturningNode: this.visitReturning.bind(this),
    CreateTableNode: this.visitCreateTable.bind(this),
    AddColumnNode: this.visitAddColumn.bind(this),
    ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
    DropTableNode: this.visitDropTable.bind(this),
    DataTypeNode: this.visitDataType.bind(this),
    OrderByNode: this.visitOrderBy.bind(this),
    OrderByItemNode: this.visitOrderByItem.bind(this),
    GroupByNode: this.visitGroupBy.bind(this),
    GroupByItemNode: this.visitGroupByItem.bind(this),
    UpdateQueryNode: this.visitUpdateQuery.bind(this),
    ColumnUpdateNode: this.visitColumnUpdate.bind(this),
    LimitNode: this.visitLimit.bind(this),
    OffsetNode: this.visitOffset.bind(this),
    OnConflictNode: this.visitOnConflict.bind(this),
    OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
    CreateIndexNode: this.visitCreateIndex.bind(this),
    DropIndexNode: this.visitDropIndex.bind(this),
    ListNode: this.visitList.bind(this),
    PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
    UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
    ReferencesNode: this.visitReferences.bind(this),
    CheckConstraintNode: this.visitCheckConstraint.bind(this),
    WithNode: this.visitWith.bind(this),
    CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
    CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
    HavingNode: this.visitHaving.bind(this),
    CreateSchemaNode: this.visitCreateSchema.bind(this),
    DropSchemaNode: this.visitDropSchema.bind(this),
    AlterTableNode: this.visitAlterTable.bind(this),
    DropColumnNode: this.visitDropColumn.bind(this),
    RenameColumnNode: this.visitRenameColumn.bind(this),
    AlterColumnNode: this.visitAlterColumn.bind(this),
    ModifyColumnNode: this.visitModifyColumn.bind(this),
    AddConstraintNode: this.visitAddConstraint.bind(this),
    DropConstraintNode: this.visitDropConstraint.bind(this),
    RenameConstraintNode: this.visitRenameConstraint.bind(this),
    ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
    CreateViewNode: this.visitCreateView.bind(this),
    RefreshMaterializedViewNode: this.visitRefreshMaterializedView.bind(this),
    DropViewNode: this.visitDropView.bind(this),
    GeneratedNode: this.visitGenerated.bind(this),
    DefaultValueNode: this.visitDefaultValue.bind(this),
    OnNode: this.visitOn.bind(this),
    ValuesNode: this.visitValues.bind(this),
    SelectModifierNode: this.visitSelectModifier.bind(this),
    CreateTypeNode: this.visitCreateType.bind(this),
    DropTypeNode: this.visitDropType.bind(this),
    ExplainNode: this.visitExplain.bind(this),
    DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
    AggregateFunctionNode: this.visitAggregateFunction.bind(this),
    OverNode: this.visitOver.bind(this),
    PartitionByNode: this.visitPartitionBy.bind(this),
    PartitionByItemNode: this.visitPartitionByItem.bind(this),
    SetOperationNode: this.visitSetOperation.bind(this),
    BinaryOperationNode: this.visitBinaryOperation.bind(this),
    UnaryOperationNode: this.visitUnaryOperation.bind(this),
    UsingNode: this.visitUsing.bind(this),
    FunctionNode: this.visitFunction.bind(this),
    CaseNode: this.visitCase.bind(this),
    WhenNode: this.visitWhen.bind(this),
    JSONReferenceNode: this.visitJSONReference.bind(this),
    JSONPathNode: this.visitJSONPath.bind(this),
    JSONPathLegNode: this.visitJSONPathLeg.bind(this),
    JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
    TupleNode: this.visitTuple.bind(this),
    MergeQueryNode: this.visitMergeQuery.bind(this),
    MatchedNode: this.visitMatched.bind(this),
    AddIndexNode: this.visitAddIndex.bind(this),
    CastNode: this.visitCast.bind(this),
    FetchNode: this.visitFetch.bind(this),
    TopNode: this.visitTop.bind(this),
    OutputNode: this.visitOutput.bind(this),
    OrActionNode: this.visitOrAction.bind(this),
    CollateNode: this.visitCollate.bind(this)
  });
  visitNode = (node) => {
    this.nodeStack.push(node);
    this.#visitors[node.kind](node);
    this.nodeStack.pop();
  };
}
var init_operation_node_visitor = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js
var LIT_WRAP_REGEX, DefaultQueryCompiler, SELECT_MODIFIER_SQL, SELECT_MODIFIER_PRIORITY, JOIN_TYPE_SQL;
var init_default_query_compiler = __esm(() => {
  init_create_table_node();
  init_insert_query_node();
  init_operation_node_visitor();
  init_operator_node();
  init_parens_node();
  init_query_node();
  init_object_utils();
  init_create_view_node();
  init_set_operation_node();
  init_merge_query_node();
  init_log_once();
  LIT_WRAP_REGEX = /'/g;
  DefaultQueryCompiler = class DefaultQueryCompiler extends OperationNodeVisitor {
    #sql = "";
    #parameters = [];
    get numParameters() {
      return this.#parameters.length;
    }
    compileQuery(node, queryId) {
      this.#sql = "";
      this.#parameters = [];
      this.nodeStack.splice(0, this.nodeStack.length);
      this.visitNode(node);
      return freeze({
        query: node,
        queryId,
        sql: this.getSql(),
        parameters: [...this.#parameters]
      });
    }
    getSql() {
      return this.#sql;
    }
    visitSelectQuery(node) {
      const wrapInParens = this.parentNode !== undefined && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
      if (this.parentNode === undefined && node.explain) {
        this.visitNode(node.explain);
        this.append(" ");
      }
      if (wrapInParens) {
        this.append("(");
      }
      if (node.with) {
        this.visitNode(node.with);
        this.append(" ");
      }
      this.append("select");
      if (node.distinctOn) {
        this.append(" ");
        this.compileDistinctOn(node.distinctOn);
      }
      if (node.frontModifiers?.length) {
        this.append(" ");
        this.compileList(node.frontModifiers, " ");
      }
      if (node.top) {
        this.append(" ");
        this.visitNode(node.top);
      }
      if (node.selections) {
        this.append(" ");
        this.compileList(node.selections);
      }
      if (node.from) {
        this.append(" ");
        this.visitNode(node.from);
      }
      if (node.joins) {
        this.append(" ");
        this.compileList(node.joins, " ");
      }
      if (node.where) {
        this.append(" ");
        this.visitNode(node.where);
      }
      if (node.groupBy) {
        this.append(" ");
        this.visitNode(node.groupBy);
      }
      if (node.having) {
        this.append(" ");
        this.visitNode(node.having);
      }
      if (node.setOperations) {
        this.append(" ");
        this.compileList(node.setOperations, " ");
      }
      if (node.orderBy) {
        this.append(" ");
        this.visitNode(node.orderBy);
      }
      if (node.limit) {
        this.append(" ");
        this.visitNode(node.limit);
      }
      if (node.offset) {
        this.append(" ");
        this.visitNode(node.offset);
      }
      if (node.fetch) {
        this.append(" ");
        this.visitNode(node.fetch);
      }
      if (node.endModifiers?.length) {
        this.append(" ");
        this.compileList(this.sortSelectModifiers([...node.endModifiers]), " ");
      }
      if (wrapInParens) {
        this.append(")");
      }
    }
    visitFrom(node) {
      this.append("from ");
      this.compileList(node.froms);
    }
    visitSelection(node) {
      this.visitNode(node.selection);
    }
    visitColumn(node) {
      this.visitNode(node.column);
    }
    compileDistinctOn(expressions) {
      this.append("distinct on (");
      this.compileList(expressions);
      this.append(")");
    }
    compileList(nodes, separator = ", ") {
      const lastIndex = nodes.length - 1;
      for (let i = 0;i <= lastIndex; i++) {
        this.visitNode(nodes[i]);
        if (i < lastIndex) {
          this.append(separator);
        }
      }
    }
    visitWhere(node) {
      this.append("where ");
      this.visitNode(node.where);
    }
    visitHaving(node) {
      this.append("having ");
      this.visitNode(node.having);
    }
    visitInsertQuery(node) {
      const rootQueryNode = this.nodeStack.find(QueryNode.is);
      const isSubQuery = rootQueryNode !== node;
      if (!isSubQuery && node.explain) {
        this.visitNode(node.explain);
        this.append(" ");
      }
      if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
        this.append("(");
      }
      if (node.with) {
        this.visitNode(node.with);
        this.append(" ");
      }
      this.append(node.replace ? "replace" : "insert");
      if (node.ignore) {
        logOnce("`InsertQueryNode.ignore` is deprecated. Use `InsertQueryNode.orAction` instead.");
        this.append(" ignore");
      }
      if (node.orAction) {
        this.append(" ");
        this.visitNode(node.orAction);
      }
      if (node.top) {
        this.append(" ");
        this.visitNode(node.top);
      }
      if (node.into) {
        this.append(" into ");
        this.visitNode(node.into);
      }
      if (node.columns) {
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
      }
      if (node.output) {
        this.append(" ");
        this.visitNode(node.output);
      }
      if (node.values) {
        this.append(" ");
        this.visitNode(node.values);
      }
      if (node.defaultValues) {
        this.append(" ");
        this.append("default values");
      }
      if (node.onConflict) {
        this.append(" ");
        this.visitNode(node.onConflict);
      }
      if (node.onDuplicateKey) {
        this.append(" ");
        this.visitNode(node.onDuplicateKey);
      }
      if (node.returning) {
        this.append(" ");
        this.visitNode(node.returning);
      }
      if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
        this.append(")");
      }
      if (node.endModifiers?.length) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
    visitValues(node) {
      this.append("values ");
      this.compileList(node.values);
    }
    visitDeleteQuery(node) {
      const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;
      if (!isSubQuery && node.explain) {
        this.visitNode(node.explain);
        this.append(" ");
      }
      if (isSubQuery) {
        this.append("(");
      }
      if (node.with) {
        this.visitNode(node.with);
        this.append(" ");
      }
      this.append("delete ");
      if (node.top) {
        this.visitNode(node.top);
        this.append(" ");
      }
      this.visitNode(node.from);
      if (node.output) {
        this.append(" ");
        this.visitNode(node.output);
      }
      if (node.using) {
        this.append(" ");
        this.visitNode(node.using);
      }
      if (node.joins) {
        this.append(" ");
        this.compileList(node.joins, " ");
      }
      if (node.where) {
        this.append(" ");
        this.visitNode(node.where);
      }
      if (node.orderBy) {
        this.append(" ");
        this.visitNode(node.orderBy);
      }
      if (node.limit) {
        this.append(" ");
        this.visitNode(node.limit);
      }
      if (node.returning) {
        this.append(" ");
        this.visitNode(node.returning);
      }
      if (isSubQuery) {
        this.append(")");
      }
      if (node.endModifiers?.length) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
    visitReturning(node) {
      this.append("returning ");
      this.compileList(node.selections);
    }
    visitAlias(node) {
      this.visitNode(node.node);
      this.append(" as ");
      this.visitNode(node.alias);
    }
    visitReference(node) {
      if (node.table) {
        this.visitNode(node.table);
        this.append(".");
      }
      this.visitNode(node.column);
    }
    visitSelectAll(_) {
      this.append("*");
    }
    visitIdentifier(node) {
      this.append(this.getLeftIdentifierWrapper());
      this.compileUnwrappedIdentifier(node);
      this.append(this.getRightIdentifierWrapper());
    }
    compileUnwrappedIdentifier(node) {
      if (!isString2(node.name)) {
        throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
      }
      this.append(this.sanitizeIdentifier(node.name));
    }
    visitAnd(node) {
      this.visitNode(node.left);
      this.append(" and ");
      this.visitNode(node.right);
    }
    visitOr(node) {
      this.visitNode(node.left);
      this.append(" or ");
      this.visitNode(node.right);
    }
    visitValue(node) {
      if (node.immediate) {
        this.appendImmediateValue(node.value);
      } else {
        this.appendValue(node.value);
      }
    }
    visitValueList(node) {
      this.append("(");
      this.compileList(node.values);
      this.append(")");
    }
    visitTuple(node) {
      this.append("(");
      this.compileList(node.values);
      this.append(")");
    }
    visitPrimitiveValueList(node) {
      this.append("(");
      const { values } = node;
      for (let i = 0;i < values.length; ++i) {
        this.appendValue(values[i]);
        if (i !== values.length - 1) {
          this.append(", ");
        }
      }
      this.append(")");
    }
    visitParens(node) {
      this.append("(");
      this.visitNode(node.node);
      this.append(")");
    }
    visitJoin(node) {
      this.append(JOIN_TYPE_SQL[node.joinType]);
      this.append(" ");
      this.visitNode(node.table);
      if (node.on) {
        this.append(" ");
        this.visitNode(node.on);
      }
    }
    visitOn(node) {
      this.append("on ");
      this.visitNode(node.on);
    }
    visitRaw(node) {
      const { sqlFragments, parameters: params } = node;
      for (let i = 0;i < sqlFragments.length; ++i) {
        this.append(sqlFragments[i]);
        if (params.length > i) {
          this.visitNode(params[i]);
        }
      }
    }
    visitOperator(node) {
      this.append(node.operator);
    }
    visitTable(node) {
      this.visitNode(node.table);
    }
    visitSchemableIdentifier(node) {
      if (node.schema) {
        this.visitNode(node.schema);
        this.append(".");
      }
      this.visitNode(node.identifier);
    }
    visitCreateTable(node) {
      this.append("create ");
      if (node.frontModifiers && node.frontModifiers.length > 0) {
        this.compileList(node.frontModifiers, " ");
        this.append(" ");
      }
      if (node.temporary) {
        this.append("temporary ");
      }
      this.append("table ");
      if (node.ifNotExists) {
        this.append("if not exists ");
      }
      this.visitNode(node.table);
      if (node.selectQuery) {
        this.append(" as ");
        this.visitNode(node.selectQuery);
      } else {
        this.append(" (");
        this.compileList([...node.columns, ...node.constraints ?? []]);
        this.append(")");
        if (node.onCommit) {
          this.append(" on commit ");
          this.append(node.onCommit);
        }
        if (node.endModifiers && node.endModifiers.length > 0) {
          this.append(" ");
          this.compileList(node.endModifiers, " ");
        }
      }
    }
    visitColumnDefinition(node) {
      if (node.ifNotExists) {
        this.append("if not exists ");
      }
      this.visitNode(node.column);
      this.append(" ");
      this.visitNode(node.dataType);
      if (node.unsigned) {
        this.append(" unsigned");
      }
      if (node.frontModifiers && node.frontModifiers.length > 0) {
        this.append(" ");
        this.compileList(node.frontModifiers, " ");
      }
      if (node.generated) {
        this.append(" ");
        this.visitNode(node.generated);
      }
      if (node.identity) {
        this.append(" identity");
      }
      if (node.defaultTo) {
        this.append(" ");
        this.visitNode(node.defaultTo);
      }
      if (node.notNull) {
        this.append(" not null");
      }
      if (node.unique) {
        this.append(" unique");
      }
      if (node.nullsNotDistinct) {
        this.append(" nulls not distinct");
      }
      if (node.primaryKey) {
        this.append(" primary key");
      }
      if (node.autoIncrement) {
        this.append(" ");
        this.append(this.getAutoIncrement());
      }
      if (node.references) {
        this.append(" ");
        this.visitNode(node.references);
      }
      if (node.check) {
        this.append(" ");
        this.visitNode(node.check);
      }
      if (node.endModifiers && node.endModifiers.length > 0) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
    getAutoIncrement() {
      return "auto_increment";
    }
    visitReferences(node) {
      this.append("references ");
      this.visitNode(node.table);
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
      if (node.onDelete) {
        this.append(" on delete ");
        this.append(node.onDelete);
      }
      if (node.onUpdate) {
        this.append(" on update ");
        this.append(node.onUpdate);
      }
    }
    visitDropTable(node) {
      this.append("drop table ");
      if (node.ifExists) {
        this.append("if exists ");
      }
      this.visitNode(node.table);
      if (node.cascade) {
        this.append(" cascade");
      }
    }
    visitDataType(node) {
      this.append(node.dataType);
    }
    visitOrderBy(node) {
      this.append("order by ");
      this.compileList(node.items);
    }
    visitOrderByItem(node) {
      this.visitNode(node.orderBy);
      if (node.collation) {
        this.append(" ");
        this.visitNode(node.collation);
      }
      if (node.direction) {
        this.append(" ");
        this.visitNode(node.direction);
      }
      if (node.nulls) {
        this.append(" nulls ");
        this.append(node.nulls);
      }
    }
    visitGroupBy(node) {
      this.append("group by ");
      this.compileList(node.items);
    }
    visitGroupByItem(node) {
      this.visitNode(node.groupBy);
    }
    visitUpdateQuery(node) {
      const rootQueryNode = this.nodeStack.find(QueryNode.is);
      const isSubQuery = rootQueryNode !== node;
      if (!isSubQuery && node.explain) {
        this.visitNode(node.explain);
        this.append(" ");
      }
      if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
        this.append("(");
      }
      if (node.with) {
        this.visitNode(node.with);
        this.append(" ");
      }
      this.append("update ");
      if (node.top) {
        this.visitNode(node.top);
        this.append(" ");
      }
      if (node.table) {
        this.visitNode(node.table);
        this.append(" ");
      }
      this.append("set ");
      if (node.updates) {
        this.compileList(node.updates);
      }
      if (node.output) {
        this.append(" ");
        this.visitNode(node.output);
      }
      if (node.from) {
        this.append(" ");
        this.visitNode(node.from);
      }
      if (node.joins) {
        if (!node.from) {
          throw new Error("Joins in an update query are only supported as a part of a PostgreSQL 'update set from join' query. If you want to create a MySQL 'update join set' query, see https://kysely.dev/docs/examples/update/my-sql-joins");
        }
        this.append(" ");
        this.compileList(node.joins, " ");
      }
      if (node.where) {
        this.append(" ");
        this.visitNode(node.where);
      }
      if (node.orderBy) {
        this.append(" ");
        this.visitNode(node.orderBy);
      }
      if (node.limit) {
        this.append(" ");
        this.visitNode(node.limit);
      }
      if (node.returning) {
        this.append(" ");
        this.visitNode(node.returning);
      }
      if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
        this.append(")");
      }
      if (node.endModifiers?.length) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
    visitColumnUpdate(node) {
      this.visitNode(node.column);
      this.append(" = ");
      this.visitNode(node.value);
    }
    visitLimit(node) {
      this.append("limit ");
      this.visitNode(node.limit);
    }
    visitOffset(node) {
      this.append("offset ");
      this.visitNode(node.offset);
    }
    visitOnConflict(node) {
      this.append("on conflict");
      if (node.columns) {
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
      } else if (node.constraint) {
        this.append(" on constraint ");
        this.visitNode(node.constraint);
      } else if (node.indexExpression) {
        this.append(" (");
        this.visitNode(node.indexExpression);
        this.append(")");
      }
      if (node.indexWhere) {
        this.append(" ");
        this.visitNode(node.indexWhere);
      }
      if (node.doNothing === true) {
        this.append(" do nothing");
      } else if (node.updates) {
        this.append(" do update set ");
        this.compileList(node.updates);
        if (node.updateWhere) {
          this.append(" ");
          this.visitNode(node.updateWhere);
        }
      }
    }
    visitOnDuplicateKey(node) {
      this.append("on duplicate key update ");
      this.compileList(node.updates);
    }
    visitCreateIndex(node) {
      this.append("create ");
      if (node.unique) {
        this.append("unique ");
      }
      this.append("index ");
      if (node.ifNotExists) {
        this.append("if not exists ");
      }
      this.visitNode(node.name);
      if (node.table) {
        this.append(" on ");
        this.visitNode(node.table);
      }
      if (node.using) {
        this.append(" using ");
        this.visitNode(node.using);
      }
      if (node.columns) {
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
      }
      if (node.nullsNotDistinct) {
        this.append(" nulls not distinct");
      }
      if (node.where) {
        this.append(" ");
        this.visitNode(node.where);
      }
    }
    visitDropIndex(node) {
      this.append("drop index ");
      if (node.ifExists) {
        this.append("if exists ");
      }
      this.visitNode(node.name);
      if (node.table) {
        this.append(" on ");
        this.visitNode(node.table);
      }
      if (node.cascade) {
        this.append(" cascade");
      }
    }
    visitCreateSchema(node) {
      this.append("create schema ");
      if (node.ifNotExists) {
        this.append("if not exists ");
      }
      this.visitNode(node.schema);
    }
    visitDropSchema(node) {
      this.append("drop schema ");
      if (node.ifExists) {
        this.append("if exists ");
      }
      this.visitNode(node.schema);
      if (node.cascade) {
        this.append(" cascade");
      }
    }
    visitPrimaryKeyConstraint(node) {
      if (node.name) {
        this.append("constraint ");
        this.visitNode(node.name);
        this.append(" ");
      }
      this.append("primary key (");
      this.compileList(node.columns);
      this.append(")");
      this.buildDeferrable(node);
    }
    buildDeferrable(node) {
      if (node.deferrable !== undefined) {
        if (node.deferrable) {
          this.append(" deferrable");
        } else {
          this.append(" not deferrable");
        }
      }
      if (node.initiallyDeferred !== undefined) {
        if (node.initiallyDeferred) {
          this.append(" initially deferred");
        } else {
          this.append(" initially immediate");
        }
      }
    }
    visitUniqueConstraint(node) {
      if (node.name) {
        this.append("constraint ");
        this.visitNode(node.name);
        this.append(" ");
      }
      this.append("unique");
      if (node.nullsNotDistinct) {
        this.append(" nulls not distinct");
      }
      this.append(" (");
      this.compileList(node.columns);
      this.append(")");
      this.buildDeferrable(node);
    }
    visitCheckConstraint(node) {
      if (node.name) {
        this.append("constraint ");
        this.visitNode(node.name);
        this.append(" ");
      }
      this.append("check (");
      this.visitNode(node.expression);
      this.append(")");
    }
    visitForeignKeyConstraint(node) {
      if (node.name) {
        this.append("constraint ");
        this.visitNode(node.name);
        this.append(" ");
      }
      this.append("foreign key (");
      this.compileList(node.columns);
      this.append(") ");
      this.visitNode(node.references);
      if (node.onDelete) {
        this.append(" on delete ");
        this.append(node.onDelete);
      }
      if (node.onUpdate) {
        this.append(" on update ");
        this.append(node.onUpdate);
      }
      this.buildDeferrable(node);
    }
    visitList(node) {
      this.compileList(node.items);
    }
    visitWith(node) {
      this.append("with ");
      if (node.recursive) {
        this.append("recursive ");
      }
      this.compileList(node.expressions);
    }
    visitCommonTableExpression(node) {
      this.visitNode(node.name);
      this.append(" as ");
      if (isBoolean2(node.materialized)) {
        if (!node.materialized) {
          this.append("not ");
        }
        this.append("materialized ");
      }
      this.visitNode(node.expression);
    }
    visitCommonTableExpressionName(node) {
      this.visitNode(node.table);
      if (node.columns) {
        this.append("(");
        this.compileList(node.columns);
        this.append(")");
      }
    }
    visitAlterTable(node) {
      this.append("alter table ");
      this.visitNode(node.table);
      this.append(" ");
      if (node.renameTo) {
        this.append("rename to ");
        this.visitNode(node.renameTo);
      }
      if (node.setSchema) {
        this.append("set schema ");
        this.visitNode(node.setSchema);
      }
      if (node.addConstraint) {
        this.visitNode(node.addConstraint);
      }
      if (node.dropConstraint) {
        this.visitNode(node.dropConstraint);
      }
      if (node.renameConstraint) {
        this.visitNode(node.renameConstraint);
      }
      if (node.columnAlterations) {
        this.compileColumnAlterations(node.columnAlterations);
      }
      if (node.addIndex) {
        this.visitNode(node.addIndex);
      }
      if (node.dropIndex) {
        this.visitNode(node.dropIndex);
      }
    }
    visitAddColumn(node) {
      this.append("add column ");
      this.visitNode(node.column);
    }
    visitRenameColumn(node) {
      this.append("rename column ");
      this.visitNode(node.column);
      this.append(" to ");
      this.visitNode(node.renameTo);
    }
    visitDropColumn(node) {
      this.append("drop column ");
      this.visitNode(node.column);
    }
    visitAlterColumn(node) {
      this.append("alter column ");
      this.visitNode(node.column);
      this.append(" ");
      if (node.dataType) {
        if (this.announcesNewColumnDataType()) {
          this.append("type ");
        }
        this.visitNode(node.dataType);
        if (node.dataTypeExpression) {
          this.append("using ");
          this.visitNode(node.dataTypeExpression);
        }
      }
      if (node.setDefault) {
        this.append("set default ");
        this.visitNode(node.setDefault);
      }
      if (node.dropDefault) {
        this.append("drop default");
      }
      if (node.setNotNull) {
        this.append("set not null");
      }
      if (node.dropNotNull) {
        this.append("drop not null");
      }
    }
    visitModifyColumn(node) {
      this.append("modify column ");
      this.visitNode(node.column);
    }
    visitAddConstraint(node) {
      this.append("add ");
      this.visitNode(node.constraint);
    }
    visitDropConstraint(node) {
      this.append("drop constraint ");
      if (node.ifExists) {
        this.append("if exists ");
      }
      this.visitNode(node.constraintName);
      if (node.modifier === "cascade") {
        this.append(" cascade");
      } else if (node.modifier === "restrict") {
        this.append(" restrict");
      }
    }
    visitRenameConstraint(node) {
      this.append("rename constraint ");
      this.visitNode(node.oldName);
      this.append(" to ");
      this.visitNode(node.newName);
    }
    visitSetOperation(node) {
      this.append(node.operator);
      this.append(" ");
      if (node.all) {
        this.append("all ");
      }
      this.visitNode(node.expression);
    }
    visitCreateView(node) {
      this.append("create ");
      if (node.orReplace) {
        this.append("or replace ");
      }
      if (node.materialized) {
        this.append("materialized ");
      }
      if (node.temporary) {
        this.append("temporary ");
      }
      this.append("view ");
      if (node.ifNotExists) {
        this.append("if not exists ");
      }
      this.visitNode(node.name);
      this.append(" ");
      if (node.columns) {
        this.append("(");
        this.compileList(node.columns);
        this.append(") ");
      }
      if (node.as) {
        this.append("as ");
        this.visitNode(node.as);
      }
    }
    visitRefreshMaterializedView(node) {
      this.append("refresh materialized view ");
      if (node.concurrently) {
        this.append("concurrently ");
      }
      this.visitNode(node.name);
      if (node.withNoData) {
        this.append(" with no data");
      } else {
        this.append(" with data");
      }
    }
    visitDropView(node) {
      this.append("drop ");
      if (node.materialized) {
        this.append("materialized ");
      }
      this.append("view ");
      if (node.ifExists) {
        this.append("if exists ");
      }
      this.visitNode(node.name);
      if (node.cascade) {
        this.append(" cascade");
      }
    }
    visitGenerated(node) {
      this.append("generated ");
      if (node.always) {
        this.append("always ");
      }
      if (node.byDefault) {
        this.append("by default ");
      }
      this.append("as ");
      if (node.identity) {
        this.append("identity");
      }
      if (node.expression) {
        this.append("(");
        this.visitNode(node.expression);
        this.append(")");
      }
      if (node.stored) {
        this.append(" stored");
      }
    }
    visitDefaultValue(node) {
      this.append("default ");
      this.visitNode(node.defaultValue);
    }
    visitSelectModifier(node) {
      if (node.rawModifier) {
        this.visitNode(node.rawModifier);
      } else {
        this.append(SELECT_MODIFIER_SQL[node.modifier]);
      }
      if (node.of) {
        this.append(" of ");
        this.compileList(node.of, ", ");
      }
    }
    visitCreateType(node) {
      this.append("create type ");
      this.visitNode(node.name);
      if (node.enum) {
        this.append(" as enum ");
        this.visitNode(node.enum);
      }
    }
    visitDropType(node) {
      this.append("drop type ");
      if (node.ifExists) {
        this.append("if exists ");
      }
      this.visitNode(node.name);
    }
    visitExplain(node) {
      this.append("explain");
      if (node.options || node.format) {
        this.append(" ");
        this.append(this.getLeftExplainOptionsWrapper());
        if (node.options) {
          this.visitNode(node.options);
          if (node.format) {
            this.append(this.getExplainOptionsDelimiter());
          }
        }
        if (node.format) {
          this.append("format");
          this.append(this.getExplainOptionAssignment());
          this.append(node.format);
        }
        this.append(this.getRightExplainOptionsWrapper());
      }
    }
    visitDefaultInsertValue(_) {
      this.append("default");
    }
    visitAggregateFunction(node) {
      this.append(node.func);
      this.append("(");
      if (node.distinct) {
        this.append("distinct ");
      }
      this.compileList(node.aggregated);
      if (node.orderBy) {
        this.append(" ");
        this.visitNode(node.orderBy);
      }
      this.append(")");
      if (node.withinGroup) {
        this.append(" within group (");
        this.visitNode(node.withinGroup);
        this.append(")");
      }
      if (node.filter) {
        this.append(" filter(");
        this.visitNode(node.filter);
        this.append(")");
      }
      if (node.over) {
        this.append(" ");
        this.visitNode(node.over);
      }
    }
    visitOver(node) {
      this.append("over(");
      if (node.partitionBy) {
        this.visitNode(node.partitionBy);
        if (node.orderBy) {
          this.append(" ");
        }
      }
      if (node.orderBy) {
        this.visitNode(node.orderBy);
      }
      this.append(")");
    }
    visitPartitionBy(node) {
      this.append("partition by ");
      this.compileList(node.items);
    }
    visitPartitionByItem(node) {
      this.visitNode(node.partitionBy);
    }
    visitBinaryOperation(node) {
      this.visitNode(node.leftOperand);
      this.append(" ");
      this.visitNode(node.operator);
      this.append(" ");
      this.visitNode(node.rightOperand);
    }
    visitUnaryOperation(node) {
      this.visitNode(node.operator);
      if (!this.isMinusOperator(node.operator)) {
        this.append(" ");
      }
      this.visitNode(node.operand);
    }
    isMinusOperator(node) {
      return OperatorNode.is(node) && node.operator === "-";
    }
    visitUsing(node) {
      this.append("using ");
      this.compileList(node.tables);
    }
    visitFunction(node) {
      this.append(node.func);
      this.append("(");
      this.compileList(node.arguments);
      this.append(")");
    }
    visitCase(node) {
      this.append("case");
      if (node.value) {
        this.append(" ");
        this.visitNode(node.value);
      }
      if (node.when) {
        this.append(" ");
        this.compileList(node.when, " ");
      }
      if (node.else) {
        this.append(" else ");
        this.visitNode(node.else);
      }
      this.append(" end");
      if (node.isStatement) {
        this.append(" case");
      }
    }
    visitWhen(node) {
      this.append("when ");
      this.visitNode(node.condition);
      if (node.result) {
        this.append(" then ");
        this.visitNode(node.result);
      }
    }
    visitJSONReference(node) {
      this.visitNode(node.reference);
      this.visitNode(node.traversal);
    }
    visitJSONPath(node) {
      if (node.inOperator) {
        this.visitNode(node.inOperator);
      }
      this.append("'$");
      for (const pathLeg of node.pathLegs) {
        this.visitNode(pathLeg);
      }
      this.append("'");
    }
    visitJSONPathLeg(node) {
      const isArrayLocation = node.type === "ArrayLocation";
      this.append(isArrayLocation ? "[" : ".");
      this.append(String(node.value));
      if (isArrayLocation) {
        this.append("]");
      }
    }
    visitJSONOperatorChain(node) {
      for (let i = 0, len = node.values.length;i < len; i++) {
        if (i === len - 1) {
          this.visitNode(node.operator);
        } else {
          this.append("->");
        }
        this.visitNode(node.values[i]);
      }
    }
    visitMergeQuery(node) {
      if (node.with) {
        this.visitNode(node.with);
        this.append(" ");
      }
      this.append("merge ");
      if (node.top) {
        this.visitNode(node.top);
        this.append(" ");
      }
      this.append("into ");
      this.visitNode(node.into);
      if (node.using) {
        this.append(" ");
        this.visitNode(node.using);
      }
      if (node.whens) {
        this.append(" ");
        this.compileList(node.whens, " ");
      }
      if (node.returning) {
        this.append(" ");
        this.visitNode(node.returning);
      }
      if (node.output) {
        this.append(" ");
        this.visitNode(node.output);
      }
      if (node.endModifiers?.length) {
        this.append(" ");
        this.compileList(node.endModifiers, " ");
      }
    }
    visitMatched(node) {
      if (node.not) {
        this.append("not ");
      }
      this.append("matched");
      if (node.bySource) {
        this.append(" by source");
      }
    }
    visitAddIndex(node) {
      this.append("add ");
      if (node.unique) {
        this.append("unique ");
      }
      this.append("index ");
      this.visitNode(node.name);
      if (node.columns) {
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
      }
      if (node.using) {
        this.append(" using ");
        this.visitNode(node.using);
      }
    }
    visitCast(node) {
      this.append("cast(");
      this.visitNode(node.expression);
      this.append(" as ");
      this.visitNode(node.dataType);
      this.append(")");
    }
    visitFetch(node) {
      this.append("fetch next ");
      this.visitNode(node.rowCount);
      this.append(` rows ${node.modifier}`);
    }
    visitOutput(node) {
      this.append("output ");
      this.compileList(node.selections);
    }
    visitTop(node) {
      this.append(`top(${node.expression})`);
      if (node.modifiers) {
        this.append(` ${node.modifiers}`);
      }
    }
    visitOrAction(node) {
      this.append(node.action);
    }
    visitCollate(node) {
      this.append("collate ");
      this.visitNode(node.collation);
    }
    append(str) {
      this.#sql += str;
    }
    appendValue(parameter) {
      this.addParameter(parameter);
      this.append(this.getCurrentParameterPlaceholder());
    }
    getLeftIdentifierWrapper() {
      return '"';
    }
    getRightIdentifierWrapper() {
      return '"';
    }
    getCurrentParameterPlaceholder() {
      return "$" + this.numParameters;
    }
    getLeftExplainOptionsWrapper() {
      return "(";
    }
    getExplainOptionAssignment() {
      return " ";
    }
    getExplainOptionsDelimiter() {
      return ", ";
    }
    getRightExplainOptionsWrapper() {
      return ")";
    }
    sanitizeIdentifier(identifier) {
      const leftWrap = this.getLeftIdentifierWrapper();
      const rightWrap = this.getRightIdentifierWrapper();
      let sanitized = "";
      for (const c of identifier) {
        sanitized += c;
        if (c === leftWrap) {
          sanitized += leftWrap;
        } else if (c === rightWrap) {
          sanitized += rightWrap;
        }
      }
      return sanitized;
    }
    sanitizeStringLiteral(value) {
      return value.replace(LIT_WRAP_REGEX, "''");
    }
    addParameter(parameter) {
      this.#parameters.push(parameter);
    }
    appendImmediateValue(value) {
      if (isString2(value)) {
        this.appendStringLiteral(value);
      } else if (isNumber2(value) || isBoolean2(value)) {
        this.append(value.toString());
      } else if (isNull2(value)) {
        this.append("null");
      } else if (isDate2(value)) {
        this.appendImmediateValue(value.toISOString());
      } else if (isBigInt(value)) {
        this.appendImmediateValue(value.toString());
      } else {
        throw new Error(`invalid immediate value ${value}`);
      }
    }
    appendStringLiteral(value) {
      this.append("'");
      this.append(this.sanitizeStringLiteral(value));
      this.append("'");
    }
    sortSelectModifiers(arr) {
      arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);
      return freeze(arr);
    }
    compileColumnAlterations(columnAlterations) {
      this.compileList(columnAlterations);
    }
    announcesNewColumnDataType() {
      return true;
    }
  };
  SELECT_MODIFIER_SQL = freeze({
    ForKeyShare: "for key share",
    ForNoKeyUpdate: "for no key update",
    ForUpdate: "for update",
    ForShare: "for share",
    NoWait: "nowait",
    SkipLocked: "skip locked",
    Distinct: "distinct"
  });
  SELECT_MODIFIER_PRIORITY = freeze({
    ForKeyShare: 1,
    ForNoKeyUpdate: 1,
    ForUpdate: 1,
    ForShare: 1,
    NoWait: 2,
    SkipLocked: 2,
    Distinct: 0
  });
  JOIN_TYPE_SQL = freeze({
    InnerJoin: "inner join",
    LeftJoin: "left join",
    RightJoin: "right join",
    FullJoin: "full join",
    CrossJoin: "cross join",
    LateralInnerJoin: "inner join lateral",
    LateralLeftJoin: "left join lateral",
    LateralCrossJoin: "cross join lateral",
    OuterApply: "outer apply",
    CrossApply: "cross apply",
    Using: "using"
  });
});

// ../../node_modules/kysely/dist/esm/query-compiler/compiled-query.js
var CompiledQuery;
var init_compiled_query = __esm(() => {
  init_raw_node();
  init_object_utils();
  init_query_id();
  CompiledQuery = freeze({
    raw(sql3, parameters = []) {
      return freeze({
        sql: sql3,
        query: RawNode.createWithSql(sql3),
        parameters: freeze(parameters),
        queryId: createQueryId()
      });
    }
  });
});

// ../../node_modules/kysely/dist/esm/driver/database-connection.js
var init_database_connection = () => {};

// ../../node_modules/kysely/dist/esm/driver/connection-provider.js
var init_connection_provider = () => {};
// ../../node_modules/kysely/dist/esm/dialect/dialect.js
var init_dialect = () => {};

// ../../node_modules/kysely/dist/esm/dialect/dialect-adapter.js
var init_dialect_adapter = () => {};

// ../../node_modules/kysely/dist/esm/dialect/dialect-adapter-base.js
class DialectAdapterBase {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return false;
  }
  get supportsOutput() {
    return false;
  }
}

// ../../node_modules/kysely/dist/esm/dialect/database-introspector.js
var init_database_introspector = () => {};

// ../../node_modules/kysely/dist/esm/parser/savepoint-parser.js
function parseSavepointCommand(command, savepointName) {
  return RawNode.createWithChildren([
    RawNode.createWithSql(`${command} `),
    IdentifierNode.create(savepointName)
  ]);
}
var init_savepoint_parser = __esm(() => {
  init_identifier_node();
  init_raw_node();
});

// ../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-driver.js
class SqliteDriver {
  #config;
  #connectionMutex = new ConnectionMutex;
  #db;
  #connection;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  async init() {
    this.#db = isFunction3(this.#config.database) ? await this.#config.database() : this.#config.database;
    this.#connection = new SqliteConnection(this.#db);
    if (this.#config.onCreateConnection) {
      await this.#config.onCreateConnection(this.#connection);
    }
  }
  async acquireConnection() {
    await this.#connectionMutex.lock();
    return this.#connection;
  }
  async beginTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("release", savepointName), createQueryId()));
  }
  async releaseConnection() {
    this.#connectionMutex.unlock();
  }
  async destroy() {
    this.#db?.close();
  }
}

class SqliteConnection {
  #db;
  constructor(db) {
    this.#db = db;
  }
  executeQuery(compiledQuery) {
    const { sql: sql3, parameters } = compiledQuery;
    const stmt = this.#db.prepare(sql3);
    if (stmt.reader) {
      return Promise.resolve({
        rows: stmt.all(parameters)
      });
    }
    const { changes, lastInsertRowid } = stmt.run(parameters);
    return Promise.resolve({
      numAffectedRows: changes !== undefined && changes !== null ? BigInt(changes) : undefined,
      insertId: lastInsertRowid !== undefined && lastInsertRowid !== null ? BigInt(lastInsertRowid) : undefined,
      rows: []
    });
  }
  async* streamQuery(compiledQuery, _chunkSize) {
    const { sql: sql3, parameters, query } = compiledQuery;
    const stmt = this.#db.prepare(sql3);
    if (SelectQueryNode.is(query)) {
      const iter = stmt.iterate(parameters);
      for (const row of iter) {
        yield {
          rows: [row]
        };
      }
    } else {
      throw new Error("Sqlite driver only supports streaming of select queries");
    }
  }
}

class ConnectionMutex {
  #promise;
  #resolve;
  async lock() {
    while (this.#promise) {
      await this.#promise;
    }
    this.#promise = new Promise((resolve) => {
      this.#resolve = resolve;
    });
  }
  unlock() {
    const resolve = this.#resolve;
    this.#promise = undefined;
    this.#resolve = undefined;
    resolve?.();
  }
}
var init_sqlite_driver = __esm(() => {
  init_select_query_node();
  init_savepoint_parser();
  init_compiled_query();
  init_object_utils();
  init_query_id();
});

// ../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-query-compiler.js
var ID_WRAP_REGEX, SqliteQueryCompiler;
var init_sqlite_query_compiler = __esm(() => {
  init_default_query_compiler();
  ID_WRAP_REGEX = /"/g;
  SqliteQueryCompiler = class SqliteQueryCompiler extends DefaultQueryCompiler {
    visitOrAction(node) {
      this.append("or ");
      this.append(node.action);
    }
    getCurrentParameterPlaceholder() {
      return "?";
    }
    getLeftExplainOptionsWrapper() {
      return "";
    }
    getRightExplainOptionsWrapper() {
      return "";
    }
    getLeftIdentifierWrapper() {
      return '"';
    }
    getRightIdentifierWrapper() {
      return '"';
    }
    getAutoIncrement() {
      return "autoincrement";
    }
    sanitizeIdentifier(identifier) {
      return identifier.replace(ID_WRAP_REGEX, '""');
    }
    visitDefaultInsertValue(_) {
      this.append("null");
    }
  };
});

// ../../node_modules/kysely/dist/esm/plugin/noop-plugin.js
class NoopPlugin {
  transformQuery(args) {
    return args.node;
  }
  async transformResult(args) {
    return args.result;
  }
}

// ../../node_modules/kysely/dist/esm/migration/migrator.js
class Migrator {
  #props;
  constructor(props) {
    this.#props = freeze(props);
  }
  async getMigrations() {
    const executedMigrations = await this.#doesTableExists(this.#migrationTable) ? await this.#props.db.withPlugin(this.#schemaPlugin).selectFrom(this.#migrationTable).select(["name", "timestamp"]).$narrowType().execute() : [];
    const migrations = await this.#resolveMigrations();
    return migrations.map(({ name, ...migration }) => {
      const executed = executedMigrations.find((it) => it.name === name);
      return {
        name,
        migration,
        executedAt: executed ? new Date(executed.timestamp) : undefined
      };
    });
  }
  async migrateToLatest() {
    return this.#migrate(() => ({ direction: "Up", step: Infinity }));
  }
  async migrateTo(targetMigrationName) {
    return this.#migrate(({ migrations, executedMigrations, pendingMigrations }) => {
      if (targetMigrationName === NO_MIGRATIONS) {
        return { direction: "Down", step: Infinity };
      }
      if (!migrations.find((m) => m.name === targetMigrationName)) {
        throw new Error(`migration "${targetMigrationName}" doesn't exist`);
      }
      const executedIndex = executedMigrations.indexOf(targetMigrationName);
      const pendingIndex = pendingMigrations.findIndex((m) => m.name === targetMigrationName);
      if (executedIndex !== -1) {
        return {
          direction: "Down",
          step: executedMigrations.length - executedIndex - 1
        };
      } else if (pendingIndex !== -1) {
        return { direction: "Up", step: pendingIndex + 1 };
      } else {
        throw new Error(`migration "${targetMigrationName}" isn't executed or pending`);
      }
    });
  }
  async migrateUp() {
    return this.#migrate(() => ({ direction: "Up", step: 1 }));
  }
  async migrateDown() {
    return this.#migrate(() => ({ direction: "Down", step: 1 }));
  }
  async#migrate(getMigrationDirectionAndStep) {
    try {
      await this.#ensureMigrationTablesExists();
      return await this.#runMigrations(getMigrationDirectionAndStep);
    } catch (error2) {
      if (error2 instanceof MigrationResultSetError) {
        return error2.resultSet;
      }
      return { error: error2 };
    }
  }
  get #migrationTableSchema() {
    return this.#props.migrationTableSchema;
  }
  get #migrationTable() {
    return this.#props.migrationTableName ?? DEFAULT_MIGRATION_TABLE;
  }
  get #migrationLockTable() {
    return this.#props.migrationLockTableName ?? DEFAULT_MIGRATION_LOCK_TABLE;
  }
  get #allowUnorderedMigrations() {
    return this.#props.allowUnorderedMigrations ?? DEFAULT_ALLOW_UNORDERED_MIGRATIONS;
  }
  get #schemaPlugin() {
    if (this.#migrationTableSchema) {
      return new WithSchemaPlugin(this.#migrationTableSchema);
    }
    return new NoopPlugin;
  }
  async#ensureMigrationTablesExists() {
    await this.#ensureMigrationTableSchemaExists();
    await this.#ensureMigrationTableExists();
    await this.#ensureMigrationLockTableExists();
    await this.#ensureLockRowExists();
  }
  async#ensureMigrationTableSchemaExists() {
    if (!this.#migrationTableSchema) {
      return;
    }
    if (!await this.#doesSchemaExists()) {
      try {
        await this.#createIfNotExists(this.#props.db.schema.createSchema(this.#migrationTableSchema));
      } catch (error2) {
        if (!await this.#doesSchemaExists()) {
          throw error2;
        }
      }
    }
  }
  async#ensureMigrationTableExists() {
    if (!await this.#doesTableExists(this.#migrationTable)) {
      try {
        if (this.#migrationTableSchema) {
          await this.#createIfNotExists(this.#props.db.schema.createSchema(this.#migrationTableSchema));
        }
        await this.#createIfNotExists(this.#props.db.schema.withPlugin(this.#schemaPlugin).createTable(this.#migrationTable).addColumn("name", "varchar(255)", (col) => col.notNull().primaryKey()).addColumn("timestamp", "varchar(255)", (col) => col.notNull()));
      } catch (error2) {
        if (!await this.#doesTableExists(this.#migrationTable)) {
          throw error2;
        }
      }
    }
  }
  async#ensureMigrationLockTableExists() {
    if (!await this.#doesTableExists(this.#migrationLockTable)) {
      try {
        await this.#createIfNotExists(this.#props.db.schema.withPlugin(this.#schemaPlugin).createTable(this.#migrationLockTable).addColumn("id", "varchar(255)", (col) => col.notNull().primaryKey()).addColumn("is_locked", "integer", (col) => col.notNull().defaultTo(0)));
      } catch (error2) {
        if (!await this.#doesTableExists(this.#migrationLockTable)) {
          throw error2;
        }
      }
    }
  }
  async#ensureLockRowExists() {
    if (!await this.#doesLockRowExists()) {
      try {
        await this.#props.db.withPlugin(this.#schemaPlugin).insertInto(this.#migrationLockTable).values({ id: MIGRATION_LOCK_ID, is_locked: 0 }).execute();
      } catch (error2) {
        if (!await this.#doesLockRowExists()) {
          throw error2;
        }
      }
    }
  }
  async#doesSchemaExists() {
    const schemas = await this.#props.db.introspection.getSchemas();
    return schemas.some((it) => it.name === this.#migrationTableSchema);
  }
  async#doesTableExists(tableName) {
    const schema2 = this.#migrationTableSchema;
    const tables = await this.#props.db.introspection.getTables({
      withInternalKyselyTables: true
    });
    return tables.some((it) => it.name === tableName && (!schema2 || it.schema === schema2));
  }
  async#doesLockRowExists() {
    const lockRow = await this.#props.db.withPlugin(this.#schemaPlugin).selectFrom(this.#migrationLockTable).where("id", "=", MIGRATION_LOCK_ID).select("id").executeTakeFirst();
    return !!lockRow;
  }
  async#runMigrations(getMigrationDirectionAndStep) {
    const adapter = this.#props.db.getExecutor().adapter;
    const lockOptions = freeze({
      lockTable: this.#props.migrationLockTableName ?? DEFAULT_MIGRATION_LOCK_TABLE,
      lockRowId: MIGRATION_LOCK_ID,
      lockTableSchema: this.#props.migrationTableSchema
    });
    const run = async (db) => {
      try {
        await adapter.acquireMigrationLock(db, lockOptions);
        const state = await this.#getState(db);
        if (state.migrations.length === 0) {
          return { results: [] };
        }
        const { direction, step } = getMigrationDirectionAndStep(state);
        if (step <= 0) {
          return { results: [] };
        }
        if (direction === "Down") {
          return await this.#migrateDown(db, state, step);
        } else if (direction === "Up") {
          return await this.#migrateUp(db, state, step);
        }
        return { results: [] };
      } finally {
        await adapter.releaseMigrationLock(db, lockOptions);
      }
    };
    if (adapter.supportsTransactionalDdl && !this.#props.disableTransactions) {
      return this.#props.db.transaction().execute(run);
    } else {
      return this.#props.db.connection().execute(run);
    }
  }
  async#getState(db) {
    const migrations = await this.#resolveMigrations();
    const executedMigrations = await this.#getExecutedMigrations(db);
    this.#ensureNoMissingMigrations(migrations, executedMigrations);
    if (!this.#allowUnorderedMigrations) {
      this.#ensureMigrationsInOrder(migrations, executedMigrations);
    }
    const pendingMigrations = this.#getPendingMigrations(migrations, executedMigrations);
    return freeze({
      migrations,
      executedMigrations,
      lastMigration: getLast(executedMigrations),
      pendingMigrations
    });
  }
  #getPendingMigrations(migrations, executedMigrations) {
    return migrations.filter((migration) => {
      return !executedMigrations.includes(migration.name);
    });
  }
  async#resolveMigrations() {
    const allMigrations = await this.#props.provider.getMigrations();
    return Object.keys(allMigrations).sort().map((name) => ({
      ...allMigrations[name],
      name
    }));
  }
  async#getExecutedMigrations(db) {
    const executedMigrations = await db.withPlugin(this.#schemaPlugin).selectFrom(this.#migrationTable).select(["name", "timestamp"]).$narrowType().execute();
    const nameComparator = this.#props.nameComparator || ((a, b) => a.localeCompare(b));
    return executedMigrations.sort((a, b) => {
      if (a.timestamp === b.timestamp) {
        return nameComparator(a.name, b.name);
      }
      return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
    }).map((it) => it.name);
  }
  #ensureNoMissingMigrations(migrations, executedMigrations) {
    for (const executed of executedMigrations) {
      if (!migrations.some((it) => it.name === executed)) {
        throw new Error(`corrupted migrations: previously executed migration ${executed} is missing`);
      }
    }
  }
  #ensureMigrationsInOrder(migrations, executedMigrations) {
    for (let i = 0;i < executedMigrations.length; ++i) {
      if (migrations[i].name !== executedMigrations[i]) {
        throw new Error(`corrupted migrations: expected previously executed migration ${executedMigrations[i]} to be at index ${i} but ${migrations[i].name} was found in its place. New migrations must always have a name that comes alphabetically after the last executed migration.`);
      }
    }
  }
  async#migrateDown(db, state, step) {
    const migrationsToRollback = state.executedMigrations.slice().reverse().slice(0, step).map((name) => {
      return state.migrations.find((it) => it.name === name);
    });
    const results = migrationsToRollback.map((migration) => {
      return {
        migrationName: migration.name,
        direction: "Down",
        status: "NotExecuted"
      };
    });
    for (let i = 0;i < results.length; ++i) {
      const migration = migrationsToRollback[i];
      try {
        if (migration.down) {
          await migration.down(db);
          await db.withPlugin(this.#schemaPlugin).deleteFrom(this.#migrationTable).where("name", "=", migration.name).execute();
          results[i] = {
            migrationName: migration.name,
            direction: "Down",
            status: "Success"
          };
        }
      } catch (error2) {
        results[i] = {
          migrationName: migration.name,
          direction: "Down",
          status: "Error"
        };
        throw new MigrationResultSetError({
          error: error2,
          results
        });
      }
    }
    return { results };
  }
  async#migrateUp(db, state, step) {
    const migrationsToRun = state.pendingMigrations.slice(0, step);
    const results = migrationsToRun.map((migration) => {
      return {
        migrationName: migration.name,
        direction: "Up",
        status: "NotExecuted"
      };
    });
    for (let i = 0;i < results.length; i++) {
      const migration = state.pendingMigrations[i];
      try {
        await migration.up(db);
        await db.withPlugin(this.#schemaPlugin).insertInto(this.#migrationTable).values({
          name: migration.name,
          timestamp: new Date().toISOString()
        }).execute();
        results[i] = {
          migrationName: migration.name,
          direction: "Up",
          status: "Success"
        };
      } catch (error2) {
        results[i] = {
          migrationName: migration.name,
          direction: "Up",
          status: "Error"
        };
        throw new MigrationResultSetError({
          error: error2,
          results
        });
      }
    }
    return { results };
  }
  async#createIfNotExists(qb) {
    if (this.#props.db.getExecutor().adapter.supportsCreateIfNotExists) {
      qb = qb.ifNotExists();
    }
    await qb.execute();
  }
}
var DEFAULT_MIGRATION_TABLE = "kysely_migration", DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock", DEFAULT_ALLOW_UNORDERED_MIGRATIONS = false, MIGRATION_LOCK_ID = "migration_lock", NO_MIGRATIONS, MigrationResultSetError;
var init_migrator = __esm(() => {
  init_with_schema_plugin();
  init_object_utils();
  NO_MIGRATIONS = freeze({ __noMigrations__: true });
  MigrationResultSetError = class MigrationResultSetError extends Error {
    #resultSet;
    constructor(result) {
      super();
      this.#resultSet = result;
    }
    get resultSet() {
      return this.#resultSet;
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js
class SqliteIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    return await this.#getTableMetadata(options);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #tablesQuery(qb, options) {
    let tablesQuery = qb.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select(["name", "sql", "type"]).orderBy("name");
    if (!options.withInternalKyselyTables) {
      tablesQuery = tablesQuery.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    return tablesQuery;
  }
  async#getTableMetadata(options) {
    const tablesResult = await this.#tablesQuery(this.#db, options).execute();
    const tableMetadata = await this.#db.with("table_list", (qb) => this.#tablesQuery(qb, options)).selectFrom([
      "table_list as tl",
      sql2`pragma_table_info(tl.name)`.as("p")
    ]).select([
      "tl.name as table",
      "p.cid",
      "p.name",
      "p.type",
      "p.notnull",
      "p.dflt_value",
      "p.pk"
    ]).orderBy("tl.name").orderBy("p.cid").execute();
    const columnsByTable = {};
    for (const row of tableMetadata) {
      columnsByTable[row.table] ??= [];
      columnsByTable[row.table].push(row);
    }
    return tablesResult.map(({ name, sql: sql3, type }) => {
      let autoIncrementCol = sql3?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.trimStart()?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
      const columns = columnsByTable[name] ?? [];
      if (!autoIncrementCol) {
        const pkCols = columns.filter((r) => r.pk > 0);
        if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === "integer") {
          autoIncrementCol = pkCols[0].name;
        }
      }
      return {
        name,
        isView: type === "view",
        columns: columns.map((col) => ({
          name: col.name,
          dataType: col.type,
          isNullable: !col.notnull,
          isAutoIncrementing: col.name === autoIncrementCol,
          hasDefaultValue: col.dflt_value != null,
          comment: undefined
        }))
      };
    });
  }
}
var init_sqlite_introspector = __esm(() => {
  init_migrator();
  init_sql();
});

// ../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js
var SqliteAdapter;
var init_sqlite_adapter = __esm(() => {
  SqliteAdapter = class SqliteAdapter extends DialectAdapterBase {
    get supportsTransactionalDdl() {
      return false;
    }
    get supportsReturning() {
      return true;
    }
    async acquireMigrationLock(_db, _opt) {}
    async releaseMigrationLock(_db, _opt) {}
  };
});

// ../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect.js
class SqliteDialect {
  #config;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  createDriver() {
    return new SqliteDriver(this.#config);
  }
  createQueryCompiler() {
    return new SqliteQueryCompiler;
  }
  createAdapter() {
    return new SqliteAdapter;
  }
  createIntrospector(db) {
    return new SqliteIntrospector(db);
  }
}
var init_sqlite_dialect = __esm(() => {
  init_sqlite_driver();
  init_sqlite_query_compiler();
  init_sqlite_introspector();
  init_sqlite_adapter();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect-config.js
var init_sqlite_dialect_config = () => {};

// ../../node_modules/kysely/dist/esm/dialect/postgres/postgres-query-compiler.js
var ID_WRAP_REGEX2, PostgresQueryCompiler;
var init_postgres_query_compiler = __esm(() => {
  init_default_query_compiler();
  ID_WRAP_REGEX2 = /"/g;
  PostgresQueryCompiler = class PostgresQueryCompiler extends DefaultQueryCompiler {
    sanitizeIdentifier(identifier) {
      return identifier.replace(ID_WRAP_REGEX2, '""');
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/postgres/postgres-introspector.js
class PostgresIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    let rawSchemas = await this.#db.selectFrom("pg_catalog.pg_namespace").select("nspname").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.nspname }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query = this.#db.selectFrom("pg_catalog.pg_attribute as a").innerJoin("pg_catalog.pg_class as c", "a.attrelid", "c.oid").innerJoin("pg_catalog.pg_namespace as ns", "c.relnamespace", "ns.oid").innerJoin("pg_catalog.pg_type as typ", "a.atttypid", "typ.oid").innerJoin("pg_catalog.pg_namespace as dtns", "typ.typnamespace", "dtns.oid").select([
      "a.attname as column",
      "a.attnotnull as not_null",
      "a.atthasdef as has_default",
      "c.relname as table",
      "c.relkind as table_type",
      "ns.nspname as schema",
      "typ.typname as type",
      "dtns.nspname as type_schema",
      sql2`col_description(a.attrelid, a.attnum)`.as("column_description"),
      sql2`pg_get_serial_sequence(quote_ident(ns.nspname) || '.' || quote_ident(c.relname), a.attname)`.as("auto_incrementing")
    ]).where("c.relkind", "in", [
      "r",
      "v",
      "p"
    ]).where("ns.nspname", "!~", "^pg_").where("ns.nspname", "!=", "information_schema").where("a.attnum", ">=", 0).where("a.attisdropped", "!=", true).orderBy("ns.nspname").orderBy("c.relname").orderBy("a.attnum").$castTo();
    if (!options.withInternalKyselyTables) {
      query = query.where("c.relname", "!=", DEFAULT_MIGRATION_TABLE).where("c.relname", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table = tables.find((tbl) => tbl.name === it.table && tbl.schema === it.schema);
      if (!table) {
        table = freeze({
          name: it.table,
          isView: it.table_type === "v",
          schema: it.schema,
          columns: []
        });
        tables.push(table);
      }
      table.columns.push(freeze({
        name: it.column,
        dataType: it.type,
        dataTypeSchema: it.type_schema,
        isNullable: !it.not_null,
        isAutoIncrementing: it.auto_incrementing !== null,
        hasDefaultValue: it.has_default,
        comment: it.column_description ?? undefined
      }));
      return tables;
    }, []);
  }
}
var init_postgres_introspector = __esm(() => {
  init_migrator();
  init_object_utils();
  init_sql();
});

// ../../node_modules/kysely/dist/esm/dialect/postgres/postgres-adapter.js
var LOCK_ID, PostgresAdapter;
var init_postgres_adapter = __esm(() => {
  init_sql();
  LOCK_ID = BigInt("3853314791062309107");
  PostgresAdapter = class PostgresAdapter extends DialectAdapterBase {
    get supportsTransactionalDdl() {
      return true;
    }
    get supportsReturning() {
      return true;
    }
    async acquireMigrationLock(db, _opt) {
      await sql2`select pg_advisory_xact_lock(${sql2.lit(LOCK_ID)})`.execute(db);
    }
    async releaseMigrationLock(_db, _opt) {}
  };
});

// ../../node_modules/kysely/dist/esm/util/stack-trace-utils.js
function extendStackTrace(err, stackError) {
  if (isStackHolder(err) && stackError.stack) {
    const stackExtension = stackError.stack.split(`
`).slice(1).join(`
`);
    err.stack += `
${stackExtension}`;
    return err;
  }
  return err;
}
function isStackHolder(obj) {
  return isObject3(obj) && isString2(obj.stack);
}
var init_stack_trace_utils = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/dialect/mysql/mysql-driver.js
class MysqlDriver {
  #config;
  #connections = new WeakMap;
  #pool;
  constructor(configOrPool) {
    this.#config = freeze({ ...configOrPool });
  }
  async init() {
    this.#pool = isFunction3(this.#config.pool) ? await this.#config.pool() : this.#config.pool;
  }
  async acquireConnection() {
    const rawConnection = await this.#acquireConnection();
    let connection = this.#connections.get(rawConnection);
    if (!connection) {
      connection = new MysqlConnection(rawConnection);
      this.#connections.set(rawConnection, connection);
      if (this.#config?.onCreateConnection) {
        await this.#config.onCreateConnection(connection);
      }
    }
    if (this.#config?.onReserveConnection) {
      await this.#config.onReserveConnection(connection);
    }
    return connection;
  }
  async#acquireConnection() {
    return new Promise((resolve, reject) => {
      this.#pool.getConnection(async (err, rawConnection) => {
        if (err) {
          reject(err);
        } else {
          resolve(rawConnection);
        }
      });
    });
  }
  async beginTransaction(connection, settings) {
    if (settings.isolationLevel || settings.accessMode) {
      const parts = [];
      if (settings.isolationLevel) {
        parts.push(`isolation level ${settings.isolationLevel}`);
      }
      if (settings.accessMode) {
        parts.push(settings.accessMode);
      }
      const sql3 = `set transaction ${parts.join(", ")}`;
      await connection.executeQuery(CompiledQuery.raw(sql3));
    }
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("release savepoint", savepointName), createQueryId()));
  }
  async releaseConnection(connection) {
    connection[PRIVATE_RELEASE_METHOD]();
  }
  async destroy() {
    return new Promise((resolve, reject) => {
      this.#pool.end((err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
}
function isOkPacket(obj) {
  return isObject3(obj) && "insertId" in obj && "affectedRows" in obj;
}
var PRIVATE_RELEASE_METHOD, MysqlConnection;
var init_mysql_driver = __esm(() => {
  init_savepoint_parser();
  init_compiled_query();
  init_object_utils();
  init_query_id();
  init_stack_trace_utils();
  PRIVATE_RELEASE_METHOD = Symbol();
  MysqlConnection = class MysqlConnection {
    #rawConnection;
    constructor(rawConnection) {
      this.#rawConnection = rawConnection;
    }
    async executeQuery(compiledQuery) {
      try {
        const result = await this.#executeQuery(compiledQuery);
        if (isOkPacket(result)) {
          const { insertId, affectedRows, changedRows } = result;
          return {
            insertId: insertId !== undefined && insertId !== null && insertId.toString() !== "0" ? BigInt(insertId) : undefined,
            numAffectedRows: affectedRows !== undefined && affectedRows !== null ? BigInt(affectedRows) : undefined,
            numChangedRows: changedRows !== undefined && changedRows !== null ? BigInt(changedRows) : undefined,
            rows: []
          };
        } else if (Array.isArray(result)) {
          return {
            rows: result
          };
        }
        return {
          rows: []
        };
      } catch (err) {
        throw extendStackTrace(err, new Error);
      }
    }
    #executeQuery(compiledQuery) {
      return new Promise((resolve, reject) => {
        this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters, (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });
    }
    async* streamQuery(compiledQuery, _chunkSize) {
      const stream4 = this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters).stream({
        objectMode: true
      });
      try {
        for await (const row of stream4) {
          yield {
            rows: [row]
          };
        }
      } catch (ex) {
        if (ex && typeof ex === "object" && "code" in ex && ex.code === "ERR_STREAM_PREMATURE_CLOSE") {
          return;
        }
        throw ex;
      }
    }
    [PRIVATE_RELEASE_METHOD]() {
      this.#rawConnection.release();
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/mysql/mysql-query-compiler.js
var ID_WRAP_REGEX3, MysqlQueryCompiler;
var init_mysql_query_compiler = __esm(() => {
  init_default_query_compiler();
  ID_WRAP_REGEX3 = /`/g;
  MysqlQueryCompiler = class MysqlQueryCompiler extends DefaultQueryCompiler {
    getCurrentParameterPlaceholder() {
      return "?";
    }
    getLeftExplainOptionsWrapper() {
      return "";
    }
    getExplainOptionAssignment() {
      return "=";
    }
    getExplainOptionsDelimiter() {
      return " ";
    }
    getRightExplainOptionsWrapper() {
      return "";
    }
    getLeftIdentifierWrapper() {
      return "`";
    }
    getRightIdentifierWrapper() {
      return "`";
    }
    sanitizeIdentifier(identifier) {
      return identifier.replace(ID_WRAP_REGEX3, "``");
    }
    visitCreateIndex(node) {
      this.append("create ");
      if (node.unique) {
        this.append("unique ");
      }
      this.append("index ");
      if (node.ifNotExists) {
        this.append("if not exists ");
      }
      this.visitNode(node.name);
      if (node.using) {
        this.append(" using ");
        this.visitNode(node.using);
      }
      if (node.table) {
        this.append(" on ");
        this.visitNode(node.table);
      }
      if (node.columns) {
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
      }
      if (node.where) {
        this.append(" ");
        this.visitNode(node.where);
      }
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/mysql/mysql-introspector.js
class MysqlIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    let rawSchemas = await this.#db.selectFrom("information_schema.schemata").select("schema_name").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.SCHEMA_NAME }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query = this.#db.selectFrom("information_schema.columns as columns").innerJoin("information_schema.tables as tables", (b) => b.onRef("columns.TABLE_CATALOG", "=", "tables.TABLE_CATALOG").onRef("columns.TABLE_SCHEMA", "=", "tables.TABLE_SCHEMA").onRef("columns.TABLE_NAME", "=", "tables.TABLE_NAME")).select([
      "columns.COLUMN_NAME",
      "columns.COLUMN_DEFAULT",
      "columns.TABLE_NAME",
      "columns.TABLE_SCHEMA",
      "tables.TABLE_TYPE",
      "columns.IS_NULLABLE",
      "columns.DATA_TYPE",
      "columns.EXTRA",
      "columns.COLUMN_COMMENT"
    ]).where("columns.TABLE_SCHEMA", "=", sql2`database()`).orderBy("columns.TABLE_NAME").orderBy("columns.ORDINAL_POSITION").$castTo();
    if (!options.withInternalKyselyTables) {
      query = query.where("columns.TABLE_NAME", "!=", DEFAULT_MIGRATION_TABLE).where("columns.TABLE_NAME", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table = tables.find((tbl) => tbl.name === it.TABLE_NAME);
      if (!table) {
        table = freeze({
          name: it.TABLE_NAME,
          isView: it.TABLE_TYPE === "VIEW",
          schema: it.TABLE_SCHEMA,
          columns: []
        });
        tables.push(table);
      }
      table.columns.push(freeze({
        name: it.COLUMN_NAME,
        dataType: it.DATA_TYPE,
        isNullable: it.IS_NULLABLE === "YES",
        isAutoIncrementing: it.EXTRA.toLowerCase().includes("auto_increment"),
        hasDefaultValue: it.COLUMN_DEFAULT !== null,
        comment: it.COLUMN_COMMENT === "" ? undefined : it.COLUMN_COMMENT
      }));
      return tables;
    }, []);
  }
}
var init_mysql_introspector = __esm(() => {
  init_migrator();
  init_object_utils();
  init_sql();
});

// ../../node_modules/kysely/dist/esm/dialect/mysql/mysql-adapter.js
var LOCK_ID2 = "ea586330-2c93-47c8-908d-981d9d270f9d", LOCK_TIMEOUT_SECONDS, MysqlAdapter;
var init_mysql_adapter = __esm(() => {
  init_sql();
  LOCK_TIMEOUT_SECONDS = 60 * 60;
  MysqlAdapter = class MysqlAdapter extends DialectAdapterBase {
    get supportsTransactionalDdl() {
      return false;
    }
    get supportsReturning() {
      return false;
    }
    async acquireMigrationLock(db, _opt) {
      await sql2`select get_lock(${sql2.lit(LOCK_ID2)}, ${sql2.lit(LOCK_TIMEOUT_SECONDS)})`.execute(db);
    }
    async releaseMigrationLock(db, _opt) {
      await sql2`select release_lock(${sql2.lit(LOCK_ID2)})`.execute(db);
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect.js
class MysqlDialect {
  #config;
  constructor(config2) {
    this.#config = config2;
  }
  createDriver() {
    return new MysqlDriver(this.#config);
  }
  createQueryCompiler() {
    return new MysqlQueryCompiler;
  }
  createAdapter() {
    return new MysqlAdapter;
  }
  createIntrospector(db) {
    return new MysqlIntrospector(db);
  }
}
var init_mysql_dialect = __esm(() => {
  init_mysql_driver();
  init_mysql_query_compiler();
  init_mysql_introspector();
  init_mysql_adapter();
});

// ../../node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect-config.js
var init_mysql_dialect_config = () => {};

// ../../node_modules/kysely/dist/esm/dialect/postgres/postgres-driver.js
class PostgresDriver {
  #config;
  #connections = new WeakMap;
  #pool;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
  }
  async init() {
    this.#pool = isFunction3(this.#config.pool) ? await this.#config.pool() : this.#config.pool;
  }
  async acquireConnection() {
    const client = await this.#pool.connect();
    let connection = this.#connections.get(client);
    if (!connection) {
      connection = new PostgresConnection(client, {
        cursor: this.#config.cursor ?? null
      });
      this.#connections.set(client, connection);
      if (this.#config.onCreateConnection) {
        await this.#config.onCreateConnection(connection);
      }
    }
    if (this.#config.onReserveConnection) {
      await this.#config.onReserveConnection(connection);
    }
    return connection;
  }
  async beginTransaction(connection, settings) {
    if (settings.isolationLevel || settings.accessMode) {
      let sql3 = "start transaction";
      if (settings.isolationLevel) {
        sql3 += ` isolation level ${settings.isolationLevel}`;
      }
      if (settings.accessMode) {
        sql3 += ` ${settings.accessMode}`;
      }
      await connection.executeQuery(CompiledQuery.raw(sql3));
    } else {
      await connection.executeQuery(CompiledQuery.raw("begin"));
    }
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async savepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("savepoint", savepointName), createQueryId()));
  }
  async rollbackToSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("rollback to", savepointName), createQueryId()));
  }
  async releaseSavepoint(connection, savepointName, compileQuery) {
    await connection.executeQuery(compileQuery(parseSavepointCommand("release", savepointName), createQueryId()));
  }
  async releaseConnection(connection) {
    connection[PRIVATE_RELEASE_METHOD2]();
  }
  async destroy() {
    if (this.#pool) {
      const pool = this.#pool;
      this.#pool = undefined;
      await pool.end();
    }
  }
}
var PRIVATE_RELEASE_METHOD2, PostgresConnection;
var init_postgres_driver = __esm(() => {
  init_savepoint_parser();
  init_compiled_query();
  init_object_utils();
  init_query_id();
  init_stack_trace_utils();
  PRIVATE_RELEASE_METHOD2 = Symbol();
  PostgresConnection = class PostgresConnection {
    #client;
    #options;
    constructor(client, options) {
      this.#client = client;
      this.#options = options;
    }
    async executeQuery(compiledQuery) {
      try {
        const { command, rowCount, rows } = await this.#client.query(compiledQuery.sql, [...compiledQuery.parameters]);
        return {
          numAffectedRows: command === "INSERT" || command === "UPDATE" || command === "DELETE" || command === "MERGE" ? BigInt(rowCount) : undefined,
          rows: rows ?? []
        };
      } catch (err) {
        throw extendStackTrace(err, new Error);
      }
    }
    async* streamQuery(compiledQuery, chunkSize) {
      if (!this.#options.cursor) {
        throw new Error("'cursor' is not present in your postgres dialect config. It's required to make streaming work in postgres.");
      }
      if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
        throw new Error("chunkSize must be a positive integer");
      }
      const cursor = this.#client.query(new this.#options.cursor(compiledQuery.sql, compiledQuery.parameters.slice()));
      try {
        while (true) {
          const rows = await cursor.read(chunkSize);
          if (rows.length === 0) {
            break;
          }
          yield {
            rows
          };
        }
      } finally {
        await cursor.close();
      }
    }
    [PRIVATE_RELEASE_METHOD2]() {
      this.#client.release();
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect-config.js
var init_postgres_dialect_config = () => {};

// ../../node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect.js
class PostgresDialect {
  #config;
  constructor(config2) {
    this.#config = config2;
  }
  createDriver() {
    return new PostgresDriver(this.#config);
  }
  createQueryCompiler() {
    return new PostgresQueryCompiler;
  }
  createAdapter() {
    return new PostgresAdapter;
  }
  createIntrospector(db) {
    return new PostgresIntrospector(db);
  }
}
var init_postgres_dialect = __esm(() => {
  init_postgres_driver();
  init_postgres_introspector();
  init_postgres_query_compiler();
  init_postgres_adapter();
});

// ../../node_modules/kysely/dist/esm/dialect/mssql/mssql-adapter.js
var MssqlAdapter;
var init_mssql_adapter = __esm(() => {
  init_migrator();
  init_sql();
  MssqlAdapter = class MssqlAdapter extends DialectAdapterBase {
    get supportsCreateIfNotExists() {
      return false;
    }
    get supportsTransactionalDdl() {
      return true;
    }
    get supportsOutput() {
      return true;
    }
    async acquireMigrationLock(db) {
      await sql2`exec sp_getapplock @DbPrincipal = ${sql2.lit("dbo")}, @Resource = ${sql2.lit(DEFAULT_MIGRATION_TABLE)}, @LockMode = ${sql2.lit("Exclusive")}`.execute(db);
    }
    async releaseMigrationLock() {}
  };
});

// ../../node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect-config.js
var init_mssql_dialect_config = () => {};

// ../../node_modules/kysely/dist/esm/dialect/mssql/mssql-driver.js
class MssqlDriver {
  #config;
  #pool;
  constructor(config2) {
    this.#config = freeze({ ...config2 });
    const { tarn, tedious, validateConnections } = this.#config;
    const { validateConnections: deprecatedValidateConnections, ...poolOptions } = tarn.options;
    this.#pool = new tarn.Pool({
      ...poolOptions,
      create: async () => {
        const connection = await tedious.connectionFactory();
        return await new MssqlConnection(connection, tedious).connect();
      },
      destroy: async (connection) => {
        await connection[PRIVATE_DESTROY_METHOD]();
      },
      validate: validateConnections === false || deprecatedValidateConnections === false ? undefined : (connection) => connection.validate()
    });
  }
  async init() {}
  async acquireConnection() {
    return await this.#pool.acquire().promise;
  }
  async beginTransaction(connection, settings) {
    await connection.beginTransaction(settings);
  }
  async commitTransaction(connection) {
    await connection.commitTransaction();
  }
  async rollbackTransaction(connection) {
    await connection.rollbackTransaction();
  }
  async savepoint(connection, savepointName) {
    await connection.savepoint(savepointName);
  }
  async rollbackToSavepoint(connection, savepointName) {
    await connection.rollbackTransaction(savepointName);
  }
  async releaseConnection(connection) {
    if (this.#config.resetConnectionsOnRelease || this.#config.tedious.resetConnectionOnRelease) {
      await connection[PRIVATE_RESET_METHOD]();
    }
    this.#pool.release(connection);
  }
  async destroy() {
    await this.#pool.destroy();
  }
}

class MssqlRequest {
  #request;
  #rows;
  #streamChunkSize;
  #subscribers;
  #tedious;
  #rowCount;
  constructor(props) {
    const { compiledQuery, onDone, streamChunkSize, tedious } = props;
    this.#rows = [];
    this.#streamChunkSize = streamChunkSize;
    this.#subscribers = {};
    this.#tedious = tedious;
    if (onDone) {
      const subscriptionKey = "onDone";
      this.#subscribers[subscriptionKey] = (event, error2) => {
        if (event === "chunkReady") {
          return;
        }
        delete this.#subscribers[subscriptionKey];
        if (event === "error") {
          onDone.reject(error2);
        } else {
          onDone.resolve({
            rowCount: this.#rowCount,
            rows: this.#rows
          });
        }
      };
    }
    this.#request = new this.#tedious.Request(compiledQuery.sql, (err, rowCount) => {
      if (err) {
        Object.values(this.#subscribers).forEach((subscriber) => subscriber("error", err instanceof AggregateError ? err.errors : err));
      } else {
        this.#rowCount = rowCount;
      }
    });
    this.#addParametersToRequest(compiledQuery.parameters);
    this.#attachListeners();
  }
  get request() {
    return this.#request;
  }
  readChunk() {
    const subscriptionKey = this.readChunk.name;
    return new Promise((resolve, reject) => {
      this.#subscribers[subscriptionKey] = (event, error2) => {
        delete this.#subscribers[subscriptionKey];
        if (event === "error") {
          reject(error2);
        } else {
          resolve(this.#rows.splice(0, this.#streamChunkSize));
        }
      };
      this.#request.resume();
    });
  }
  #addParametersToRequest(parameters) {
    for (let i = 0;i < parameters.length; i++) {
      const parameter = parameters[i];
      this.#request.addParameter(String(i + 1), this.#getTediousDataType(parameter), parameter);
    }
  }
  #attachListeners() {
    const pauseAndEmitChunkReady = this.#streamChunkSize ? () => {
      if (this.#streamChunkSize <= this.#rows.length) {
        this.#request.pause();
        Object.values(this.#subscribers).forEach((subscriber) => subscriber("chunkReady"));
      }
    } : () => {};
    const rowListener = (columns) => {
      const row = {};
      for (const column of columns) {
        row[column.metadata.colName] = column.value;
      }
      this.#rows.push(row);
      pauseAndEmitChunkReady();
    };
    this.#request.on("row", rowListener);
    this.#request.once("requestCompleted", () => {
      Object.values(this.#subscribers).forEach((subscriber) => subscriber("completed"));
      this.#request.off("row", rowListener);
    });
  }
  #getTediousDataType(value) {
    if (isNull2(value) || isUndefined2(value) || isString2(value)) {
      return this.#tedious.TYPES.NVarChar;
    }
    if (isBigInt(value) || isNumber2(value) && value % 1 === 0) {
      if (value < -2147483648 || value > 2147483647) {
        return this.#tedious.TYPES.BigInt;
      } else {
        return this.#tedious.TYPES.Int;
      }
    }
    if (isNumber2(value)) {
      return this.#tedious.TYPES.Float;
    }
    if (isBoolean2(value)) {
      return this.#tedious.TYPES.Bit;
    }
    if (isDate2(value)) {
      return this.#tedious.TYPES.DateTime;
    }
    if (isBuffer2(value)) {
      return this.#tedious.TYPES.VarBinary;
    }
    return this.#tedious.TYPES.NVarChar;
  }
}
var PRIVATE_RESET_METHOD, PRIVATE_DESTROY_METHOD, MssqlConnection;
var init_mssql_driver = __esm(() => {
  init_object_utils();
  init_compiled_query();
  init_stack_trace_utils();
  init_random_string();
  PRIVATE_RESET_METHOD = Symbol();
  PRIVATE_DESTROY_METHOD = Symbol();
  MssqlConnection = class MssqlConnection {
    #connection;
    #tedious;
    constructor(connection, tedious) {
      this.#connection = connection;
      this.#tedious = tedious;
      this.#connection.on("error", console.error);
      this.#connection.once("end", () => {
        this.#connection.off("error", console.error);
      });
    }
    async beginTransaction(settings) {
      const { isolationLevel } = settings;
      await new Promise((resolve, reject) => this.#connection.beginTransaction((error2) => {
        if (error2)
          reject(error2);
        else
          resolve(undefined);
      }, isolationLevel ? randomString(8) : undefined, isolationLevel ? this.#getTediousIsolationLevel(isolationLevel) : undefined));
    }
    async commitTransaction() {
      await new Promise((resolve, reject) => this.#connection.commitTransaction((error2) => {
        if (error2)
          reject(error2);
        else
          resolve(undefined);
      }));
    }
    async connect() {
      await new Promise((resolve, reject) => {
        this.#connection.connect((error2) => {
          if (error2) {
            console.error(error2);
            reject(error2);
          } else {
            resolve(undefined);
          }
        });
      });
      return this;
    }
    async executeQuery(compiledQuery) {
      try {
        const deferred = new Deferred;
        const request = new MssqlRequest({
          compiledQuery,
          tedious: this.#tedious,
          onDone: deferred
        });
        this.#connection.execSql(request.request);
        const { rowCount, rows } = await deferred.promise;
        return {
          numAffectedRows: rowCount !== undefined ? BigInt(rowCount) : undefined,
          rows
        };
      } catch (err) {
        throw extendStackTrace(err, new Error);
      }
    }
    async rollbackTransaction(savepointName) {
      await new Promise((resolve, reject) => this.#connection.rollbackTransaction((error2) => {
        if (error2)
          reject(error2);
        else
          resolve(undefined);
      }, savepointName));
    }
    async savepoint(savepointName) {
      await new Promise((resolve, reject) => this.#connection.saveTransaction((error2) => {
        if (error2)
          reject(error2);
        else
          resolve(undefined);
      }, savepointName));
    }
    async* streamQuery(compiledQuery, chunkSize) {
      if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
        throw new Error("chunkSize must be a positive integer");
      }
      const request = new MssqlRequest({
        compiledQuery,
        streamChunkSize: chunkSize,
        tedious: this.#tedious
      });
      this.#connection.execSql(request.request);
      try {
        while (true) {
          const rows = await request.readChunk();
          if (rows.length === 0) {
            break;
          }
          yield { rows };
          if (rows.length < chunkSize) {
            break;
          }
        }
      } finally {
        await this.#cancelRequest(request);
      }
    }
    async validate() {
      try {
        const deferred = new Deferred;
        const request = new MssqlRequest({
          compiledQuery: CompiledQuery.raw("select 1"),
          onDone: deferred,
          tedious: this.#tedious
        });
        this.#connection.execSql(request.request);
        await deferred.promise;
        return true;
      } catch {
        return false;
      }
    }
    #getTediousIsolationLevel(isolationLevel) {
      const { ISOLATION_LEVEL } = this.#tedious;
      const mapper = {
        "read committed": ISOLATION_LEVEL.READ_COMMITTED,
        "read uncommitted": ISOLATION_LEVEL.READ_UNCOMMITTED,
        "repeatable read": ISOLATION_LEVEL.REPEATABLE_READ,
        serializable: ISOLATION_LEVEL.SERIALIZABLE,
        snapshot: ISOLATION_LEVEL.SNAPSHOT
      };
      const tediousIsolationLevel = mapper[isolationLevel];
      if (tediousIsolationLevel === undefined) {
        throw new Error(`Unknown isolation level: ${isolationLevel}`);
      }
      return tediousIsolationLevel;
    }
    #cancelRequest(request) {
      return new Promise((resolve) => {
        request.request.once("requestCompleted", resolve);
        const wasCanceled = this.#connection.cancel();
        if (!wasCanceled) {
          request.request.off("requestCompleted", resolve);
          resolve(undefined);
        }
      });
    }
    async[PRIVATE_RESET_METHOD]() {
      await new Promise((resolve, reject) => {
        this.#connection.reset((error2) => {
          if (error2)
            reject(error2);
          else
            resolve(undefined);
        });
      });
    }
    [PRIVATE_DESTROY_METHOD]() {
      return new Promise((resolve) => {
        this.#connection.once("end", () => {
          resolve(undefined);
        });
        this.#connection.close();
      });
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/mssql/mssql-introspector.js
class MssqlIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    return await this.#db.selectFrom("sys.schemas").select("name").execute();
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    const rawColumns = await this.#db.selectFrom("sys.tables as tables").leftJoin("sys.schemas as table_schemas", "table_schemas.schema_id", "tables.schema_id").innerJoin("sys.columns as columns", "columns.object_id", "tables.object_id").innerJoin("sys.types as types", "types.user_type_id", "columns.user_type_id").leftJoin("sys.schemas as type_schemas", "type_schemas.schema_id", "types.schema_id").leftJoin("sys.extended_properties as comments", (join) => join.onRef("comments.major_id", "=", "tables.object_id").onRef("comments.minor_id", "=", "columns.column_id").on("comments.name", "=", "MS_Description")).$if(!options.withInternalKyselyTables, (qb) => qb.where("tables.name", "!=", DEFAULT_MIGRATION_TABLE).where("tables.name", "!=", DEFAULT_MIGRATION_LOCK_TABLE)).select([
      "tables.name as table_name",
      (eb) => eb.ref("tables.type").$castTo().as("table_type"),
      "table_schemas.name as table_schema_name",
      "columns.default_object_id as column_default_object_id",
      "columns.generated_always_type_desc as column_generated_always_type",
      "columns.is_computed as column_is_computed",
      "columns.is_identity as column_is_identity",
      "columns.is_nullable as column_is_nullable",
      "columns.is_rowguidcol as column_is_rowguidcol",
      "columns.name as column_name",
      "types.is_nullable as type_is_nullable",
      "types.name as type_name",
      "type_schemas.name as type_schema_name",
      "comments.value as column_comment"
    ]).unionAll(this.#db.selectFrom("sys.views as views").leftJoin("sys.schemas as view_schemas", "view_schemas.schema_id", "views.schema_id").innerJoin("sys.columns as columns", "columns.object_id", "views.object_id").innerJoin("sys.types as types", "types.user_type_id", "columns.user_type_id").leftJoin("sys.schemas as type_schemas", "type_schemas.schema_id", "types.schema_id").leftJoin("sys.extended_properties as comments", (join) => join.onRef("comments.major_id", "=", "views.object_id").onRef("comments.minor_id", "=", "columns.column_id").on("comments.name", "=", "MS_Description")).select([
      "views.name as table_name",
      "views.type as table_type",
      "view_schemas.name as table_schema_name",
      "columns.default_object_id as column_default_object_id",
      "columns.generated_always_type_desc as column_generated_always_type",
      "columns.is_computed as column_is_computed",
      "columns.is_identity as column_is_identity",
      "columns.is_nullable as column_is_nullable",
      "columns.is_rowguidcol as column_is_rowguidcol",
      "columns.name as column_name",
      "types.is_nullable as type_is_nullable",
      "types.name as type_name",
      "type_schemas.name as type_schema_name",
      "comments.value as column_comment"
    ])).orderBy("table_schema_name").orderBy("table_name").orderBy("column_name").execute();
    const tableDictionary = {};
    for (const rawColumn of rawColumns) {
      const key = `${rawColumn.table_schema_name}.${rawColumn.table_name}`;
      const table = tableDictionary[key] = tableDictionary[key] || freeze({
        columns: [],
        isView: rawColumn.table_type === "V ",
        name: rawColumn.table_name,
        schema: rawColumn.table_schema_name ?? undefined
      });
      table.columns.push(freeze({
        dataType: rawColumn.type_name,
        dataTypeSchema: rawColumn.type_schema_name ?? undefined,
        hasDefaultValue: rawColumn.column_default_object_id > 0 || rawColumn.column_generated_always_type !== "NOT_APPLICABLE" || rawColumn.column_is_identity || rawColumn.column_is_computed || rawColumn.column_is_rowguidcol,
        isAutoIncrementing: rawColumn.column_is_identity,
        isNullable: rawColumn.column_is_nullable && rawColumn.type_is_nullable,
        name: rawColumn.column_name,
        comment: rawColumn.column_comment ?? undefined
      }));
    }
    return Object.values(tableDictionary);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
}
var init_mssql_introspector = __esm(() => {
  init_migrator();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/dialect/mssql/mssql-query-compiler.js
var COLLATION_CHAR_REGEX, MssqlQueryCompiler;
var init_mssql_query_compiler = __esm(() => {
  init_default_query_compiler();
  COLLATION_CHAR_REGEX = /^[a-z0-9_]$/i;
  MssqlQueryCompiler = class MssqlQueryCompiler extends DefaultQueryCompiler {
    getCurrentParameterPlaceholder() {
      return `@${this.numParameters}`;
    }
    visitOffset(node) {
      super.visitOffset(node);
      this.append(" rows");
    }
    compileColumnAlterations(columnAlterations) {
      const nodesByKind = {};
      for (const columnAlteration of columnAlterations) {
        if (!nodesByKind[columnAlteration.kind]) {
          nodesByKind[columnAlteration.kind] = [];
        }
        nodesByKind[columnAlteration.kind].push(columnAlteration);
      }
      let first = true;
      if (nodesByKind.AddColumnNode) {
        this.append("add ");
        this.compileList(nodesByKind.AddColumnNode);
        first = false;
      }
      if (nodesByKind.AlterColumnNode) {
        if (!first)
          this.append(", ");
        this.compileList(nodesByKind.AlterColumnNode);
      }
      if (nodesByKind.DropColumnNode) {
        if (!first)
          this.append(", ");
        this.append("drop column ");
        this.compileList(nodesByKind.DropColumnNode);
      }
      if (nodesByKind.ModifyColumnNode) {
        if (!first)
          this.append(", ");
        this.compileList(nodesByKind.ModifyColumnNode);
      }
      if (nodesByKind.RenameColumnNode) {
        if (!first)
          this.append(", ");
        this.compileList(nodesByKind.RenameColumnNode);
      }
    }
    visitAddColumn(node) {
      this.visitNode(node.column);
    }
    visitDropColumn(node) {
      this.visitNode(node.column);
    }
    visitMergeQuery(node) {
      super.visitMergeQuery(node);
      this.append(";");
    }
    visitCollate(node) {
      this.append("collate ");
      const { name } = node.collation;
      for (const char2 of name) {
        if (!COLLATION_CHAR_REGEX.test(char2)) {
          throw new Error(`Invalid collation: ${name}`);
        }
      }
      this.append(name);
    }
    announcesNewColumnDataType() {
      return false;
    }
  };
});

// ../../node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect.js
class MssqlDialect {
  #config;
  constructor(config2) {
    this.#config = config2;
  }
  createDriver() {
    return new MssqlDriver(this.#config);
  }
  createQueryCompiler() {
    return new MssqlQueryCompiler;
  }
  createAdapter() {
    return new MssqlAdapter;
  }
  createIntrospector(db) {
    return new MssqlIntrospector(db);
  }
}
var init_mssql_dialect = __esm(() => {
  init_mssql_adapter();
  init_mssql_driver();
  init_mssql_introspector();
  init_mssql_query_compiler();
});

// ../../node_modules/kysely/dist/esm/query-compiler/query-compiler.js
var init_query_compiler = () => {};

// ../../node_modules/kysely/dist/esm/migration/file-migration-provider.js
class FileMigrationProvider {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getMigrations() {
    const migrations = {};
    const files = await this.#props.fs.readdir(this.#props.migrationFolder);
    for (const fileName of files) {
      if (fileName.endsWith(".js") || fileName.endsWith(".ts") && !fileName.endsWith(".d.ts") || fileName.endsWith(".mjs") || fileName.endsWith(".mts") && !fileName.endsWith(".d.mts")) {
        const migration = await import(this.#props.path.join(this.#props.migrationFolder, fileName));
        const migrationKey = fileName.substring(0, fileName.lastIndexOf("."));
        if (isMigration(migration?.default)) {
          migrations[migrationKey] = migration.default;
        } else if (isMigration(migration)) {
          migrations[migrationKey] = migration;
        }
      }
    }
    return migrations;
  }
}
function isMigration(obj) {
  return isObject3(obj) && isFunction3(obj.up);
}
var init_file_migration_provider = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/plugin/kysely-plugin.js
var init_kysely_plugin = () => {};

// ../../node_modules/kysely/dist/esm/plugin/camel-case/camel-case-transformer.js
var SnakeCaseTransformer;
var init_camel_case_transformer = __esm(() => {
  init_operation_node_transformer();
  SnakeCaseTransformer = class SnakeCaseTransformer extends OperationNodeTransformer {
    #snakeCase;
    constructor(snakeCase) {
      super();
      this.#snakeCase = snakeCase;
    }
    transformIdentifier(node, queryId) {
      node = super.transformIdentifier(node, queryId);
      return {
        ...node,
        name: this.#snakeCase(node.name)
      };
    }
  };
});

// ../../node_modules/kysely/dist/esm/plugin/camel-case/camel-case.js
function createSnakeCaseMapper({ upperCase = false, underscoreBeforeDigits = false, underscoreBetweenUppercaseLetters = false } = {}) {
  return memoize((str) => {
    if (str.length === 0) {
      return str;
    }
    const upper = str.toUpperCase();
    const lower = str.toLowerCase();
    let out = lower[0];
    for (let i = 1, l = str.length;i < l; ++i) {
      const char2 = str[i];
      const prevChar = str[i - 1];
      const upperChar = upper[i];
      const prevUpperChar = upper[i - 1];
      const lowerChar = lower[i];
      const prevLowerChar = lower[i - 1];
      if (underscoreBeforeDigits && isDigit(char2) && !isDigit(prevChar) && !out.endsWith("_")) {
        out += "_" + char2;
        continue;
      }
      if (char2 === upperChar && upperChar !== lowerChar) {
        const prevCharacterIsUppercase = prevChar === prevUpperChar && prevUpperChar !== prevLowerChar;
        if (underscoreBetweenUppercaseLetters || !prevCharacterIsUppercase) {
          out += "_" + lowerChar;
        } else {
          out += lowerChar;
        }
      } else {
        out += char2;
      }
    }
    if (upperCase) {
      return out.toUpperCase();
    } else {
      return out;
    }
  });
}
function createCamelCaseMapper({ upperCase = false } = {}) {
  return memoize((str) => {
    if (str.length === 0) {
      return str;
    }
    if (upperCase && isAllUpperCaseSnakeCase(str)) {
      str = str.toLowerCase();
    }
    let out = str[0];
    for (let i = 1, l = str.length;i < l; ++i) {
      const char2 = str[i];
      const prevChar = str[i - 1];
      if (char2 !== "_") {
        if (prevChar === "_") {
          out += char2.toUpperCase();
        } else {
          out += char2;
        }
      }
    }
    return out;
  });
}
function isAllUpperCaseSnakeCase(str) {
  for (let i = 1, l = str.length;i < l; ++i) {
    const char2 = str[i];
    if (char2 !== "_" && char2 !== char2.toUpperCase()) {
      return false;
    }
  }
  return true;
}
function isDigit(char2) {
  return char2 >= "0" && char2 <= "9";
}
function memoize(func) {
  const cache = new Map;
  return (str) => {
    let mapped = cache.get(str);
    if (!mapped) {
      mapped = func(str);
      cache.set(str, mapped);
    }
    return mapped;
  };
}

// ../../node_modules/kysely/dist/esm/plugin/camel-case/camel-case-plugin.js
class CamelCasePlugin {
  opt;
  #camelCase;
  #snakeCase;
  #snakeCaseTransformer;
  constructor(opt = {}) {
    this.opt = opt;
    this.#camelCase = createCamelCaseMapper(opt);
    this.#snakeCase = createSnakeCaseMapper(opt);
    this.#snakeCaseTransformer = new SnakeCaseTransformer(this.snakeCase.bind(this));
  }
  transformQuery(args) {
    return this.#snakeCaseTransformer.transformNode(args.node, args.queryId);
  }
  async transformResult(args) {
    if (args.result.rows && Array.isArray(args.result.rows)) {
      return {
        ...args.result,
        rows: args.result.rows.map((row) => this.mapRow(row))
      };
    }
    return args.result;
  }
  mapRow(row) {
    return Object.keys(row).reduce((obj, key) => {
      let value = row[key];
      if (Array.isArray(value)) {
        value = value.map((it) => canMap(it, this.opt) ? this.mapRow(it) : it);
      } else if (canMap(value, this.opt)) {
        value = this.mapRow(value);
      }
      obj[this.camelCase(key)] = value;
      return obj;
    }, {});
  }
  snakeCase(str) {
    return this.#snakeCase(str);
  }
  camelCase(str) {
    return this.#camelCase(str);
  }
}
function canMap(obj, opt) {
  return isPlainObject3(obj) && !opt?.maintainNestedObjectKeys;
}
var init_camel_case_plugin = __esm(() => {
  init_object_utils();
  init_camel_case_transformer();
});

// ../../node_modules/kysely/dist/esm/plugin/deduplicate-joins/deduplicate-joins-transformer.js
var DeduplicateJoinsTransformer;
var init_deduplicate_joins_transformer = __esm(() => {
  init_operation_node_transformer();
  init_object_utils();
  DeduplicateJoinsTransformer = class DeduplicateJoinsTransformer extends OperationNodeTransformer {
    transformSelectQuery(node, queryId) {
      return this.#transformQuery(super.transformSelectQuery(node, queryId));
    }
    transformUpdateQuery(node, queryId) {
      return this.#transformQuery(super.transformUpdateQuery(node, queryId));
    }
    transformDeleteQuery(node, queryId) {
      return this.#transformQuery(super.transformDeleteQuery(node, queryId));
    }
    #transformQuery(node) {
      if (!node.joins || node.joins.length === 0) {
        return node;
      }
      return freeze({
        ...node,
        joins: this.#deduplicateJoins(node.joins)
      });
    }
    #deduplicateJoins(joins) {
      const out = [];
      for (let i = 0;i < joins.length; ++i) {
        let foundDuplicate = false;
        for (let j = 0;j < out.length; ++j) {
          if (compare(joins[i], out[j])) {
            foundDuplicate = true;
            break;
          }
        }
        if (!foundDuplicate) {
          out.push(joins[i]);
        }
      }
      return freeze(out);
    }
  };
});

// ../../node_modules/kysely/dist/esm/plugin/deduplicate-joins/deduplicate-joins-plugin.js
class DeduplicateJoinsPlugin {
  #transformer = new DeduplicateJoinsTransformer;
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  transformResult(args) {
    return Promise.resolve(args.result);
  }
}
var init_deduplicate_joins_plugin = __esm(() => {
  init_deduplicate_joins_transformer();
});

// ../../node_modules/kysely/dist/esm/plugin/parse-json-results/parse-json-results-plugin.js
class ParseJSONResultsPlugin {
  opt;
  #objectStrategy;
  constructor(opt = {}) {
    this.opt = opt;
    this.#objectStrategy = opt.objectStrategy || "in-place";
  }
  transformQuery(args) {
    return args.node;
  }
  async transformResult(args) {
    return {
      ...args.result,
      rows: parseArray(args.result.rows, this.#objectStrategy)
    };
  }
}
function parseArray(arr, objectStrategy) {
  const target = objectStrategy === "create" ? new Array(arr.length) : arr;
  for (let i = 0;i < arr.length; ++i) {
    target[i] = parse2(arr[i], objectStrategy);
  }
  return target;
}
function parse2(obj, objectStrategy) {
  if (isString2(obj)) {
    return parseString(obj);
  }
  if (Array.isArray(obj)) {
    return parseArray(obj, objectStrategy);
  }
  if (isPlainObject3(obj)) {
    return parseObject(obj, objectStrategy);
  }
  return obj;
}
function parseString(str) {
  if (maybeJson(str)) {
    try {
      return parse2(JSON.parse(str), "in-place");
    } catch (err) {}
  }
  return str;
}
function maybeJson(value) {
  return value.match(/^[\[\{]/) != null;
}
function parseObject(obj, objectStrategy) {
  const target = objectStrategy === "create" ? {} : obj;
  for (const key in obj) {
    target[key] = parse2(obj[key], objectStrategy);
  }
  return target;
}
var init_parse_json_results_plugin = __esm(() => {
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/plugin/handle-empty-in-lists/handle-empty-in-lists-transformer.js
var HandleEmptyInListsTransformer;
var init_handle_empty_in_lists_transformer = __esm(() => {
  init_operation_node_transformer();
  init_primitive_value_list_node();
  init_operator_node();
  init_value_list_node();
  HandleEmptyInListsTransformer = class HandleEmptyInListsTransformer extends OperationNodeTransformer {
    #strategy;
    constructor(strategy) {
      super();
      this.#strategy = strategy;
    }
    transformBinaryOperation(node) {
      if (this.#isEmptyInListNode(node)) {
        return this.#strategy(node);
      }
      return node;
    }
    #isEmptyInListNode(node) {
      const { operator, rightOperand } = node;
      return (PrimitiveValueListNode.is(rightOperand) || ValueListNode.is(rightOperand)) && rightOperand.values.length === 0 && OperatorNode.is(operator) && (operator.operator === "in" || operator.operator === "not in");
    }
  };
});

// ../../node_modules/kysely/dist/esm/plugin/handle-empty-in-lists/handle-empty-in-lists-plugin.js
class HandleEmptyInListsPlugin {
  opt;
  #transformer;
  constructor(opt) {
    this.opt = opt;
    this.#transformer = new HandleEmptyInListsTransformer(opt.strategy);
  }
  transformQuery(args) {
    return this.#transformer.transformNode(args.node, args.queryId);
  }
  async transformResult(args) {
    return args.result;
  }
}
var init_handle_empty_in_lists_plugin = __esm(() => {
  init_handle_empty_in_lists_transformer();
});

// ../../node_modules/kysely/dist/esm/plugin/handle-empty-in-lists/handle-empty-in-lists.js
var init_handle_empty_in_lists = __esm(() => {
  init_binary_operation_node();
  init_cast_node();
  init_data_type_node();
  init_operator_node();
  init_value_list_node();
  init_value_node();
  init_object_utils();
});

// ../../node_modules/kysely/dist/esm/operation-node/constraint-node.js
var init_constraint_node = () => {};

// ../../node_modules/kysely/dist/esm/operation-node/operation-node.js
var init_operation_node = () => {};

// ../../node_modules/kysely/dist/esm/operation-node/simple-reference-expression-node.js
var init_simple_reference_expression_node = () => {};

// ../../node_modules/kysely/dist/esm/util/column-type.js
var init_column_type = () => {};

// ../../node_modules/kysely/dist/esm/util/explainable.js
var init_explainable = () => {};

// ../../node_modules/kysely/dist/esm/util/streamable.js
var init_streamable = () => {};

// ../../node_modules/kysely/dist/esm/util/infer-result.js
var init_infer_result = () => {};

// ../../node_modules/kysely/dist/esm/index.js
var init_esm = __esm(() => {
  init_kysely();
  init_query_creator();
  init_expression();
  init_expression_builder();
  init_expression_wrapper();
  init_where_interface();
  init_returning_interface();
  init_output_interface();
  init_having_interface();
  init_order_by_interface();
  init_select_query_builder();
  init_insert_query_builder();
  init_update_query_builder();
  init_delete_query_builder();
  init_no_result_error();
  init_join_builder();
  init_function_module();
  init_on_conflict_builder();
  init_aggregate_function_builder();
  init_case_builder();
  init_json_path_builder();
  init_merge_query_builder();
  init_order_by_item_builder();
  init_raw_builder();
  init_sql();
  init_query_executor();
  init_default_query_executor();
  init_noop_query_executor();
  init_query_executor_provider();
  init_default_query_compiler();
  init_compiled_query();
  init_schema();
  init_create_table_builder();
  init_create_type_builder();
  init_drop_table_builder();
  init_drop_type_builder();
  init_create_index_builder();
  init_drop_index_builder();
  init_create_schema_builder();
  init_drop_schema_builder();
  init_column_definition_builder();
  init_foreign_key_constraint_builder();
  init_alter_table_builder();
  init_create_view_builder();
  init_refresh_materialized_view_builder();
  init_drop_view_builder();
  init_alter_column_builder();
  init_dynamic();
  init_driver();
  init_database_connection();
  init_connection_provider();
  init_dialect();
  init_dialect_adapter();
  init_database_introspector();
  init_sqlite_dialect();
  init_sqlite_dialect_config();
  init_sqlite_driver();
  init_postgres_query_compiler();
  init_postgres_introspector();
  init_postgres_adapter();
  init_mysql_dialect();
  init_mysql_dialect_config();
  init_mysql_driver();
  init_mysql_query_compiler();
  init_mysql_introspector();
  init_mysql_adapter();
  init_postgres_driver();
  init_postgres_dialect_config();
  init_postgres_dialect();
  init_sqlite_query_compiler();
  init_sqlite_introspector();
  init_sqlite_adapter();
  init_mssql_adapter();
  init_mssql_dialect_config();
  init_mssql_dialect();
  init_mssql_driver();
  init_mssql_introspector();
  init_mssql_query_compiler();
  init_default_query_compiler();
  init_query_compiler();
  init_migrator();
  init_file_migration_provider();
  init_kysely_plugin();
  init_camel_case_plugin();
  init_deduplicate_joins_plugin();
  init_with_schema_plugin();
  init_parse_json_results_plugin();
  init_handle_empty_in_lists_plugin();
  init_handle_empty_in_lists();
  init_add_column_node();
  init_add_constraint_node();
  init_add_index_node();
  init_aggregate_function_node();
  init_alias_node();
  init_alter_column_node();
  init_alter_table_node();
  init_and_node();
  init_binary_operation_node();
  init_case_node();
  init_cast_node();
  init_check_constraint_node();
  init_collate_node();
  init_column_definition_node();
  init_column_node();
  init_column_update_node();
  init_common_table_expression_name_node();
  init_common_table_expression_node();
  init_constraint_node();
  init_create_index_node();
  init_create_schema_node();
  init_create_table_node();
  init_create_type_node();
  init_create_view_node();
  init_refresh_materialized_view_node();
  init_data_type_node();
  init_default_insert_value_node();
  init_default_value_node();
  init_delete_query_node();
  init_drop_column_node();
  init_drop_constraint_node();
  init_drop_index_node();
  init_drop_schema_node();
  init_drop_table_node();
  init_drop_type_node();
  init_drop_view_node();
  init_explain_node();
  init_fetch_node();
  init_foreign_key_constraint_node();
  init_from_node();
  init_function_node();
  init_generated_node();
  init_group_by_item_node();
  init_group_by_node();
  init_having_node();
  init_identifier_node();
  init_insert_query_node();
  init_join_node();
  init_json_operator_chain_node();
  init_json_path_leg_node();
  init_json_path_node();
  init_json_reference_node();
  init_limit_node();
  init_list_node();
  init_matched_node();
  init_merge_query_node();
  init_modify_column_node();
  init_offset_node();
  init_on_conflict_node();
  init_on_duplicate_key_node();
  init_on_node();
  init_operation_node_source();
  init_operation_node_transformer();
  init_operation_node_visitor();
  init_operation_node();
  init_operator_node();
  init_or_action_node();
  init_or_node();
  init_order_by_item_node();
  init_order_by_node();
  init_output_node();
  init_over_node();
  init_parens_node();
  init_partition_by_item_node();
  init_partition_by_node();
  init_primary_key_constraint_node();
  init_primitive_value_list_node();
  init_query_node();
  init_raw_node();
  init_reference_node();
  init_references_node();
  init_rename_column_node();
  init_rename_constraint_node();
  init_returning_node();
  init_schemable_identifier_node();
  init_select_all_node();
  init_select_modifier_node();
  init_select_query_node();
  init_selection_node();
  init_set_operation_node();
  init_simple_reference_expression_node();
  init_table_node();
  init_top_node();
  init_tuple_node();
  init_unary_operation_node();
  init_unique_constraint_node();
  init_update_query_node();
  init_using_node();
  init_value_list_node();
  init_value_node();
  init_values_node();
  init_when_node();
  init_where_node();
  init_with_node();
  init_column_type();
  init_compilable();
  init_explainable();
  init_streamable();
  init_log();
  init_infer_result();
  init_log_once();
  init_query_id();
});

// ../../node_modules/better-auth/dist/chunks/bun-sqlite-dialect.mjs
var exports_bun_sqlite_dialect = {};
__export(exports_bun_sqlite_dialect, {
  BunSqliteQueryCompiler: () => BunSqliteQueryCompiler,
  BunSqliteIntrospector: () => BunSqliteIntrospector,
  BunSqliteDriver: () => BunSqliteDriver,
  BunSqliteDialect: () => BunSqliteDialect,
  BunSqliteAdapter: () => BunSqliteAdapter
});

class BunSqliteAdapter {
  get supportsCreateIfNotExists() {
    return true;
  }
  get supportsTransactionalDdl() {
    return false;
  }
  get supportsReturning() {
    return true;
  }
  async acquireMigrationLock() {}
  async releaseMigrationLock() {}
  get supportsOutput() {
    return true;
  }
}

class BunSqliteDriver {
  #config;
  #connectionMutex = new ConnectionMutex2;
  #db;
  #connection;
  constructor(config2) {
    this.#config = { ...config2 };
  }
  async init() {
    this.#db = this.#config.database;
    this.#connection = new BunSqliteConnection(this.#db);
    if (this.#config.onCreateConnection) {
      await this.#config.onCreateConnection(this.#connection);
    }
  }
  async acquireConnection() {
    await this.#connectionMutex.lock();
    return this.#connection;
  }
  async beginTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("begin"));
  }
  async commitTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("commit"));
  }
  async rollbackTransaction(connection) {
    await connection.executeQuery(CompiledQuery.raw("rollback"));
  }
  async releaseConnection() {
    this.#connectionMutex.unlock();
  }
  async destroy() {
    this.#db?.close();
  }
}

class BunSqliteConnection {
  #db;
  constructor(db) {
    this.#db = db;
  }
  executeQuery(compiledQuery) {
    const { sql: sql22, parameters } = compiledQuery;
    const stmt = this.#db.prepare(sql22);
    return Promise.resolve({
      rows: stmt.all(parameters)
    });
  }
  async* streamQuery() {
    throw new Error("Streaming query is not supported by SQLite driver.");
  }
}

class ConnectionMutex2 {
  #promise;
  #resolve;
  async lock() {
    while (this.#promise) {
      await this.#promise;
    }
    this.#promise = new Promise((resolve) => {
      this.#resolve = resolve;
    });
  }
  unlock() {
    const resolve = this.#resolve;
    this.#promise = undefined;
    this.#resolve = undefined;
    resolve?.();
  }
}

class BunSqliteIntrospector {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    return [];
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query = this.#db.selectFrom("sqlite_schema").where("type", "=", "table").where("name", "not like", "sqlite_%").select("name").$castTo();
    if (!options.withInternalKyselyTables) {
      query = query.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const tables = await query.execute();
    return Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  async#getTableMetadata(table) {
    const db = this.#db;
    const createSql = await db.selectFrom("sqlite_master").where("name", "=", table).select("sql").$castTo().execute();
    const autoIncrementCol = createSql[0]?.sql?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
    const columns = await db.selectFrom(sql2`pragma_table_info(${table})`.as("table_info")).select(["name", "type", "notnull", "dflt_value"]).execute();
    return {
      name: table,
      columns: columns.map((col) => ({
        name: col.name,
        dataType: col.type,
        isNullable: !col.notnull,
        isAutoIncrementing: col.name === autoIncrementCol,
        hasDefaultValue: col.dflt_value != null
      })),
      isView: true
    };
  }
}

class BunSqliteDialect {
  #config;
  constructor(config2) {
    this.#config = { ...config2 };
  }
  createDriver() {
    return new BunSqliteDriver(this.#config);
  }
  createQueryCompiler() {
    return new BunSqliteQueryCompiler;
  }
  createAdapter() {
    return new BunSqliteAdapter;
  }
  createIntrospector(db) {
    return new BunSqliteIntrospector(db);
  }
}
var BunSqliteQueryCompiler;
var init_bun_sqlite_dialect = __esm(() => {
  init_esm();
  BunSqliteQueryCompiler = class BunSqliteQueryCompiler extends DefaultQueryCompiler {
    getCurrentParameterPlaceholder() {
      return "?";
    }
    getLeftIdentifierWrapper() {
      return '"';
    }
    getRightIdentifierWrapper() {
      return '"';
    }
    getAutoIncrement() {
      return "autoincrement";
    }
  };
});

// ../../node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform2) {
    return new ArrayParser(source, transform2).parse();
  };

  class ArrayParser {
    constructor(source, transform2) {
      this.source = source;
      this.transform = transform2 || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char2 = this.nextCharacter();
          if (char2.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// ../../node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source, transform2) {
      return {
        parse: function() {
          return array.parse(source, transform2);
        }
      };
    }
  };
});

// ../../node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate2(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year2 = parseInt(matches[1], 10);
    if (isBC) {
      year2 = bcYearToNegativeYear(year2);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var hour2 = parseInt(matches[4], 10);
    var minute2 = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date2;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date2 = new Date(Date.UTC(year2, month, day2, hour2, minute2, second, ms));
      if (is0To99(year2)) {
        date2.setUTCFullYear(year2);
      }
      if (offset !== 0) {
        date2.setTime(date2.getTime() - offset);
      }
    } else {
      date2 = new Date(year2, month, day2, hour2, minute2, second, ms);
      if (is0To99(year2)) {
        date2.setFullYear(year2);
      }
    }
    return date2;
  };
  function getDate2(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year2 = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year2 = bcYearToNegativeYear(year2);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day2 = matches[3];
    var date2 = new Date(year2, month, day2);
    if (is0To99(year2)) {
      date2.setFullYear(year2);
    }
    return date2;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type = zone[1];
    if (type === "Z") {
      return 0;
    }
    var sign2 = type === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign2 * 1000;
  }
  function bcYearToNegativeYear(year2) {
    return -(year2 - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// ../../node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend2;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function extend2(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty2.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// ../../node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend2 = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend2(this, parse3(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse3(interval2) {
    if (!interval2)
      return {};
    var matches = INTERVAL.exec(interval2);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// ../../node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// ../../node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point2 = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point2 += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point2);
    result.radius = parseFloat(radius);
    return result;
  };
  var init2 = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init: init2
  };
});

// ../../node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign2 = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign2 = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign2 + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign2 + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign2 + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign2 + digits + result;
    }
  }
  module.exports = readInt8;
});

// ../../node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign2 = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign2 === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign2 === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign2 = parseBits(value, 16, 32);
    if (sign2 == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign2 === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign2 = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign2 === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray2 = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse3 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count2 = dimension.shift();
        for (i2 = 0;i2 < count2; i2++) {
          array[i2] = parse3(dimension, elementType2);
        }
        dimension.unshift(count2);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse3(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init2 = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray2);
    register(1007, parseArray2);
    register(1016, parseArray2);
    register(1008, parseArray2);
    register(1009, parseArray2);
    register(25, parseText);
  };
  module.exports = {
    init: init2
  };
});

// ../../node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// ../../node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// ../../node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// ../../node_modules/pg/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var defaults2 = require_defaults();
  var util6 = __require("util");
  var { isDate: isDate3 } = util6.types || util6;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate3(val)) {
        if (defaults2.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date2) {
    let offset = -date2.getTimezoneOffset();
    let year2 = date2.getFullYear();
    const isBCYear = year2 < 1;
    if (isBCYear)
      year2 = Math.abs(year2) + 1;
    let ret = String(year2).padStart(4, "0") + "-" + String(date2.getMonth() + 1).padStart(2, "0") + "-" + String(date2.getDate()).padStart(2, "0") + "T" + String(date2.getHours()).padStart(2, "0") + ":" + String(date2.getMinutes()).padStart(2, "0") + ":" + String(date2.getSeconds()).padStart(2, "0") + "." + String(date2.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date2) {
    let year2 = date2.getUTCFullYear();
    const isBCYear = year2 < 1;
    if (isBCYear)
      year2 = Math.abs(year2) + 1;
    let ret = String(year2).padStart(4, "0") + "-" + String(date2.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date2.getUTCDate()).padStart(2, "0") + "T" + String(date2.getUTCHours()).padStart(2, "0") + ":" + String(date2.getUTCMinutes()).padStart(2, "0") + ":" + String(date2.getUTCSeconds()).padStart(2, "0") + "." + String(date2.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config2, values, callback) {
    config2 = typeof config2 === "string" ? { text: config2 } : config2;
    if (values) {
      if (typeof values === "function") {
        config2.callback = values;
      } else {
        config2.values = values;
      }
    }
    if (callback) {
      config2.callback = callback;
    }
    return config2;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// ../../node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user2, password, salt) {
    const inner = md5(password + user2);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha2562(text2) {
    return nodeCrypto.createHash("sha256").update(text2).digest();
  }
  function hashByName(hashName, text2) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text2).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256: sha2562,
    hashByName,
    hmacSha256,
    md5
  };
});

// ../../node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256: sha2562,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto2 = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto2.subtle;
  var textEncoder2 = new TextEncoder;
  function randomBytes(length) {
    return webCrypto2.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder2.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user2, password, salt) {
    const inner = await md5(password + user2);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha2562(text2) {
    return await subtleCrypto.digest("SHA-256", text2);
  }
  async function hashByName(hashName, text2) {
    return await subtleCrypto.digest(hashName, text2);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder2.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder2.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// ../../node_modules/pg/lib/crypto/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// ../../node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// ../../node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto3 = require_utils2();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream4) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream4)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream4.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto3.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream4 ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session2, password, serverData, stream4) {
    if (session2.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session2.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session2.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session2.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream4 ? "eSws" : "biws";
    if (session2.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream4.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto3.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto3.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto3.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto3.sha256(clientKey);
    const clientSignature = await crypto3.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto3.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto3.hmacSha256(serverKey, authMessage);
    session2.message = "SASLResponse";
    session2.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session2.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session2, serverData) {
    if (session2.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session2.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text2.split("").map((_, i) => text2.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text2);
  }
  function parseAttributePairs(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text2.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// ../../node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types3 = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types3;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// ../../node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse3(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config3 = str.split(" ");
      return { host: config3[0], database: config3[1] };
    }
    const config2 = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err) {
      err.input && (err.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config2[entry[0]] = entry[1];
    }
    config2.user = config2.user || decodeURIComponent(result.username);
    config2.password = config2.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config2.host = decodeURI(result.pathname);
      config2.database = result.searchParams.get("db");
      config2.client_encoding = result.searchParams.get("encoding");
      return config2;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config2.host) {
      config2.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config2.port) {
      config2.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config2.database = pathname ? decodeURI(pathname) : null;
    if (config2.ssl === "true" || config2.ssl === "1") {
      config2.ssl = true;
    }
    if (config2.ssl === "0") {
      config2.ssl = false;
    }
    if (config2.sslcert || config2.sslkey || config2.sslrootcert || config2.sslmode) {
      config2.ssl = {};
    }
    const fs = config2.sslcert || config2.sslkey || config2.sslrootcert ? __require("fs") : null;
    if (config2.sslcert) {
      config2.ssl.cert = fs.readFileSync(config2.sslcert).toString();
    }
    if (config2.sslkey) {
      config2.ssl.key = fs.readFileSync(config2.sslkey).toString();
    }
    if (config2.sslrootcert) {
      config2.ssl.ca = fs.readFileSync(config2.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config2.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config2.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config2.sslrootcert) {
            config2.ssl.checkServerIdentity = function() {};
          } else {
            config2.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config2.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config2.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config2;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
      if (value !== undefined && value !== null) {
        c[key] = value;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config2) {
    const poolConfig = Object.entries(config2).reduce((c, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== undefined && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse3(str));
  }
  module.exports = parse3;
  parse3.parse = parse3;
  parse3.toClientConfig = toClientConfig;
  parse3.parseIntoClientConfig = parseIntoClientConfig;
});

// ../../node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults2 = require_defaults();
  var parse3 = require_pg_connection_string().parse;
  var val = function(key, config2, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config2[key] || envVar || defaults2[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults2.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config2, paramName) {
    const value = config2[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config2) {
      config2 = typeof config2 === "string" ? parse3(config2) : config2 || {};
      if (config2.connectionString) {
        config2 = Object.assign({}, config2, parse3(config2.connectionString));
      }
      this.user = val("user", config2);
      this.database = val("database", config2);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config2), 10);
      this.host = val("host", config2);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config2)
      });
      this.binary = val("binary", config2);
      this.options = val("options", config2);
      this.ssl = typeof config2.ssl === "undefined" ? readSSLConfigFromEnvironment() : config2.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config2);
      this.replication = val("replication", config2);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config2, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config2, false);
      this.statement_timeout = val("statement_timeout", config2, false);
      this.lock_timeout = val("lock_timeout", config2, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config2, false);
      this.query_timeout = val("query_timeout", config2, false);
      if (config2.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config2.connectionTimeoutMillis / 1000);
      }
      if (config2.keepAlive === false) {
        this.keepalives = 0;
      } else if (config2.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config2.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config2.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// ../../node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types3 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types4) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types4;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          row[field] = this._parsers[i](rawValue);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc2 = fieldDescriptions[i];
        row[desc2.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        } else {
          this._parsers[i] = types3.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// ../../node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter: EventEmitter2 } = __require("events");
  var Result = require_result();
  var utils = require_utils();

  class Query extends EventEmitter2 {
    constructor(config2, values, callback) {
      super();
      config2 = utils.normalizeQueryConfig(config2, values, callback);
      this.text = config2.text;
      this.values = config2.values;
      this.rows = config2.rows;
      this.types = config2.types;
      this.name = config2.name;
      this.queryMode = config2.queryMode;
      this.binary = config2.binary;
      this.portal = config2.portal || "";
      this.callback = config2.callback;
      this._rowMode = config2.rowMode;
      if (process.domain && config2.callback) {
        this.callback = process.domain.bind(config2.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err, connection) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// ../../node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message2, length, name) {
      super(message2);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary2, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary2;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text2) {
      this.length = length;
      this.text = text2;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message2) {
      this.length = length;
      this.message = message2;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// ../../node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      const len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// ../../node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text2) => {
    return writer.addCString(text2).flush(81);
  };
  var emptyArray = [];
  var parse3 = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types3 = query2.types || emptyArray;
    const len = types3.length;
    const buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer.addInt32(types3[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind2 = (config2 = {}) => {
    const portal = config2.portal || "";
    const statement = config2.statement || "";
    const binary2 = config2.binary || false;
    const values = config2.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config2.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(binary2 ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config2) => {
    if (!config2 || !config2.portal && !config2.rows) {
      return emptyExecute;
    }
    const portal = config2.portal || "";
    const rows = config2.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text2 = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text2);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message2) => {
    return cstringMessage(102, message2);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse3,
    bind: bind2,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// ../../node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// ../../node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message2 = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message2);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text2 = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text2);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message2 = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message2.columnTypes[i] = this.reader.int16();
      }
      return message2;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message2 = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message2.fields[i] = this.parseField();
      }
      return message2;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message2 = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message2.dataTypeIDs[i] = this.reader.int32();
      }
      return message2;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message2 = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message2.length === 8) {
            message2.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message2.length === 12) {
            message2.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message2.name = "authenticationSASL";
            message2.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message2.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message2.name = "authenticationSASLContinue";
          message2.data = this.reader.string(length - 8);
          break;
        case 12:
          message2.name = "authenticationSASLFinal";
          message2.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message2;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message2 = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message2.severity = fields.S;
      message2.code = fields.C;
      message2.detail = fields.D;
      message2.hint = fields.H;
      message2.position = fields.P;
      message2.internalPosition = fields.p;
      message2.internalQuery = fields.q;
      message2.where = fields.W;
      message2.schema = fields.s;
      message2.table = fields.t;
      message2.column = fields.c;
      message2.dataType = fields.d;
      message2.constraint = fields.n;
      message2.file = fields.F;
      message2.line = fields.L;
      message2.routine = fields.R;
      return message2;
    }
  }
  exports.Parser = Parser;
});

// ../../node_modules/pg-protocol/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse3(stream4, callback) {
    const parser = new parser_1.Parser;
    stream4.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream4.on("end", () => resolve()));
  }
  exports.parse = parse3;
});

// ../../node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {};
});

// ../../node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// ../../node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var { parse: parse3, serialize } = require_dist();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter2 {
    constructor(config2) {
      super();
      config2 = config2 || {};
      this.stream = config2.stream || getStream(config2.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config2);
      }
      this._keepAlive = config2.keepAlive;
      this._keepAliveInitialDelayMillis = config2.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config2.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error2) {
        if (self2._ending && (error2.code === "ECONNRESET" || error2.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error2);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream4) {
      parse3(stream4, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config2) {
      this.stream.write(serialize.startup(config2));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text2) {
      this._send(serialize.query(text2));
    }
    parse(query) {
      this._send(serialize.parse(query));
    }
    bind(config2) {
      this._send(serialize.bind(config2));
    }
    execute(config2) {
      this._send(serialize.execute(config2));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// ../../node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform2(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error2) {
        return cb(error2);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error2) {
        return cb(error2);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop3(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop3;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop3;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform2;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream4 = new Transform(options);
    stream4[kLast] = "";
    stream4[kDecoder] = new StringDecoder("utf8");
    stream4.matcher = matcher;
    stream4.mapper = mapper;
    stream4.maxLength = options.maxLength;
    stream4.skipOverflow = options.skipOverflow || false;
    stream4.overflow = false;
    stream4._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream4;
  }
  module.exports = split;
});

// ../../node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util6 = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util6.format.apply(util6, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream4) {
    var old = warnStream;
    warnStream = stream4;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env2 = rawEnv || process.env;
    var file = env2.PGPASSFILE || (isWin ? path.join(env2.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env2.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream4, cb) {
    var pass;
    var lineStream = stream4.pipe(split());
    function onLine(line2) {
      var entry = parseLine(line2);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream4.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream4.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream4.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line2) {
    if (line2.length < 11 || line2.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line2.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line2.length - 1; i += 1) {
      curChar = line2.charAt(i + 1);
      prevChar = line2.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// ../../node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// ../../node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var utils = require_utils();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults2 = require_defaults();
  var Connection = require_connection();
  var crypto3 = require_utils2();

  class Client extends EventEmitter2 {
    constructor(config2) {
      super();
      this.connectionParameters = new ConnectionParameters(config2);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config2 || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults2.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error2);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error2);
            } else {
              this._handleErrorEvent(error2);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error2);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error2) => {
          if (error2) {
            reject(error2);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto3.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config2, values, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config2 === null || config2 === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config2.submit === "function") {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        result = query = config2;
        if (typeof values === "function") {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config2, values, callback);
        if (!query.callback) {
          result = new this._Promise((resolve, reject) => {
            query.callback = (err, res) => err ? reject(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error2 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error2, this.connection);
          });
          queryCallback(error2);
          query.callback = () => {};
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// ../../node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client) {
      err ? rej(err) : res(client);
    };
    const result = new Promise2(function(resolve, reject) {
      res = resolve;
      rej = reject;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err) {
      err.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client);
      pool.emit("error", err, client);
    };
  }

  class Pool extends EventEmitter2 {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context = this;
      client.end(() => {
        context.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err = new Error("Connection terminated due to connection timeout", { cause: err });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err2, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err) => {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err);
      };
    }
    _release(client, idleListener, err) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err, client);
      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text2, values, cb) {
      if (typeof text2 === "function") {
        const response2 = promisify(this.Promise, text2);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err2);
          cb(err2);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text2, values, (err2, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// ../../node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var util6 = __require("util");
  var utils = require_utils();
  var NativeQuery = module.exports = function(config2, values, callback) {
    EventEmitter2.call(this);
    config2 = utils.normalizeQueryConfig(config2, values, callback);
    this.text = config2.text;
    this.values = config2.values;
    this.name = config2.name;
    this.queryMode = config2.queryMode;
    this.callback = config2.callback;
    this.state = "new";
    this._arrayMode = config2.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util6.inherits(NativeQuery, EventEmitter2);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject) {
      this._once("end", resolve);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err) {
        if (err)
          return after(err);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// ../../node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter2 = __require("events").EventEmitter;
  var util6 = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config2) {
    EventEmitter2.call(this);
    config2 = config2 || {};
    this._Promise = config2.Promise || global.Promise;
    this._types = new TypeOverrides(config2.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config2);
    if (config2.nativeConnectionString)
      cp.nativeConnectionString = config2.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util6.inherits(Client, EventEmitter2);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject) => {
      this._connect((error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config2, values, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config2 === null || config2 === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config2.submit === "function") {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      result = query = config2;
      if (typeof values === "function") {
        config2.callback = values;
      }
    } else {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config2, values, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject) => {
          resolveOut = resolve;
          rejectOut = reject;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error2 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error2, this.connection);
        });
        queryCallback(error2);
        query.callback = () => {};
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject) {
        cb = (err) => err ? reject(err) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self2 = this;
    query.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// ../../node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Client = require_client();
  var defaults2 = require_defaults();
  var Connection = require_connection();
  var Result = require_result();
  var utils = require_utils();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist();
  var { escapeIdentifier, escapeLiteral } = require_utils();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults2;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client2());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// ../../node_modules/domelementtype/lib/esm/index.js
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var ElementType, Root, Text, Directive, Comment, Script, Style, Tag, CDATA, Doctype;
var init_esm2 = __esm(() => {
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  Root = ElementType.Root;
  Text = ElementType.Text;
  Directive = ElementType.Directive;
  Comment = ElementType.Comment;
  Script = ElementType.Script;
  Style = ElementType.Style;
  Tag = ElementType.Tag;
  CDATA = ElementType.CDATA;
  Doctype = ElementType.Doctype;
});

// ../../node_modules/domhandler/lib/esm/node.js
class Node3 {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone2);
    if (node.namespace != null) {
      clone2.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new CDATA2(children);
    children.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Document(children);
    children.forEach((child) => child.parent = clone2);
    if (node["x-mode"]) {
      clone2["x-mode"] = node["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i = 1;i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}
var DataNode, Text2, Comment2, ProcessingInstruction, NodeWithChildren, CDATA2, Document, Element;
var init_node = __esm(() => {
  init_esm2();
  DataNode = class DataNode extends Node3 {
    constructor(data) {
      super();
      this.data = data;
    }
    get nodeValue() {
      return this.data;
    }
    set nodeValue(data) {
      this.data = data;
    }
  };
  Text2 = class Text2 extends DataNode {
    constructor() {
      super(...arguments);
      this.type = ElementType.Text;
    }
    get nodeType() {
      return 3;
    }
  };
  Comment2 = class Comment2 extends DataNode {
    constructor() {
      super(...arguments);
      this.type = ElementType.Comment;
    }
    get nodeType() {
      return 8;
    }
  };
  ProcessingInstruction = class ProcessingInstruction extends DataNode {
    constructor(name, data) {
      super(data);
      this.name = name;
      this.type = ElementType.Directive;
    }
    get nodeType() {
      return 1;
    }
  };
  NodeWithChildren = class NodeWithChildren extends Node3 {
    constructor(children) {
      super();
      this.children = children;
    }
    get firstChild() {
      var _a;
      return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
    }
    get lastChild() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    }
    get childNodes() {
      return this.children;
    }
    set childNodes(children) {
      this.children = children;
    }
  };
  CDATA2 = class CDATA2 extends NodeWithChildren {
    constructor() {
      super(...arguments);
      this.type = ElementType.CDATA;
    }
    get nodeType() {
      return 4;
    }
  };
  Document = class Document extends NodeWithChildren {
    constructor() {
      super(...arguments);
      this.type = ElementType.Root;
    }
    get nodeType() {
      return 9;
    }
  };
  Element = class Element extends NodeWithChildren {
    constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
      super(children);
      this.name = name;
      this.attribs = attribs;
      this.type = type;
    }
    get nodeType() {
      return 1;
    }
    get tagName() {
      return this.name;
    }
    set tagName(name) {
      this.name = name;
    }
    get attributes() {
      return Object.keys(this.attribs).map((name) => {
        var _a, _b;
        return {
          name,
          value: this.attribs[name],
          namespace: (_a = this["x-attribsNamespace"]) === null || _a === undefined ? undefined : _a[name],
          prefix: (_b = this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
        };
      });
    }
  };
});

// ../../node_modules/domhandler/lib/esm/index.js
class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error2) {
    this.handleCallback(error2);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node2 = new Text2(data);
      this.addNode(node2);
      this.lastNode = node2;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node2 = new Comment2(data);
    this.addNode(node2);
    this.lastNode = node2;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text2 = new Text2("");
    const node2 = new CDATA2([text2]);
    this.addNode(node2);
    text2.parent = node2;
    this.lastNode = text2;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node2 = new ProcessingInstruction(name, data);
    this.addNode(node2);
  }
  handleCallback(error2) {
    if (typeof this.callback === "function") {
      this.callback(error2, this.dom);
    } else if (error2) {
      throw error2;
    }
  }
  addNode(node2) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node2.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node2.endIndex = this.parser.endIndex;
    }
    parent.children.push(node2);
    if (previousSibling) {
      node2.prev = previousSibling;
      previousSibling.next = node2;
    }
    node2.parent = parent;
    this.lastNode = null;
  }
}
var defaultOpts;
var init_esm3 = __esm(() => {
  init_esm2();
  init_node();
  init_node();
  defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
});

// ../../node_modules/leac/lib/leac.mjs
function n(n2) {
  const o = [...n2.matchAll(e)].map((e2) => e2.index || 0);
  o.unshift(-1);
  const s = t(o, 0, o.length);
  return (e2) => r(s, e2);
}
function t(e2, n2, r) {
  if (r - n2 == 1)
    return { offset: e2[n2], index: n2 + 1 };
  const o = Math.ceil((n2 + r) / 2), s = t(e2, n2, o), l = t(e2, o, r);
  return { offset: s.offset, low: s, high: l };
}
function r(e2, n2) {
  return function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "index");
  }(e2) ? { line: e2.index, column: n2 - e2.offset } : r(e2.high.offset < n2 ? e2.high : e2.low, n2);
}
function o(e2, t2 = "", r2 = {}) {
  const o2 = typeof t2 != "string" ? t2 : r2, l = typeof t2 == "string" ? t2 : "", c = e2.map(s), f = !!o2.lineNumbers;
  return function(e3, t3 = 0) {
    const r3 = f ? n(e3) : () => ({ line: 0, column: 0 });
    let o3 = t3;
    const s = [];
    e:
      for (;o3 < e3.length; ) {
        let n2 = false;
        for (const t4 of c) {
          t4.regex.lastIndex = o3;
          const c2 = t4.regex.exec(e3);
          if (c2 && c2[0].length > 0) {
            if (!t4.discard) {
              const e4 = r3(o3), n3 = typeof t4.replace == "string" ? c2[0].replace(new RegExp(t4.regex.source, t4.regex.flags), t4.replace) : c2[0];
              s.push({ state: l, name: t4.name, text: n3, offset: o3, len: c2[0].length, line: e4.line, column: e4.column });
            }
            if (o3 = t4.regex.lastIndex, n2 = true, t4.push) {
              const n3 = t4.push(e3, o3);
              s.push(...n3.tokens), o3 = n3.offset;
            }
            if (t4.pop)
              break e;
            break;
          }
        }
        if (!n2)
          break;
      }
    return { tokens: s, offset: o3, complete: e3.length <= o3 };
  };
}
function s(e2, n2) {
  return { ...e2, regex: l(e2, n2) };
}
function l(e2, n2) {
  if (e2.name.length === 0)
    throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "regex");
  }(e2))
    return function(e3) {
      if (e3.global)
        throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
      return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
    }(e2.regex);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "str");
  }(e2)) {
    if (e2.str.length === 0)
      throw new Error(`Rule #${n2} ("${e2.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e2.str), "y");
  }
  return new RegExp(c(e2.name), "y");
}
function c(e2) {
  return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}
var e;
var init_leac = __esm(() => {
  e = /\n/g;
});

// ../../node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i) => {
    let position = i;
    let value = undefined;
    if (i < data.tokens.length) {
      value = onToken(data.tokens[i], data, i);
      if (value !== undefined) {
        position++;
      }
    } else {
      onEnd?.(data, i);
    }
    return value === undefined ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
}
function mapOuter(r2, f) {
  return r2.matched ? f(r2) : r2;
}
function map2(p, mapper) {
  return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
}
function option(p, def) {
  return (data, i) => {
    const r2 = p(data, i);
    return r2.matched ? r2 : {
      matched: true,
      position: i,
      value: def
    };
  };
}
function choice(...ps) {
  return (data, i) => {
    for (const p of ps) {
      const result = p(data, i);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa, pb) {
  return (data, i) => {
    const r1 = pa(data, i);
    return r1.matched ? r1 : pb(data, i);
  };
}
function takeWhile(p, test2) {
  return (data, i) => {
    const values = [];
    let success = true;
    do {
      const r2 = p(data, i);
      if (r2.matched && test2(r2.value, values.length + 1, data, i, r2.position)) {
        values.push(r2.value);
        i = r2.position;
      } else {
        success = false;
      }
    } while (success);
    return {
      matched: true,
      position: i,
      value: values
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa, pb, join) {
  return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join(ma.value, vb, data, i, j)));
}
function left(pa, pb) {
  return ab(pa, pb, (va) => va);
}
function right(pa, pb) {
  return ab(pa, pb, (va, vb) => vb);
}
function abc(pa, pb, pc, join) {
  return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join(ma.value, mb.value, vc, data, i, j))));
}
function middle(pa, pb, pc) {
  return abc(pa, pb, pc, (ra, rb) => rb);
}
function all2(...ps) {
  return (data, i) => {
    const result = [];
    let position = i;
    for (const p of ps) {
      const r1 = p(data, position);
      if (r1.matched) {
        result.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten(...ps) {
  return flatten1(all2(...ps));
}
function flatten1(p) {
  return map2(p, (vs) => vs.flatMap((v) => v));
}
function chainReduce(acc, f) {
  return (data, i) => {
    let loop = true;
    let acc1 = acc;
    let pos = i;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map2(p, (v, data, i, j) => reducer(acc2, v, data, i, j)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
}
function chain(p, f) {
  return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}
var init_core = () => {};

// ../../node_modules/parseley/lib/parseley.mjs
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
  return [a0 + b0, a1 + b1, a2 + b2];
}
function sumAllSpec(ss) {
  return ss.reduce(sumSpec, [0, 0, 0]);
}
function unescape2(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
  return result.value;
}
function literal(name2) {
  return token((t2) => t2.name === name2 ? true : undefined);
}
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
function parse_(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!
` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t2, r2) => t2 ? "\u2409" : r2 ? "\u240D" : "\u240A")}
${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize2(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize2(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node2) => {
        if (node2.type === "combinator") {
          return serialize2(node2) + acc;
        } else {
          return acc + serialize2(node2);
        }
      }, "");
    case "list":
      return selector.list.map(serialize2).join(",");
  }
}
function _serNs(ns) {
  return ns || ns === "" ? _serIdent(ns) + "|" : "";
}
function _codePoint(char2) {
  return `\\${char2.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl2, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl2 ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
}
function _serStr(str) {
  return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs, nl2, ctrl) => dq ? "\\\"" : bs ? "\\\\" : nl2 ? "\uFFFD" : _codePoint(ctrl));
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b) => serialize2(a) < serialize2(b) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize2(selector)];
    case "attrValue":
      return [5, serialize2(selector)];
    case "combinator":
      return [15, serialize2(selector)];
  }
}
function compareSpecificity(a, b) {
  return _compareArrays(a, b);
}
function _compareArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b.length ? a.length : b.length;
  for (let i = 0;i < shorter; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return a.length - b.length;
}
var ws = `(?:[ \\t\\r\\n\\f]*)`, nl = `(?:\\n|\\r\\n|\\r|\\f)`, nonascii = `[^\\x00-\\x7F]`, unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`, escape2 = `(?:\\\\[^\\n\\r\\f0-9a-f])`, nmstart, nmchar, name, ident, string1, string2, lexSelector, lexEscapedString, unicodeEscapedSequence_, escapedSequence_, anyChar_, escapedString_, whitespace_, optionalWhitespace_, identifier_, hashId_, string_, namespace_, qualifiedName_, uniSelector_, tagSelector_, classSelector_, idSelector_, attrModifier_, attrValue_, attrMatcher_, attrPresenceSelector_, attrValueSelector_, attrSelector_, typeSelector_, subclassSelector_, compoundSelector_, combinator_, combinatorSeparator_, complexSelector_, listSelector_;
var init_parseley = __esm(() => {
  init_leac();
  init_core();
  nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape2})`;
  nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape2})`;
  name = `(?:${nmchar}+)`;
  ident = `(?:[-]?${nmstart}${nmchar}*)`;
  string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape2})*'`;
  string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape2})*"`;
  lexSelector = o([
    { name: "ws", regex: new RegExp(ws) },
    { name: "hash", regex: new RegExp(`#${name}`, "i") },
    { name: "ident", regex: new RegExp(ident, "i") },
    { name: "str1", regex: new RegExp(string1, "i") },
    { name: "str2", regex: new RegExp(string2, "i") },
    { name: "*" },
    { name: "." },
    { name: "," },
    { name: "[" },
    { name: "]" },
    { name: "=" },
    { name: ">" },
    { name: "|" },
    { name: "+" },
    { name: "~" },
    { name: "^" },
    { name: "$" }
  ]);
  lexEscapedString = o([
    { name: "unicode", regex: new RegExp(unicode, "i") },
    { name: "escape", regex: new RegExp(escape2, "i") },
    { name: "any", regex: new RegExp("[\\s\\S]", "i") }
  ]);
  unicodeEscapedSequence_ = token((t2) => t2.name === "unicode" ? String.fromCodePoint(parseInt(t2.text.slice(1), 16)) : undefined);
  escapedSequence_ = token((t2) => t2.name === "escape" ? t2.text.slice(1) : undefined);
  anyChar_ = token((t2) => t2.name === "any" ? t2.text : undefined);
  escapedString_ = map2(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(""));
  whitespace_ = token((t2) => t2.name === "ws" ? null : undefined);
  optionalWhitespace_ = option(whitespace_, null);
  identifier_ = token((t2) => t2.name === "ident" ? unescape2(t2.text) : undefined);
  hashId_ = token((t2) => t2.name === "hash" ? unescape2(t2.text.slice(1)) : undefined);
  string_ = token((t2) => t2.name.startsWith("str") ? unescape2(t2.text.slice(1, -1)) : undefined);
  namespace_ = left(option(identifier_, ""), literal("|"));
  qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name2) => ({ name: name2, namespace: ns })), map2(identifier_, (name2) => ({ name: name2, namespace: null })));
  uniSelector_ = otherwise(ab(namespace_, literal("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), map2(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
  tagSelector_ = map2(qualifiedName_, ({ name: name2, namespace }) => ({
    type: "tag",
    name: name2,
    namespace,
    specificity: [0, 0, 1]
  }));
  classSelector_ = ab(literal("."), identifier_, (fullstop, name2) => ({
    type: "class",
    name: name2,
    specificity: [0, 1, 0]
  }));
  idSelector_ = map2(hashId_, (name2) => ({
    type: "id",
    name: name2,
    specificity: [1, 0, 0]
  }));
  attrModifier_ = token((t2) => {
    if (t2.name === "ident") {
      if (t2.text === "i" || t2.text === "I") {
        return "i";
      }
      if (t2.text === "s" || t2.text === "S") {
        return "s";
      }
    }
    return;
  });
  attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
  attrMatcher_ = choice(map2(literal("="), () => "="), ab(literal("~"), literal("="), () => "~="), ab(literal("|"), literal("="), () => "|="), ab(literal("^"), literal("="), () => "^="), ab(literal("$"), literal("="), () => "$="), ab(literal("*"), literal("="), () => "*="));
  attrPresenceSelector_ = abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name2, namespace }) => ({
    type: "attrPresence",
    name: name2,
    namespace,
    specificity: [0, 1, 0]
  }));
  attrValueSelector_ = middle(literal("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
    type: "attrValue",
    name: name2,
    namespace,
    matcher,
    value,
    modifier,
    specificity: [0, 1, 0]
  })), literal("]"));
  attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
  typeSelector_ = otherwise(uniSelector_, tagSelector_);
  subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
  compoundSelector_ = map2(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
    return {
      type: "compound",
      list: ss,
      specificity: sumAllSpec(ss.map((s2) => s2.specificity))
    };
  });
  combinator_ = choice(map2(literal(">"), () => ">"), map2(literal("+"), () => "+"), map2(literal("~"), () => "~"), ab(literal("|"), literal("|"), () => "||"));
  combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map2(whitespace_, () => " "));
  complexSelector_ = leftAssoc2(compoundSelector_, map2(combinatorSeparator_, (c2) => (left2, right2) => ({
    type: "compound",
    list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
    specificity: sumSpec(left2.specificity, right2.specificity)
  })), compoundSelector_);
  listSelector_ = leftAssoc2(map2(complexSelector_, (s2) => ({ type: "list", list: [s2] })), map2(optionallySpaced(literal(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
});

// ../../node_modules/selderee/lib/selderee.mjs
class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0;i < len; i++) {
    const [selectorString, val] = array[i];
    const ast = preprocess(parse1(selectorString));
    results[i] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node2) => node2.type === "terminal");
      matches.forEach((node2) => results.push(node2));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch2 = simpsels.some((node2) => getSelectorKind(node2) === selectedKind);
      (isMatch2 ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name2, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => serialize2(x.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length;i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node2 of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node2)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x of src) {
    if (predicate(x)) {
      matches.push(x);
    } else {
      rest.push(x);
    }
  }
  return { matches, rest };
}

class Picker {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1;i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
}
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}
var init_selderee = __esm(() => {
  init_parseley();
  init_parseley();
});

// ../../node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
}
function handleNode(node2) {
  switch (node2.type) {
    case "terminal": {
      const result = [node2.valueContainer];
      return (el, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node2);
    case "attrValue":
      return handleAttrValueName(node2);
    case "attrPresence":
      return handleAttrPresenceName(node2);
    case "pushElement":
      return handlePushElementNode(node2);
    case "popElement":
      return handlePopElementNode(node2);
  }
}
function handleTagName(node2) {
  const variants = {};
  for (const variant of node2.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node2) {
  const attrName = node2.name;
  const continuation = handleArray(node2.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node2) {
  const callbacks = [];
  for (const matcher of node2.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node2.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node2) {
  const continuation = handleArray(node2.cont);
  const leftElementGetter = node2.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
}
function handlePopElementNode(node2) {
  const continuation = handleArray(node2.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
}
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
}, getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag2(parent) ? parent : null;
};
var init_hp2_builder = __esm(() => {
  init_esm3();
  init_selderee();
});

// ../../node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default;
var init_decode_data_html = __esm(() => {
  decode_data_html_default = new Uint16Array("\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\x00\x00\x00\x00\x00\x00\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\x00\x00\x00\u0342\u0354\x00\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\x00\x00\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\x00\x00\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\x00\u0446\x00\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\x00\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\x00\x00\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\x00\x00\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\x00\u05BF\x00\x00\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\x00\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\x00\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\x00\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\x00\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\x00\u08C3bleBracket;\u67E6n\u01D4\u08C8\x00\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B\"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\x00\u1005bleBracket;\u67E7n\u01D4\u100A\x00\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\x00\x00\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\x00\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\x00\u132C\u1331\x00\x00\x00\x00\x00\u1338\u133D\u1377\u1385\x00\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\x00\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\x00\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\x00\u15B0\u15B6\u15BF\x00\x00\x00\x00\u15C6\u15DB\u15EB\u165F\u166D\x00\u1695\u169B\u16B2\u16B9\x00\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\x00\x00\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\x00\x00\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\x00\u1833\u01B2\u182F\x00\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\x00\u19E8\u1A11\u1A15\u1A32\x00\u1A37\u1A50\x00\x00\u1AB4\x00\x00\u1AC1\x00\x00\u1B21\u1B2E\u1B4D\u1B52\x00\u1BFD\x00\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\x00\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\x00\x00\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\x00\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\x00\x00\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\x00\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\x00\x00\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\x00\x00\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\x00\x00\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\x00\x00\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\x00\x00\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\x00\u1F9E\x00\u1FA1\u1FA7\x00\x00\u1FC6\u1FCC\x00\u1FD3\x00\u1FE6\u1FEA\u2000\x00\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\x00\x00\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\x00\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\x00\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\x00\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\x00\u2036;\u6154;\u6156\u02B4\u203E\u2041\x00\x00\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\x00\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\x00\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\x00\u22AA\x00\u22B8\u22C5\u22CE\x00\u22D5\u22F3\x00\x00\u22F8\u2322\u2367\u2362\u237F\x00\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\x00\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\x00\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\x00\u24AA\x00\u24B1\x00\x00\x00\x00\x00\u24B5\u24BA\x00\u24C6\u24C8\u24CD\x00\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\x00\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\x00\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\x00\x00\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\u2D2D\x00\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\x00\x00\u2D8D\u2DAB\x00\u2DC8\u2DCE\x00\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\x00\x00\u2D7C\x00\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\x00\u2E7D\x00\u2E80\u2E9D\x00\u2EA2\u2EB9\x00\x00\u2ECB\u0E9C\x00\u2F13\x00\x00\u2F2B\u2FBC\x00\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\x00\x00\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\x00\u337A\u33A4\x00\x00\u33EC\u33F0\x00\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\x00\u3616\x00\x00\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\x00\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\x00\x00\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\x00\u367E\u36C2\x00\x00\x00\x00\x00\u36DB\u3703\x00\u3709\u376C\x00\x00\x00\u3787\u0272\u3656\x00\x00\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\x00\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\x00\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\x00\x00\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\x00\x00\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\x00\u3A8B\x00\u3A90\u3A9B\x00\x00\u3A9D\u3AA8\u3AAB\u3AAF\x00\x00\u3AC3\u3ACE\x00\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C".split("").map((c2) => c2.charCodeAt(0)));
});

// ../../node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default;
var init_decode_data_xml = __esm(() => {
  decode_data_xml_default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\x00\x00\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0)));
});

// ../../node_modules/entities/lib/esm/decode_codepoint.js
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
}
var _a, decodeMap, fromCodePoint;
var init_decode_codepoint = __esm(() => {
  decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
});

// ../../node_modules/entities/lib/esm/decode.js
function isNumber3(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber3(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber3(char2) || isHexadecimalCharacter(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char2, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber3(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char2, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === undefined || _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char2 = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char2);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char2)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char2 === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === undefined || _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === undefined || _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder2 = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder2.startEntity(decodeMode);
      const len = decoder2.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder2.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char2) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char2 === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char2 - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char2) {
      lo = mid + 1;
    } else if (midVal > char2) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var CharCodes, TO_LOWER_BIT = 32, BinTrieFlags, EntityDecoderState, DecodingMode, htmlDecoder, xmlDecoder;
var init_decode = __esm(() => {
  init_decode_data_html();
  init_decode_data_xml();
  init_decode_codepoint();
  init_decode_codepoint();
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  htmlDecoder = getDecoder(decode_data_html_default);
  xmlDecoder = getDecoder(decode_data_xml_default);
});

// ../../node_modules/htmlparser2/lib/esm/Tokenizer.js
function isWhitespace(c2) {
  return c2 === CharCodes2.Space || c2 === CharCodes2.NewLine || c2 === CharCodes2.Tab || c2 === CharCodes2.FormFeed || c2 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes2.Slash || c2 === CharCodes2.Gt || isWhitespace(c2);
}
function isNumber4(c2) {
  return c2 >= CharCodes2.Zero && c2 <= CharCodes2.Nine;
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerZ || c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperF || c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerF;
}

class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch2 = isEnd ? isEndOfTagSection(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch2) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) {} else if (c2 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes2.Slash || c2 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c2 === CharCodes2.Amp) {} else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber4(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber4(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {} else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
}
var CharCodes2, State, QuoteType, Sequences;
var init_Tokenizer = __esm(() => {
  init_decode();
  (function(CharCodes3) {
    CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
    CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
    CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
    CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes3[CharCodes3["Space"] = 32] = "Space";
    CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes3[CharCodes3["Number"] = 35] = "Number";
    CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
    CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
    CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
    CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
    CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
    CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
    CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
    CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
    CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
    CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
    CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
    CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
    CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
    CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
    CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
    CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
    CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
    CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
    CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes2 || (CharCodes2 = {}));
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  };
});

// ../../node_modules/htmlparser2/lib/esm/Parser.js
class Parser {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== undefined ? _a2 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a2, _b;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === undefined || _b.call(_a2, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp) {
    var _a2, _b;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === undefined || _b.call(_a2, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === undefined || _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count3 = this.stack.length - pos;
          while (count3--) {
            this.cbs.onclosetag(this.stack.pop(), count3 !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a2 = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a2, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a2, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === undefined || _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name2 = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === undefined || _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length;index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === undefined || _b.call(_a2);
  }
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === undefined || _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === undefined || _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === undefined || _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}
var formTags, pTag, tableSectionTags, ddtTags, rtpTags, openImpliesClose, voidElements, foreignContextElements, htmlIntegrationElements, reNameEnd;
var init_Parser = __esm(() => {
  init_Tokenizer();
  init_decode();
  formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  pTag = new Set(["p"]);
  tableSectionTags = new Set(["thead", "tbody"]);
  ddtTags = new Set(["dd", "dt"]);
  rtpTags = new Set(["rt", "rp"]);
  openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags]
  ]);
  voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  foreignContextElements = new Set(["math", "svg"]);
  htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]);
  reNameEnd = /\s|\//;
});

// ../../node_modules/entities/lib/esm/escape.js
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i = match.index;
    const char2 = str.charCodeAt(i);
    const next = xmlCodeMap.get(char2);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char2 & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map3) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map3.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var xmlReplacer, xmlCodeMap, getCodePoint, escapeUTF8, escapeAttribute, escapeText;
var init_escape = __esm(() => {
  xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c2, index) => (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index);
  escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
});

// ../../node_modules/entities/lib/esm/index.js
var EntityLevel, EncodingMode;
var init_esm4 = __esm(() => {
  init_escape();
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel || (EntityLevel = {}));
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode || (EncodingMode = {}));
});

// ../../node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames, attributeNames;
var init_foreignNames = __esm(() => {
  elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((val) => [val.toLowerCase(), val]));
  attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((val) => [val.toLowerCase(), val]));
});

// ../../node_modules/dom-serializer/lib/esm/index.js
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a2;
  if (!attributes)
    return;
  const encode5 = ((_a2 = opts.encodeEntities) !== null && _a2 !== undefined ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes[key]) !== null && _a3 !== undefined ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode5(value)}"`;
  }).join(" ");
}
function render(node2, options = {}) {
  const nodes = "length" in node2 ? node2 : [node2];
  let output = "";
  for (let i = 0;i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
function renderNode(node2, options) {
  switch (node2.type) {
    case Root:
      return render(node2.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node2);
    case Comment:
      return renderComment(node2);
    case CDATA:
      return renderCdata(node2);
    case Script:
    case Style:
    case Tag:
      return renderTag(node2, options);
    case Text:
      return renderText(node2, options);
  }
}
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== undefined ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag2 = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag2 += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag2 += " ";
    tag2 += "/>";
  } else {
    tag2 += ">";
    if (elem.children.length > 0) {
      tag2 += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag2 += `</${elem.name}>`;
    }
  }
  return tag2;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== undefined ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
var unencodedElements, singleTag, foreignModeIntegrationPoints, foreignElements;
var init_esm5 = __esm(() => {
  init_esm2();
  init_esm4();
  init_foreignNames();
  unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  foreignElements = new Set(["svg", "math"]);
});

// ../../node_modules/domutils/lib/esm/stringify.js
var init_stringify = () => {};

// ../../node_modules/domutils/lib/esm/traversal.js
var init_traversal = () => {};

// ../../node_modules/domutils/lib/esm/querying.js
var init_querying = () => {};

// ../../node_modules/domutils/lib/esm/legacy.js
var init_legacy = () => {};

// ../../node_modules/domutils/lib/esm/helpers.js
var DocumentPosition;
var init_helpers = __esm(() => {
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));
});

// ../../node_modules/domutils/lib/esm/feeds.js
var init_feeds = () => {};

// ../../node_modules/domutils/lib/esm/index.js
var init_esm6 = __esm(() => {
  init_stringify();
  init_traversal();
  init_querying();
  init_legacy();
  init_helpers();
  init_feeds();
});

// ../../node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser(handler, options).end(data);
  return handler.root;
}
var init_esm7 = __esm(() => {
  init_Parser();
  init_esm3();
  init_esm2();
  init_esm6();
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// ../../node_modules/html-to-text/lib/html-to-text.mjs
function limitedDepthRecursive(n2, f, g = () => {
  return;
}) {
  if (n2 === undefined) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g), ...args);
    };
  }
  return g;
}
function trimCharacter(str, char2) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char2) {
    ++start;
  }
  while (end > start && str[end - 1] === char2) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char2) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char2) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map3 = new Map;
  for (let i = items.length;i-- > 0; ) {
    const item = items[i];
    const key = getKey(item);
    map3.set(key, map3.has(key) ? import_deepmerge.default(item, map3.get(key), { arrayMerge: overwriteMerge$1 }) : item);
  }
  return [...map3.values()].reverse();
}
function get(obj, path2) {
  for (const key of path2) {
    if (!obj) {
      return;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? "" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join("");
}

class InlineTextBuilder {
  constructor(options, maxLineLength = undefined) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join(`
`);
  }
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}

class StackItem {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}

class WhitespaceProcessor {
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform2 = (str) => str, noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (m[0] === `
`) {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform2(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text2)) !== null) {
            if (m[0] === `
`) {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform2 = (str) => str, noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform2(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text2)) !== null) {
            inlineTextBuilder.pushWord(transform2(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    }
  }
  addLiteral(text2, inlineTextBuilder, noWrap = true) {
    if (!text2) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text2);
    if (m) {
      anyMatch = true;
      if (m[0] === `
`) {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text2)) !== null) {
        if (m[0] === `
`) {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  testLeadingWhitespace(text2) {
    return this.leadingWhitespaceRe.test(text2);
  }
  testTrailingWhitespace(text2) {
    return this.trailingWhitespaceRe.test(text2);
  }
  testContainsWords(text2) {
    return !this.allWhitespaceOrEmptyRe.test(text2);
  }
  countNewlinesNoWords(text2) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text2)) !== null) {
      if (match[0] === `
`) {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}

class BlockTextBuilder {
  constructor(options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = undefined;
  }
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  popWordTransform() {
    if (!this._wordTransformer) {
      return;
    }
    const transform2 = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform2;
  }
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  _getCombinedWordTransformer() {
    const wt = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
    const ce = this.options.encodeCharacters;
    return wt ? ce ? (str) => ce(wt(str)) : wt : ce;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += `
`;
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  openListItem({ prefix = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = `
` + " ".repeat(prefixLength);
    const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text2 = prefix + getText(listItem).replace(/\n/g, spacing);
    addText(list, text2, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
  }
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text2 = getText(list);
    if (text2) {
      addText(this._stackItem, text2, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  openTableCell({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text2 = trimCharacter(getText(cell), `
`);
    cell.next.cells.push({ colspan, rowspan, text: text2 });
  }
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text2, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + `
`.repeat(lineBreaks) + text2;
  } else {
    stackItem.rawText = text2;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", "));
  }
  const picker = new DecisionTree(options.selectors.map((s2) => [s2.selector, s2])).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s2, i) => [s2, i + 1])).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
    builder.addInline(options.limits.ellipsis || "");
  });
  return function(html2, metadata = undefined) {
    return process2(html2, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html2, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html2 && html2.length > maxInputLength) {
    console.warn(`Input length ${html2.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
    html2 = html2.substring(0, maxInputLength);
  }
  const document2 = parseDocument(html2, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b) => a.selectorIndex - b.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return;
  }
  const entries = Object.entries(dict).filter(([, v]) => v !== false);
  const regex = new RegExp(entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"), "g");
  const values = entries.map(([, v]) => v);
  const replacer = (m, ...cgs) => values[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k, v]) => v === "" ? k : `${k}=${v.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
function getRow(matrix, j) {
  if (!matrix[j]) {
    matrix[j] = [];
  }
  return matrix[j];
}
function findFirstVacantIndex(row, x = 0) {
  while (row[x]) {
    x++;
  }
  return x;
}
function transposeInPlace(matrix, maxSize) {
  for (let i = 0;i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0;j < i; j++) {
      const rowJ = getRow(matrix, j);
      if (rowI[j] || rowJ[i]) {
        const temp = rowI[j];
        rowI[j] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r2 = 0;r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout, baseRow + r2);
    for (let c2 = 0;c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index) {
  if (offsets[index] === undefined) {
    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j = 0;j < rowNumber; j++) {
    const layoutRow = getRow(layout, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0;i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split(`
`);
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x = 0;x < colNumber; x++) {
    let y = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y < rowsInThisColumn) {
      cell = layout[x][y];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j = 0;j < cell.lines.length; j++) {
            const line2 = cell.lines[j];
            const lineOffset = rowOffsets[y] + j;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line2;
            cellWidth = line2.length > cellWidth ? line2.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y++;
      }
    }
  }
  return outputLines.join(`
`);
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, `
`) : str).split(`
`).map((line2) => "> " + line2).join(`
`)
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path2, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path2, metadata, elem) : path2;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text2 = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text2, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text2 = "";
    builder.pushWordTransform((str) => {
      if (str) {
        text2 += str;
      }
      return str;
    });
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text2;
    if (!hideSameLink) {
      builder.addInline(!text2 ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix.length > maxPrefixLength) {
      maxPrefixLength = prefix.length;
    }
    return { node: child, prefix };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node: node2, prefix } of listItems) {
    builder.openListItem({ prefix });
    walk([node2], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i) => numberToLetterSequence(i, "a");
    case "A":
      return (i) => numberToLetterSequence(i, "A");
    case "i":
      return (i) => numberToRoman(i).toLowerCase();
    case "I":
      return (i) => numberToRoman(i);
    case "1":
    default:
      return (i) => i.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
function compile(options = {}) {
  options = import_deepmerge.default(DEFAULT_OPTIONS, options, {
    arrayMerge: overwriteMerge,
    customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
  });
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert(html2, options = {}, metadata = undefined) {
  return compile(options)(html2, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  }
  function set(obj, path2, value) {
    const valueKey = path2.pop();
    for (const key of path2) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
  }
  if (options["returnDomByDefault"] !== undefined) {
    set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set(definition, ["options", "linkBrackets"], false);
    }
  }
}
var import_deepmerge, overwriteMerge$1 = (acc, src, options) => [...src], I, V, BlockStackItem, ListStackItem, ListItemStackItem, TableStackItem, TableRowStackItem, TableCellStackItem, TransformerStackItem, genericFormatters, textFormatters, DEFAULT_OPTIONS, concatMerge = (acc, src, options) => [...acc, ...src], overwriteMerge = (acc, src, options) => [...src], selectorsMerge = (acc, src, options) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
var init_html_to_text = __esm(() => {
  init_hp2_builder();
  init_esm7();
  init_selderee();
  import_deepmerge = __toESM(require_cjs(), 1);
  init_esm5();
  I = ["I", "X", "C", "M"];
  V = ["V", "L", "D"];
  BlockStackItem = class BlockStackItem extends StackItem {
    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
      super(next);
      this.leadingLineBreaks = leadingLineBreaks;
      this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  ListStackItem = class ListStackItem extends BlockStackItem {
    constructor(options, next = null, {
      interRowLineBreaks = 1,
      leadingLineBreaks = 2,
      maxLineLength = undefined,
      maxPrefixLength = 0,
      prefixAlign = "left"
    } = {}) {
      super(options, next, leadingLineBreaks, maxLineLength);
      this.maxPrefixLength = maxPrefixLength;
      this.prefixAlign = prefixAlign;
      this.interRowLineBreaks = interRowLineBreaks;
    }
  };
  ListItemStackItem = class ListItemStackItem extends BlockStackItem {
    constructor(options, next = null, {
      leadingLineBreaks = 1,
      maxLineLength = undefined,
      prefix = ""
    } = {}) {
      super(options, next, leadingLineBreaks, maxLineLength);
      this.prefix = prefix;
    }
  };
  TableStackItem = class TableStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.rows = [];
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  TableRowStackItem = class TableRowStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.cells = [];
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  TableCellStackItem = class TableCellStackItem extends StackItem {
    constructor(options, next = null, maxColumnWidth = undefined) {
      super(next);
      this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  TransformerStackItem = class TransformerStackItem extends StackItem {
    constructor(next = null, transform2) {
      super(next);
      this.transform = transform2;
    }
  };
  genericFormatters = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block: formatBlock$1,
    blockHtml: formatBlockHtml,
    blockString: formatBlockString,
    blockTag: formatBlockTag,
    inline: formatInline,
    inlineHtml: formatInlineHtml,
    inlineString: formatInlineString,
    inlineSurround: formatInlineSurround,
    inlineTag: formatInlineTag,
    skip: formatSkip
  });
  textFormatters = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    anchor: formatAnchor,
    blockquote: formatBlockquote,
    dataTable: formatDataTable,
    heading: formatHeading,
    horizontalLine: formatHorizontalLine,
    image: formatImage,
    lineBreak: formatLineBreak,
    orderedList: formatOrderedList,
    paragraph: formatParagraph,
    pre: formatPre,
    table: formatTable,
    unorderedList: formatUnorderedList,
    wbr: formatWbr
  });
  DEFAULT_OPTIONS = {
    baseElements: {
      selectors: ["body"],
      orderBy: "selectors",
      returnDomByDefault: true
    },
    decodeEntities: true,
    encodeCharacters: {},
    formatters: {},
    limits: {
      ellipsis: "...",
      maxBaseElements: undefined,
      maxChildNodes: undefined,
      maxDepth: undefined,
      maxInputLength: 1 << 24
    },
    longWordSplit: {
      forceWrapOnLimit: false,
      wrapCharacters: []
    },
    preserveNewlines: false,
    selectors: [
      { selector: "*", format: "inline" },
      {
        selector: "a",
        format: "anchor",
        options: {
          baseUrl: null,
          hideLinkHrefIfSameAsText: false,
          ignoreHref: false,
          linkBrackets: ["[", "]"],
          noAnchorUrl: true
        }
      },
      { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "blockquote",
        format: "blockquote",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
      },
      { selector: "br", format: "lineBreak" },
      { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "hr",
        format: "horizontalLine",
        options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
      },
      {
        selector: "img",
        format: "image",
        options: { baseUrl: null, linkBrackets: ["[", "]"] }
      },
      { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "ol",
        format: "orderedList",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "table",
        format: "table",
        options: {
          colSpacing: 3,
          leadingLineBreaks: 2,
          maxColumnWidth: 60,
          rowSpacing: 0,
          trailingLineBreaks: 2,
          uppercaseHeaderCells: true
        }
      },
      {
        selector: "ul",
        format: "unorderedList",
        options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "wbr", format: "wbr" }
    ],
    tables: [],
    whitespaceCharacters: ` 	\r
\f\u200B`,
    wordwrap: 80
  };
});

// ../../node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  (function() {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function() {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e2) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name2 = getComponentNameFromType(type);
        return name2 ? "<" + name2 + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config2) {
      if (hasOwnProperty2.call(config2, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config2.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
      self2 = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (self2 !== undefined ? self2 : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, undefined, undefined, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape4(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return typeof element === "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape4("" + element.key)) : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (typeof thenable.status === "string" ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
            thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function(error2) {
            thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error2);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean")
        children = null;
      var invokeCallback = false;
      if (children === null)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = nameSoFar === "" ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", childKey != null && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
          return c2;
        })) : callback != null && (isValidElement(callback) && (callback.key != null && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), nameSoFar !== "" && invokeCallback != null && isValidElement(invokeCallback) && invokeCallback.key == null && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = nameSoFar === "" ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0;i < children.length; i++)
          nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (i = getIteratorFn(children), typeof i === "function")
        for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true), children = i.call(children), i = 0;!(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (type === "object") {
        if (typeof children.then === "function")
          return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (children == null)
        return children;
      var result = [], count3 = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count3++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(function(moduleObject) {
          if (payload._status === 0 || payload._status === -1)
            payload._status = 1, payload._result = moduleObject;
        }, function(error2) {
          if (payload._status === 0 || payload._status === -1)
            payload._status = 2, payload._result = error2;
        });
        payload._status === -1 && (payload._status = 0, payload._result = ctor);
      }
      if (payload._status === 1)
        return ctor = payload._result, ctor === undefined && console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ctor), "default" in ctor || console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ctor), ctor.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    function noop4() {}
    function enqueueTask(task) {
      if (enqueueTaskImpl === null)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function(callback) {
            didWarnAboutMessageChannel === false && (didWarnAboutMessageChannel = true, typeof MessageChannel === "undefined" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var channel = new MessageChannel;
            channel.port1.onmessage = callback;
            channel.port2.postMessage(undefined);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors2) {
      return 1 < errors2.length && typeof AggregateError === "function" ? new AggregateError(errors2) : errors2[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (queue !== null)
        if (queue.length !== 0)
          try {
            flushActQueue(queue);
            enqueueTask(function() {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error2) {
            ReactSharedInternals.thrownErrors.push(error2);
          }
        else
          ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = true;
        var i = 0;
        try {
          for (;i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = false;
              var continuation = callback(false);
              if (continuation !== null) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else
                break;
            } while (1);
          }
          queue.length = 0;
        } catch (error2) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error2);
        } finally {
          isFlushing = false;
        }
      }
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    }, fnName;
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy;
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      V: null,
      actQueue: null,
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false,
      didUsePromise: false,
      thrownErrors: [],
      getCurrentStack: null,
      recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty2 = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    deprecatedAPIs = {
      "react-stack-bottom-frame": function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = typeof reportError === "function" ? reportError : function(error2) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error2 === "object" && error2 !== null && typeof error2.message === "string" ? String(error2.message) : String(error2),
          error: error2
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error2);
        return;
      }
      console.error(error2);
    }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = typeof queueMicrotask === "function" ? function(callback) {
      queueMicrotask(function() {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function(size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    exports.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function(children) {
        var n2 = 0;
        mapChildren(children, function() {
          n2++;
        });
        return n2;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
      var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = prevActQueue !== null ? prevActQueue : [], didAwaitActCall = false;
      try {
        var result = callback();
      } catch (error2) {
        ReactSharedInternals.thrownErrors.push(error2);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (result !== null && typeof result === "object" && typeof result.then === "function") {
        var thenable = result;
        queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            thenable.then(function(returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (prevActScopeDepth === 0) {
                try {
                  flushActQueue(queue), enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error$0) {
                  ReactSharedInternals.thrownErrors.push(error$0);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else
                resolve(returnValue);
            }, function(error2) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error2 = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error2)) : reject(error2);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      prevActScopeDepth === 0 && (flushActQueue(queue), queue.length !== 0 && queueSeveralMicrotasks(function() {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function(resolve, reject) {
          didAwaitActCall = true;
          prevActScopeDepth === 0 ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.captureOwnerStack = function() {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return getCurrentStack === null ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config2, children) {
      if (element === null || element === undefined)
        throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props), key = element.key, owner = element._owner;
      if (config2 != null) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty2.call(config2, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config2, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = false;
            break a;
          }
          JSCompiler_inline_result = config2.ref !== undefined;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key);
        for (propName in config2)
          !hasOwnProperty2.call(config2, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config2.ref === undefined || (props[propName] = config2[propName]);
      }
      var propName = arguments.length - 2;
      if (propName === 1)
        props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0;i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, undefined, undefined, owner, props, element._debugStack, element._debugTask);
      for (key = 2;key < arguments.length; key++)
        owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
      return props;
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function(type, config2, children) {
      for (var i = 2;i < arguments.length; i++) {
        var node2 = arguments[i];
        isValidElement(node2) && node2._store && (node2._store.validated = 1);
      }
      i = {};
      node2 = null;
      if (config2 != null)
        for (propName in didWarnAboutOldJSXRuntime || !("__self" in config2) || "key" in config2 || (didWarnAboutOldJSXRuntime = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), node2 = "" + config2.key), config2)
          hasOwnProperty2.call(config2, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (i[propName] = config2[propName]);
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1)
        i.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0;_i < childrenLength; _i++)
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          i[propName] === undefined && (i[propName] = childrenLength[propName]);
      node2 && defineKeyPropWarningGetter(i, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, node2, undefined, undefined, getOwner(), i, propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function(render2) {
      render2 != null && render2.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render2 !== "function" ? console.error("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2) : render2.length !== 0 && render2.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      render2 != null && render2.defaultProps != null && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render2 }, ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name2) {
          ownName = name2;
          render2.name || render2.displayName || (Object.defineProperty(render2, "name", { value: name2 }), render2.displayName = name2);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type, compare2) {
      type == null && console.error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
      compare2 = {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: compare2 === undefined ? null : compare2
      };
      var ownName;
      Object.defineProperty(compare2, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name2) {
          ownName = name2;
          type.name || type.displayName || (Object.defineProperty(type, "name", { value: name2 }), type.displayName = name2);
        }
      });
      return compare2;
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && returnValue.then(noop4, reportGlobalError);
      } catch (error2) {
        reportGlobalError(error2);
      } finally {
        prevTransition === null && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context2) {
      var dispatcher = resolveDispatcher();
      Context2.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context2);
    };
    exports.useDebugValue = function(value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, createDeps, update) {
      create == null && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      var dispatcher = resolveDispatcher();
      if (typeof update === "function")
        throw Error("useEffect CRUD overload is not enabled in this build of React.");
      return dispatcher.useEffect(create, createDeps);
    };
    exports.useId = function() {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      create == null && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      create == null && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init2) {
      return resolveDispatcher().useReducer(reducer, initialArg, init2);
    };
    exports.useRef = function(initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.1.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// ../../node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development(), 1);
  if (false) {} else {
    module.exports = react_development;
  }
});

// ../../node_modules/prettier/plugins/html.mjs
var exports_html = {};
__export(exports_html, {
  printers: () => Uo,
  parsers: () => Zr,
  options: () => Bs,
  languages: () => xs,
  default: () => Gh
});
function hi(t2) {
  if (typeof t2 == "string")
    return ye;
  if (Array.isArray(t2))
    return Ge;
  if (!t2)
    return;
  let { type: e2 } = t2;
  if (At.has(e2))
    return e2;
}
function mi(t2) {
  let e2 = t2 === null ? "null" : typeof t2;
  if (e2 !== "string" && e2 !== "object")
    return `Unexpected doc '${e2}', 
Expected it to be 'string' or 'object'.`;
  if (Le(t2))
    throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(t2);
  if (r2 !== "[object Object]")
    return `Unexpected doc '${r2}'.`;
  let n2 = fi([...At].map((s2) => `'${s2}'`));
  return `Unexpected doc.type '${t2.type}'.
Expected it to be ${n2}.`;
}
function hr(t2, e2) {
  if (typeof t2 == "string")
    return e2(t2);
  let r2 = new Map;
  return n2(t2);
  function n2(i) {
    if (r2.has(i))
      return r2.get(i);
    let a = s2(i);
    return r2.set(i, a), a;
  }
  function s2(i) {
    switch (Le(i)) {
      case Ge:
        return e2(i.map(n2));
      case xe:
        return e2({ ...i, parts: i.parts.map(n2) });
      case ce:
        return e2({ ...i, breakContents: n2(i.breakContents), flatContents: n2(i.flatContents) });
      case Te: {
        let { expandedStates: a, contents: o2 } = i;
        return a ? (a = a.map(n2), o2 = a[0]) : o2 = n2(o2), e2({ ...i, contents: o2, expandedStates: a });
      }
      case be:
      case we:
      case ke:
      case Xe:
      case Ke:
        return e2({ ...i, contents: n2(i.contents) });
      case ye:
      case Ye:
      case je:
      case Qe:
      case j:
      case Be:
        return e2(i);
      default:
        throw new pr(i);
    }
  }
}
function B(t2, e2 = cn) {
  return hr(t2, (r2) => typeof r2 == "string" ? H(e2, r2.split(`
`)) : r2);
}
function k(t2) {
  return ne2(t2), { type: we, contents: t2 };
}
function hn(t2, e2) {
  return ne2(e2), { type: be, contents: e2, n: t2 };
}
function E(t2, e2 = {}) {
  return ne2(t2), mr(e2.expandedStates, true), { type: Te, id: e2.id, contents: t2, break: !!e2.shouldBreak, expandedStates: e2.expandedStates };
}
function fn(t2) {
  return hn(Number.NEGATIVE_INFINITY, t2);
}
function mn(t2) {
  return hn({ type: "root" }, t2);
}
function Dt(t2) {
  return pn(t2), { type: xe, parts: t2 };
}
function pe(t2, e2 = "", r2 = {}) {
  return ne2(t2), e2 !== "" && ne2(e2), { type: ce, breakContents: t2, flatContents: e2, groupId: r2.groupId };
}
function dn(t2, e2) {
  return ne2(t2), { type: ke, contents: t2, groupId: e2.groupId, negate: e2.negate };
}
function H(t2, e2) {
  ne2(t2), mr(e2);
  let r2 = [];
  for (let n2 = 0;n2 < e2.length; n2++)
    n2 !== 0 && r2.push(t2), r2.push(e2[n2]);
  return r2;
}
function Si(t2, e2) {
  let r2 = e2 === true || e2 === vt ? vt : gn, n2 = r2 === vt ? gn : vt, s2 = 0, i = 0;
  for (let a of t2)
    a === r2 ? s2++ : a === n2 && i++;
  return s2 > i ? n2 : r2;
}
function dr(t2) {
  if (typeof t2 != "string")
    throw new TypeError("Expected a string");
  return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Ai(t2) {
  return (t2 == null ? undefined : t2.type) === "front-matter";
}
function En(t2, e2) {
  var r2;
  if (t2.type === "text" || t2.type === "comment" || Fe(t2) || t2.type === "yaml" || t2.type === "toml")
    return null;
  if (t2.type === "attribute" && delete e2.value, t2.type === "docType" && delete e2.value, t2.type === "angularControlFlowBlock" && ((r2 = t2.parameters) != null && r2.children))
    for (let n2 of e2.parameters.children)
      vi.has(t2.name) ? delete n2.expression : n2.expression = n2.expression.trim();
  t2.type === "angularIcuExpression" && (e2.switchValue = t2.switchValue.trim()), t2.type === "angularLetDeclarationInitializer" && delete e2.value;
}
async function yi(t2, e2) {
  if (t2.language === "yaml") {
    let r2 = t2.value.trim(), n2 = r2 ? await e2(r2, { parser: "yaml" }) : "";
    return mn([t2.startDelimiter, t2.explicitLanguage, S, n2, n2 ? S : "", t2.endDelimiter]);
  }
}
function he(t2, e2 = true) {
  return [k([v, t2]), e2 ? v : ""];
}
function Q(t2, e2) {
  let r2 = t2.type === "NGRoot" ? t2.node.type === "NGMicrosyntax" && t2.node.body.length === 1 && t2.node.body[0].type === "NGMicrosyntaxExpression" ? t2.node.body[0].expression : t2.node : t2.type === "JsExpressionRoot" ? t2.node : t2;
  return r2 && (r2.type === "ObjectExpression" || r2.type === "ArrayExpression" || (e2.parser === "__vue_expression" || e2.parser === "__vue_ts_expression") && (r2.type === "TemplateLiteral" || r2.type === "StringLiteral"));
}
async function T(t2, e2, r2, n2) {
  r2 = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r2 };
  let s2 = true;
  n2 && (r2.__onHtmlBindingRoot = (a, o2) => {
    s2 = n2(a, o2);
  });
  let i = await e2(t2, r2, e2);
  return s2 ? E(i) : he(i);
}
function wi(t2, e2, r2, n2) {
  let { node: s2 } = r2, i = n2.originalText.slice(s2.sourceSpan.start.offset, s2.sourceSpan.end.offset);
  return /^\s*$/u.test(i) ? "" : T(i, t2, { parser: "__ng_directive", __isInHtmlAttribute: false }, Q);
}
function yn(t2, e2) {
  if (!e2)
    return;
  let r2 = bi(e2).toLowerCase();
  return t2.find(({ filenames: n2 }) => n2 == null ? undefined : n2.some((s2) => s2.toLowerCase() === r2)) ?? t2.find(({ extensions: n2 }) => n2 == null ? undefined : n2.some((s2) => r2.endsWith(s2)));
}
function Ti(t2, e2) {
  if (e2)
    return t2.find(({ name: r2 }) => r2.toLowerCase() === e2) ?? t2.find(({ aliases: r2 }) => r2 == null ? undefined : r2.includes(e2)) ?? t2.find(({ extensions: r2 }) => r2 == null ? undefined : r2.includes(`.${e2}`));
}
function xi(t2, e2) {
  let r2 = t2.plugins.flatMap((s2) => s2.languages ?? []), n2 = Ti(r2, e2.language) ?? yn(r2, e2.physicalFile) ?? yn(r2, e2.file) ?? (e2.physicalFile, undefined);
  return n2 == null ? undefined : n2.parsers[0];
}
function ki(t2) {
  return t2.type === "element" && !t2.hasExplicitNamespace && !["html", "svg"].includes(t2.namespace);
}
function yt(t2, e2) {
  return !!(t2.type === "ieConditionalComment" && t2.lastChild && !t2.lastChild.isSelfClosing && !t2.lastChild.endSourceSpan || t2.type === "ieConditionalComment" && !t2.complete || me(t2) && t2.children.some((r2) => r2.type !== "text" && r2.type !== "interpolation") || Tt(t2, e2) && !W(t2) && t2.type !== "interpolation");
}
function de(t2) {
  return t2.type === "attribute" || !t2.parent || !t2.prev ? false : Li(t2.prev);
}
function Li(t2) {
  return t2.type === "comment" && t2.value.trim() === "prettier-ignore";
}
function $(t2) {
  return t2.type === "text" || t2.type === "comment";
}
function W(t2) {
  return t2.type === "element" && (t2.fullName === "script" || t2.fullName === "style" || t2.fullName === "svg:style" || t2.fullName === "svg:script" || fe(t2) && (t2.name === "script" || t2.name === "style"));
}
function Bn(t2) {
  return t2.children && !W(t2);
}
function Ln(t2) {
  return W(t2) || t2.type === "interpolation" || _r(t2);
}
function _r(t2) {
  return Vn(t2).startsWith("pre");
}
function Fn(t2, e2) {
  var s2, i;
  let r2 = n2();
  if (r2 && !t2.prev && ((i = (s2 = t2.parent) == null ? undefined : s2.tagDefinition) != null && i.ignoreFirstLf))
    return t2.type === "interpolation";
  return r2;
  function n2() {
    return Fe(t2) || t2.type === "angularControlFlowBlock" ? false : (t2.type === "text" || t2.type === "interpolation") && t2.prev && (t2.prev.type === "text" || t2.prev.type === "interpolation") ? true : !t2.parent || t2.parent.cssDisplay === "none" ? false : me(t2.parent) ? true : !(!t2.prev && (t2.parent.type === "root" || me(t2) && t2.parent || W(t2.parent) || et(t2.parent, e2) || !$i(t2.parent.cssDisplay)) || t2.prev && !qi(t2.prev.cssDisplay));
  }
}
function Nn(t2, e2) {
  return Fe(t2) || t2.type === "angularControlFlowBlock" ? false : (t2.type === "text" || t2.type === "interpolation") && t2.next && (t2.next.type === "text" || t2.next.type === "interpolation") ? true : !t2.parent || t2.parent.cssDisplay === "none" ? false : me(t2.parent) ? true : !(!t2.next && (t2.parent.type === "root" || me(t2) && t2.parent || W(t2.parent) || et(t2.parent, e2) || !Oi(t2.parent.cssDisplay)) || t2.next && !Mi(t2.next.cssDisplay));
}
function Pn(t2) {
  return Hi(t2.cssDisplay) && !W(t2);
}
function Je(t2) {
  return Fe(t2) || t2.next && t2.sourceSpan.end && t2.sourceSpan.end.line + 1 < t2.next.sourceSpan.start.line;
}
function In(t2) {
  return Er(t2) || t2.type === "element" && t2.children.length > 0 && (["body", "script", "style"].includes(t2.name) || t2.children.some((e2) => Ni(e2))) || t2.firstChild && t2.firstChild === t2.lastChild && t2.firstChild.type !== "text" && $n(t2.firstChild) && (!t2.lastChild.isTrailingSpaceSensitive || On(t2.lastChild));
}
function Er(t2) {
  return t2.type === "element" && t2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t2.name) || t2.cssDisplay.startsWith("table") && t2.cssDisplay !== "table-cell");
}
function wt(t2) {
  return Mn(t2) || t2.prev && Fi(t2.prev) || Rn(t2);
}
function Fi(t2) {
  return Mn(t2) || t2.type === "element" && t2.fullName === "br" || Rn(t2);
}
function Rn(t2) {
  return $n(t2) && On(t2);
}
function $n(t2) {
  return t2.hasLeadingSpaces && (t2.prev ? t2.prev.sourceSpan.end.line < t2.sourceSpan.start.line : t2.parent.type === "root" || t2.parent.startSourceSpan.end.line < t2.sourceSpan.start.line);
}
function On(t2) {
  return t2.hasTrailingSpaces && (t2.next ? t2.next.sourceSpan.start.line > t2.sourceSpan.end.line : t2.parent.type === "root" || t2.parent.endSourceSpan && t2.parent.endSourceSpan.start.line > t2.sourceSpan.end.line);
}
function Mn(t2) {
  switch (t2.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(t2.name);
  }
  return false;
}
function bt(t2) {
  return t2.lastChild ? bt(t2.lastChild) : t2;
}
function Ni(t2) {
  var e2;
  return (e2 = t2.children) == null ? undefined : e2.some((r2) => r2.type !== "text");
}
function qn(t2) {
  if (t2)
    switch (t2) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t2.endsWith("json") || t2.endsWith("importmap") || t2 === "speculationrules")
          return "json";
    }
}
function Pi(t2, e2) {
  let { name: r2, attrMap: n2 } = t2;
  if (r2 !== "script" || Object.prototype.hasOwnProperty.call(n2, "src"))
    return;
  let { type: s2, lang: i } = t2.attrMap;
  return !i && !s2 ? "babel" : Ne(e2, { language: i }) ?? qn(s2);
}
function Ii(t2, e2) {
  if (!Tt(t2, e2))
    return;
  let { attrMap: r2 } = t2;
  if (Object.prototype.hasOwnProperty.call(r2, "src"))
    return;
  let { type: n2, lang: s2 } = r2;
  return Ne(e2, { language: s2 }) ?? qn(n2);
}
function Ri(t2, e2) {
  if (t2.name !== "style")
    return;
  let { lang: r2 } = t2.attrMap;
  return r2 ? Ne(e2, { language: r2 }) : "css";
}
function Ar(t2, e2) {
  return Pi(t2, e2) ?? Ri(t2, e2) ?? Ii(t2, e2);
}
function Ze(t2) {
  return t2 === "block" || t2 === "list-item" || t2.startsWith("table");
}
function $i(t2) {
  return !Ze(t2) && t2 !== "inline-block";
}
function Oi(t2) {
  return !Ze(t2) && t2 !== "inline-block";
}
function Mi(t2) {
  return !Ze(t2);
}
function qi(t2) {
  return !Ze(t2);
}
function Hi(t2) {
  return !Ze(t2) && t2 !== "inline-block";
}
function me(t2) {
  return Vn(t2).startsWith("pre");
}
function Vi(t2, e2) {
  let r2 = t2;
  for (;r2; ) {
    if (e2(r2))
      return true;
    r2 = r2.parent;
  }
  return false;
}
function Hn(t2, e2) {
  var n2;
  if (ge(t2, e2))
    return "block";
  if (((n2 = t2.prev) == null ? undefined : n2.type) === "comment") {
    let s2 = t2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (s2)
      return s2[1];
  }
  let r2 = false;
  if (t2.type === "element" && t2.namespace === "svg")
    if (Vi(t2, (s2) => s2.fullName === "svg:foreignObject"))
      r2 = true;
    else
      return t2.name === "svg" ? "inline-block" : "block";
  switch (e2.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t2.type === "element" && (!t2.namespace || r2 || fe(t2)) && bn[t2.name] || wn;
  }
}
function Vn(t2) {
  return t2.type === "element" && (!t2.namespace || fe(t2)) && xn[t2.name] || Tn;
}
function Ui(t2) {
  let e2 = Number.POSITIVE_INFINITY;
  for (let r2 of t2.split(`
`)) {
    if (r2.length === 0)
      continue;
    let n2 = O.getLeadingWhitespaceCount(r2);
    if (n2 === 0)
      return 0;
    r2.length !== n2 && n2 < e2 && (e2 = n2);
  }
  return e2 === Number.POSITIVE_INFINITY ? 0 : e2;
}
function Dr(t2, e2 = Ui(t2)) {
  return e2 === 0 ? t2 : t2.split(`
`).map((r2) => r2.slice(e2)).join(`
`);
}
function vr(t2) {
  return w(false, w(false, t2, "&apos;", "'"), "&quot;", '"');
}
function N(t2) {
  return vr(t2.value);
}
function et(t2, e2) {
  return ge(t2, e2) && !Wi.has(t2.fullName);
}
function ge(t2, e2) {
  return e2.parser === "vue" && t2.type === "element" && t2.parent.type === "root" && t2.fullName.toLowerCase() !== "html";
}
function Tt(t2, e2) {
  return ge(t2, e2) && (et(t2, e2) || t2.attrMap.lang && t2.attrMap.lang !== "html");
}
function Un(t2) {
  let e2 = t2.fullName;
  return e2.charAt(0) === "#" || e2 === "slot-scope" || e2 === "v-slot" || e2.startsWith("v-slot:");
}
function Wn(t2, e2) {
  let r2 = t2.parent;
  if (!ge(r2, e2))
    return false;
  let n2 = r2.fullName, s2 = t2.fullName;
  return n2 === "script" && s2 === "setup" || n2 === "style" && s2 === "vars";
}
function xt(t2, e2 = t2.value) {
  return t2.parent.isWhitespaceSensitive ? t2.parent.isIndentationSensitive ? B(e2) : B(Dr(Sr(e2)), S) : H(_, O.split(e2));
}
function kt(t2, e2) {
  return ge(t2, e2) && t2.name === "script";
}
async function zn(t2, e2) {
  let r2 = [];
  for (let [n2, s2] of t2.split(yr).entries())
    if (n2 % 2 === 0)
      r2.push(B(s2));
    else
      try {
        r2.push(E(["{{", k([_, await T(s2, e2, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), _, "}}"]));
      } catch {
        r2.push("{{", B(s2), "}}");
      }
  return r2;
}
function wr({ parser: t2 }) {
  return (e2, r2, n2) => T(N(n2.node), e2, { parser: t2 }, Q);
}
function ji(t2, e2) {
  if (e2.parser !== "angular")
    return;
  let { node: r2 } = t2, n2 = r2.fullName;
  if (n2.startsWith("(") && n2.endsWith(")") || n2.startsWith("on-"))
    return zi;
  if (n2.startsWith("[") && n2.endsWith("]") || /^bind(?:on)?-/u.test(n2) || /^ng-(?:if|show|hide|class|style)$/u.test(n2))
    return Gi;
  if (n2.startsWith("*"))
    return Yi;
  let s2 = N(r2);
  if (/^i18n(?:-.+)?$/u.test(n2))
    return () => he(Dt(xt(r2, s2.trim())), !s2.includes("@@"));
  if (yr.test(s2))
    return (i) => zn(s2, i);
}
function Ki(t2, e2) {
  let { node: r2 } = t2, n2 = N(r2);
  if (r2.fullName === "class" && !e2.parentParser && !n2.includes("{{"))
    return () => n2.trim().split(/\s+/u).join(" ");
}
function jn(t2) {
  return t2 === "\t" || t2 === `
` || t2 === "\f" || t2 === "\r" || t2 === " ";
}
function ta(t2) {
  let e2 = t2.length, r2, n2, s2, i, a, o2 = 0, u;
  function p(C) {
    let A, D = C.exec(t2.substring(o2));
    if (D)
      return [A] = D, o2 += A.length, A;
  }
  let l2 = [];
  for (;; ) {
    if (p(Xi), o2 >= e2) {
      if (l2.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return l2;
    }
    u = o2, r2 = p(Ji), n2 = [], r2.slice(-1) === "," ? (r2 = r2.replace(Zi, ""), d()) : f();
  }
  function f() {
    for (p(Qi), s2 = "", i = "in descriptor";; ) {
      if (a = t2.charAt(o2), i === "in descriptor")
        if (jn(a))
          s2 && (n2.push(s2), s2 = "", i = "after descriptor");
        else if (a === ",") {
          o2 += 1, s2 && n2.push(s2), d();
          return;
        } else if (a === "(")
          s2 += a, i = "in parens";
        else if (a === "") {
          s2 && n2.push(s2), d();
          return;
        } else
          s2 += a;
      else if (i === "in parens")
        if (a === ")")
          s2 += a, i = "in descriptor";
        else if (a === "") {
          n2.push(s2), d();
          return;
        } else
          s2 += a;
      else if (i === "after descriptor" && !jn(a))
        if (a === "") {
          d();
          return;
        } else
          i = "in descriptor", o2 -= 1;
      o2 += 1;
    }
  }
  function d() {
    let C = false, A, D, I2, F, c2 = {}, g, y, q, x, U;
    for (F = 0;F < n2.length; F++)
      g = n2[F], y = g[g.length - 1], q = g.substring(0, g.length - 1), x = parseInt(q, 10), U = parseFloat(q), Kn.test(q) && y === "w" ? ((A || D) && (C = true), x === 0 ? C = true : A = x) : ea.test(q) && y === "x" ? ((A || D || I2) && (C = true), U < 0 ? C = true : D = U) : Kn.test(q) && y === "h" ? ((I2 || D) && (C = true), x === 0 ? C = true : I2 = x) : C = true;
    if (!C)
      c2.source = { value: r2, startOffset: u }, A && (c2.width = { value: A }), D && (c2.density = { value: D }), I2 && (c2.height = { value: I2 }), l2.push(c2);
    else
      throw new Error(`Invalid srcset descriptor found in "${t2}" at "${g}".`);
  }
}
function ra(t2) {
  if (t2.node.fullName === "srcset" && (t2.parent.fullName === "img" || t2.parent.fullName === "source"))
    return () => sa(N(t2.node));
}
function sa(t2) {
  let e2 = Qn(t2), r2 = na.filter((l2) => e2.some((f) => Object.prototype.hasOwnProperty.call(f, l2)));
  if (r2.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [n2] = r2, s2 = Xn[n2], i = e2.map((l2) => l2.source.value), a = Math.max(...i.map((l2) => l2.length)), o2 = e2.map((l2) => l2[n2] ? String(l2[n2].value) : ""), u = o2.map((l2) => {
    let f = l2.indexOf(".");
    return f === -1 ? l2.length : f;
  }), p = Math.max(...u);
  return he(H([",", _], i.map((l2, f) => {
    let d = [l2], C = o2[f];
    if (C) {
      let A = a - l2.length + 1, D = p - u[f], I2 = " ".repeat(A + D);
      d.push(pe(I2, " "), C + s2);
    }
    return d;
  })));
}
function Zn(t2, e2) {
  let { node: r2 } = t2, n2 = N(t2.node).trim();
  if (r2.fullName === "style" && !e2.parentParser && !n2.includes("{{"))
    return async (s2) => he(await s2(n2, { parser: "css", __isHTMLStyleAttribute: true }));
}
function ia(t2, e2) {
  let { root: r2 } = t2;
  return br.has(r2) || br.set(r2, r2.children.some((n2) => kt(n2, e2) && ["ts", "typescript"].includes(n2.attrMap.lang))), br.get(r2);
}
function es(t2, e2, r2) {
  let { node: n2 } = r2, s2 = N(n2);
  return T(`type T<${s2}> = any`, t2, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, Q);
}
function ts(t2, e2, { parseWithTs: r2 }) {
  return T(`function _(${t2}) {}`, e2, { parser: r2 ? "babel-ts" : "babel", __isVueBindings: true });
}
async function rs(t2, e2, r2, n2) {
  let s2 = N(r2.node), { left: i, operator: a, right: o2 } = aa(s2), u = Pe(r2, n2);
  return [E(await T(`function _(${i}) {}`, t2, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await T(o2, t2, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function aa(t2) {
  let e2 = /(.*?)\s+(in|of)\s+(.*)/su, r2 = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n2 = /^\(|\)$/gu, s2 = t2.match(e2);
  if (!s2)
    return;
  let i = {};
  if (i.for = s2[3].trim(), !i.for)
    return;
  let a = w(false, s2[1].trim(), n2, ""), o2 = a.match(r2);
  o2 ? (i.alias = a.replace(r2, ""), i.iterator1 = o2[1].trim(), o2[2] && (i.iterator2 = o2[2].trim())) : i.alias = a;
  let u = [i.alias, i.iterator1, i.iterator2];
  if (!u.some((p, l2) => !p && (l2 === 0 || u.slice(l2 + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: s2[2], right: i.for };
}
function oa(t2, e2) {
  if (e2.parser !== "vue")
    return;
  let { node: r2 } = t2, n2 = r2.fullName;
  if (n2 === "v-for")
    return rs;
  if (n2 === "generic" && kt(r2.parent, e2))
    return es;
  let s2 = N(r2), i = Pe(t2, e2);
  if (Un(r2) || Wn(r2, e2))
    return (a) => ts(s2, a, { parseWithTs: i });
  if (n2.startsWith("@") || n2.startsWith("v-on:"))
    return (a) => ua(s2, a, { parseWithTs: i });
  if (n2.startsWith(":") || n2.startsWith(".") || n2.startsWith("v-bind:"))
    return (a) => la(s2, a, { parseWithTs: i });
  if (n2.startsWith("v-"))
    return (a) => ns(s2, a, { parseWithTs: i });
}
async function ua(t2, e2, { parseWithTs: r2 }) {
  var n2;
  try {
    return await ns(t2, e2, { parseWithTs: r2 });
  } catch (s2) {
    if (((n2 = s2.cause) == null ? undefined : n2.code) !== "BABEL_PARSER_SYNTAX_ERROR")
      throw s2;
  }
  return T(t2, e2, { parser: r2 ? "__vue_ts_event_binding" : "__vue_event_binding" }, Q);
}
function la(t2, e2, { parseWithTs: r2 }) {
  return T(t2, e2, { parser: r2 ? "__vue_ts_expression" : "__vue_expression" }, Q);
}
function ns(t2, e2, { parseWithTs: r2 }) {
  return T(t2, e2, { parser: r2 ? "__ts_expression" : "__js_expression" }, Q);
}
function ca(t2, e2) {
  let { node: r2 } = t2;
  if (r2.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e2.originalText.slice(r2.valueSpan.start.offset, r2.valueSpan.end.offset)) || e2.parser === "lwc" && r2.value.startsWith("{") && r2.value.endsWith("}"))
      return [r2.rawName, "=", r2.value];
    for (let n2 of [Jn, Zn, Yn, ss, Gn]) {
      let s2 = n2(t2, e2);
      if (s2)
        return pa(s2);
    }
  }
}
function pa(t2) {
  return async (e2, r2, n2, s2) => {
    let i = await t2(e2, r2, n2, s2);
    if (i)
      return i = hr(i, (a) => typeof a == "string" ? w(false, a, '"', "&quot;") : a), [n2.node.rawName, '="', E(i), '"'];
  };
}
function ha(t2) {
  return Array.isArray(t2) && t2.length > 0;
}
function J(t2) {
  return t2.sourceSpan.start.offset;
}
function Z(t2) {
  return t2.sourceSpan.end.offset;
}
function tt(t2, e2) {
  return [t2.isSelfClosing ? "" : fa(t2, e2), Ce(t2, e2)];
}
function fa(t2, e2) {
  return t2.lastChild && Ee(t2.lastChild) ? "" : [ma(t2, e2), Bt(t2, e2)];
}
function Ce(t2, e2) {
  return (t2.next ? X(t2.next) : _e(t2.parent)) ? "" : [Se(t2, e2), z(t2, e2)];
}
function ma(t2, e2) {
  return _e(t2) ? Se(t2.lastChild, e2) : "";
}
function z(t2, e2) {
  return Ee(t2) ? Bt(t2.parent, e2) : rt(t2) ? Lt(t2.next, e2) : "";
}
function Bt(t2, e2) {
  if (Tr.ok(!t2.isSelfClosing), us(t2, e2))
    return "";
  switch (t2.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t2.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t2.rawName}`;
  }
}
function Se(t2, e2) {
  if (us(t2, e2))
    return "";
  switch (t2.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t2.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function us(t2, e2) {
  return !t2.isSelfClosing && !t2.endSourceSpan && (de(t2) || yt(t2.parent, e2));
}
function X(t2) {
  return t2.prev && t2.prev.type !== "docType" && t2.type !== "angularControlFlowBlock" && !$(t2.prev) && t2.isLeadingSpaceSensitive && !t2.hasLeadingSpaces;
}
function _e(t2) {
  var e2;
  return ((e2 = t2.lastChild) == null ? undefined : e2.isTrailingSpaceSensitive) && !t2.lastChild.hasTrailingSpaces && !$(bt(t2.lastChild)) && !me(t2);
}
function Ee(t2) {
  return !t2.next && !t2.hasTrailingSpaces && t2.isTrailingSpaceSensitive && $(bt(t2));
}
function rt(t2) {
  return t2.next && !$(t2.next) && $(t2) && t2.isTrailingSpaceSensitive && !t2.hasTrailingSpaces;
}
function da(t2) {
  let e2 = t2.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return e2 ? e2[1] ? e2[1].split(/\s+/u) : true : false;
}
function nt(t2) {
  return !t2.prev && t2.isLeadingSpaceSensitive && !t2.hasLeadingSpaces;
}
function ga(t2, e2, r2) {
  var f;
  let { node: n2 } = t2;
  if (!Ie(n2.attrs))
    return n2.isSelfClosing ? " " : "";
  let s2 = ((f = n2.prev) == null ? undefined : f.type) === "comment" && da(n2.prev.value), i = typeof s2 == "boolean" ? () => s2 : Array.isArray(s2) ? (d) => s2.includes(d.rawName) : () => false, a = t2.map(({ node: d }) => i(d) ? B(e2.originalText.slice(J(d), Z(d))) : r2(), "attrs"), o2 = n2.type === "element" && n2.fullName === "script" && n2.attrs.length === 1 && n2.attrs[0].fullName === "src" && n2.children.length === 0, p = e2.singleAttributePerLine && n2.attrs.length > 1 && !ge(n2, e2) ? S : _, l2 = [k([o2 ? " " : _, H(p, a)])];
  return n2.firstChild && nt(n2.firstChild) || n2.isSelfClosing && _e(n2.parent) || o2 ? l2.push(n2.isSelfClosing ? " " : "") : l2.push(e2.bracketSameLine ? n2.isSelfClosing ? " " : "" : n2.isSelfClosing ? _ : v), l2;
}
function Ca(t2) {
  return t2.firstChild && nt(t2.firstChild) ? "" : Ft(t2);
}
function st(t2, e2, r2) {
  let { node: n2 } = t2;
  return [Ae(n2, e2), ga(t2, e2, r2), n2.isSelfClosing ? "" : Ca(n2)];
}
function Ae(t2, e2) {
  return t2.prev && rt(t2.prev) ? "" : [G(t2, e2), Lt(t2, e2)];
}
function G(t2, e2) {
  return nt(t2) ? Ft(t2.parent) : X(t2) ? Se(t2.prev, e2) : "";
}
function Lt(t2, e2) {
  switch (t2.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t2.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (t2.value === "html") {
        let n2 = e2.filepath ?? "";
        if (/\.html?$/u.test(n2))
          return os;
      }
      return e2.originalText.slice(J(t2), Z(t2)).slice(0, os.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t2.condition)
        return `<!--[if ${t2.condition}]><!--><${t2.rawName}`;
    default:
      return `<${t2.rawName}`;
  }
}
function Ft(t2) {
  switch (Tr.ok(!t2.isSelfClosing), t2.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t2.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function Sa(t2, e2) {
  if (!t2.endSourceSpan)
    return "";
  let r2 = t2.startSourceSpan.end.offset;
  t2.firstChild && nt(t2.firstChild) && (r2 -= Ft(t2).length);
  let n2 = t2.endSourceSpan.start.offset;
  return t2.lastChild && Ee(t2.lastChild) ? n2 += Bt(t2, e2).length : _e(t2) && (n2 -= Se(t2.lastChild, e2).length), e2.originalText.slice(r2, n2);
}
function Ea(t2, e2) {
  let { node: r2 } = t2;
  switch (r2.type) {
    case "element":
      if (W(r2) || r2.type === "interpolation")
        return;
      if (!r2.isSelfClosing && Tt(r2, e2)) {
        let n2 = Ar(r2, e2);
        return n2 ? async (s2, i) => {
          let a = Nt(r2, e2), o2 = /^\s*$/u.test(a), u = "";
          return o2 || (u = await s2(Sr(a), { parser: n2, __embeddedInHtml: true }), o2 = u === ""), [G(r2, e2), E(st(t2, e2, i)), o2 ? "" : S, u, o2 ? "" : S, tt(r2, e2), z(r2, e2)];
        } : undefined;
      }
      break;
    case "text":
      if (W(r2.parent)) {
        let n2 = Ar(r2.parent, e2);
        if (n2)
          return async (s2) => {
            let i = n2 === "markdown" ? Dr(r2.value.replace(/^[^\S\n]*\n/u, "")) : r2.value, a = { parser: n2, __embeddedInHtml: true };
            if (e2.parser === "html" && n2 === "babel") {
              let o2 = "script", { attrMap: u } = r2.parent;
              u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (o2 = "module"), a.__babelSourceType = o2;
            }
            return [se, G(r2, e2), await s2(i, a), z(r2, e2)];
          };
      } else if (r2.parent.type === "interpolation")
        return async (n2) => {
          let s2 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return e2.parser === "angular" ? s2.parser = "__ng_interpolation" : e2.parser === "vue" ? s2.parser = Pe(t2, e2) ? "__vue_ts_expression" : "__vue_expression" : s2.parser = "__js_expression", [k([_, await n2(r2.value, s2)]), r2.parent.next && X(r2.parent.next) ? " " : _];
        };
      break;
    case "attribute":
      return is3(t2, e2);
    case "front-matter":
      return (n2) => Dn(r2, n2);
    case "angularControlFlowBlockParameters":
      return _a2.has(t2.parent.name) ? vn : undefined;
    case "angularLetDeclarationInitializer":
      return (n2) => T(r2.value, n2, { parser: "__ng_binding", __isInHtmlAttribute: false });
  }
}
function at(t2) {
  if (it !== null && typeof it.property) {
    let e2 = it;
    return it = at.prototype = null, e2;
  }
  return it = at.prototype = t2 ?? Object.create(null), new at;
}
function xr(t2) {
  return at(t2);
}
function Da(t2, e2 = "type") {
  xr(t2);
  function r2(n2) {
    let s2 = n2[e2], i = t2[s2];
    if (!Array.isArray(i))
      throw Object.assign(new Error(`Missing visitor keys for '${s2}'.`), { node: n2 });
    return i;
  }
  return r2;
}
function fs(t2) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/u.test(t2);
}
function ms(t2) {
  return `<!-- @format -->

` + t2;
}
function gs(t2) {
  let e2 = Z(t2);
  return t2.type === "element" && !t2.endSourceSpan && Ie(t2.children) ? Math.max(e2, gs(K(false, t2.children, -1))) : e2;
}
function ot(t2, e2, r2) {
  let n2 = t2.node;
  if (de(n2)) {
    let s2 = gs(n2);
    return [G(n2, e2), B(O.trimEnd(e2.originalText.slice(J(n2) + (n2.prev && rt(n2.prev) ? Lt(n2).length : 0), s2 - (n2.next && X(n2.next) ? Se(n2, e2).length : 0)))), z(n2, e2)];
  }
  return r2();
}
function Pt(t2, e2) {
  return $(t2) && $(e2) ? t2.isTrailingSpaceSensitive ? t2.hasTrailingSpaces ? wt(e2) ? S : _ : "" : wt(e2) ? S : v : rt(t2) && (de(e2) || e2.firstChild || e2.isSelfClosing || e2.type === "element" && e2.attrs.length > 0) || t2.type === "element" && t2.isSelfClosing && X(e2) ? "" : !e2.isLeadingSpaceSensitive || wt(e2) || X(e2) && t2.lastChild && Ee(t2.lastChild) && t2.lastChild.lastChild && Ee(t2.lastChild.lastChild) ? S : e2.hasLeadingSpaces ? _ : v;
}
function Re(t2, e2, r2) {
  let { node: n2 } = t2;
  if (Er(n2))
    return [se, ...t2.map((i) => {
      let a = i.node, o2 = a.prev ? Pt(a.prev, a) : "";
      return [o2 ? [o2, Je(a.prev) ? S : ""] : "", ot(i, e2, r2)];
    }, "children")];
  let s2 = n2.children.map(() => Symbol(""));
  return t2.map((i, a) => {
    let o2 = i.node;
    if ($(o2)) {
      if (o2.prev && $(o2.prev)) {
        let A = Pt(o2.prev, o2);
        if (A)
          return Je(o2.prev) ? [S, S, ot(i, e2, r2)] : [A, ot(i, e2, r2)];
      }
      return ot(i, e2, r2);
    }
    let u = [], p = [], l2 = [], f = [], d = o2.prev ? Pt(o2.prev, o2) : "", C = o2.next ? Pt(o2, o2.next) : "";
    return d && (Je(o2.prev) ? u.push(S, S) : d === S ? u.push(S) : $(o2.prev) ? p.push(d) : p.push(pe("", v, { groupId: s2[a - 1] }))), C && (Je(o2) ? $(o2.next) && f.push(S, S) : C === S ? $(o2.next) && f.push(S) : l2.push(C)), [...u, E([...p, E([ot(i, e2, r2), ...l2], { id: s2[a] })]), ...f];
  }, "children");
}
function Cs(t2, e2, r2) {
  let { node: n2 } = t2, s2 = [];
  wa(t2) && s2.push("} "), s2.push("@", n2.name), n2.parameters && s2.push(" (", E(r2("parameters")), ")"), s2.push(" {");
  let i = Ss(n2);
  return n2.children.length > 0 ? (n2.firstChild.hasLeadingSpaces = true, n2.lastChild.hasTrailingSpaces = true, s2.push(k([S, Re(t2, e2, r2)])), i && s2.push(S, "}")) : i && s2.push("}"), E(s2, { shouldBreak: true });
}
function Ss(t2) {
  var e2, r2;
  return !(((e2 = t2.next) == null ? undefined : e2.type) === "angularControlFlowBlock" && ((r2 = ds.get(t2.name)) != null && r2.has(t2.next.name)));
}
function wa(t2) {
  let { previous: e2 } = t2;
  return (e2 == null ? undefined : e2.type) === "angularControlFlowBlock" && !de(e2) && !Ss(e2);
}
function _s(t2, e2, r2) {
  return [k([v, H([";", _], t2.map(r2, "children"))]), v];
}
function Es(t2, e2, r2) {
  let { node: n2 } = t2;
  return [Ae(n2, e2), E([n2.switchValue.trim(), ", ", n2.clause, n2.cases.length > 0 ? [",", k([_, H(_, t2.map(r2, "cases"))])] : "", v]), Ce(n2, e2)];
}
function As(t2, e2, r2) {
  let { node: n2 } = t2;
  return [n2.value, " {", E([k([v, t2.map(({ node: s2, isLast: i }) => {
    let a = [r2()];
    return s2.type === "text" && (s2.hasLeadingSpaces && a.unshift(_), s2.hasTrailingSpaces && !i && a.push(_)), a;
  }, "expression")]), v]), "}"];
}
function Ds(t2, e2, r2) {
  let { node: n2 } = t2;
  if (yt(n2, e2))
    return [G(n2, e2), E(st(t2, e2, r2)), B(Nt(n2, e2)), ...tt(n2, e2), z(n2, e2)];
  let s2 = n2.children.length === 1 && (n2.firstChild.type === "interpolation" || n2.firstChild.type === "angularIcuExpression") && n2.firstChild.isLeadingSpaceSensitive && !n2.firstChild.hasLeadingSpaces && n2.lastChild.isTrailingSpaceSensitive && !n2.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), a = (l2) => E([E(st(t2, e2, r2), { id: i }), l2, tt(n2, e2)]), o2 = (l2) => s2 ? dn(l2, { groupId: i }) : (W(n2) || et(n2, e2)) && n2.parent.type === "root" && e2.parser === "vue" && !e2.vueIndentScriptAndStyle ? l2 : k(l2), u = () => s2 ? pe(v, "", { groupId: i }) : n2.firstChild.hasLeadingSpaces && n2.firstChild.isLeadingSpaceSensitive ? _ : n2.firstChild.type === "text" && n2.isWhitespaceSensitive && n2.isIndentationSensitive ? fn(v) : v, p = () => (n2.next ? X(n2.next) : _e(n2.parent)) ? n2.lastChild.hasTrailingSpaces && n2.lastChild.isTrailingSpaceSensitive ? " " : "" : s2 ? pe(v, "", { groupId: i }) : n2.lastChild.hasTrailingSpaces && n2.lastChild.isTrailingSpaceSensitive ? _ : (n2.lastChild.type === "comment" || n2.lastChild.type === "text" && n2.isWhitespaceSensitive && n2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e2.tabWidth * (t2.ancestors.length - 1)}}$`, "u").test(n2.lastChild.value) ? "" : v;
  return n2.children.length === 0 ? a(n2.hasDanglingSpaces && n2.isDanglingSpaceSensitive ? _ : "") : a([In(n2) ? se : "", o2([u(), Re(t2, e2, r2)]), p()]);
}
function ut(t2) {
  return t2 >= 9 && t2 <= 32 || t2 == 160;
}
function It(t2) {
  return 48 <= t2 && t2 <= 57;
}
function lt2(t2) {
  return t2 >= 97 && t2 <= 122 || t2 >= 65 && t2 <= 90;
}
function vs(t2) {
  return t2 >= 97 && t2 <= 102 || t2 >= 65 && t2 <= 70 || It(t2);
}
function Rt(t2) {
  return t2 === 10 || t2 === 13;
}
function kr(t2) {
  return 48 <= t2 && t2 <= 55;
}
function $t(t2) {
  return t2 === 39 || t2 === 34 || t2 === 96;
}
function ws2(t2) {
  return t2.replace(ba, (...e2) => e2[1].toUpperCase());
}
function xa(t3, e2) {
  for (let r2 of Ta)
    r2(t3, e2);
  return t3;
}
function ka(t3) {
  t3.walk((e2) => {
    if (e2.type === "element" && e2.tagDefinition.ignoreFirstLf && e2.children.length > 0 && e2.children[0].type === "text" && e2.children[0].value[0] === `
`) {
      let r2 = e2.children[0];
      r2.value.length === 1 ? e2.removeChild(r2) : r2.value = r2.value.slice(1);
    }
  });
}
function Ba(t3) {
  let e2 = (r2) => {
    var n2, s2;
    return r2.type === "element" && ((n2 = r2.prev) == null ? undefined : n2.type) === "ieConditionalStartComment" && r2.prev.sourceSpan.end.offset === r2.startSourceSpan.start.offset && ((s2 = r2.firstChild) == null ? undefined : s2.type) === "ieConditionalEndComment" && r2.firstChild.sourceSpan.start.offset === r2.startSourceSpan.end.offset;
  };
  t3.walk((r2) => {
    if (r2.children)
      for (let n2 = 0;n2 < r2.children.length; n2++) {
        let s2 = r2.children[n2];
        if (!e2(s2))
          continue;
        let { prev: i, firstChild: a } = s2;
        r2.removeChild(i), n2--;
        let o2 = new h(i.sourceSpan.start, a.sourceSpan.end), u = new h(o2.start, s2.sourceSpan.end);
        s2.condition = i.condition, s2.sourceSpan = u, s2.startSourceSpan = o2, s2.removeChild(a);
      }
  });
}
function La(t3, e2, r2) {
  t3.walk((n2) => {
    if (n2.children)
      for (let s2 = 0;s2 < n2.children.length; s2++) {
        let i = n2.children[s2];
        if (i.type !== "text" && !e2(i))
          continue;
        i.type !== "text" && (i.type = "text", i.value = r2(i));
        let a = i.prev;
        !a || a.type !== "text" || (a.value += i.value, a.sourceSpan = new h(a.sourceSpan.start, i.sourceSpan.end), n2.removeChild(i), s2--);
      }
  });
}
function Fa(t3) {
  return La(t3, (e2) => e2.type === "cdata", (e2) => `<![CDATA[${e2.value}]]>`);
}
function Na(t3) {
  let e2 = (r2) => {
    var n2, s2;
    return r2.type === "element" && r2.attrs.length === 0 && r2.children.length === 1 && r2.firstChild.type === "text" && !O.hasWhitespaceCharacter(r2.children[0].value) && !r2.firstChild.hasLeadingSpaces && !r2.firstChild.hasTrailingSpaces && r2.isLeadingSpaceSensitive && !r2.hasLeadingSpaces && r2.isTrailingSpaceSensitive && !r2.hasTrailingSpaces && ((n2 = r2.prev) == null ? undefined : n2.type) === "text" && ((s2 = r2.next) == null ? undefined : s2.type) === "text";
  };
  t3.walk((r2) => {
    if (r2.children)
      for (let n2 = 0;n2 < r2.children.length; n2++) {
        let s2 = r2.children[n2];
        if (!e2(s2))
          continue;
        let { prev: i, next: a } = s2;
        i.value += `<${s2.rawName}>` + s2.firstChild.value + `</${s2.rawName}>` + a.value, i.sourceSpan = new h(i.sourceSpan.start, a.sourceSpan.end), i.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i.hasTrailingSpaces = a.hasTrailingSpaces, r2.removeChild(s2), n2--, r2.removeChild(a);
      }
  });
}
function Pa(t3, e2) {
  if (e2.parser === "html")
    return;
  let r2 = /\{\{(.+?)\}\}/su;
  t3.walk((n2) => {
    if (Bn(n2))
      for (let s2 of n2.children) {
        if (s2.type !== "text")
          continue;
        let i = s2.sourceSpan.start, a = null, o2 = s2.value.split(r2);
        for (let u = 0;u < o2.length; u++, i = a) {
          let p = o2[u];
          if (u % 2 === 0) {
            a = i.moveBy(p.length), p.length > 0 && n2.insertChildBefore(s2, { type: "text", value: p, sourceSpan: new h(i, a) });
            continue;
          }
          a = i.moveBy(p.length + 4), n2.insertChildBefore(s2, { type: "interpolation", sourceSpan: new h(i, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new h(i.moveBy(2), a.moveBy(-2)) }] });
        }
        n2.removeChild(s2);
      }
  });
}
function Ia(t3) {
  t3.walk((e2) => {
    let r2 = e2.$children;
    if (!r2)
      return;
    if (r2.length === 0 || r2.length === 1 && r2[0].type === "text" && O.trim(r2[0].value).length === 0) {
      e2.hasDanglingSpaces = r2.length > 0, e2.$children = [];
      return;
    }
    let n2 = Ln(e2), s2 = _r(e2);
    if (!n2)
      for (let i = 0;i < r2.length; i++) {
        let a = r2[i];
        if (a.type !== "text")
          continue;
        let { leadingWhitespace: o2, text: u, trailingWhitespace: p } = kn(a.value), l2 = a.prev, f = a.next;
        u ? (a.value = u, a.sourceSpan = new h(a.sourceSpan.start.moveBy(o2.length), a.sourceSpan.end.moveBy(-p.length)), o2 && (l2 && (l2.hasTrailingSpaces = true), a.hasLeadingSpaces = true), p && (a.hasTrailingSpaces = true, f && (f.hasLeadingSpaces = true))) : (e2.removeChild(a), i--, (o2 || p) && (l2 && (l2.hasTrailingSpaces = true), f && (f.hasLeadingSpaces = true)));
      }
    e2.isWhitespaceSensitive = n2, e2.isIndentationSensitive = s2;
  });
}
function Ra(t3) {
  t3.walk((e2) => {
    e2.isSelfClosing = !e2.children || e2.type === "element" && (e2.tagDefinition.isVoid || e2.endSourceSpan && e2.startSourceSpan.start === e2.endSourceSpan.start && e2.startSourceSpan.end === e2.endSourceSpan.end);
  });
}
function $a(t3, e2) {
  t3.walk((r2) => {
    r2.type === "element" && (r2.hasHtmComponentClosingTag = r2.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e2.originalText.slice(r2.endSourceSpan.start.offset, r2.endSourceSpan.end.offset)));
  });
}
function Oa(t3, e2) {
  t3.walk((r2) => {
    r2.cssDisplay = Hn(r2, e2);
  });
}
function Ma(t3, e2) {
  t3.walk((r2) => {
    let { children: n2 } = r2;
    if (n2) {
      if (n2.length === 0) {
        r2.isDanglingSpaceSensitive = Pn(r2);
        return;
      }
      for (let s2 of n2)
        s2.isLeadingSpaceSensitive = Fn(s2, e2), s2.isTrailingSpaceSensitive = Nn(s2, e2);
      for (let s2 = 0;s2 < n2.length; s2++) {
        let i = n2[s2];
        i.isLeadingSpaceSensitive = (s2 === 0 || i.prev.isTrailingSpaceSensitive) && i.isLeadingSpaceSensitive, i.isTrailingSpaceSensitive = (s2 === n2.length - 1 || i.next.isLeadingSpaceSensitive) && i.isTrailingSpaceSensitive;
      }
    }
  });
}
function qa(t3, e2, r2) {
  let { node: n2 } = t3;
  switch (n2.type) {
    case "front-matter":
      return B(n2.raw);
    case "root":
      return e2.__onHtmlRoot && e2.__onHtmlRoot(n2), [E(Re(t3, e2, r2)), S];
    case "element":
    case "ieConditionalComment":
      return Ds(t3, e2, r2);
    case "angularControlFlowBlock":
      return Cs(t3, e2, r2);
    case "angularControlFlowBlockParameters":
      return _s(t3, e2, r2);
    case "angularControlFlowBlockParameter":
      return O.trim(n2.expression);
    case "angularLetDeclaration":
      return E(["@let ", E([n2.id, " =", E(k([_, r2("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return n2.value;
    case "angularIcuExpression":
      return Es(t3, e2, r2);
    case "angularIcuCase":
      return As(t3, e2, r2);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [Ae(n2), Ce(n2)];
    case "interpolation":
      return [Ae(n2, e2), ...t3.map(r2, "children"), Ce(n2, e2)];
    case "text": {
      if (n2.parent.type === "interpolation") {
        let o2 = /\n[^\S\n]*$/u, u = o2.test(n2.value), p = u ? n2.value.replace(o2, "") : n2.value;
        return [B(p), u ? S : ""];
      }
      let s2 = G(n2, e2), i = xt(n2), a = z(n2, e2);
      return i[0] = [s2, i[0]], i.push([i.pop(), a]), Dt(i);
    }
    case "docType":
      return [E([Ae(n2, e2), " ", w(false, n2.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), Ce(n2, e2)];
    case "comment":
      return [G(n2, e2), B(e2.originalText.slice(J(n2), Z(n2))), z(n2, e2)];
    case "attribute": {
      if (n2.value === null)
        return n2.rawName;
      let s2 = vr(n2.value), i = Cn(s2, '"');
      return [n2.rawName, "=", i, B(i === '"' ? w(false, s2, '"', "&quot;") : w(false, s2, "'", "&apos;")), i];
    }
    case "cdata":
    default:
      throw new _n(n2, "HTML");
  }
}
function ct(t3, e2 = true) {
  if (t3[0] != ":")
    return [null, t3];
  let r2 = t3.indexOf(":", 1);
  if (r2 === -1) {
    if (e2)
      throw new Error(`Unsupported format "${t3}" expecting ":namespace:name"`);
    return [null, t3];
  }
  return [t3.slice(1, r2), t3.slice(r2 + 1)];
}
function Nr(t3) {
  return ct(t3)[1] === "ng-container";
}
function Pr(t3) {
  return ct(t3)[1] === "ng-content";
}
function Me(t3) {
  return t3 === null ? null : ct(t3)[0];
}
function qe(t3, e2) {
  return t3 ? `:${t3}:${e2}` : e2;
}
function Ir() {
  return qt || (qt = {}, Mt(ee.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), Mt(ee.STYLE, ["*|style"]), Mt(ee.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), Mt(ee.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), qt;
}
function Mt(t3, e2) {
  for (let r2 of e2)
    qt[r2.toLowerCase()] = t3;
}
function Ka(t3) {
  switch (t3) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
function He(t3) {
  return pt || (Rs = new m({ canSelfClose: true }), pt = Object.assign(Object.create(null), { base: new m({ isVoid: true }), meta: new m({ isVoid: true }), area: new m({ isVoid: true }), embed: new m({ isVoid: true }), link: new m({ isVoid: true }), img: new m({ isVoid: true }), input: new m({ isVoid: true }), param: new m({ isVoid: true }), hr: new m({ isVoid: true }), br: new m({ isVoid: true }), source: new m({ isVoid: true }), track: new m({ isVoid: true }), wbr: new m({ isVoid: true }), p: new m({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new m({ closedByChildren: ["tbody", "tfoot"] }), tbody: new m({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new m({ closedByChildren: ["tbody"], closedByParent: true }), tr: new m({ closedByChildren: ["tr"], closedByParent: true }), td: new m({ closedByChildren: ["td", "th"], closedByParent: true }), th: new m({ closedByChildren: ["td", "th"], closedByParent: true }), col: new m({ isVoid: true }), svg: new m({ implicitNamespacePrefix: "svg" }), foreignObject: new m({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new m({ implicitNamespacePrefix: "math" }), li: new m({ closedByChildren: ["li"], closedByParent: true }), dt: new m({ closedByChildren: ["dt", "dd"] }), dd: new m({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new m({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new m({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new m({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new m({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new m({ closedByChildren: ["optgroup"], closedByParent: true }), option: new m({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new m({ ignoreFirstLf: true }), listing: new m({ ignoreFirstLf: true }), style: new m({ contentType: P.RAW_TEXT }), script: new m({ contentType: P.RAW_TEXT }), title: new m({ contentType: { default: P.ESCAPABLE_RAW_TEXT, svg: P.PARSABLE_DATA } }), textarea: new m({ contentType: P.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Vt().allKnownElementNames().forEach((e2) => {
    !pt[e2] && Me(e2) === null && (pt[e2] = new m({ canSelfClose: false }));
  })), pt[t3] ?? Rs;
}
function Qt(t3, e2, r2 = null) {
  let n2 = [], s2 = t3.visit ? (i) => t3.visit(i, r2) || i.visit(t3, r2) : (i) => i.visit(t3, r2);
  return e2.forEach((i) => {
    let a = s2(i);
    a && n2.push(a);
  }), n2;
}
function $s(t3, e2) {
  if (e2 != null && !(Array.isArray(e2) && e2.length == 2))
    throw new Error(`Expected '${t3}' to be an array, [start, end].`);
  if (e2 != null) {
    let r2 = e2[0], n2 = e2[1];
    Ja.forEach((s2) => {
      if (s2.test(r2) || s2.test(n2))
        throw new Error(`['${r2}', '${n2}'] contains unusable interpolation symbol.`);
    });
  }
}
function Qs(t4, e2, r2, n2 = {}) {
  let s2 = new Ur(new De(t4, e2), r2, n2);
  return s2.tokenize(), new Vr(wo(s2.tokens), s2.errors, s2.nonNormalizedIcuExpressions);
}
function Ue(t4) {
  return `Unexpected character "${t4 === 0 ? "EOF" : String.fromCharCode(t4)}"`;
}
function Vs(t4) {
  return `Unknown entity "${t4}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function _o(t4, e2) {
  return `Unable to parse entity "${e2}" - ${t4} character reference entities must end with ";"`;
}
function b(t4) {
  return !ut(t4) || t4 === 0;
}
function Us(t4) {
  return ut(t4) || t4 === 62 || t4 === 60 || t4 === 47 || t4 === 39 || t4 === 34 || t4 === 61 || t4 === 0;
}
function Eo(t4) {
  return (t4 < 97 || 122 < t4) && (t4 < 65 || 90 < t4) && (t4 < 48 || t4 > 57);
}
function Ao(t4) {
  return t4 === 59 || t4 === 0 || !vs(t4);
}
function Do(t4) {
  return t4 === 59 || t4 === 0 || !lt2(t4);
}
function vo(t4) {
  return t4 !== 125;
}
function yo(t4, e2) {
  return Ws(t4) === Ws(e2);
}
function Ws(t4) {
  return t4 >= 97 && t4 <= 122 ? t4 - 97 + 65 : t4;
}
function zs(t4) {
  return lt2(t4) || It(t4) || t4 === 95;
}
function Gs(t4) {
  return t4 !== 59 && b(t4);
}
function wo(t4) {
  let e2 = [], r2;
  for (let n2 = 0;n2 < t4.length; n2++) {
    let s2 = t4[n2];
    r2 && r2.type === 5 && s2.type === 5 || r2 && r2.type === 16 && s2.type === 16 ? (r2.parts[0] += s2.parts[0], r2.sourceSpan.end = s2.sourceSpan.end) : (r2 = s2, e2.push(r2));
  }
  return e2;
}
function Xs(t8, e2) {
  return t8.length > 0 && t8[t8.length - 1] === e2;
}
function Js(t8, e2) {
  return Ve[e2] !== undefined ? Ve[e2] || t8 : /^#x[a-f0-9]+$/i.test(e2) ? String.fromCodePoint(parseInt(e2.slice(2), 16)) : /^#\d+$/.test(e2) ? String.fromCodePoint(parseInt(e2.slice(1), 10)) : t8;
}
function Qr(t8, e2 = {}) {
  let { canSelfClose: r2 = false, allowHtmComponentClosingTags: n2 = false, isTagNameCaseSensitive: s2 = false, getTagContentType: i, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o2 = false } = e2;
  return bo().parse(t8, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: undefined, canSelfClose: r2, allowHtmComponentClosingTags: n2, tokenizeBlocks: a, tokenizeLet: o2 }, s2, i);
}
function To(t8, e2) {
  let r2 = new SyntaxError(t8 + " (" + e2.loc.start.line + ":" + e2.loc.start.column + ")");
  return Object.assign(r2, e2);
}
function xo(t8) {
  let e2 = t8.slice(0, _t);
  if (e2 !== "---" && e2 !== "+++")
    return;
  let r2 = t8.indexOf(`
`, _t);
  if (r2 === -1)
    return;
  let n2 = t8.slice(_t, r2).trim(), s2 = t8.indexOf(`
${e2}`, r2), i = n2;
  if (i || (i = e2 === "+++" ? "toml" : "yaml"), s2 === -1 && e2 === "---" && i === "yaml" && (s2 = t8.indexOf(`
...`, r2)), s2 === -1)
    return;
  let a = s2 + 1 + _t, o2 = t8.charAt(a + 1);
  if (!/\s?/u.test(o2))
    return;
  let u = t8.slice(0, a);
  return { type: "front-matter", language: i, explicitLanguage: n2, value: t8.slice(r2 + 1, s2), startDelimiter: e2, endDelimiter: u.slice(-_t), raw: u };
}
function ko(t8) {
  let e2 = xo(t8);
  if (!e2)
    return { content: t8 };
  let { raw: r2 } = e2;
  return { frontMatter: e2, content: w(false, r2, /[^\n]/gu, " ") + t8.slice(r2.length) };
}
function Bo(t8, e2) {
  let r2 = t8.map(e2);
  return r2.some((n2, s2) => n2 !== t8[s2]) ? r2 : t8;
}
function ri(t8, e2) {
  if (t8.value)
    for (let { regex: r2, parse: n2 } of Lo) {
      let s2 = t8.value.match(r2);
      if (s2)
        return n2(t8, e2, s2);
    }
  return null;
}
function Fo(t8, e2, r2) {
  let [, n2, s2, i] = r2, a = 4 + n2.length, o2 = t8.sourceSpan.start.moveBy(a), u = o2.moveBy(i.length), [p, l2] = (() => {
    try {
      return [true, e2(i, o2).children];
    } catch {
      return [false, [{ type: "text", value: i, sourceSpan: new h(o2, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: p, children: l2, condition: w(false, s2.trim(), /\s+/gu, " "), sourceSpan: t8.sourceSpan, startSourceSpan: new h(t8.sourceSpan.start, o2), endSourceSpan: new h(u, t8.sourceSpan.end) };
}
function No(t8, e2, r2) {
  let [, n2] = r2;
  return { type: "ieConditionalStartComment", condition: w(false, n2.trim(), /\s+/gu, " "), sourceSpan: t8.sourceSpan };
}
function Po(t8) {
  return { type: "ieConditionalEndComment", sourceSpan: t8.sourceSpan };
}
function Io(t8) {
  if (t8.type === "block") {
    if (t8.name = w(false, t8.name.toLowerCase(), /\s+/gu, " ").trim(), t8.type = "angularControlFlowBlock", !Ie(t8.parameters)) {
      delete t8.parameters;
      return;
    }
    for (let e2 of t8.parameters)
      e2.type = "angularControlFlowBlockParameter";
    t8.parameters = { type: "angularControlFlowBlockParameters", children: t8.parameters, sourceSpan: new h(t8.parameters[0].sourceSpan.start, K(false, t8.parameters, -1).sourceSpan.end) };
  }
}
function Ro(t8) {
  t8.type === "letDeclaration" && (t8.type = "angularLetDeclaration", t8.id = t8.name, t8.init = { type: "angularLetDeclarationInitializer", sourceSpan: new h(t8.valueSpan.start, t8.valueSpan.end), value: t8.value }, delete t8.name, delete t8.value);
}
function $o(t8) {
  (t8.type === "plural" || t8.type === "select") && (t8.clause = t8.type, t8.type = "angularIcuExpression"), t8.type === "expansionCase" && (t8.type = "angularIcuCase");
}
function ii(t8, e2, r2) {
  let { name: n2, canSelfClose: s2 = true, normalizeTagName: i = false, normalizeAttributeName: a = false, allowHtmComponentClosingTags: o2 = false, isTagNameCaseSensitive: u = false, shouldParseAsRawText: p } = e2, { rootNodes: l2, errors: f } = Qr(t8, { canSelfClose: s2, allowHtmComponentClosingTags: o2, isTagNameCaseSensitive: u, getTagContentType: p ? (...c2) => p(...c2) ? P.RAW_TEXT : undefined : undefined, tokenizeAngularBlocks: n2 === "angular" ? true : undefined, tokenizeAngularLetDeclaration: n2 === "angular" ? true : undefined });
  if (n2 === "vue") {
    if (l2.some((x) => x.type === "docType" && x.value === "html" || x.type === "element" && x.name.toLowerCase() === "html"))
      return ii(t8, oi, r2);
    let g, y = () => g ?? (g = Qr(t8, { canSelfClose: s2, allowHtmComponentClosingTags: o2, isTagNameCaseSensitive: u })), q = (x) => y().rootNodes.find(({ startSourceSpan: U }) => U && U.start.offset === x.startSourceSpan.start.offset) ?? x;
    for (let [x, U] of l2.entries()) {
      let { endSourceSpan: tn, startSourceSpan: ui } = U;
      if (tn === null)
        f = y().errors, l2[x] = q(U);
      else if (Oo(U, r2)) {
        let rn = y().errors.find((nn) => nn.span.start.offset > ui.start.offset && nn.span.start.offset < tn.end.offset);
        rn && si(rn), l2[x] = q(U);
      }
    }
  }
  f.length > 0 && si(f[0]);
  let d = (c2) => {
    let g = c2.name.startsWith(":") ? c2.name.slice(1).split(":")[0] : null, y = c2.nameSpan.toString(), q = g !== null && y.startsWith(`${g}:`), x = q ? y.slice(g.length + 1) : y;
    c2.name = x, c2.namespace = g, c2.hasExplicitNamespace = q;
  }, C = (c2) => {
    switch (c2.type) {
      case "element":
        d(c2);
        for (let g of c2.attrs)
          d(g), g.valueSpan ? (g.value = g.valueSpan.toString(), /["']/u.test(g.value[0]) && (g.value = g.value.slice(1, -1))) : g.value = null;
        break;
      case "comment":
        c2.value = c2.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        c2.value = c2.sourceSpan.toString();
        break;
    }
  }, A = (c2, g) => {
    let y = c2.toLowerCase();
    return g(y) ? y : c2;
  }, D = (c2) => {
    if (c2.type === "element" && (i && (!c2.namespace || c2.namespace === c2.tagDefinition.implicitNamespacePrefix || fe(c2)) && (c2.name = A(c2.name, (g) => ni.has(g))), a))
      for (let g of c2.attrs)
        g.namespace || (g.name = A(g.name, (y) => or2.has(c2.name) && (or2.get("*").has(y) || or2.get(c2.name).has(y))));
  }, I2 = (c2) => {
    c2.sourceSpan && c2.endSourceSpan && (c2.sourceSpan = new h(c2.sourceSpan.start, c2.endSourceSpan.end));
  }, F = (c2) => {
    if (c2.type === "element") {
      let g = He(u ? c2.name : c2.name.toLowerCase());
      !c2.namespace || c2.namespace === g.implicitNamespacePrefix || fe(c2) ? c2.tagDefinition = g : c2.tagDefinition = He("");
    }
  };
  return Qt(new class extends mt {
    visitExpansionCase(c2, g) {
      n2 === "angular" && this.visitChildren(g, (y) => {
        y(c2.expression);
      });
    }
    visit(c2) {
      C(c2), F(c2), D(c2), I2(c2);
    }
  }, l2), l2;
}
function Oo(t8, e2) {
  var n2;
  if (t8.type !== "element" || t8.name !== "template")
    return false;
  let r2 = (n2 = t8.attrs.find((s2) => s2.name === "lang")) == null ? undefined : n2.value;
  return !r2 || Ne(e2, { language: r2 }) === "html";
}
function si(t8) {
  let { msg: e2, span: { start: r2, end: n2 } } = t8;
  throw Zs(e2, { loc: { start: { line: r2.line + 1, column: r2.col + 1 }, end: { line: n2.line + 1, column: n2.col + 1 } }, cause: t8 });
}
function ai(t8, e2, r2 = {}, n2 = true) {
  let { frontMatter: s2, content: i } = n2 ? ei(t8) : { frontMatter: null, content: t8 }, a = new De(t8, r2.filepath), o2 = new ie(a, 0, 0, 0), u = o2.moveBy(t8.length), p = { type: "root", sourceSpan: new h(o2, u), children: ii(i, e2, r2) };
  if (s2) {
    let d = new ie(a, 0, 0, 0), C = d.moveBy(s2.raw.length);
    s2.sourceSpan = new h(d, C), p.children.unshift(s2);
  }
  let l2 = new ar(p), f = (d, C) => {
    let { offset: A } = C, D = w(false, t8.slice(0, A), /[^\n\r]/gu, " "), F = ai(D + d, e2, r2, false);
    F.sourceSpan = new h(C, K(false, F.children, -1).sourceSpan.end);
    let c2 = F.children[0];
    return c2.length === A ? F.children.shift() : (c2.sourceSpan = new h(c2.sourceSpan.start.moveBy(A), c2.sourceSpan.end), c2.value = c2.value.slice(A)), F;
  };
  return l2.walk((d) => {
    if (d.type === "comment") {
      let C = ri(d, f);
      C && d.parent.replaceChild(d, C);
    }
    Io(d), Ro(d), $o(d);
  }), l2;
}
function ur(t8) {
  return { parse: (e2, r2) => ai(e2, t8, r2), hasPragma: fs, astFormat: "html", locStart: J, locEnd: Z };
}
var sn, an = (t2) => {
  throw TypeError(t2);
}, li = (t2, e2, r2) => (e2 in t2) ? sn(t2, e2, { enumerable: true, configurable: true, writable: true, value: r2 }) : t2[e2] = r2, on = (t2, e2) => {
  for (var r2 in e2)
    sn(t2, r2, { get: e2[r2], enumerable: true });
}, lr = (t2, e2, r2) => li(t2, typeof e2 != "symbol" ? e2 + "" : e2, r2), un = (t2, e2, r2) => e2.has(t2) || an("Cannot " + r2), R = (t2, e2, r2) => (un(t2, e2, "read from private field"), r2 ? r2.call(t2) : e2.get(t2)), Et = (t2, e2, r2) => e2.has(t2) ? an("Cannot add the same private member more than once") : e2 instanceof WeakSet ? e2.add(t2) : e2.set(t2, r2), ln = (t2, e2, r2, n2) => (un(t2, e2, "write to private field"), n2 ? n2.call(t2, r2) : e2.set(t2, r2), r2), en, ci = (t2, e2, r2, n2) => {
  if (!(t2 && e2 == null))
    return e2.replaceAll ? e2.replaceAll(r2, n2) : r2.global ? e2.replace(r2, n2) : e2.split(r2).join(n2);
}, w, ye = "string", Ge = "array", Ye = "cursor", we = "indent", be = "align", je = "trim", Te = "group", xe = "fill", ce = "if-break", ke = "indent-if-break", Ke = "line-suffix", Qe = "line-suffix-boundary", j = "line", Xe = "label", Be = "break-parent", At, pi = (t2, e2, r2) => {
  if (!(t2 && e2 == null))
    return Array.isArray(e2) || typeof e2 == "string" ? e2[r2 < 0 ? e2.length + r2 : r2] : e2.at(r2);
}, K, Le, fi = (t2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t2), cr, pr, fr = () => {}, ne2, mr, pn, se, gi, Ci, _, v, S, cn, vt = "'", gn = '"', Cn, V2, gr = class {
  constructor(e2) {
    Et(this, V2);
    ln(this, V2, new Set(e2));
  }
  getLeadingWhitespaceCount(e2) {
    let r2 = R(this, V2), n2 = 0;
    for (let s2 = 0;s2 < e2.length && r2.has(e2.charAt(s2)); s2++)
      n2++;
    return n2;
  }
  getTrailingWhitespaceCount(e2) {
    let r2 = R(this, V2), n2 = 0;
    for (let s2 = e2.length - 1;s2 >= 0 && r2.has(e2.charAt(s2)); s2--)
      n2++;
    return n2;
  }
  getLeadingWhitespace(e2) {
    let r2 = this.getLeadingWhitespaceCount(e2);
    return e2.slice(0, r2);
  }
  getTrailingWhitespace(e2) {
    let r2 = this.getTrailingWhitespaceCount(e2);
    return e2.slice(e2.length - r2);
  }
  hasLeadingWhitespace(e2) {
    return R(this, V2).has(e2.charAt(0));
  }
  hasTrailingWhitespace(e2) {
    return R(this, V2).has(K(false, e2, -1));
  }
  trimStart(e2) {
    let r2 = this.getLeadingWhitespaceCount(e2);
    return e2.slice(r2);
  }
  trimEnd(e2) {
    let r2 = this.getTrailingWhitespaceCount(e2);
    return e2.slice(0, e2.length - r2);
  }
  trim(e2) {
    return this.trimEnd(this.trimStart(e2));
  }
  split(e2, r2 = false) {
    let n2 = `[${dr([...R(this, V2)].join(""))}]+`, s2 = new RegExp(r2 ? `(${n2})` : n2, "u");
    return e2.split(s2);
  }
  hasWhitespaceCharacter(e2) {
    let r2 = R(this, V2);
    return Array.prototype.some.call(e2, (n2) => r2.has(n2));
  }
  hasNonWhitespaceCharacter(e2) {
    let r2 = R(this, V2);
    return Array.prototype.some.call(e2, (n2) => !r2.has(n2));
  }
  isWhitespaceOnly(e2) {
    let r2 = R(this, V2);
    return Array.prototype.every.call(e2, (n2) => r2.has(n2));
  }
}, Sn, _i, Ei, O, Cr, _n, Fe, Di, vi, An, Dn, vn, bi = (t2) => String(t2).split(/[/\\]/u).pop(), Ne, wn = "inline", bn, Tn = "normal", xn, fe, Bi = (t2) => w(false, t2, /^[\t\f\r ]*\n/gu, ""), Sr = (t2) => Bi(O.trimEnd(t2)), kn = (t2) => {
  let e2 = t2, r2 = O.getLeadingWhitespace(e2);
  r2 && (e2 = e2.slice(r2.length));
  let n2 = O.getTrailingWhitespace(e2);
  return n2 && (e2 = e2.slice(0, -n2.length)), { leadingWhitespace: r2, trailingWhitespace: n2, text: e2 };
}, Wi, yr, zi, Gi, Yi, Gn, Yn, Qi, Xi, Ji, Zi, Kn, ea, Qn, Xn, na, Jn, br, Pe, ss, is3, as, Tr, Ie, os = "<!doctype", Nt, _a2, ls, it = null, Aa = 10, cs, va, ps, ya, hs, ds, ba, ie = class t2 {
  constructor(e2, r2, n2, s2) {
    this.file = e2, this.offset = r2, this.line = n2, this.col = s2;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e2) {
    let r2 = this.file.content, n2 = r2.length, s2 = this.offset, i = this.line, a = this.col;
    for (;s2 > 0 && e2 < 0; )
      if (s2--, e2++, r2.charCodeAt(s2) == 10) {
        i--;
        let u = r2.substring(0, s2 - 1).lastIndexOf(String.fromCharCode(10));
        a = u > 0 ? s2 - u : s2;
      } else
        a--;
    for (;s2 < n2 && e2 > 0; ) {
      let o2 = r2.charCodeAt(s2);
      s2++, e2--, o2 == 10 ? (i++, a = 0) : a++;
    }
    return new t2(this.file, s2, i, a);
  }
  getContext(e2, r2) {
    let n2 = this.file.content, s2 = this.offset;
    if (s2 != null) {
      s2 > n2.length - 1 && (s2 = n2.length - 1);
      let i = s2, a = 0, o2 = 0;
      for (;a < e2 && s2 > 0 && (s2--, a++, !(n2[s2] == `
` && ++o2 == r2)); )
        ;
      for (a = 0, o2 = 0;a < e2 && i < n2.length - 1 && (i++, a++, !(n2[i] == `
` && ++o2 == r2)); )
        ;
      return { before: n2.substring(s2, this.offset), after: n2.substring(this.offset, i + 1) };
    }
    return null;
  }
}, De = class {
  constructor(e2, r2) {
    this.content = e2, this.url = r2;
  }
}, h = class {
  constructor(e2, r2, n2 = e2, s2 = null) {
    this.start = e2, this.end = r2, this.fullStart = n2, this.details = s2;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, Ot, Oe = class {
  constructor(e2, r2, n2 = Ot.ERROR) {
    this.span = e2, this.msg = r2, this.level = n2;
  }
  contextualMessage() {
    let e2 = this.span.start.getContext(100, 3);
    return e2 ? `${this.msg} ("${e2.before}[${Ot[this.level]} ->]${e2.after}")` : this.msg;
  }
  toString() {
    let e2 = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e2}`;
  }
}, Ta, bs, Ha, Ts, xs, Br, ks = "HTML", Va, Bs, Zr, xp, Ls, Fs, Ns, Lr, Fr, ee, Ps, P, qt, Ht = class {
}, Ua = "boolean", Wa = "number", za = "string", Ga = "object", Ya, Is, ja, Vt, m = class {
  constructor({ closedByChildren: e2, implicitNamespacePrefix: r2, contentType: n2 = P.PARSABLE_DATA, closedByParent: s2 = false, isVoid: i = false, ignoreFirstLf: a = false, preventNamespaceInheritance: o2 = false, canSelfClose: u = false } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, e2 && e2.length > 0 && e2.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i, this.closedByParent = s2 || i, this.implicitNamespacePrefix = r2 || null, this.contentType = n2, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o2, this.canSelfClose = u ?? i;
  }
  isClosedByChild(e2) {
    return this.isVoid || e2.toLowerCase() in this.closedByChildren;
  }
  getContentType(e2) {
    return typeof this.contentType == "object" ? (e2 === undefined ? undefined : this.contentType[e2]) ?? this.contentType.default : this.contentType;
  }
}, Rs, pt, ae = class {
  constructor(e2, r2) {
    this.sourceSpan = e2, this.i18n = r2;
  }
}, Ut, Wt, zt, Gt = class {
  constructor(e2, r2, n2, s2, i) {
    this.value = e2, this.expression = r2, this.sourceSpan = n2, this.valueSourceSpan = s2, this.expSourceSpan = i, this.type = "expansionCase";
  }
  visit(e2, r2) {
    return e2.visitExpansionCase(this, r2);
  }
}, Yt, Y, jt = class {
  constructor(e2, r2) {
    this.value = e2, this.sourceSpan = r2, this.type = "comment";
  }
  visit(e2, r2) {
    return e2.visitComment(this, r2);
  }
}, Kt = class {
  constructor(e2, r2) {
    this.value = e2, this.sourceSpan = r2, this.type = "docType";
  }
  visit(e2, r2) {
    return e2.visitDocType(this, r2);
  }
}, te, ht = class {
  constructor(e2, r2) {
    this.expression = e2, this.sourceSpan = r2, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e2, r2) {
    return e2.visitBlockParameter(this, r2);
  }
}, ft = class {
  constructor(e2, r2, n2, s2, i) {
    this.name = e2, this.value = r2, this.sourceSpan = n2, this.nameSpan = s2, this.valueSpan = i, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e2, r2) {
    return e2.visitLetDeclaration(this, r2);
  }
}, mt = class {
  constructor() {}
  visitElement(e2, r2) {
    this.visitChildren(r2, (n2) => {
      n2(e2.attrs), n2(e2.children);
    });
  }
  visitAttribute(e2, r2) {}
  visitText(e2, r2) {}
  visitCdata(e2, r2) {}
  visitComment(e2, r2) {}
  visitDocType(e2, r2) {}
  visitExpansion(e2, r2) {
    return this.visitChildren(r2, (n2) => {
      n2(e2.cases);
    });
  }
  visitExpansionCase(e2, r2) {}
  visitBlock(e2, r2) {
    this.visitChildren(r2, (n2) => {
      n2(e2.parameters), n2(e2.children);
    });
  }
  visitBlockParameter(e2, r2) {}
  visitLetDeclaration(e2, r2) {}
  visitChildren(e2, r2) {
    let n2 = [], s2 = this;
    function i(a) {
      a && n2.push(Qt(s2, a, e2));
    }
    return r2(i), Array.prototype.concat.apply([], n2);
  }
}, Ve, Xa = "\uE500", Ja, Rr = class t3 {
  static fromArray(e2) {
    return e2 ? ($s("interpolation", e2), new t3(e2[0], e2[1])) : $r;
  }
  constructor(e2, r2) {
    this.start = e2, this.end = r2;
  }
}, $r, gt2, Vr = class {
  constructor(e2, r2, n2) {
    this.tokens = e2, this.errors = r2, this.nonNormalizedIcuExpressions = n2;
  }
}, So, tr, Ct = class {
  constructor(e2) {
    this.error = e2;
  }
}, Ur = class {
  constructor(e2, r2, n2) {
    this._getTagContentType = r2, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n2.tokenizeExpansionForms || false, this._interpolationConfig = n2.interpolationConfig || $r, this._leadingTriviaCodePoints = n2.leadingTriviaChars && n2.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = n2.canSelfClose || false, this._allowHtmComponentClosingTags = n2.allowHtmComponentClosingTags || false;
    let s2 = n2.range || { endPos: e2.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n2.escapedString ? new Wr(e2, s2) : new rr(e2, s2), this._preserveLineEndings = n2.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = n2.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = n2.tokenizeBlocks ?? true, this._tokenizeLet = n2.tokenizeLet ?? true;
    try {
      this._cursor.init();
    } catch (i) {
      this.handleError(i);
    }
  }
  _processCarriageReturns(e2) {
    return this._preserveLineEndings ? e2 : e2.replace(So, `
`);
  }
  tokenize() {
    for (;this._cursor.peek() !== 0; ) {
      let e2 = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e2) : this._attemptStr("--") ? this._consumeComment(e2) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e2) : this._consumeBogusComment(e2);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e2);
          else {
            let r2 = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r2, this._consumeBogusComment(e2)) : this._consumeTagOpen(e2);
          }
        else
          this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e2) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e2) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e2) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r2) {
        this.handleError(r2);
      }
    }
    this._beginToken(34), this._endToken([]);
  }
  _getBlockName() {
    let e2 = false, r2 = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n2) => ut(n2) ? !e2 : zs(n2) ? (e2 = true, false) : true), this._cursor.getChars(r2).trim();
  }
  _consumeBlockStart(e2) {
    this._beginToken(25, e2);
    let r2 = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(b);
      else {
        r2.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r2.type = 29;
  }
  _consumeBlockEnd(e2) {
    this._beginToken(27, e2), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(Gs);this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e2 = this._cursor.clone(), r2 = null, n2 = 0;
      for (;this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r2 !== null; ) {
        let s2 = this._cursor.peek();
        if (s2 === 92)
          this._cursor.advance();
        else if (s2 === r2)
          r2 = null;
        else if (r2 === null && $t(s2))
          r2 = s2;
        else if (s2 === 40 && r2 === null)
          n2++;
        else if (s2 === 41 && r2 === null) {
          if (n2 === 0)
            break;
          n2 > 0 && n2--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e2)]), this._attemptCharCodeUntilFn(Gs);
    }
  }
  _consumeLetDeclaration(e2) {
    if (this._beginToken(30, e2), ut(this._cursor.peek()))
      this._attemptCharCodeUntilFn(b);
    else {
      let s2 = this._endToken([this._cursor.getChars(e2)]);
      s2.type = 33;
      return;
    }
    let r2 = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(b), !this._attemptCharCode(61)) {
      r2.type = 33;
      return;
    }
    this._attemptCharCodeUntilFn((s2) => b(s2) && !Rt(s2)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r2.type = 33, r2.sourceSpan = this._cursor.getSpan(e2));
  }
  _getLetDeclarationName() {
    let e2 = this._cursor.clone(), r2 = false;
    return this._attemptCharCodeUntilFn((n2) => lt2(n2) || n2 === 36 || n2 === 95 || r2 && It(n2) ? (r2 = true, false) : true), this._cursor.getChars(e2).trim();
  }
  _consumeLetDeclarationValue() {
    let e2 = this._cursor.clone();
    for (this._beginToken(31, e2);this._cursor.peek() !== 0; ) {
      let r2 = this._cursor.peek();
      if (r2 === 59)
        break;
      $t(r2) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n2) => n2 === 92 ? (this._cursor.advance(), false) : n2 === r2)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e2)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), true;
    if (vo(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), true;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), true;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), true;
    }
    return false;
  }
  _beginToken(e2, r2 = this._cursor.clone()) {
    this._currentTokenStart = r2, this._currentTokenType = e2;
  }
  _endToken(e2, r2) {
    if (this._currentTokenStart === null)
      throw new gt2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r2));
    if (this._currentTokenType === null)
      throw new gt2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n2 = { type: this._currentTokenType, parts: e2, sourceSpan: (r2 ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n2), this._currentTokenStart = null, this._currentTokenType = null, n2;
  }
  _createError(e2, r2) {
    this._isInExpansionForm() && (e2 += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n2 = new gt2(e2, this._currentTokenType, r2);
    return this._currentTokenStart = null, this._currentTokenType = null, new Ct(n2);
  }
  handleError(e2) {
    if (e2 instanceof St && (e2 = this._createError(e2.msg, this._cursor.getSpan(e2.cursor))), e2 instanceof Ct)
      this.errors.push(e2.error);
    else
      throw e2;
  }
  _attemptCharCode(e2) {
    return this._cursor.peek() === e2 ? (this._cursor.advance(), true) : false;
  }
  _attemptCharCodeCaseInsensitive(e2) {
    return yo(this._cursor.peek(), e2) ? (this._cursor.advance(), true) : false;
  }
  _requireCharCode(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptCharCode(e2))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _attemptStr(e2) {
    let r2 = e2.length;
    if (this._cursor.charsLeft() < r2)
      return false;
    let n2 = this._cursor.clone();
    for (let s2 = 0;s2 < r2; s2++)
      if (!this._attemptCharCode(e2.charCodeAt(s2)))
        return this._cursor = n2, false;
    return true;
  }
  _attemptStrCaseInsensitive(e2) {
    for (let r2 = 0;r2 < e2.length; r2++)
      if (!this._attemptCharCodeCaseInsensitive(e2.charCodeAt(r2)))
        return false;
    return true;
  }
  _requireStr(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptStr(e2))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _requireStrCaseInsensitive(e2) {
    let r2 = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e2))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r2));
  }
  _attemptCharCodeUntilFn(e2) {
    for (;!e2(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e2, r2) {
    let n2 = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e2), this._cursor.diff(n2) < r2)
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(n2));
  }
  _attemptUntilChar(e2) {
    for (;this._cursor.peek() !== e2; )
      this._cursor.advance();
  }
  _readChar() {
    let e2 = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e2;
  }
  _consumeEntity(e2) {
    this._beginToken(9);
    let r2 = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n2 = this._attemptCharCode(120) || this._attemptCharCode(88), s2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Ao), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = n2 ? tr.HEX : tr.DEC;
        throw this._createError(_o(a, this._cursor.getChars(r2)), this._cursor.getSpan());
      }
      let i = this._cursor.getChars(s2);
      this._cursor.advance();
      try {
        let a = parseInt(i, n2 ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r2)]);
      } catch {
        throw this._createError(Vs(this._cursor.getChars(r2)), this._cursor.getSpan());
      }
    } else {
      let n2 = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Do), this._cursor.peek() != 59)
        this._beginToken(e2, r2), this._cursor = n2, this._endToken(["&"]);
      else {
        let s2 = this._cursor.getChars(n2);
        this._cursor.advance();
        let i = Ve[s2];
        if (!i)
          throw this._createError(Vs(s2), this._cursor.getSpan(r2));
        this._endToken([i, `&${s2};`]);
      }
    }
  }
  _consumeRawText(e2, r2) {
    this._beginToken(e2 ? 6 : 7);
    let n2 = [];
    for (;; ) {
      let s2 = this._cursor.clone(), i = r2();
      if (this._cursor = s2, i)
        break;
      e2 && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n2.join(""))]), n2.length = 0, this._consumeEntity(6), this._beginToken(6)) : n2.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n2.join(""))]);
  }
  _consumeComment(e2) {
    this._beginToken(10, e2), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e2) {
    this._beginToken(10, e2), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e2) {
    this._beginToken(12, e2), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e2) {
    this._beginToken(18, e2), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e2 = this._cursor.clone(), r2 = "";
    for (;this._cursor.peek() !== 58 && !Eo(this._cursor.peek()); )
      this._cursor.advance();
    let n2;
    this._cursor.peek() === 58 ? (r2 = this._cursor.getChars(e2), this._cursor.advance(), n2 = this._cursor.clone()) : n2 = e2, this._requireCharCodeUntilFn(Us, r2 === "" ? 0 : 1);
    let s2 = this._cursor.getChars(n2);
    return [r2, s2];
  }
  _consumeTagOpen(e2) {
    let r2, n2, s2, i = [];
    try {
      if (!lt2(this._cursor.peek()))
        throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(e2));
      for (s2 = this._consumeTagOpenStart(e2), n2 = s2.parts[0], r2 = s2.parts[1], this._attemptCharCodeUntilFn(b);this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o2, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(b), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(b);
          let p = this._consumeAttributeValue();
          i.push({ prefix: o2, name: u, value: p });
        } else
          i.push({ prefix: o2, name: u });
        this._attemptCharCodeUntilFn(b);
      }
      this._consumeTagOpenEnd();
    } catch (o2) {
      if (o2 instanceof Ct) {
        s2 ? s2.type = 4 : (this._beginToken(5, e2), this._endToken(["<"]));
        return;
      }
      throw o2;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let a = this._getTagContentType(r2, n2, this._fullNameStack.length > 0, i);
    this._handleFullNameStackForTagOpen(n2, r2), a === P.RAW_TEXT ? this._consumeRawTextWithTagClose(n2, r2, false) : a === P.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n2, r2, true);
  }
  _consumeRawTextWithTagClose(e2, r2, n2) {
    this._consumeRawText(n2, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b), !this._attemptStrCaseInsensitive(e2 ? `${e2}:${r2}` : r2)) ? false : (this._attemptCharCodeUntilFn(b), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s2) => s2 === 62, 3), this._cursor.advance(), this._endToken([e2, r2]), this._handleFullNameStackForTagClose(e2, r2);
  }
  _consumeTagOpenStart(e2) {
    this._beginToken(0, e2);
    let r2 = this._consumePrefixAndName();
    return this._endToken(r2);
  }
  _consumeAttributeName() {
    let e2 = this._cursor.peek();
    if (e2 === 39 || e2 === 34)
      throw this._createError(Ue(e2), this._cursor.getSpan());
    this._beginToken(14);
    let r2 = this._consumePrefixAndName();
    return this._endToken(r2), r2;
  }
  _consumeAttributeValue() {
    let e2;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r2 = this._cursor.peek();
      this._consumeQuote(r2);
      let n2 = () => this._cursor.peek() === r2;
      e2 = this._consumeWithInterpolation(16, 17, n2, n2), this._consumeQuote(r2);
    } else {
      let r2 = () => Us(this._cursor.peek());
      e2 = this._consumeWithInterpolation(16, 17, r2, r2);
    }
    return e2;
  }
  _consumeQuote(e2) {
    this._beginToken(15), this._requireCharCode(e2), this._endToken([String.fromCodePoint(e2)]);
  }
  _consumeTagOpenEnd() {
    let e2 = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e2), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e2) {
    if (this._beginToken(3, e2), this._attemptCharCodeUntilFn(b), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([]);
    else {
      let [r2, n2] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([r2, n2]), this._handleFullNameStackForTagClose(r2, n2);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e2 = this._readUntil(44), r2 = this._processCarriageReturns(e2);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r2]);
    else {
      let s2 = this._endToken([e2]);
      r2 !== e2 && this.nonNormalizedIcuExpressions.push(s2);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(b), this._beginToken(7);
    let n2 = this._readUntil(44);
    this._endToken([n2]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e2 = this._readUntil(123).trim();
    this._endToken([e2]), this._attemptCharCodeUntilFn(b), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e2, r2, n2, s2) {
    this._beginToken(e2);
    let i = [];
    for (;!n2(); ) {
      let o2 = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o2), i.length = 0, this._consumeInterpolation(r2, o2, s2), this._beginToken(e2)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e2), this._beginToken(e2)) : i.push(this._readChar());
    }
    this._inInterpolation = false;
    let a = this._processCarriageReturns(i.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e2, r2, n2) {
    let s2 = [];
    this._beginToken(e2, r2), s2.push(this._interpolationConfig.start);
    let i = this._cursor.clone(), a = null, o2 = false;
    for (;this._cursor.peek() !== 0 && (n2 === null || !n2()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, s2.push(this._getProcessedChars(i, u)), this._endToken(s2);
        return;
      }
      if (a === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          s2.push(this._getProcessedChars(i, u)), s2.push(this._interpolationConfig.end), this._endToken(s2);
          return;
        } else
          this._attemptStr("//") && (o2 = true);
      let p = this._cursor.peek();
      this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o2 && a === null && $t(p) && (a = p);
    }
    s2.push(this._getProcessedChars(i, this._cursor)), this._endToken(s2);
  }
  _getProcessedChars(e2, r2) {
    return this._processCarriageReturns(r2.getChars(e2));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e2 = this._cursor.clone();
      e2.advance();
      let r2 = e2.peek();
      if (97 <= r2 && r2 <= 122 || 65 <= r2 && r2 <= 90 || r2 === 47 || r2 === 33)
        return true;
    }
    return false;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e2 = this._cursor.clone();
      if (e2.advance(), zs(e2.peek()))
        return true;
    }
    return false;
  }
  _readUntil(e2) {
    let r2 = this._cursor.clone();
    return this._attemptUntilChar(e2), this._cursor.getChars(r2);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return false;
    if (this._interpolationConfig) {
      let e2 = this._cursor.clone(), r2 = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e2, !r2;
    }
    return true;
  }
  _handleFullNameStackForTagOpen(e2, r2) {
    let n2 = qe(e2, r2);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n2) && this._fullNameStack.push(n2);
  }
  _handleFullNameStackForTagClose(e2, r2) {
    let n2 = qe(e2, r2);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n2 && this._fullNameStack.pop();
  }
}, rr = class t4 {
  constructor(e2, r2) {
    if (e2 instanceof t4) {
      this.file = e2.file, this.input = e2.input, this.end = e2.end;
      let n2 = e2.state;
      this.state = { peek: n2.peek, offset: n2.offset, line: n2.line, column: n2.column };
    } else {
      if (!r2)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e2, this.input = e2.content, this.end = r2.endPos, this.state = { peek: -1, offset: r2.startPos, line: r2.startLine, column: r2.startCol };
    }
  }
  clone() {
    return new t4(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e2) {
    return this.state.offset - e2.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e2, r2) {
    e2 = e2 || this;
    let n2 = e2;
    if (r2)
      for (;this.diff(e2) > 0 && r2.indexOf(e2.peek()) !== -1; )
        n2 === e2 && (e2 = e2.clone()), e2.advance();
    let s2 = this.locationFromCursor(e2), i = this.locationFromCursor(this), a = n2 !== e2 ? this.locationFromCursor(n2) : s2;
    return new h(s2, i, a);
  }
  getChars(e2) {
    return this.input.substring(e2.state.offset, this.state.offset);
  }
  charAt(e2) {
    return this.input.charCodeAt(e2);
  }
  advanceState(e2) {
    if (e2.offset >= this.end)
      throw this.state = e2, new St('Unexpected character "EOF"', this);
    let r2 = this.charAt(e2.offset);
    r2 === 10 ? (e2.line++, e2.column = 0) : Rt(r2) || e2.column++, e2.offset++, this.updatePeek(e2);
  }
  updatePeek(e2) {
    e2.peek = e2.offset >= this.end ? 0 : this.charAt(e2.offset);
  }
  locationFromCursor(e2) {
    return new ie(e2.file, e2.state.offset, e2.state.line, e2.state.column);
  }
}, Wr, St = class {
  constructor(e2, r2) {
    this.msg = e2, this.cursor = r2;
  }
}, L, Yr = class {
  constructor(e2, r2) {
    this.rootNodes = e2, this.errors = r2;
  }
}, nr = class {
  constructor(e2) {
    this.getTagDefinition = e2;
  }
  parse(e2, r2, n2, s2 = false, i) {
    let a = (D) => (I2, ...F) => D(I2.toLowerCase(), ...F), o2 = s2 ? this.getTagDefinition : a(this.getTagDefinition), u = (D) => o2(D).getContentType(), p = s2 ? i : a(i), f = Qs(e2, r2, i ? (D, I2, F, c2) => {
      let g = p(D, I2, F, c2);
      return g !== undefined ? g : u(D);
    } : u, n2), d = n2 && n2.canSelfClose || false, C = n2 && n2.allowHtmComponentClosingTags || false, A = new jr(f.tokens, o2, d, C, s2);
    return A.build(), new Yr(A.rootNodes, f.errors.concat(A.errors));
  }
}, jr = class t7 {
  constructor(e2, r2, n2, s2, i) {
    this.tokens = e2, this.getTagDefinition = r2, this.canSelfClose = n2, this.allowHtmComponentClosingTags = s2, this.isTagNameCaseSensitive = i, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (;this._peek.type !== 34; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
    for (let e2 of this._containerStack)
      e2 instanceof te && this.errors.push(L.create(e2.name, e2.sourceSpan, `Unclosed block "${e2.name}"`));
  }
  _advance() {
    let e2 = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e2;
  }
  _advanceIf(e2) {
    return this._peek.type === e2 ? this._advance() : null;
  }
  _consumeCdata(e2) {
    let r2 = this._advance(), n2 = this._getText(r2), s2 = this._advanceIf(13);
    this._addToParent(new Wt(n2, new h(e2.sourceSpan.start, (s2 || r2).sourceSpan.end), [r2]));
  }
  _consumeComment(e2) {
    let r2 = this._advanceIf(7), n2 = this._advanceIf(11), s2 = r2 != null ? r2.parts[0].trim() : null, i = n2 == null ? e2.sourceSpan : new h(e2.sourceSpan.start, n2.sourceSpan.end, e2.sourceSpan.fullStart);
    this._addToParent(new jt(s2, i));
  }
  _consumeDocType(e2) {
    let r2 = this._advanceIf(7), n2 = this._advanceIf(19), s2 = r2 != null ? r2.parts[0].trim() : null, i = new h(e2.sourceSpan.start, (n2 || r2 || e2).sourceSpan.end);
    this._addToParent(new Kt(s2, i));
  }
  _consumeExpansion(e2) {
    let r2 = this._advance(), n2 = this._advance(), s2 = [];
    for (;this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a)
        return;
      s2.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let i = new h(e2.sourceSpan.start, this._peek.sourceSpan.end, e2.sourceSpan.fullStart);
    this._addToParent(new zt(r2.parts[0], n2.parts[0], s2, i, r2.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e2 = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r2 = this._advance(), n2 = this._collectExpansionExpTokens(r2);
    if (!n2)
      return null;
    let s2 = this._advance();
    n2.push({ type: 34, parts: [], sourceSpan: s2.sourceSpan });
    let i = new t7(n2, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (i.build(), i.errors.length > 0)
      return this.errors = this.errors.concat(i.errors), null;
    let a = new h(e2.sourceSpan.start, s2.sourceSpan.end, e2.sourceSpan.fullStart), o2 = new h(r2.sourceSpan.start, s2.sourceSpan.end, r2.sourceSpan.fullStart);
    return new Gt(e2.parts[0], i.rootNodes, a, e2.sourceSpan, o2);
  }
  _collectExpansionExpTokens(e2) {
    let r2 = [], n2 = [22];
    for (;; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n2.push(this._peek.type), this._peek.type === 23)
        if (Xs(n2, 22)) {
          if (n2.pop(), n2.length === 0)
            return r2;
        } else
          return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (Xs(n2, 20))
          n2.pop();
        else
          return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 34)
        return this.errors.push(L.create(null, e2.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r2.push(this._advance());
    }
  }
  _getText(e2) {
    let r2 = e2.parts[0];
    if (r2.length > 0 && r2[0] == `
`) {
      let n2 = this._getClosestParentElement();
      n2 != null && n2.children.length == 0 && this.getTagDefinition(n2.name).ignoreFirstLf && (r2 = r2.substring(1));
    }
    return r2;
  }
  _consumeText(e2) {
    let r2 = [e2], n2 = e2.sourceSpan, s2 = e2.parts[0];
    if (s2.length > 0 && s2[0] === `
`) {
      let i = this._getContainer();
      i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (s2 = s2.substring(1), r2[0] = { type: e2.type, sourceSpan: e2.sourceSpan, parts: [s2] });
    }
    for (;this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e2 = this._advance(), r2.push(e2), e2.type === 8 ? s2 += e2.parts.join("").replace(/&([^;]+);/g, Js) : e2.type === 9 ? s2 += e2.parts[0] : s2 += e2.parts.join("");
    if (s2.length > 0) {
      let i = e2.sourceSpan;
      this._addToParent(new Ut(s2, new h(n2.start, i.end, n2.fullStart, n2.details), r2));
    }
  }
  _closeVoidElement() {
    let e2 = this._getContainer();
    e2 instanceof Y && this.getTagDefinition(e2.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e2) {
    let [r2, n2] = e2.parts, s2 = [];
    for (;this._peek.type === 14; )
      s2.push(this._consumeAttr(this._advance()));
    let i = this._getElementFullName(r2, n2, this._getClosestParentElement()), a = false;
    if (this._peek.type === 2) {
      this._advance(), a = true;
      let C = this.getTagDefinition(i);
      this.canSelfClose || C.canSelfClose || Me(i) !== null || C.isVoid || this.errors.push(L.create(i, e2.sourceSpan, `Only void, custom and foreign elements can be self closed "${e2.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), a = false);
    let o2 = this._peek.sourceSpan.fullStart, u = new h(e2.sourceSpan.start, o2, e2.sourceSpan.fullStart), p = new h(e2.sourceSpan.start, o2, e2.sourceSpan.fullStart), l2 = new h(e2.sourceSpan.start.moveBy(1), e2.sourceSpan.end), f = new Y(i, s2, [], u, p, undefined, l2), d = this._getContainer();
    this._pushContainer(f, d instanceof Y && this.getTagDefinition(d.name).isClosedByChild(f.name)), a ? this._popContainer(i, Y, u) : e2.type === 4 && (this._popContainer(i, Y, null), this.errors.push(L.create(i, u, `Opening tag "${i}" not terminated.`)));
  }
  _pushContainer(e2, r2) {
    r2 && this._containerStack.pop(), this._addToParent(e2), this._containerStack.push(e2);
  }
  _consumeEndTag(e2) {
    let r2 = this.allowHtmComponentClosingTags && e2.parts.length === 0 ? null : this._getElementFullName(e2.parts[0], e2.parts[1], this._getClosestParentElement());
    if (r2 && this.getTagDefinition(r2).isVoid)
      this.errors.push(L.create(r2, e2.sourceSpan, `Void elements do not have end tags "${e2.parts[1]}"`));
    else if (!this._popContainer(r2, Y, e2.sourceSpan)) {
      let n2 = `Unexpected closing tag "${r2}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(L.create(r2, e2.sourceSpan, n2));
    }
  }
  _popContainer(e2, r2, n2) {
    let s2 = false;
    for (let i = this._containerStack.length - 1;i >= 0; i--) {
      let a = this._containerStack[i];
      if (Me(a.name) ? a.name === e2 : (e2 == null || a.name.toLowerCase() === e2.toLowerCase()) && a instanceof r2)
        return a.endSourceSpan = n2, a.sourceSpan.end = n2 !== null ? n2.end : a.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !s2;
      (a instanceof te || a instanceof Y && !this.getTagDefinition(a.name).closedByParent) && (s2 = true);
    }
    return false;
  }
  _consumeAttr(e2) {
    let r2 = qe(e2.parts[0], e2.parts[1]), n2 = e2.sourceSpan.end, s2;
    this._peek.type === 15 && (s2 = this._advance());
    let i = "", a = [], o2, u;
    if (this._peek.type === 16)
      for (o2 = this._peek.sourceSpan, u = this._peek.sourceSpan.end;this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let f = this._advance();
        a.push(f), f.type === 17 ? i += f.parts.join("").replace(/&([^;]+);/g, Js) : f.type === 9 ? i += f.parts[0] : i += f.parts.join(""), u = n2 = f.sourceSpan.end;
      }
    this._peek.type === 15 && (u = n2 = this._advance().sourceSpan.end);
    let l2 = o2 && u && new h((s2 == null ? undefined : s2.sourceSpan.start) ?? o2.start, u, (s2 == null ? undefined : s2.sourceSpan.fullStart) ?? o2.fullStart);
    return new Yt(r2, i, new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), e2.sourceSpan, l2, a.length > 0 ? a : undefined, undefined);
  }
  _consumeBlockOpen(e2) {
    let r2 = [];
    for (;this._peek.type === 28; ) {
      let o2 = this._advance();
      r2.push(new ht(o2.parts[0], o2.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n2 = this._peek.sourceSpan.fullStart, s2 = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), i = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), a = new te(e2.parts[0], r2, [], s2, e2.sourceSpan, i);
    this._pushContainer(a, false);
  }
  _consumeBlockClose(e2) {
    this._popContainer(null, te, e2.sourceSpan) || this.errors.push(L.create(null, e2.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e2) {
    let r2 = [];
    for (;this._peek.type === 28; ) {
      let o2 = this._advance();
      r2.push(new ht(o2.parts[0], o2.sourceSpan));
    }
    let n2 = this._peek.sourceSpan.fullStart, s2 = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), i = new h(e2.sourceSpan.start, n2, e2.sourceSpan.fullStart), a = new te(e2.parts[0], r2, [], s2, e2.sourceSpan, i);
    this._pushContainer(a, false), this._popContainer(null, te, null), this.errors.push(L.create(e2.parts[0], s2, `Incomplete block "${e2.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(e2) {
    let r2 = e2.parts[0], n2, s2;
    if (this._peek.type !== 31) {
      this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Invalid @let declaration "${r2}". Declaration must have a value.`));
      return;
    } else
      n2 = this._advance();
    if (this._peek.type !== 32) {
      this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Unterminated @let declaration "${r2}". Declaration must be terminated with a semicolon.`));
      return;
    } else
      s2 = this._advance();
    let i = s2.sourceSpan.fullStart, a = new h(e2.sourceSpan.start, i, e2.sourceSpan.fullStart), o2 = e2.sourceSpan.toString().lastIndexOf(r2), u = e2.sourceSpan.start.moveBy(o2), p = new h(u, e2.sourceSpan.end), l2 = new ft(r2, n2.parts[0], a, p, n2.sourceSpan);
    this._addToParent(l2);
  }
  _consumeIncompleteLet(e2) {
    let r2 = e2.parts[0] ?? "", n2 = r2 ? ` "${r2}"` : "";
    if (r2.length > 0) {
      let s2 = e2.sourceSpan.toString().lastIndexOf(r2), i = e2.sourceSpan.start.moveBy(s2), a = new h(i, e2.sourceSpan.end), o2 = new h(e2.sourceSpan.start, e2.sourceSpan.start.moveBy(0)), u = new ft(r2, "", e2.sourceSpan, a, o2);
      this._addToParent(u);
    }
    this.errors.push(L.create(e2.parts[0], e2.sourceSpan, `Incomplete @let declaration${n2}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e2 = this._containerStack.length - 1;e2 > -1; e2--)
      if (this._containerStack[e2] instanceof Y)
        return this._containerStack[e2];
    return null;
  }
  _addToParent(e2) {
    let r2 = this._getContainer();
    r2 === null ? this.rootNodes.push(e2) : r2.children.push(e2);
  }
  _getElementFullName(e2, r2, n2) {
    if (e2 === "" && (e2 = this.getTagDefinition(r2).implicitNamespacePrefix || "", e2 === "" && n2 != null)) {
      let s2 = ct(n2.name)[1];
      this.getTagDefinition(s2).preventNamespaceInheritance || (e2 = Me(n2.name));
    }
    return qe(e2, r2);
  }
}, sr, Kr = null, bo = () => (Kr || (Kr = new sr), Kr), Zs, _t = 3, ei, ir, ti, le, Xr, Jr, ze = class ze2 {
  constructor(e2 = {}) {
    Et(this, le);
    lr(this, "type");
    lr(this, "parent");
    for (let r2 of new Set([...ti, ...Object.keys(e2)]))
      this.setProperty(r2, e2[r2]);
  }
  setProperty(e2, r2) {
    if (this[e2] !== r2) {
      if (e2 in ir && (r2 = r2.map((n2) => this.createChild(n2))), !ti.has(e2)) {
        this[e2] = r2;
        return;
      }
      Object.defineProperty(this, e2, { value: r2, enumerable: false, configurable: true });
    }
  }
  map(e2) {
    let r2;
    for (let n2 in ir) {
      let s2 = this[n2];
      if (s2) {
        let i = Bo(s2, (a) => a.map(e2));
        r2 !== s2 && (r2 || (r2 = new ze2({ parent: this.parent })), r2.setProperty(n2, i));
      }
    }
    if (r2)
      for (let n2 in this)
        n2 in ir || (r2[n2] = this[n2]);
    return e2(r2 || this);
  }
  walk(e2) {
    for (let r2 in ir) {
      let n2 = this[r2];
      if (n2)
        for (let s2 = 0;s2 < n2.length; s2++)
          n2[s2].walk(e2);
    }
    e2(this);
  }
  createChild(e2) {
    let r2 = e2 instanceof ze2 ? e2.clone() : new ze2(e2);
    return r2.setProperty("parent", this), r2;
  }
  insertChildBefore(e2, r2) {
    let n2 = this.$children;
    n2.splice(n2.indexOf(e2), 0, this.createChild(r2));
  }
  removeChild(e2) {
    let r2 = this.$children;
    r2.splice(r2.indexOf(e2), 1);
  }
  replaceChild(e2, r2) {
    let n2 = this.$children;
    n2[n2.indexOf(e2)] = this.createChild(r2);
  }
  clone() {
    return new ze2(this);
  }
  get $children() {
    return this[R(this, le, Xr)];
  }
  set $children(e2) {
    this[R(this, le, Xr)] = e2;
  }
  get firstChild() {
    var e2;
    return (e2 = this.$children) == null ? undefined : e2[0];
  }
  get lastChild() {
    return K(true, this.$children, -1);
  }
  get prev() {
    let e2 = R(this, le, Jr);
    return e2[e2.indexOf(this) - 1];
  }
  get next() {
    let e2 = R(this, le, Jr);
    return e2[e2.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e2) => [e2.fullName, e2.value]));
  }
}, ar, Lo, or2, ni, oi, Mo, qo, Ho, Vo, Uo, Gh;
var init_html = __esm(() => {
  sn = Object.defineProperty;
  en = {};
  on(en, { languages: () => xs, options: () => Bs, parsers: () => Zr, printers: () => Uo });
  w = ci;
  At = new Set([Ye, we, be, je, Te, xe, ce, ke, Ke, Qe, j, Xe, Be]);
  K = pi;
  Le = hi;
  cr = class extends Error {
    name = "InvalidDocError";
    constructor(e2) {
      super(mi(e2)), this.doc = e2;
    }
  };
  pr = cr;
  ne2 = fr;
  mr = fr;
  pn = fr;
  se = { type: Be };
  gi = { type: j, hard: true };
  Ci = { type: j, hard: true, literal: true };
  _ = { type: j };
  v = { type: j, soft: true };
  S = [gi, se];
  cn = [Ci, se];
  Cn = Si;
  V2 = new WeakMap;
  Sn = gr;
  _i = ["\t", `
`, "\f", "\r", " "];
  Ei = new Sn(_i);
  O = Ei;
  Cr = class extends Error {
    name = "UnexpectedNodeError";
    constructor(e2, r2, n2 = "type") {
      super(`Unexpected ${r2} node ${n2}: ${JSON.stringify(e2[n2])}.`), this.node = e2;
    }
  };
  _n = Cr;
  Fe = Ai;
  Di = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]);
  vi = new Set(["if", "else if", "for", "switch", "case"]);
  En.ignoredProperties = Di;
  An = En;
  Dn = yi;
  vn = wi;
  Ne = xi;
  bn = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" };
  xn = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
  fe = ki;
  Wi = new Set(["template", "style", "script"]);
  yr = /\{\{(.+?)\}\}/su;
  zi = wr({ parser: "__ng_action" });
  Gi = wr({ parser: "__ng_binding" });
  Yi = wr({ parser: "__ng_directive" });
  Gn = ji;
  Yn = Ki;
  Qi = /^[ \t\n\r\u000c]+/;
  Xi = /^[, \t\n\r\u000c]+/;
  Ji = /^[^ \t\n\r\u000c]+/;
  Zi = /[,]+$/;
  Kn = /^\d+$/;
  ea = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
  Qn = ta;
  Xn = { width: "w", height: "h", density: "x" };
  na = Object.keys(Xn);
  Jn = ra;
  br = new WeakMap;
  Pe = ia;
  ss = oa;
  is3 = ca;
  as = new Proxy(() => {}, { get: () => as });
  Tr = as;
  Ie = ha;
  Nt = Sa;
  _a2 = new Set(["if", "else if", "for", "switch", "case"]);
  ls = Ea;
  for (let t2 = 0;t2 <= Aa; t2++)
    at();
  cs = Da;
  va = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] };
  ps = va;
  ya = cs(ps);
  hs = ya;
  ds = new Map([["if", new Set(["else if", "else"])], ["else if", new Set(["else if", "else"])], ["for", new Set(["empty"])], ["defer", new Set(["placeholder", "error", "loading"])], ["placeholder", new Set(["placeholder", "error", "loading"])], ["error", new Set(["placeholder", "error", "loading"])], ["loading", new Set(["placeholder", "error", "loading"])]]);
  ba = /-+([a-z0-9])/g;
  (function(t3) {
    t3[t3.WARNING = 0] = "WARNING", t3[t3.ERROR = 1] = "ERROR";
  })(Ot || (Ot = {}));
  Ta = [ka, Ba, Fa, Pa, Ia, Oa, Ra, $a, Ma, Na];
  bs = xa;
  Ha = { preprocess: bs, print: qa, insertPragma: ms, massageAstNode: An, embed: ls, getVisitorKeys: hs };
  Ts = Ha;
  xs = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }];
  Br = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
  Va = { bracketSameLine: Br.bracketSameLine, htmlWhitespaceSensitivity: { category: ks, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Br.singleAttributePerLine, vueIndentScriptAndStyle: { category: ks, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
  Bs = Va;
  Zr = {};
  on(Zr, { angular: () => qo, html: () => Mo, lwc: () => Vo, vue: () => Ho });
  xp = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
  (function(t3) {
    t3[t3.Emulated = 0] = "Emulated", t3[t3.None = 2] = "None", t3[t3.ShadowDom = 3] = "ShadowDom";
  })(Ls || (Ls = {}));
  (function(t3) {
    t3[t3.OnPush = 0] = "OnPush", t3[t3.Default = 1] = "Default";
  })(Fs || (Fs = {}));
  (function(t3) {
    t3[t3.None = 0] = "None", t3[t3.SignalBased = 1] = "SignalBased", t3[t3.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
  })(Ns || (Ns = {}));
  Lr = { name: "custom-elements" };
  Fr = { name: "no-errors-schema" };
  (function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.HTML = 1] = "HTML", t3[t3.STYLE = 2] = "STYLE", t3[t3.SCRIPT = 3] = "SCRIPT", t3[t3.URL = 4] = "URL", t3[t3.RESOURCE_URL = 5] = "RESOURCE_URL";
  })(ee || (ee = {}));
  (function(t3) {
    t3[t3.Error = 0] = "Error", t3[t3.Warning = 1] = "Warning", t3[t3.Ignore = 2] = "Ignore";
  })(Ps || (Ps = {}));
  (function(t3) {
    t3[t3.RAW_TEXT = 0] = "RAW_TEXT", t3[t3.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t3[t3.PARSABLE_DATA = 2] = "PARSABLE_DATA";
  })(P || (P = {}));
  Ya = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"];
  Is = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }));
  ja = Array.from(Is).reduce((t3, [e2, r2]) => (t3.set(e2, r2), t3), new Map);
  Vt = class extends Ht {
    constructor() {
      super(), this._schema = new Map, this._eventSchema = new Map, Ya.forEach((e2) => {
        let r2 = new Map, n2 = new Set, [s2, i] = e2.split("|"), a = i.split(","), [o2, u] = s2.split("^");
        o2.split(",").forEach((l2) => {
          this._schema.set(l2.toLowerCase(), r2), this._eventSchema.set(l2.toLowerCase(), n2);
        });
        let p = u && this._schema.get(u.toLowerCase());
        if (p) {
          for (let [l2, f] of p)
            r2.set(l2, f);
          for (let l2 of this._eventSchema.get(u.toLowerCase()))
            n2.add(l2);
        }
        a.forEach((l2) => {
          if (l2.length > 0)
            switch (l2[0]) {
              case "*":
                n2.add(l2.substring(1));
                break;
              case "!":
                r2.set(l2.substring(1), Ua);
                break;
              case "#":
                r2.set(l2.substring(1), Wa);
                break;
              case "%":
                r2.set(l2.substring(1), Ga);
                break;
              default:
                r2.set(l2, za);
            }
        });
      });
    }
    hasProperty(e2, r2, n2) {
      if (n2.some((i) => i.name === Fr.name))
        return true;
      if (e2.indexOf("-") > -1) {
        if (Nr(e2) || Pr(e2))
          return false;
        if (n2.some((i) => i.name === Lr.name))
          return true;
      }
      return (this._schema.get(e2.toLowerCase()) || this._schema.get("unknown")).has(r2);
    }
    hasElement(e2, r2) {
      return r2.some((n2) => n2.name === Fr.name) || e2.indexOf("-") > -1 && (Nr(e2) || Pr(e2) || r2.some((n2) => n2.name === Lr.name)) ? true : this._schema.has(e2.toLowerCase());
    }
    securityContext(e2, r2, n2) {
      n2 && (r2 = this.getMappedPropName(r2)), e2 = e2.toLowerCase(), r2 = r2.toLowerCase();
      let s2 = Ir()[e2 + "|" + r2];
      return s2 || (s2 = Ir()["*|" + r2], s2 || ee.NONE);
    }
    getMappedPropName(e2) {
      return Is.get(e2) ?? e2;
    }
    getDefaultComponentElementName() {
      return "ng-component";
    }
    validateProperty(e2) {
      return e2.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e2}' is disallowed for security reasons, please use (${e2.slice(2)})=...
If '${e2}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
    }
    validateAttribute(e2) {
      return e2.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e2}' is disallowed for security reasons, please use (${e2.slice(2)})=...` } : { error: false };
    }
    allKnownElementNames() {
      return Array.from(this._schema.keys());
    }
    allKnownAttributesOfElement(e2) {
      let r2 = this._schema.get(e2.toLowerCase()) || this._schema.get("unknown");
      return Array.from(r2.keys()).map((n2) => ja.get(n2) ?? n2);
    }
    allKnownEventsOfElement(e2) {
      return Array.from(this._eventSchema.get(e2.toLowerCase()) ?? []);
    }
    normalizeAnimationStyleProperty(e2) {
      return ws2(e2);
    }
    normalizeAnimationStyleValue(e2, r2, n2) {
      let s2 = "", i = n2.toString().trim(), a = null;
      if (Ka(e2) && n2 !== 0 && n2 !== "0")
        if (typeof n2 == "number")
          s2 = "px";
        else {
          let o2 = n2.match(/^[+-]?[\d\.]+([a-z]*)$/);
          o2 && o2[1].length == 0 && (a = `Please provide a CSS unit value for ${r2}:${n2}`);
        }
      return { error: a, value: i + s2 };
    }
  };
  Ut = class extends ae {
    constructor(e2, r2, n2, s2) {
      super(r2, s2), this.value = e2, this.tokens = n2, this.type = "text";
    }
    visit(e2, r2) {
      return e2.visitText(this, r2);
    }
  };
  Wt = class extends ae {
    constructor(e2, r2, n2, s2) {
      super(r2, s2), this.value = e2, this.tokens = n2, this.type = "cdata";
    }
    visit(e2, r2) {
      return e2.visitCdata(this, r2);
    }
  };
  zt = class extends ae {
    constructor(e2, r2, n2, s2, i, a) {
      super(s2, a), this.switchValue = e2, this.type = r2, this.cases = n2, this.switchValueSourceSpan = i;
    }
    visit(e2, r2) {
      return e2.visitExpansion(this, r2);
    }
  };
  Yt = class extends ae {
    constructor(e2, r2, n2, s2, i, a, o2) {
      super(n2, o2), this.name = e2, this.value = r2, this.keySpan = s2, this.valueSpan = i, this.valueTokens = a, this.type = "attribute";
    }
    visit(e2, r2) {
      return e2.visitAttribute(this, r2);
    }
    get nameSpan() {
      return this.keySpan;
    }
  };
  Y = class extends ae {
    constructor(e2, r2, n2, s2, i, a = null, o2 = null, u) {
      super(s2, u), this.name = e2, this.attrs = r2, this.children = n2, this.startSourceSpan = i, this.endSourceSpan = a, this.nameSpan = o2, this.type = "element";
    }
    visit(e2, r2) {
      return e2.visitElement(this, r2);
    }
  };
  te = class extends ae {
    constructor(e2, r2, n2, s2, i, a, o2 = null, u) {
      super(s2, u), this.name = e2, this.parameters = r2, this.children = n2, this.nameSpan = i, this.startSourceSpan = a, this.endSourceSpan = o2, this.type = "block";
    }
    visit(e2, r2) {
      return e2.visitBlock(this, r2);
    }
  };
  Ve = { AElig: "\xC6", AMP: "&", amp: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\uD835\uDD04", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\uD835\uDD38", ApplyFunction: "\u2061", af: "\u2061", Aring: "\xC5", angst: "\xC5", Ascr: "\uD835\uDC9C", Assign: "\u2254", colone: "\u2254", coloneq: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", setminus: "\u2216", setmn: "\u2216", smallsetminus: "\u2216", ssetmn: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", doublebarwedge: "\u2306", Bcy: "\u0411", Because: "\u2235", becaus: "\u2235", because: "\u2235", Bernoullis: "\u212C", Bscr: "\u212C", bernou: "\u212C", Beta: "\u0392", Bfr: "\uD835\uDD05", Bopf: "\uD835\uDD39", Breve: "\u02D8", breve: "\u02D8", Bumpeq: "\u224E", HumpDownHump: "\u224E", bump: "\u224E", CHcy: "\u0427", COPY: "\xA9", copy: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", DD: "\u2145", Cayleys: "\u212D", Cfr: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", cedil: "\xB8", CenterDot: "\xB7", centerdot: "\xB7", middot: "\xB7", Chi: "\u03A7", CircleDot: "\u2299", odot: "\u2299", CircleMinus: "\u2296", ominus: "\u2296", CirclePlus: "\u2295", oplus: "\u2295", CircleTimes: "\u2297", otimes: "\u2297", ClockwiseContourIntegral: "\u2232", cwconint: "\u2232", CloseCurlyDoubleQuote: "\u201D", rdquo: "\u201D", rdquor: "\u201D", CloseCurlyQuote: "\u2019", rsquo: "\u2019", rsquor: "\u2019", Colon: "\u2237", Proportion: "\u2237", Colone: "\u2A74", Congruent: "\u2261", equiv: "\u2261", Conint: "\u222F", DoubleContourIntegral: "\u222F", ContourIntegral: "\u222E", conint: "\u222E", oint: "\u222E", Copf: "\u2102", complexes: "\u2102", Coproduct: "\u2210", coprod: "\u2210", CounterClockwiseContourIntegral: "\u2233", awconint: "\u2233", Cross: "\u2A2F", Cscr: "\uD835\uDC9E", Cup: "\u22D3", CupCap: "\u224D", asympeq: "\u224D", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", ddagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", DoubleLeftTee: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", nabla: "\u2207", Delta: "\u0394", Dfr: "\uD835\uDD07", DiacriticalAcute: "\xB4", acute: "\xB4", DiacriticalDot: "\u02D9", dot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", dblac: "\u02DD", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "\u02DC", tilde: "\u02DC", Diamond: "\u22C4", diam: "\u22C4", diamond: "\u22C4", DifferentialD: "\u2146", dd: "\u2146", Dopf: "\uD835\uDD3B", Dot: "\xA8", DoubleDot: "\xA8", die: "\xA8", uml: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", doteq: "\u2250", esdot: "\u2250", DoubleDownArrow: "\u21D3", Downarrow: "\u21D3", dArr: "\u21D3", DoubleLeftArrow: "\u21D0", Leftarrow: "\u21D0", lArr: "\u21D0", DoubleLeftRightArrow: "\u21D4", Leftrightarrow: "\u21D4", hArr: "\u21D4", iff: "\u21D4", DoubleLongLeftArrow: "\u27F8", Longleftarrow: "\u27F8", xlArr: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", Longleftrightarrow: "\u27FA", xhArr: "\u27FA", DoubleLongRightArrow: "\u27F9", Longrightarrow: "\u27F9", xrArr: "\u27F9", DoubleRightArrow: "\u21D2", Implies: "\u21D2", Rightarrow: "\u21D2", rArr: "\u21D2", DoubleRightTee: "\u22A8", vDash: "\u22A8", DoubleUpArrow: "\u21D1", Uparrow: "\u21D1", uArr: "\u21D1", DoubleUpDownArrow: "\u21D5", Updownarrow: "\u21D5", vArr: "\u21D5", DoubleVerticalBar: "\u2225", par: "\u2225", parallel: "\u2225", shortparallel: "\u2225", spar: "\u2225", DownArrow: "\u2193", ShortDownArrow: "\u2193", darr: "\u2193", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", duarr: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", leftharpoondown: "\u21BD", lhard: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", rhard: "\u21C1", rightharpoondown: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", top: "\u22A4", DownTeeArrow: "\u21A7", mapstodown: "\u21A7", Dscr: "\uD835\uDC9F", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\uD835\uDD08", Egrave: "\xC8", Element: "\u2208", in: "\u2208", isin: "\u2208", isinv: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\uD835\uDD3C", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", eqsim: "\u2242", esim: "\u2242", Equilibrium: "\u21CC", rightleftharpoons: "\u21CC", rlhar: "\u21CC", Escr: "\u2130", expectation: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", exist: "\u2203", ExponentialE: "\u2147", ee: "\u2147", exponentiale: "\u2147", Fcy: "\u0424", Ffr: "\uD835\uDD09", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", blacksquare: "\u25AA", squarf: "\u25AA", squf: "\u25AA", Fopf: "\uD835\uDD3D", ForAll: "\u2200", forall: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", gt: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\uD835\uDD0A", Gg: "\u22D9", ggg: "\u22D9", Gopf: "\uD835\uDD3E", GreaterEqual: "\u2265", ge: "\u2265", geq: "\u2265", GreaterEqualLess: "\u22DB", gel: "\u22DB", gtreqless: "\u22DB", GreaterFullEqual: "\u2267", gE: "\u2267", geqq: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", gl: "\u2277", gtrless: "\u2277", GreaterSlantEqual: "\u2A7E", geqslant: "\u2A7E", ges: "\u2A7E", GreaterTilde: "\u2273", gsim: "\u2273", gtrsim: "\u2273", Gscr: "\uD835\uDCA2", Gt: "\u226B", NestedGreaterGreater: "\u226B", gg: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", caron: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", Poincareplane: "\u210C", HilbertSpace: "\u210B", Hscr: "\u210B", hamilt: "\u210B", Hopf: "\u210D", quaternions: "\u210D", HorizontalLine: "\u2500", boxh: "\u2500", Hstrok: "\u0126", HumpEqual: "\u224F", bumpe: "\u224F", bumpeq: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Im: "\u2111", image: "\u2111", imagpart: "\u2111", Igrave: "\xCC", Imacr: "\u012A", ImaginaryI: "\u2148", ii: "\u2148", Int: "\u222C", Integral: "\u222B", int: "\u222B", Intersection: "\u22C2", bigcap: "\u22C2", xcap: "\u22C2", InvisibleComma: "\u2063", ic: "\u2063", InvisibleTimes: "\u2062", it: "\u2062", Iogon: "\u012E", Iopf: "\uD835\uDD40", Iota: "\u0399", Iscr: "\u2110", imagline: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\uD835\uDD0D", Jopf: "\uD835\uDD41", Jscr: "\uD835\uDCA5", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\uD835\uDD0E", Kopf: "\uD835\uDD42", Kscr: "\uD835\uDCA6", LJcy: "\u0409", LT: "<", lt: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Lscr: "\u2112", lagran: "\u2112", Larr: "\u219E", twoheadleftarrow: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", lang: "\u27E8", langle: "\u27E8", LeftArrow: "\u2190", ShortLeftArrow: "\u2190", larr: "\u2190", leftarrow: "\u2190", slarr: "\u2190", LeftArrowBar: "\u21E4", larrb: "\u21E4", LeftArrowRightArrow: "\u21C6", leftrightarrows: "\u21C6", lrarr: "\u21C6", LeftCeiling: "\u2308", lceil: "\u2308", LeftDoubleBracket: "\u27E6", lobrk: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", dharl: "\u21C3", downharpoonleft: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", lfloor: "\u230A", LeftRightArrow: "\u2194", harr: "\u2194", leftrightarrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", dashv: "\u22A3", LeftTeeArrow: "\u21A4", mapstoleft: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", vartriangleleft: "\u22B2", vltri: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", ltrie: "\u22B4", trianglelefteq: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", uharl: "\u21BF", upharpoonleft: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", leftharpoonup: "\u21BC", lharu: "\u21BC", LeftVectorBar: "\u2952", LessEqualGreater: "\u22DA", leg: "\u22DA", lesseqgtr: "\u22DA", LessFullEqual: "\u2266", lE: "\u2266", leqq: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", lg: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", leqslant: "\u2A7D", les: "\u2A7D", LessTilde: "\u2272", lesssim: "\u2272", lsim: "\u2272", Lfr: "\uD835\uDD0F", Ll: "\u22D8", Lleftarrow: "\u21DA", lAarr: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", longleftarrow: "\u27F5", xlarr: "\u27F5", LongLeftRightArrow: "\u27F7", longleftrightarrow: "\u27F7", xharr: "\u27F7", LongRightArrow: "\u27F6", longrightarrow: "\u27F6", xrarr: "\u27F6", Lopf: "\uD835\uDD43", LowerLeftArrow: "\u2199", swarr: "\u2199", swarrow: "\u2199", LowerRightArrow: "\u2198", searr: "\u2198", searrow: "\u2198", Lsh: "\u21B0", lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", NestedLessLess: "\u226A", ll: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mscr: "\u2133", phmmat: "\u2133", Mfr: "\uD835\uDD10", MinusPlus: "\u2213", mnplus: "\u2213", mp: "\u2213", Mopf: "\uD835\uDD44", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", ZeroWidthSpace: "\u200B", NewLine: `
`, Nfr: "\uD835\uDD11", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nbsp: "\xA0", Nopf: "\u2115", naturals: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", nequiv: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", npar: "\u2226", nparallel: "\u2226", nshortparallel: "\u2226", nspar: "\u2226", NotElement: "\u2209", notin: "\u2209", notinva: "\u2209", NotEqual: "\u2260", ne: "\u2260", NotEqualTilde: "\u2242\u0338", nesim: "\u2242\u0338", NotExists: "\u2204", nexist: "\u2204", nexists: "\u2204", NotGreater: "\u226F", ngt: "\u226F", ngtr: "\u226F", NotGreaterEqual: "\u2271", nge: "\u2271", ngeq: "\u2271", NotGreaterFullEqual: "\u2267\u0338", ngE: "\u2267\u0338", ngeqq: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", nGtv: "\u226B\u0338", NotGreaterLess: "\u2279", ntgl: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", NotGreaterTilde: "\u2275", ngsim: "\u2275", NotHumpDownHump: "\u224E\u0338", nbump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", nbumpe: "\u224F\u0338", NotLeftTriangle: "\u22EA", nltri: "\u22EA", ntriangleleft: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", nltrie: "\u22EC", ntrianglelefteq: "\u22EC", NotLess: "\u226E", nless: "\u226E", nlt: "\u226E", NotLessEqual: "\u2270", nle: "\u2270", nleq: "\u2270", NotLessGreater: "\u2278", ntlg: "\u2278", NotLessLess: "\u226A\u0338", nLtv: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", NotLessTilde: "\u2274", nlsim: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", npr: "\u2280", nprec: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", npre: "\u2AAF\u0338", npreceq: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", nprcue: "\u22E0", NotReverseElement: "\u220C", notni: "\u220C", notniva: "\u220C", NotRightTriangle: "\u22EB", nrtri: "\u22EB", ntriangleright: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", nrtrie: "\u22ED", ntrianglerighteq: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", nsqsube: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", nsqsupe: "\u22E3", NotSubset: "\u2282\u20D2", nsubset: "\u2282\u20D2", vnsub: "\u2282\u20D2", NotSubsetEqual: "\u2288", nsube: "\u2288", nsubseteq: "\u2288", NotSucceeds: "\u2281", nsc: "\u2281", nsucc: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", nsce: "\u2AB0\u0338", nsucceq: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", nsccue: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", nsupset: "\u2283\u20D2", vnsup: "\u2283\u20D2", NotSupersetEqual: "\u2289", nsupe: "\u2289", nsupseteq: "\u2289", NotTilde: "\u2241", nsim: "\u2241", NotTildeEqual: "\u2244", nsime: "\u2244", nsimeq: "\u2244", NotTildeFullEqual: "\u2247", ncong: "\u2247", NotTildeTilde: "\u2249", nap: "\u2249", napprox: "\u2249", NotVerticalBar: "\u2224", nmid: "\u2224", nshortmid: "\u2224", nsmid: "\u2224", Nscr: "\uD835\uDCA9", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\uD835\uDD12", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", ohm: "\u03A9", Omicron: "\u039F", Oopf: "\uD835\uDD46", OpenCurlyDoubleQuote: "\u201C", ldquo: "\u201C", OpenCurlyQuote: "\u2018", lsquo: "\u2018", Or: "\u2A54", Oscr: "\uD835\uDCAA", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", oline: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", tbrk: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", part: "\u2202", Pcy: "\u041F", Pfr: "\uD835\uDD13", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", plusmn: "\xB1", pm: "\xB1", Popf: "\u2119", primes: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", pr: "\u227A", prec: "\u227A", PrecedesEqual: "\u2AAF", pre: "\u2AAF", preceq: "\u2AAF", PrecedesSlantEqual: "\u227C", prcue: "\u227C", preccurlyeq: "\u227C", PrecedesTilde: "\u227E", precsim: "\u227E", prsim: "\u227E", Prime: "\u2033", Product: "\u220F", prod: "\u220F", Proportional: "\u221D", prop: "\u221D", propto: "\u221D", varpropto: "\u221D", vprop: "\u221D", Pscr: "\uD835\uDCAB", Psi: "\u03A8", QUOT: '"', quot: '"', Qfr: "\uD835\uDD14", Qopf: "\u211A", rationals: "\u211A", Qscr: "\uD835\uDCAC", RBarr: "\u2910", drbkarow: "\u2910", REG: "\xAE", circledR: "\xAE", reg: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", twoheadrightarrow: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", Rfr: "\u211C", real: "\u211C", realpart: "\u211C", ReverseElement: "\u220B", SuchThat: "\u220B", ni: "\u220B", niv: "\u220B", ReverseEquilibrium: "\u21CB", leftrightharpoons: "\u21CB", lrhar: "\u21CB", ReverseUpEquilibrium: "\u296F", duhar: "\u296F", Rho: "\u03A1", RightAngleBracket: "\u27E9", rang: "\u27E9", rangle: "\u27E9", RightArrow: "\u2192", ShortRightArrow: "\u2192", rarr: "\u2192", rightarrow: "\u2192", srarr: "\u2192", RightArrowBar: "\u21E5", rarrb: "\u21E5", RightArrowLeftArrow: "\u21C4", rightleftarrows: "\u21C4", rlarr: "\u21C4", RightCeiling: "\u2309", rceil: "\u2309", RightDoubleBracket: "\u27E7", robrk: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", dharr: "\u21C2", downharpoonright: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rfloor: "\u230B", RightTee: "\u22A2", vdash: "\u22A2", RightTeeArrow: "\u21A6", map: "\u21A6", mapsto: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", vartriangleright: "\u22B3", vrtri: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", rtrie: "\u22B5", trianglerighteq: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", uharr: "\u21BE", upharpoonright: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", rharu: "\u21C0", rightharpoonup: "\u21C0", RightVectorBar: "\u2953", Ropf: "\u211D", reals: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", rAarr: "\u21DB", Rscr: "\u211B", realine: "\u211B", Rsh: "\u21B1", rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\uD835\uDD16", ShortUpArrow: "\u2191", UpArrow: "\u2191", uarr: "\u2191", uparrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", compfn: "\u2218", Sopf: "\uD835\uDD4A", Sqrt: "\u221A", radic: "\u221A", Square: "\u25A1", squ: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", sqcap: "\u2293", SquareSubset: "\u228F", sqsub: "\u228F", sqsubset: "\u228F", SquareSubsetEqual: "\u2291", sqsube: "\u2291", sqsubseteq: "\u2291", SquareSuperset: "\u2290", sqsup: "\u2290", sqsupset: "\u2290", SquareSupersetEqual: "\u2292", sqsupe: "\u2292", sqsupseteq: "\u2292", SquareUnion: "\u2294", sqcup: "\u2294", Sscr: "\uD835\uDCAE", Star: "\u22C6", sstarf: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", sube: "\u2286", subseteq: "\u2286", Succeeds: "\u227B", sc: "\u227B", succ: "\u227B", SucceedsEqual: "\u2AB0", sce: "\u2AB0", succeq: "\u2AB0", SucceedsSlantEqual: "\u227D", sccue: "\u227D", succcurlyeq: "\u227D", SucceedsTilde: "\u227F", scsim: "\u227F", succsim: "\u227F", Sum: "\u2211", sum: "\u2211", Sup: "\u22D1", Supset: "\u22D1", Superset: "\u2283", sup: "\u2283", supset: "\u2283", SupersetEqual: "\u2287", supe: "\u2287", supseteq: "\u2287", THORN: "\xDE", TRADE: "\u2122", trade: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "\t", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\uD835\uDD17", Therefore: "\u2234", there4: "\u2234", therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", Tilde: "\u223C", sim: "\u223C", thicksim: "\u223C", thksim: "\u223C", TildeEqual: "\u2243", sime: "\u2243", simeq: "\u2243", TildeFullEqual: "\u2245", cong: "\u2245", TildeTilde: "\u2248", ap: "\u2248", approx: "\u2248", asymp: "\u2248", thickapprox: "\u2248", thkap: "\u2248", Topf: "\uD835\uDD4B", TripleDot: "\u20DB", tdot: "\u20DB", Tscr: "\uD835\uDCAF", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\uD835\uDD18", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", lowbar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", bbrk: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", bigcup: "\u22C3", xcup: "\u22C3", UnionPlus: "\u228E", uplus: "\u228E", Uogon: "\u0172", Uopf: "\uD835\uDD4C", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", udarr: "\u21C5", UpDownArrow: "\u2195", updownarrow: "\u2195", varr: "\u2195", UpEquilibrium: "\u296E", udhar: "\u296E", UpTee: "\u22A5", bot: "\u22A5", bottom: "\u22A5", perp: "\u22A5", UpTeeArrow: "\u21A5", mapstoup: "\u21A5", UpperLeftArrow: "\u2196", nwarr: "\u2196", nwarrow: "\u2196", UpperRightArrow: "\u2197", nearr: "\u2197", nearrow: "\u2197", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\uD835\uDCB0", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", bigvee: "\u22C1", xvee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", mid: "\u2223", shortmid: "\u2223", smid: "\u2223", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", wr: "\u2240", wreath: "\u2240", VeryThinSpace: "\u200A", hairsp: "\u200A", Vfr: "\uD835\uDD19", Vopf: "\uD835\uDD4D", Vscr: "\uD835\uDCB1", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", bigwedge: "\u22C0", xwedge: "\u22C0", Wfr: "\uD835\uDD1A", Wopf: "\uD835\uDD4E", Wscr: "\uD835\uDCB2", Xfr: "\uD835\uDD1B", Xi: "\u039E", Xopf: "\uD835\uDD4F", Xscr: "\uD835\uDCB3", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\uD835\uDD1C", Yopf: "\uD835\uDD50", Yscr: "\uD835\uDCB4", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", Zeta: "\u0396", Zfr: "\u2128", zeetrf: "\u2128", Zopf: "\u2124", integers: "\u2124", Zscr: "\uD835\uDCB5", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", mstpos: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acy: "\u0430", aelig: "\xE6", afr: "\uD835\uDD1E", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", and: "\u2227", wedge: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", angle: "\u2220", ange: "\u29A4", angmsd: "\u2221", measuredangle: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angzarr: "\u237C", aogon: "\u0105", aopf: "\uD835\uDD52", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", approxeq: "\u224A", apid: "\u224B", apos: "'", aring: "\xE5", ascr: "\uD835\uDCB6", ast: "*", midast: "*", atilde: "\xE3", auml: "\xE4", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", bcong: "\u224C", backepsilon: "\u03F6", bepsi: "\u03F6", backprime: "\u2035", bprime: "\u2035", backsim: "\u223D", bsim: "\u223D", backsimeq: "\u22CD", bsime: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrktbrk: "\u23B6", bcy: "\u0431", bdquo: "\u201E", ldquor: "\u201E", bemptyv: "\u29B0", beta: "\u03B2", beth: "\u2136", between: "\u226C", twixt: "\u226C", bfr: "\uD835\uDD1F", bigcirc: "\u25EF", xcirc: "\u25EF", bigodot: "\u2A00", xodot: "\u2A00", bigoplus: "\u2A01", xoplus: "\u2A01", bigotimes: "\u2A02", xotime: "\u2A02", bigsqcup: "\u2A06", xsqcup: "\u2A06", bigstar: "\u2605", starf: "\u2605", bigtriangledown: "\u25BD", xdtri: "\u25BD", bigtriangleup: "\u25B3", xutri: "\u25B3", biguplus: "\u2A04", xuplus: "\u2A04", bkarow: "\u290D", rbarr: "\u290D", blacklozenge: "\u29EB", lozf: "\u29EB", blacktriangle: "\u25B4", utrif: "\u25B4", blacktriangledown: "\u25BE", dtrif: "\u25BE", blacktriangleleft: "\u25C2", ltrif: "\u25C2", blacktriangleright: "\u25B8", rtrif: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\uD835\uDD53", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", minusb: "\u229F", boxplus: "\u229E", plusb: "\u229E", boxtimes: "\u22A0", timesb: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", brvbar: "\xA6", bscr: "\uD835\uDCB7", bsemi: "\u204F", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bumpE: "\u2AAE", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cemptyv: "\u29B2", cent: "\xA2", cfr: "\uD835\uDD20", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", cire: "\u2257", circlearrowleft: "\u21BA", olarr: "\u21BA", circlearrowright: "\u21BB", orarr: "\u21BB", circledS: "\u24C8", oS: "\u24C8", circledast: "\u229B", oast: "\u229B", circledcirc: "\u229A", ocir: "\u229A", circleddash: "\u229D", odash: "\u229D", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", comma: ",", commat: "@", comp: "\u2201", complement: "\u2201", congdot: "\u2A6D", copf: "\uD835\uDD54", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\uD835\uDCB8", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", curlyeqprec: "\u22DE", cuesc: "\u22DF", curlyeqsucc: "\u22DF", cularr: "\u21B6", curvearrowleft: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curvearrowright: "\u21B7", curarrm: "\u293C", curlyvee: "\u22CE", cuvee: "\u22CE", curlywedge: "\u22CF", cuwed: "\u22CF", curren: "\xA4", cwint: "\u2231", cylcty: "\u232D", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", dash: "\u2010", hyphen: "\u2010", dbkarow: "\u290F", rBarr: "\u290F", dcaron: "\u010F", dcy: "\u0434", ddarr: "\u21CA", downdownarrows: "\u21CA", ddotseq: "\u2A77", eDDot: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", diamondsuit: "\u2666", diams: "\u2666", digamma: "\u03DD", gammad: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", llcorner: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", doteqdot: "\u2251", eDot: "\u2251", dotminus: "\u2238", minusd: "\u2238", dotplus: "\u2214", plusdo: "\u2214", dotsquare: "\u22A1", sdotb: "\u22A1", drcorn: "\u231F", lrcorner: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", triangledown: "\u25BF", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", eqcirc: "\u2256", ecirc: "\xEA", ecolon: "\u2255", eqcolon: "\u2255", ecy: "\u044D", edot: "\u0117", efDot: "\u2252", fallingdotseq: "\u2252", efr: "\uD835\uDD22", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", eqslantgtr: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", eqslantless: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", varnothing: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\uD835\uDD56", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", straightepsilon: "\u03F5", varepsilon: "\u03F5", equals: "=", equest: "\u225F", questeq: "\u225F", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", risingdotseq: "\u2253", erarr: "\u2971", escr: "\u212F", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", fork: "\u22D4", pitchfork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", half: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", sfrown: "\u2322", fscr: "\uD835\uDCBB", gEl: "\u2A8C", gtreqqless: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gap: "\u2A86", gtrapprox: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", gimel: "\u2137", gjcy: "\u0453", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gneqq: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gnsim: "\u22E7", gopf: "\uD835\uDD58", gscr: "\u210A", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtrdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrarr: "\u2978", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hardcy: "\u044A", harrcir: "\u2948", harrw: "\u21AD", leftrightsquigarrow: "\u21AD", hbar: "\u210F", hslash: "\u210F", planck: "\u210F", plankv: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", mldr: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", hksearow: "\u2925", searhk: "\u2925", hkswarow: "\u2926", swarhk: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", larrhk: "\u21A9", hookrightarrow: "\u21AA", rarrhk: "\u21AA", hopf: "\uD835\uDD59", horbar: "\u2015", hscr: "\uD835\uDCBD", hstrok: "\u0127", hybull: "\u2043", iacute: "\xED", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", ifr: "\uD835\uDD26", igrave: "\xEC", iiiint: "\u2A0C", qint: "\u2A0C", iiint: "\u222D", tint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", imath: "\u0131", inodot: "\u0131", imof: "\u22B7", imped: "\u01B5", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", intcal: "\u22BA", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\uD835\uDD5A", iota: "\u03B9", iquest: "\xBF", iscr: "\uD835\uDCBE", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\uD835\uDD27", jmath: "\u0237", jopf: "\uD835\uDD5B", jscr: "\uD835\uDCBF", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", varkappa: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\uD835\uDD28", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\uD835\uDD5C", kscr: "\uD835\uDCC0", lAtail: "\u291B", lBarr: "\u290E", lEg: "\u2A8B", lesseqqgtr: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lambda: "\u03BB", langd: "\u2991", lap: "\u2A85", lessapprox: "\u2A85", laquo: "\xAB", larrbfs: "\u291F", larrfs: "\u291D", larrlp: "\u21AB", looparrowleft: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", leftarrowtail: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lcy: "\u043B", ldca: "\u2936", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leq: "\u2264", leftleftarrows: "\u21C7", llarr: "\u21C7", leftthreetimes: "\u22CB", lthree: "\u22CB", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessdot: "\u22D6", ltdot: "\u22D6", lfisht: "\u297C", lfr: "\uD835\uDD29", lgE: "\u2A91", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lneqq: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", longmapsto: "\u27FC", xmap: "\u27FC", looparrowright: "\u21AC", rarrlp: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", loz: "\u25CA", lozenge: "\u25CA", lpar: "(", lparlt: "\u2993", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", lsime: "\u2A8D", lsimg: "\u2A8F", lsquor: "\u201A", sbquo: "\u201A", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", triangleleft: "\u25C3", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", strns: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", mfr: "\uD835\uDD2A", mho: "\u2127", micro: "\xB5", midcir: "\u2AF0", minus: "\u2212", minusdu: "\u2A2A", mlcp: "\u2ADB", models: "\u22A7", mopf: "\uD835\uDD5E", mscr: "\uD835\uDCC2", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nLeftarrow: "\u21CD", nlArr: "\u21CD", nLeftrightarrow: "\u21CE", nhArr: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nRightarrow: "\u21CF", nrArr: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nacute: "\u0144", nang: "\u2220\u20D2", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", natur: "\u266E", natural: "\u266E", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", neArr: "\u21D7", nearhk: "\u2924", nedot: "\u2250\u0338", nesear: "\u2928", toea: "\u2928", nfr: "\uD835\uDD2B", nharr: "\u21AE", nleftrightarrow: "\u21AE", nhpar: "\u2AF2", nis: "\u22FC", nisd: "\u22FA", njcy: "\u045A", nlE: "\u2266\u0338", nleqq: "\u2266\u0338", nlarr: "\u219A", nleftarrow: "\u219A", nldr: "\u2025", nopf: "\uD835\uDD5F", not: "\xAC", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinvb: "\u22F7", notinvc: "\u22F6", notnivb: "\u22FE", notnivc: "\u22FD", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", nrarr: "\u219B", nrightarrow: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nscr: "\uD835\uDCC3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsubseteqq: "\u2AC5\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupseteqq: "\u2AC6\u0338", ntilde: "\xF1", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwnear: "\u2927", oacute: "\xF3", ocirc: "\xF4", ocy: "\u043E", odblac: "\u0151", odiv: "\u2A38", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\uD835\uDD2C", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", olcir: "\u29BE", olcross: "\u29BB", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", oopf: "\uD835\uDD60", opar: "\u29B7", operp: "\u29B9", or: "\u2228", vee: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", oscr: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", para: "\xB6", parsim: "\u2AF3", parsl: "\u2AFD", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", pertenk: "\u2031", pfr: "\uD835\uDD2D", phi: "\u03C6", phiv: "\u03D5", straightphi: "\u03D5", varphi: "\u03D5", phone: "\u260E", pi: "\u03C0", piv: "\u03D6", varpi: "\u03D6", planckh: "\u210E", plus: "+", plusacir: "\u2A23", pluscir: "\u2A22", plusdu: "\u2A25", pluse: "\u2A72", plussim: "\u2A26", plustwo: "\u2A27", pointint: "\u2A15", popf: "\uD835\uDD61", pound: "\xA3", prE: "\u2AB3", prap: "\u2AB7", precapprox: "\u2AB7", precnapprox: "\u2AB9", prnap: "\u2AB9", precneqq: "\u2AB5", prnE: "\u2AB5", precnsim: "\u22E8", prnsim: "\u22E8", prime: "\u2032", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prurel: "\u22B0", pscr: "\uD835\uDCC5", psi: "\u03C8", puncsp: "\u2008", qfr: "\uD835\uDD2E", qopf: "\uD835\uDD62", qprime: "\u2057", qscr: "\uD835\uDCC6", quatint: "\u2A16", quest: "?", rAtail: "\u291C", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", raemptyv: "\u29B3", rangd: "\u2992", range: "\u29A5", raquo: "\xBB", rarrap: "\u2975", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rightarrowtail: "\u21A3", rarrw: "\u219D", rightsquigarrow: "\u219D", ratail: "\u291A", ratio: "\u2236", rbbrk: "\u2773", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdsh: "\u21B3", rect: "\u25AD", rfisht: "\u297D", rfr: "\uD835\uDD2F", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", varrho: "\u03F1", rightrightarrows: "\u21C9", rrarr: "\u21C9", rightthreetimes: "\u22CC", rthree: "\u22CC", ring: "\u02DA", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", ropar: "\u2986", ropf: "\uD835\uDD63", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rsaquo: "\u203A", rscr: "\uD835\uDCC7", rtimes: "\u22CA", rtri: "\u25B9", triangleright: "\u25B9", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", scE: "\u2AB4", scap: "\u2AB8", succapprox: "\u2AB8", scaron: "\u0161", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", succneqq: "\u2AB6", scnap: "\u2ABA", succnapprox: "\u2ABA", scnsim: "\u22E9", succnsim: "\u22E9", scpolint: "\u2A13", scy: "\u0441", sdot: "\u22C5", sdote: "\u2A66", seArr: "\u21D8", sect: "\xA7", semi: ";", seswar: "\u2929", tosa: "\u2929", sext: "\u2736", sfr: "\uD835\uDD30", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", varsigma: "\u03C2", simdot: "\u2A6A", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", smashp: "\u2A33", smeparsl: "\u29E4", smile: "\u2323", ssmile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", spades: "\u2660", spadesuit: "\u2660", sqcaps: "\u2293\uFE00", sqcups: "\u2294\uFE00", sscr: "\uD835\uDCC8", star: "\u2606", sub: "\u2282", subset: "\u2282", subE: "\u2AC5", subseteqq: "\u2AC5", subdot: "\u2ABD", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subsetneqq: "\u2ACB", subne: "\u228A", subsetneq: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supseteqq: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supsetneqq: "\u2ACC", supne: "\u228B", supsetneq: "\u228B", supplus: "\u2AC0", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", telrec: "\u2315", tfr: "\uD835\uDD31", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", vartheta: "\u03D1", thorn: "\xFE", times: "\xD7", timesbar: "\u2A31", timesd: "\u2A30", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", topfork: "\u2ADA", tprime: "\u2034", triangle: "\u25B5", utri: "\u25B5", triangleq: "\u225C", trie: "\u225C", tridot: "\u25EC", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", uHar: "\u2963", uacute: "\xFA", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udblac: "\u0171", ufisht: "\u297E", ufr: "\uD835\uDD32", ugrave: "\xF9", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uogon: "\u0173", uopf: "\uD835\uDD66", upsi: "\u03C5", upsilon: "\u03C5", upuparrows: "\u21C8", uuarr: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\uD835\uDCCA", utdot: "\u22F0", utilde: "\u0169", uuml: "\xFC", uwangle: "\u29A7", vBar: "\u2AE8", vBarv: "\u2AE9", vangrt: "\u299C", varsubsetneq: "\u228A\uFE00", vsubne: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", vsubnE: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", vsupne: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vsupnE: "\u2ACC\uFE00", vcy: "\u0432", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", vfr: "\uD835\uDD33", vopf: "\uD835\uDD67", vscr: "\uD835\uDCCB", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedgeq: "\u2259", weierp: "\u2118", wp: "\u2118", wfr: "\uD835\uDD34", wopf: "\uD835\uDD68", wscr: "\uD835\uDCCC", xfr: "\uD835\uDD35", xi: "\u03BE", xnis: "\u22FB", xopf: "\uD835\uDD69", xscr: "\uD835\uDCCD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\uD835\uDD36", yicy: "\u0457", yopf: "\uD835\uDD6A", yscr: "\uD835\uDCCE", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeta: "\u03B6", zfr: "\uD835\uDD37", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", zscr: "\uD835\uDCCF", zwj: "\u200D", zwnj: "\u200C" };
  Ve.ngsp = Xa;
  Ja = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  $r = new Rr("{{", "}}");
  gt2 = class extends Oe {
    constructor(e2, r2, n2) {
      super(n2, e2), this.tokenType = r2;
    }
  };
  So = /\r\n?/g;
  (function(t4) {
    t4.HEX = "hexadecimal", t4.DEC = "decimal";
  })(tr || (tr = {}));
  Wr = class t5 extends rr {
    constructor(e2, r2) {
      e2 instanceof t5 ? (super(e2), this.internalState = { ...e2.internalState }) : (super(e2, r2), this.internalState = this.state);
    }
    advance() {
      this.state = this.internalState, super.advance(), this.processEscapeSequence();
    }
    init() {
      super.init(), this.processEscapeSequence();
    }
    clone() {
      return new t5(this);
    }
    getChars(e2) {
      let r2 = e2.clone(), n2 = "";
      for (;r2.internalState.offset < this.internalState.offset; )
        n2 += String.fromCodePoint(r2.peek()), r2.advance();
      return n2;
    }
    processEscapeSequence() {
      let e2 = () => this.internalState.peek;
      if (e2() === 92)
        if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e2() === 110)
          this.state.peek = 10;
        else if (e2() === 114)
          this.state.peek = 13;
        else if (e2() === 118)
          this.state.peek = 11;
        else if (e2() === 116)
          this.state.peek = 9;
        else if (e2() === 98)
          this.state.peek = 8;
        else if (e2() === 102)
          this.state.peek = 12;
        else if (e2() === 117)
          if (this.advanceState(this.internalState), e2() === 123) {
            this.advanceState(this.internalState);
            let r2 = this.clone(), n2 = 0;
            for (;e2() !== 125; )
              this.advanceState(this.internalState), n2++;
            this.state.peek = this.decodeHexDigits(r2, n2);
          } else {
            let r2 = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r2, 4);
          }
        else if (e2() === 120) {
          this.advanceState(this.internalState);
          let r2 = this.clone();
          this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r2, 2);
        } else if (kr(e2())) {
          let r2 = "", n2 = 0, s2 = this.clone();
          for (;kr(e2()) && n2 < 3; )
            s2 = this.clone(), r2 += String.fromCodePoint(e2()), this.advanceState(this.internalState), n2++;
          this.state.peek = parseInt(r2, 8), this.internalState = s2.internalState;
        } else
          Rt(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
    }
    decodeHexDigits(e2, r2) {
      let n2 = this.input.slice(e2.internalState.offset, e2.internalState.offset + r2), s2 = parseInt(n2, 16);
      if (isNaN(s2))
        throw e2.state = e2.internalState, new St("Invalid hexadecimal escape sequence", e2);
      return s2;
    }
  };
  L = class t6 extends Oe {
    static create(e2, r2, n2) {
      return new t6(e2, r2, n2);
    }
    constructor(e2, r2, n2) {
      super(r2, n2), this.elementName = e2;
    }
  };
  sr = class extends nr {
    constructor() {
      super(He);
    }
    parse(e2, r2, n2, s2 = false, i) {
      return super.parse(e2, r2, n2, s2, i);
    }
  };
  Zs = To;
  ei = ko;
  ir = { attrs: true, children: true, cases: true, expression: true };
  ti = new Set(["parent"]);
  le = new WeakSet, Xr = function() {
    return this.type === "angularIcuCase" ? "expression" : this.type === "angularIcuExpression" ? "cases" : "children";
  }, Jr = function() {
    var e2;
    return ((e2 = this.parent) == null ? undefined : e2.$children) ?? [];
  };
  ar = ze;
  Lo = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: Fo }, { regex: /^\[if([^\]]*)\]><!$/u, parse: No }, { regex: /^<!\s*\[endif\]$/u, parse: Po }];
  or2 = new Map([["*", new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", new Set(["href", "target"])], ["basefont", new Set(["color", "face", "size"])], ["blockquote", new Set(["cite"])], ["body", new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", new Set(["clear"])], ["button", new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", new Set(["height", "width"])], ["caption", new Set(["align"])], ["col", new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", new Set(["value"])], ["del", new Set(["cite", "datetime"])], ["details", new Set(["name", "open"])], ["dialog", new Set(["open"])], ["dir", new Set(["compact"])], ["div", new Set(["align"])], ["dl", new Set(["compact"])], ["embed", new Set(["height", "src", "type", "width"])], ["fieldset", new Set(["disabled", "form", "name"])], ["font", new Set(["color", "face", "size"])], ["form", new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", new Set(["cols", "rows"])], ["h1", new Set(["align"])], ["h2", new Set(["align"])], ["h3", new Set(["align"])], ["h4", new Set(["align"])], ["h5", new Set(["align"])], ["h6", new Set(["align"])], ["head", new Set(["profile"])], ["hr", new Set(["align", "noshade", "size", "width"])], ["html", new Set(["manifest", "version"])], ["iframe", new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", new Set(["cite", "datetime"])], ["isindex", new Set(["prompt"])], ["label", new Set(["for", "form"])], ["legend", new Set(["align"])], ["li", new Set(["type", "value"])], ["link", new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", new Set(["name"])], ["menu", new Set(["compact"])], ["meta", new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", new Set(["compact", "reversed", "start", "type"])], ["optgroup", new Set(["disabled", "label"])], ["option", new Set(["disabled", "label", "selected", "value"])], ["output", new Set(["for", "form", "name"])], ["p", new Set(["align"])], ["param", new Set(["name", "type", "value", "valuetype"])], ["pre", new Set(["width"])], ["progress", new Set(["max", "value"])], ["q", new Set(["cite"])], ["script", new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", new Set(["name"])], ["source", new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", new Set(["blocking", "media", "type"])], ["table", new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", new Set(["align", "char", "charoff", "valign"])], ["td", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", new Set(["align", "char", "charoff", "valign"])], ["th", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", new Set(["align", "char", "charoff", "valign"])], ["time", new Set(["datetime"])], ["tr", new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", new Set(["default", "kind", "label", "src", "srclang"])], ["ul", new Set(["compact", "type"])], ["video", new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
  ni = new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
  oi = { name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true };
  Mo = ur(oi);
  qo = ur({ name: "angular" });
  Ho = ur({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(t8, e2, r2, n2) {
    return t8.toLowerCase() !== "html" && !r2 && (t8 !== "template" || n2.some(({ name: s2, value: i }) => s2 === "lang" && i !== "html" && i !== "" && i !== undefined));
  } });
  Vo = ur({ name: "lwc", canSelfClose: false });
  Uo = { html: Ts };
  Gh = en;
});

// ../../node_modules/prettier/standalone.mjs
function U() {}
function mr2(e2, t8, r2, n2, u) {
  for (var i = [], o2;t8; )
    i.push(t8), o2 = t8.previousComponent, delete t8.previousComponent, t8 = o2;
  i.reverse();
  for (var s2 = 0, a = i.length, D = 0, l2 = 0;s2 < a; s2++) {
    var p = i[s2];
    if (p.removed)
      p.value = e2.join(n2.slice(l2, l2 + p.count)), l2 += p.count;
    else {
      if (!p.added && u) {
        var f = r2.slice(D, D + p.count);
        f = f.map(function(d, c2) {
          var F = n2[l2 + c2];
          return F.length > d.length ? F : d;
        }), p.value = e2.join(f);
      } else
        p.value = e2.join(r2.slice(D, D + p.count));
      D += p.count, p.added || (l2 += p.count);
    }
  }
  return i;
}
function hr2(e2, t8) {
  var r2;
  for (r2 = 0;r2 < e2.length && r2 < t8.length; r2++)
    if (e2[r2] != t8[r2])
      return e2.slice(0, r2);
  return e2.slice(0, r2);
}
function Er2(e2, t8) {
  var r2;
  if (!e2 || !t8 || e2[e2.length - 1] != t8[t8.length - 1])
    return "";
  for (r2 = 0;r2 < e2.length && r2 < t8.length; r2++)
    if (e2[e2.length - (r2 + 1)] != t8[t8.length - (r2 + 1)])
      return e2.slice(-r2);
  return e2.slice(-r2);
}
function Bt2(e2, t8, r2) {
  if (e2.slice(0, t8.length) != t8)
    throw Error("string ".concat(JSON.stringify(e2), " doesn't start with prefix ").concat(JSON.stringify(t8), "; this is a bug"));
  return r2 + e2.slice(t8.length);
}
function wt2(e2, t8, r2) {
  if (!t8)
    return e2 + r2;
  if (e2.slice(-t8.length) != t8)
    throw Error("string ".concat(JSON.stringify(e2), " doesn't end with suffix ").concat(JSON.stringify(t8), "; this is a bug"));
  return e2.slice(0, -t8.length) + r2;
}
function _e2(e2, t8) {
  return Bt2(e2, t8, "");
}
function Ve2(e2, t8) {
  return wt2(e2, t8, "");
}
function Cr2(e2, t8) {
  return t8.slice(0, Ou(e2, t8));
}
function Ou(e2, t8) {
  var r2 = 0;
  e2.length > t8.length && (r2 = e2.length - t8.length);
  var n2 = t8.length;
  e2.length < t8.length && (n2 = e2.length);
  var u = Array(n2), i = 0;
  u[0] = 0;
  for (var o2 = 1;o2 < n2; o2++) {
    for (t8[o2] == t8[i] ? u[o2] = u[i] : u[o2] = i;i > 0 && t8[o2] != t8[i]; )
      i = u[i];
    t8[o2] == t8[i] && i++;
  }
  i = 0;
  for (var s2 = r2;s2 < e2.length; s2++) {
    for (;i > 0 && e2[s2] != t8[i]; )
      i = u[i];
    e2[s2] == t8[i] && i++;
  }
  return i;
}
function gr2(e2, t8, r2, n2) {
  if (t8 && r2) {
    var u = t8.value.match(/^\s*/)[0], i = t8.value.match(/\s*$/)[0], o2 = r2.value.match(/^\s*/)[0], s2 = r2.value.match(/\s*$/)[0];
    if (e2) {
      var a = hr2(u, o2);
      e2.value = wt2(e2.value, o2, a), t8.value = _e2(t8.value, a), r2.value = _e2(r2.value, a);
    }
    if (n2) {
      var D = Er2(i, s2);
      n2.value = Bt2(n2.value, s2, D), t8.value = Ve2(t8.value, D), r2.value = Ve2(r2.value, D);
    }
  } else if (r2)
    e2 && (r2.value = r2.value.replace(/^\s*/, "")), n2 && (n2.value = n2.value.replace(/^\s*/, ""));
  else if (e2 && n2) {
    var l2 = n2.value.match(/^\s*/)[0], p = t8.value.match(/^\s*/)[0], f = t8.value.match(/\s*$/)[0], d = hr2(l2, p);
    t8.value = _e2(t8.value, d);
    var c2 = Er2(_e2(l2, d), f);
    t8.value = Ve2(t8.value, c2), n2.value = Bt2(n2.value, l2, c2), e2.value = wt2(e2.value, l2, l2.slice(0, l2.length - c2.length));
  } else if (n2) {
    var F = n2.value.match(/^\s*/)[0], m2 = t8.value.match(/\s*$/)[0], h2 = Cr2(m2, F);
    t8.value = Ve2(t8.value, h2);
  } else if (e2) {
    var C = e2.value.match(/\s*$/)[0], v2 = t8.value.match(/^\s*/)[0], E2 = Cr2(C, v2);
    t8.value = _e2(t8.value, E2);
  }
}
function _t2(e2) {
  "@babel/helpers - typeof";
  return _t2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t8) {
    return typeof t8;
  } : function(t8) {
    return t8 && typeof Symbol == "function" && t8.constructor === Symbol && t8 !== Symbol.prototype ? "symbol" : typeof t8;
  }, _t2(e2);
}
function xt2(e2, t8, r2, n2, u) {
  t8 = t8 || [], r2 = r2 || [], n2 && (e2 = n2(u, e2));
  var i;
  for (i = 0;i < t8.length; i += 1)
    if (t8[i] === e2)
      return r2[i];
  var o2;
  if (Object.prototype.toString.call(e2) === "[object Array]") {
    for (t8.push(e2), o2 = new Array(e2.length), r2.push(o2), i = 0;i < e2.length; i += 1)
      o2[i] = xt2(e2[i], t8, r2, n2, u);
    return t8.pop(), r2.pop(), o2;
  }
  if (e2 && e2.toJSON && (e2 = e2.toJSON()), _t2(e2) === "object" && e2 !== null) {
    t8.push(e2), o2 = {}, r2.push(o2);
    var s2 = [], a;
    for (a in e2)
      Object.prototype.hasOwnProperty.call(e2, a) && s2.push(a);
    for (s2.sort(), i = 0;i < s2.length; i += 1)
      a = s2[i], o2[a] = xt2(e2[a], t8, r2, n2, a);
    t8.pop(), r2.pop();
  } else
    o2 = e2;
  return o2;
}
function yr2(e2, t8, r2) {
  return ze3.diff(e2, t8, r2);
}
function Ar2(e2) {
  let t8 = e2.indexOf("\r");
  return t8 !== -1 ? e2.charAt(t8 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function be2(e2) {
  switch (e2) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Nt2(e2, t8) {
  let r2;
  switch (t8) {
    case `
`:
      r2 = /\n/gu;
      break;
    case "\r":
      r2 = /\r/gu;
      break;
    case `\r
`:
      r2 = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t8)}.`);
  }
  let n2 = e2.match(r2);
  return n2 ? n2.length : 0;
}
function vr2(e2) {
  return ne3(false, e2, /\r\n?/gu, `
`);
}
function Iu(e2) {
  if (typeof e2 == "string")
    return $2;
  if (Array.isArray(e2))
    return H2;
  if (!e2)
    return;
  let { type: t8 } = e2;
  if (Ke2.has(t8))
    return t8;
}
function Yu(e2) {
  let t8 = e2 === null ? "null" : typeof e2;
  if (t8 !== "string" && t8 !== "object")
    return `Unexpected doc '${t8}', 
Expected it to be 'string' or 'object'.`;
  if (M(e2))
    throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(e2);
  if (r2 !== "[object Object]")
    return `Unexpected doc '${r2}'.`;
  let n2 = Ru([...Ke2].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
}
function ju(e2, t8, r2, n2) {
  let u = [e2];
  for (;u.length > 0; ) {
    let i = u.pop();
    if (i === Br2) {
      r2(u.pop());
      continue;
    }
    r2 && u.push(i, Br2);
    let o2 = M(i);
    if (!o2)
      throw new Q2(i);
    if ((t8 == null ? undefined : t8(i)) !== false)
      switch (o2) {
        case H2:
        case N2: {
          let s2 = o2 === H2 ? i : i.parts;
          for (let a = s2.length, D = a - 1;D >= 0; --D)
            u.push(s2[D]);
          break;
        }
        case w2:
          u.push(i.flatContents, i.breakContents);
          break;
        case B2:
          if (n2 && i.expandedStates)
            for (let s2 = i.expandedStates.length, a = s2 - 1;a >= 0; --a)
              u.push(i.expandedStates[a]);
          else
            u.push(i.contents);
          break;
        case k2:
        case T2:
        case P2:
        case O2:
        case I2:
          u.push(i.contents);
          break;
        case $2:
        case z2:
        case L2:
        case R2:
        case y:
        case _2:
          break;
        default:
          throw new Q2(i);
      }
  }
}
function Oe2(e2, t8) {
  if (typeof e2 == "string")
    return t8(e2);
  let r2 = new Map;
  return n2(e2);
  function n2(i) {
    if (r2.has(i))
      return r2.get(i);
    let o2 = u(i);
    return r2.set(i, o2), o2;
  }
  function u(i) {
    switch (M(i)) {
      case H2:
        return t8(i.map(n2));
      case N2:
        return t8({ ...i, parts: i.parts.map(n2) });
      case w2:
        return t8({ ...i, breakContents: n2(i.breakContents), flatContents: n2(i.flatContents) });
      case B2: {
        let { expandedStates: o2, contents: s2 } = i;
        return o2 ? (o2 = o2.map(n2), s2 = o2[0]) : s2 = n2(s2), t8({ ...i, contents: s2, expandedStates: o2 });
      }
      case k2:
      case T2:
      case P2:
      case O2:
      case I2:
        return t8({ ...i, contents: n2(i.contents) });
      case $2:
      case z2:
      case L2:
      case R2:
      case y:
      case _2:
        return t8(i);
      default:
        throw new Q2(i);
    }
  }
}
function Je2(e2, t8, r2) {
  let n2 = r2, u = false;
  function i(o2) {
    if (u)
      return false;
    let s2 = t8(o2);
    s2 !== undefined && (u = true, n2 = s2);
  }
  return Fe2(e2, i), n2;
}
function Hu(e2) {
  if (e2.type === B2 && e2.break || e2.type === y && e2.hard || e2.type === _2)
    return true;
}
function xr2(e2) {
  return Je2(e2, Hu, false);
}
function wr2(e2) {
  if (e2.length > 0) {
    let t8 = A(false, e2, -1);
    !t8.expandedStates && !t8.break && (t8.break = "propagated");
  }
  return null;
}
function br2(e2) {
  let t8 = new Set, r2 = [];
  function n2(i) {
    if (i.type === _2 && wr2(r2), i.type === B2) {
      if (r2.push(i), t8.has(i))
        return false;
      t8.add(i);
    }
  }
  function u(i) {
    i.type === B2 && r2.pop().break && wr2(r2);
  }
  Fe2(e2, n2, u, true);
}
function Wu(e2) {
  return e2.type === y && !e2.hard ? e2.soft ? "" : " " : e2.type === w2 ? e2.flatContents : e2;
}
function Nr2(e2) {
  return Oe2(e2, Wu);
}
function _r2(e2) {
  for (e2 = [...e2];e2.length >= 2 && A(false, e2, -2).type === y && A(false, e2, -1).type === _2; )
    e2.length -= 2;
  if (e2.length > 0) {
    let t8 = Ne2(A(false, e2, -1));
    e2[e2.length - 1] = t8;
  }
  return e2;
}
function Ne2(e2) {
  switch (M(e2)) {
    case T2:
    case P2:
    case B2:
    case I2:
    case O2: {
      let t8 = Ne2(e2.contents);
      return { ...e2, contents: t8 };
    }
    case w2:
      return { ...e2, breakContents: Ne2(e2.breakContents), flatContents: Ne2(e2.flatContents) };
    case N2:
      return { ...e2, parts: _r2(e2.parts) };
    case H2:
      return _r2(e2);
    case $2:
      return e2.replace(/[\n\r]*$/u, "");
    case k2:
    case z2:
    case L2:
    case R2:
    case y:
    case _2:
      break;
    default:
      throw new Q2(e2);
  }
  return e2;
}
function qe2(e2) {
  return Ne2(Mu(e2));
}
function $u(e2) {
  switch (M(e2)) {
    case N2:
      if (e2.parts.every((t8) => t8 === ""))
        return "";
      break;
    case B2:
      if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates)
        return "";
      if (e2.contents.type === B2 && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates)
        return e2.contents;
      break;
    case k2:
    case T2:
    case P2:
    case I2:
      if (!e2.contents)
        return "";
      break;
    case w2:
      if (!e2.flatContents && !e2.breakContents)
        return "";
      break;
    case H2: {
      let t8 = [];
      for (let r2 of e2) {
        if (!r2)
          continue;
        let [n2, ...u] = Array.isArray(r2) ? r2 : [r2];
        typeof n2 == "string" && typeof A(false, t8, -1) == "string" ? t8[t8.length - 1] += n2 : t8.push(n2), t8.push(...u);
      }
      return t8.length === 0 ? "" : t8.length === 1 ? t8[0] : t8;
    }
    case $2:
    case z2:
    case L2:
    case R2:
    case y:
    case O2:
    case _2:
      break;
    default:
      throw new Q2(e2);
  }
  return e2;
}
function Mu(e2) {
  return Oe2(e2, (t8) => $u(t8));
}
function Or(e2, t8 = Xe2) {
  return Oe2(e2, (r2) => typeof r2 == "string" ? Se2(t8, r2.split(`
`)) : r2);
}
function Vu(e2) {
  if (e2.type === y)
    return true;
}
function Sr2(e2) {
  return Je2(e2, Vu, false);
}
function me2(e2, t8) {
  return e2.type === O2 ? { ...e2, contents: t8(e2.contents) } : t8(e2);
}
function le2(e2) {
  return G2(e2), { type: T2, contents: e2 };
}
function De2(e2, t8) {
  return G2(t8), { type: k2, contents: t8, n: e2 };
}
function kt2(e2, t8 = {}) {
  return G2(e2), Tt2(t8.expandedStates, true), { type: B2, id: t8.id, contents: e2, break: !!t8.shouldBreak, expandedStates: t8.expandedStates };
}
function kr2(e2) {
  return De2(Number.NEGATIVE_INFINITY, e2);
}
function Lr2(e2) {
  return De2({ type: "root" }, e2);
}
function Pr2(e2) {
  return De2(-1, e2);
}
function Ir2(e2, t8) {
  return kt2(e2[0], { ...t8, expandedStates: e2 });
}
function Rr2(e2) {
  return Tr2(e2), { type: N2, parts: e2 };
}
function Yr2(e2, t8 = "", r2 = {}) {
  return G2(e2), t8 !== "" && G2(t8), { type: w2, breakContents: e2, flatContents: t8, groupId: r2.groupId };
}
function jr2(e2, t8) {
  return G2(e2), { type: P2, contents: e2, groupId: t8.groupId, negate: t8.negate };
}
function Te2(e2) {
  return G2(e2), { type: I2, contents: e2 };
}
function Se2(e2, t8) {
  G2(e2), Tt2(t8);
  let r2 = [];
  for (let n2 = 0;n2 < t8.length; n2++)
    n2 !== 0 && r2.push(e2), r2.push(t8[n2]);
  return r2;
}
function Ze2(e2, t8, r2) {
  G2(e2);
  let n2 = e2;
  if (t8 > 0) {
    for (let u = 0;u < Math.floor(t8 / r2); ++u)
      n2 = le2(n2);
    n2 = De2(t8 % r2, n2), n2 = De2(Number.NEGATIVE_INFINITY, n2);
  }
  return n2;
}
function Mr(e2, t8) {
  return G2(t8), e2 ? { type: O2, label: e2, contents: t8 } : t8;
}
function ee2(e2) {
  var t8;
  if (!e2)
    return "";
  if (Array.isArray(e2)) {
    let r2 = [];
    for (let n2 of e2)
      if (Array.isArray(n2))
        r2.push(...ee2(n2));
      else {
        let u = ee2(n2);
        u !== "" && r2.push(u);
      }
    return r2;
  }
  return e2.type === w2 ? { ...e2, breakContents: ee2(e2.breakContents), flatContents: ee2(e2.flatContents) } : e2.type === B2 ? { ...e2, contents: ee2(e2.contents), expandedStates: (t8 = e2.expandedStates) == null ? undefined : t8.map(ee2) } : e2.type === N2 ? { type: "fill", parts: e2.parts.map(ee2) } : e2.contents ? { ...e2, contents: ee2(e2.contents) } : e2;
}
function Vr2(e2) {
  let t8 = Object.create(null), r2 = new Set;
  return n2(ee2(e2));
  function n2(i, o2, s2) {
    var a, D;
    if (typeof i == "string")
      return JSON.stringify(i);
    if (Array.isArray(i)) {
      let l2 = i.map(n2).filter(Boolean);
      return l2.length === 1 ? l2[0] : `[${l2.join(", ")}]`;
    }
    if (i.type === y) {
      let l2 = ((a = s2 == null ? undefined : s2[o2 + 1]) == null ? undefined : a.type) === _2;
      return i.literal ? l2 ? "literalline" : "literallineWithoutBreakParent" : i.hard ? l2 ? "hardline" : "hardlineWithoutBreakParent" : i.soft ? "softline" : "line";
    }
    if (i.type === _2)
      return ((D = s2 == null ? undefined : s2[o2 - 1]) == null ? undefined : D.type) === y && s2[o2 - 1].hard ? undefined : "breakParent";
    if (i.type === L2)
      return "trim";
    if (i.type === T2)
      return "indent(" + n2(i.contents) + ")";
    if (i.type === k2)
      return i.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n2(i.contents) + ")" : i.n < 0 ? "dedent(" + n2(i.contents) + ")" : i.n.type === "root" ? "markAsRoot(" + n2(i.contents) + ")" : "align(" + JSON.stringify(i.n) + ", " + n2(i.contents) + ")";
    if (i.type === w2)
      return "ifBreak(" + n2(i.breakContents) + (i.flatContents ? ", " + n2(i.flatContents) : "") + (i.groupId ? (i.flatContents ? "" : ', ""') + `, { groupId: ${u(i.groupId)} }` : "") + ")";
    if (i.type === P2) {
      let l2 = [];
      i.negate && l2.push("negate: true"), i.groupId && l2.push(`groupId: ${u(i.groupId)}`);
      let p = l2.length > 0 ? `, { ${l2.join(", ")} }` : "";
      return `indentIfBreak(${n2(i.contents)}${p})`;
    }
    if (i.type === B2) {
      let l2 = [];
      i.break && i.break !== "propagated" && l2.push("shouldBreak: true"), i.id && l2.push(`id: ${u(i.id)}`);
      let p = l2.length > 0 ? `, { ${l2.join(", ")} }` : "";
      return i.expandedStates ? `conditionalGroup([${i.expandedStates.map((f) => n2(f)).join(",")}]${p})` : `group(${n2(i.contents)}${p})`;
    }
    if (i.type === N2)
      return `fill([${i.parts.map((l2) => n2(l2)).join(", ")}])`;
    if (i.type === I2)
      return "lineSuffix(" + n2(i.contents) + ")";
    if (i.type === R2)
      return "lineSuffixBoundary";
    if (i.type === O2)
      return `label(${JSON.stringify(i.label)}, ${n2(i.contents)})`;
    throw new Error("Unknown doc type " + i.type);
  }
  function u(i) {
    if (typeof i != "symbol")
      return JSON.stringify(String(i));
    if (i in t8)
      return t8[i];
    let o2 = i.description || "symbol";
    for (let s2 = 0;; s2++) {
      let a = o2 + (s2 > 0 ? ` #${s2}` : "");
      if (!r2.has(a))
        return r2.add(a), t8[i] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
function zr(e2) {
  return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
}
function Gr(e2) {
  return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9776 && e2 <= 9783 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 >= 9866 && e2 <= 9871 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12773 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101631 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 >= 119552 && e2 <= 119638 || e2 >= 119648 && e2 <= 119670 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129673 || e2 >= 129679 && e2 <= 129734 || e2 >= 129742 && e2 <= 129756 || e2 >= 129759 && e2 <= 129769 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
}
function zu(e2) {
  if (!e2)
    return 0;
  if (!Uu.test(e2))
    return e2.length;
  e2 = e2.replace(Ur2(), "  ");
  let t8 = 0;
  for (let r2 of e2) {
    let n2 = r2.codePointAt(0);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t8 += Kr2(n2) ? 1 : 2);
  }
  return t8;
}
function Jr2() {
  return { value: "", length: 0, queue: [] };
}
function Gu(e2, t8) {
  return It2(e2, { type: "indent" }, t8);
}
function Ku(e2, t8, r2) {
  return t8 === Number.NEGATIVE_INFINITY ? e2.root || Jr2() : t8 < 0 ? It2(e2, { type: "dedent" }, r2) : t8 ? t8.type === "root" ? { ...e2, root: e2 } : It2(e2, { type: typeof t8 == "string" ? "stringAlign" : "numberAlign", n: t8 }, r2) : e2;
}
function It2(e2, t8, r2) {
  let n2 = t8.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t8], u = "", i = 0, o2 = 0, s2 = 0;
  for (let c2 of n2)
    switch (c2.type) {
      case "indent":
        l2(), r2.useTabs ? a(1) : D(r2.tabWidth);
        break;
      case "stringAlign":
        l2(), u += c2.n, i += c2.n.length;
        break;
      case "numberAlign":
        o2 += 1, s2 += c2.n;
        break;
      default:
        throw new Error(`Unexpected type '${c2.type}'`);
    }
  return f(), { ...e2, value: u, length: i, queue: n2 };
  function a(c2) {
    u += "\t".repeat(c2), i += r2.tabWidth * c2;
  }
  function D(c2) {
    u += " ".repeat(c2), i += c2;
  }
  function l2() {
    r2.useTabs ? p() : f();
  }
  function p() {
    o2 > 0 && a(o2), d();
  }
  function f() {
    s2 > 0 && D(s2), d();
  }
  function d() {
    o2 = 0, s2 = 0;
  }
}
function Rt2(e2) {
  let t8 = 0, r2 = 0, n2 = e2.length;
  e:
    for (;n2--; ) {
      let u = e2[n2];
      if (u === Ee2) {
        r2++;
        continue;
      }
      for (let i = u.length - 1;i >= 0; i--) {
        let o2 = u[i];
        if (o2 === " " || o2 === "\t")
          t8++;
        else {
          e2[n2] = u.slice(0, i + 1);
          break e;
        }
      }
    }
  if (t8 > 0 || r2 > 0)
    for (e2.length = n2 + 1;r2-- > 0; )
      e2.push(Ee2);
  return t8;
}
function et2(e2, t8, r2, n2, u, i) {
  if (r2 === Number.POSITIVE_INFINITY)
    return true;
  let o2 = t8.length, s2 = [e2], a = [];
  for (;r2 >= 0; ) {
    if (s2.length === 0) {
      if (o2 === 0)
        return true;
      s2.push(t8[--o2]);
      continue;
    }
    let { mode: D, doc: l2 } = s2.pop(), p = M(l2);
    switch (p) {
      case $2:
        a.push(l2), r2 -= Le2(l2);
        break;
      case H2:
      case N2: {
        let f = p === H2 ? l2 : l2.parts, d = l2[Pt2] ?? 0;
        for (let c2 = f.length - 1;c2 >= d; c2--)
          s2.push({ mode: D, doc: f[c2] });
        break;
      }
      case T2:
      case k2:
      case P2:
      case O2:
        s2.push({ mode: D, doc: l2.contents });
        break;
      case L2:
        r2 += Rt2(a);
        break;
      case B2: {
        if (i && l2.break)
          return false;
        let f = l2.break ? Y2 : D, d = l2.expandedStates && f === Y2 ? A(false, l2.expandedStates, -1) : l2.contents;
        s2.push({ mode: f, doc: d });
        break;
      }
      case w2: {
        let d = (l2.groupId ? u[l2.groupId] || J2 : D) === Y2 ? l2.breakContents : l2.flatContents;
        d && s2.push({ mode: D, doc: d });
        break;
      }
      case y:
        if (D === Y2 || l2.hard)
          return true;
        l2.soft || (a.push(" "), r2--);
        break;
      case I2:
        n2 = true;
        break;
      case R2:
        if (n2)
          return false;
        break;
    }
  }
  return false;
}
function Ce2(e2, t8) {
  let r2 = {}, n2 = t8.printWidth, u = be2(t8.endOfLine), i = 0, o2 = [{ ind: Jr2(), mode: Y2, doc: e2 }], s2 = [], a = false, D = [], l2 = 0;
  for (br2(e2);o2.length > 0; ) {
    let { ind: f, mode: d, doc: c2 } = o2.pop();
    switch (M(c2)) {
      case $2: {
        let F = u !== `
` ? ne3(false, c2, `
`, u) : c2;
        s2.push(F), o2.length > 0 && (i += Le2(F));
        break;
      }
      case H2:
        for (let F = c2.length - 1;F >= 0; F--)
          o2.push({ ind: f, mode: d, doc: c2[F] });
        break;
      case z2:
        if (l2 >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        s2.push(Ee2), l2++;
        break;
      case T2:
        o2.push({ ind: Gu(f, t8), mode: d, doc: c2.contents });
        break;
      case k2:
        o2.push({ ind: Ku(f, c2.n, t8), mode: d, doc: c2.contents });
        break;
      case L2:
        i -= Rt2(s2);
        break;
      case B2:
        switch (d) {
          case J2:
            if (!a) {
              o2.push({ ind: f, mode: c2.break ? Y2 : J2, doc: c2.contents });
              break;
            }
          case Y2: {
            a = false;
            let F = { ind: f, mode: J2, doc: c2.contents }, m2 = n2 - i, h2 = D.length > 0;
            if (!c2.break && et2(F, o2, m2, h2, r2))
              o2.push(F);
            else if (c2.expandedStates) {
              let C = A(false, c2.expandedStates, -1);
              if (c2.break) {
                o2.push({ ind: f, mode: Y2, doc: C });
                break;
              } else
                for (let v2 = 1;v2 < c2.expandedStates.length + 1; v2++)
                  if (v2 >= c2.expandedStates.length) {
                    o2.push({ ind: f, mode: Y2, doc: C });
                    break;
                  } else {
                    let E2 = c2.expandedStates[v2], g = { ind: f, mode: J2, doc: E2 };
                    if (et2(g, o2, m2, h2, r2)) {
                      o2.push(g);
                      break;
                    }
                  }
            } else
              o2.push({ ind: f, mode: Y2, doc: c2.contents });
            break;
          }
        }
        c2.id && (r2[c2.id] = A(false, o2, -1).mode);
        break;
      case N2: {
        let F = n2 - i, m2 = c2[Pt2] ?? 0, { parts: h2 } = c2, C = h2.length - m2;
        if (C === 0)
          break;
        let v2 = h2[m2 + 0], E2 = h2[m2 + 1], g = { ind: f, mode: J2, doc: v2 }, j2 = { ind: f, mode: Y2, doc: v2 }, b2 = et2(g, [], F, D.length > 0, r2, true);
        if (C === 1) {
          b2 ? o2.push(g) : o2.push(j2);
          break;
        }
        let X2 = { ind: f, mode: J2, doc: E2 }, ae2 = { ind: f, mode: Y2, doc: E2 };
        if (C === 2) {
          b2 ? o2.push(X2, g) : o2.push(ae2, j2);
          break;
        }
        let $e = h2[m2 + 2], yt2 = { ind: f, mode: d, doc: { ...c2, [Pt2]: m2 + 2 } };
        et2({ ind: f, mode: J2, doc: [v2, E2, $e] }, [], F, D.length > 0, r2, true) ? o2.push(yt2, X2, g) : b2 ? o2.push(yt2, ae2, g) : o2.push(yt2, ae2, j2);
        break;
      }
      case w2:
      case P2: {
        let F = c2.groupId ? r2[c2.groupId] : d;
        if (F === Y2) {
          let m2 = c2.type === w2 ? c2.breakContents : c2.negate ? c2.contents : le2(c2.contents);
          m2 && o2.push({ ind: f, mode: d, doc: m2 });
        }
        if (F === J2) {
          let m2 = c2.type === w2 ? c2.flatContents : c2.negate ? le2(c2.contents) : c2.contents;
          m2 && o2.push({ ind: f, mode: d, doc: m2 });
        }
        break;
      }
      case I2:
        D.push({ ind: f, mode: d, doc: c2.contents });
        break;
      case R2:
        D.length > 0 && o2.push({ ind: f, mode: d, doc: ke2 });
        break;
      case y:
        switch (d) {
          case J2:
            if (c2.hard)
              a = true;
            else {
              c2.soft || (s2.push(" "), i += 1);
              break;
            }
          case Y2:
            if (D.length > 0) {
              o2.push({ ind: f, mode: d, doc: c2 }, ...D.reverse()), D.length = 0;
              break;
            }
            c2.literal ? f.root ? (s2.push(u, f.root.value), i = f.root.length) : (s2.push(u), i = 0) : (i -= Rt2(s2), s2.push(u + f.value), i = f.length);
            break;
        }
        break;
      case O2:
        o2.push({ ind: f, mode: d, doc: c2.contents });
        break;
      case _2:
        break;
      default:
        throw new Q2(c2);
    }
    o2.length === 0 && D.length > 0 && (o2.push(...D.reverse()), D.length = 0);
  }
  let p = s2.indexOf(Ee2);
  if (p !== -1) {
    let f = s2.indexOf(Ee2, p + 1);
    if (f === -1)
      return { formatted: s2.filter((m2) => m2 !== Ee2).join("") };
    let d = s2.slice(0, p).join(""), c2 = s2.slice(p + 1, f).join(""), F = s2.slice(f + 1).join("");
    return { formatted: d + c2 + F, cursorNodeStart: d.length, cursorNodeText: c2 };
  }
  return { formatted: s2.join("") };
}
function Ju(e2, t8, r2 = 0) {
  let n2 = 0;
  for (let u = r2;u < e2.length; ++u)
    e2[u] === "\t" ? n2 = n2 + t8 - n2 % t8 : n2++;
  return n2;
}
function qu(e2) {
  return e2 !== null && typeof e2 == "object";
}
function* ye2(e2, t8) {
  let { getVisitorKeys: r2, filter: n2 = () => true } = t8, u = (i) => Qr2(i) && n2(i);
  for (let i of r2(e2)) {
    let o2 = e2[i];
    if (Array.isArray(o2))
      for (let s2 of o2)
        u(s2) && (yield s2);
    else
      u(o2) && (yield o2);
  }
}
function* Zr2(e2, t8) {
  let r2 = [e2];
  for (let n2 = 0;n2 < r2.length; n2++) {
    let u = r2[n2];
    for (let i of ye2(u, t8))
      yield i, r2.push(i);
  }
}
function en2(e2, t8) {
  return ye2(e2, t8).next().done;
}
function Ae2(e2) {
  return (t8, r2, n2) => {
    let u = !!(n2 != null && n2.backwards);
    if (r2 === false)
      return false;
    let { length: i } = t8, o2 = r2;
    for (;o2 >= 0 && o2 < i; ) {
      let s2 = t8.charAt(o2);
      if (e2 instanceof RegExp) {
        if (!e2.test(s2))
          return o2;
      } else if (!e2.includes(s2))
        return o2;
      u ? o2-- : o2++;
    }
    return o2 === -1 || o2 === i ? o2 : false;
  };
}
function Xu(e2, t8, r2) {
  let n2 = !!(r2 != null && r2.backwards);
  if (t8 === false)
    return false;
  let u = e2.charAt(t8);
  if (n2) {
    if (e2.charAt(t8 - 1) === "\r" && u === `
`)
      return t8 - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029")
      return t8 - 1;
  } else {
    if (u === "\r" && e2.charAt(t8 + 1) === `
`)
      return t8 + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029")
      return t8 + 1;
  }
  return t8;
}
function Qu(e2, t8, r2 = {}) {
  let n2 = S2(e2, r2.backwards ? t8 - 1 : t8, r2), u = W2(e2, n2, r2);
  return n2 !== u;
}
function Zu(e2) {
  return Array.isArray(e2) && e2.length > 0;
}
function ti2(e2) {
  return e2 ? (t8) => e2(t8, rn) : ei2;
}
function ri2(e2) {
  let t8 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
  return r2.length > 20 && (r2 = r2.slice(0, 19) + "\u2026"), t8 + (r2 ? " " + r2 : "");
}
function Wt2(e2, t8) {
  (e2.comments ?? (e2.comments = [])).push(t8), t8.printed = false, t8.nodeDescription = ri2(e2);
}
function ue(e2, t8) {
  t8.leading = true, t8.trailing = false, Wt2(e2, t8);
}
function re(e2, t8, r2) {
  t8.leading = false, t8.trailing = false, r2 && (t8.marker = r2), Wt2(e2, t8);
}
function ie2(e2, t8) {
  t8.leading = false, t8.trailing = true, Wt2(e2, t8);
}
function ut2(e2, t8) {
  if ($t2.has(e2))
    return $t2.get(e2);
  let { printer: { getCommentChildNodes: r2, canAttachComment: n2, getVisitorKeys: u }, locStart: i, locEnd: o2 } = t8;
  if (!n2)
    return [];
  let s2 = ((r2 == null ? undefined : r2(e2, t8)) ?? [...ye2(e2, { getVisitorKeys: q(u) })]).flatMap((a) => n2(a) ? [a] : ut2(a, t8));
  return s2.sort((a, D) => i(a) - i(D) || o2(a) - o2(D)), $t2.set(e2, s2), s2;
}
function un2(e2, t8, r2, n2) {
  let { locStart: u, locEnd: i } = r2, o2 = u(t8), s2 = i(t8), a = ut2(e2, r2), D, l2, p = 0, f = a.length;
  for (;p < f; ) {
    let d = p + f >> 1, c2 = a[d], F = u(c2), m2 = i(c2);
    if (F <= o2 && s2 <= m2)
      return un2(c2, t8, r2, c2);
    if (m2 <= o2) {
      D = c2, p = d + 1;
      continue;
    }
    if (s2 <= F) {
      l2 = c2, f = d;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n2 == null ? undefined : n2.type) === "TemplateLiteral") {
    let { quasis: d } = n2, c2 = Vt2(d, t8, r2);
    D && Vt2(d, D, r2) !== c2 && (D = null), l2 && Vt2(d, l2, r2) !== c2 && (l2 = null);
  }
  return { enclosingNode: n2, precedingNode: D, followingNode: l2 };
}
function on2(e2, t8) {
  let { comments: r2 } = e2;
  if (delete e2.comments, !Ht2(r2) || !t8.printer.canAttachComment)
    return;
  let n2 = [], { locStart: u, locEnd: i, printer: { experimentalFeatures: { avoidAstMutation: o2 = false } = {}, handleComments: s2 = {} }, originalText: a } = t8, { ownLine: D = Mt2, endOfLine: l2 = Mt2, remaining: p = Mt2 } = s2, f = r2.map((d, c2) => ({ ...un2(e2, d, t8), comment: d, text: a, options: t8, ast: e2, isLastComment: r2.length - 1 === c2 }));
  for (let [d, c2] of f.entries()) {
    let { comment: F, precedingNode: m2, enclosingNode: h2, followingNode: C, text: v2, options: E2, ast: g, isLastComment: j2 } = c2;
    if (E2.parser === "json" || E2.parser === "json5" || E2.parser === "jsonc" || E2.parser === "__js_expression" || E2.parser === "__ts_expression" || E2.parser === "__vue_expression" || E2.parser === "__vue_ts_expression") {
      if (u(F) - u(g) <= 0) {
        ue(g, F);
        continue;
      }
      if (i(F) - i(g) >= 0) {
        ie2(g, F);
        continue;
      }
    }
    let b2;
    if (o2 ? b2 = [c2] : (F.enclosingNode = h2, F.precedingNode = m2, F.followingNode = C, b2 = [F, v2, E2, g, j2]), ni2(v2, E2, f, d))
      F.placement = "ownLine", D(...b2) || (C ? ue(C, F) : m2 ? ie2(m2, F) : h2 ? re(h2, F) : re(g, F));
    else if (ui(v2, E2, f, d))
      F.placement = "endOfLine", l2(...b2) || (m2 ? ie2(m2, F) : C ? ue(C, F) : h2 ? re(h2, F) : re(g, F));
    else if (F.placement = "remaining", !p(...b2))
      if (m2 && C) {
        let X2 = n2.length;
        X2 > 0 && n2[X2 - 1].followingNode !== C && nn(n2, E2), n2.push(c2);
      } else
        m2 ? ie2(m2, F) : C ? ue(C, F) : h2 ? re(h2, F) : re(g, F);
  }
  if (nn(n2, t8), !o2)
    for (let d of r2)
      delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
}
function ni2(e2, t8, r2, n2) {
  let { comment: u, precedingNode: i } = r2[n2], { locStart: o2, locEnd: s2 } = t8, a = o2(u);
  if (i)
    for (let D = n2 - 1;D >= 0; D--) {
      let { comment: l2, precedingNode: p } = r2[D];
      if (p !== i || !sn2(e2.slice(s2(l2), a)))
        break;
      a = o2(l2);
    }
  return V3(e2, a, { backwards: true });
}
function ui(e2, t8, r2, n2) {
  let { comment: u, followingNode: i } = r2[n2], { locStart: o2, locEnd: s2 } = t8, a = s2(u);
  if (i)
    for (let D = n2 + 1;D < r2.length; D++) {
      let { comment: l2, followingNode: p } = r2[D];
      if (p !== i || !sn2(e2.slice(a, o2(l2))))
        break;
      a = s2(l2);
    }
  return V3(e2, a);
}
function nn(e2, t8) {
  var s2, a;
  let r2 = e2.length;
  if (r2 === 0)
    return;
  let { precedingNode: n2, followingNode: u } = e2[0], i = t8.locStart(u), o2;
  for (o2 = r2;o2 > 0; --o2) {
    let { comment: D, precedingNode: l2, followingNode: p } = e2[o2 - 1];
    Pe2.strictEqual(l2, n2), Pe2.strictEqual(p, u);
    let f = t8.originalText.slice(t8.locEnd(D), i);
    if (((a = (s2 = t8.printer).isGap) == null ? undefined : a.call(s2, f, t8)) ?? /^[\s(]*$/u.test(f))
      i = t8.locStart(D);
    else
      break;
  }
  for (let [D, { comment: l2 }] of e2.entries())
    D < o2 ? ie2(n2, l2) : ue(u, l2);
  for (let D of [n2, u])
    D.comments && D.comments.length > 1 && D.comments.sort((l2, p) => t8.locStart(l2) - t8.locStart(p));
  e2.length = 0;
}
function Vt2(e2, t8, r2) {
  let n2 = r2.locStart(t8) - 1;
  for (let u = 1;u < e2.length; ++u)
    if (n2 < r2.locStart(e2[u]))
      return u - 1;
  return 0;
}
function ii2(e2, t8) {
  let r2 = t8 - 1;
  r2 = S2(e2, r2, { backwards: true }), r2 = W2(e2, r2, { backwards: true }), r2 = S2(e2, r2, { backwards: true });
  let n2 = W2(e2, r2, { backwards: true });
  return r2 !== n2;
}
function an2(e2, t8) {
  let r2 = e2.node;
  return r2.printed = true, t8.printer.printComment(e2, t8);
}
function oi2(e2, t8) {
  var l2;
  let r2 = e2.node, n2 = [an2(e2, t8)], { printer: u, originalText: i, locStart: o2, locEnd: s2 } = t8;
  if ((l2 = u.isBlockComment) == null ? undefined : l2.call(u, r2)) {
    let p = V3(i, s2(r2)) ? V3(i, o2(r2), { backwards: true }) ? K2 : Qe2 : " ";
    n2.push(p);
  } else
    n2.push(K2);
  let D = W2(i, S2(i, s2(r2)));
  return D !== false && V3(i, D) && n2.push(K2), n2;
}
function si2(e2, t8, r2) {
  var D;
  let n2 = e2.node, u = an2(e2, t8), { printer: i, originalText: o2, locStart: s2 } = t8, a = (D = i.isBlockComment) == null ? undefined : D.call(i, n2);
  if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || V3(o2, s2(n2), { backwards: true })) {
    let l2 = Ie2(o2, s2(n2));
    return { doc: Te2([K2, l2 ? K2 : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r2 != null && r2.hasLineSuffix ? { doc: [Te2([" ", u]), he2], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function ai2(e2, t8) {
  let r2 = e2.node;
  if (!r2)
    return {};
  let n2 = t8[Symbol.for("printedComments")];
  if ((r2.comments || []).filter((a) => !n2.has(a)).length === 0)
    return { leading: "", trailing: "" };
  let i = [], o2 = [], s2;
  return e2.each(() => {
    let a = e2.node;
    if (n2 != null && n2.has(a))
      return;
    let { leading: D, trailing: l2 } = a;
    D ? i.push(oi2(e2, t8)) : l2 && (s2 = si2(e2, t8, s2), o2.push(s2.doc));
  }, "comments"), { leading: i, trailing: o2 };
}
function Dn2(e2, t8, r2) {
  let { leading: n2, trailing: u } = ai2(e2, r2);
  return !n2 && !u ? t8 : me2(t8, (i) => [n2, i, u]);
}
function ln2(e2) {
  let { [Symbol.for("comments")]: t8, [Symbol.for("printedComments")]: r2 } = e2;
  for (let n2 of t8) {
    if (!n2.printed && !r2.has(n2))
      throw new Error('Comment "' + n2.value.trim() + '" was not printed. Please report this error!');
    delete n2.printed;
  }
}
function Di2(e2) {
  return () => {};
}
function it2({ plugins: e2 = [], showDeprecated: t8 = false } = {}) {
  let r2 = e2.flatMap((u) => u.languages ?? []), n2 = [];
  for (let u of ci2(Object.assign({}, ...e2.map(({ options: i }) => i), fn2)))
    !t8 && u.deprecated || (Array.isArray(u.choices) && (t8 || (u.choices = u.choices.filter((i) => !i.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...li2(u.choices, r2, e2)])), u.pluginDefaults = Object.fromEntries(e2.filter((i) => {
      var o2;
      return ((o2 = i.defaultOptions) == null ? undefined : o2[u.name]) !== undefined;
    }).map((i) => [i.name, i.defaultOptions[u.name]])), n2.push(u));
  return { languages: r2, options: n2 };
}
function* li2(e2, t8, r2) {
  let n2 = new Set(e2.map((u) => u.value));
  for (let u of t8)
    if (u.parsers) {
      for (let i of u.parsers)
        if (!n2.has(i)) {
          n2.add(i);
          let o2 = r2.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, i)), s2 = u.name;
          o2 != null && o2.name && (s2 += ` (plugin: ${o2.name})`), yield { value: i, description: s2 };
        }
    }
}
function ci2(e2) {
  let t8 = [];
  for (let [r2, n2] of Object.entries(e2)) {
    let u = { name: r2, ...n2 };
    Array.isArray(u.default) && (u.default = A(false, u.default, -1).value), t8.push(u);
  }
  return t8;
}
function dn2(e2, t8) {
  if (!t8)
    return;
  let r2 = fi2(t8).toLowerCase();
  return e2.find(({ filenames: n2 }) => n2 == null ? undefined : n2.some((u) => u.toLowerCase() === r2)) ?? e2.find(({ extensions: n2 }) => n2 == null ? undefined : n2.some((u) => r2.endsWith(u)));
}
function di(e2, t8) {
  if (t8)
    return e2.find(({ name: r2 }) => r2.toLowerCase() === t8) ?? e2.find(({ aliases: r2 }) => r2 == null ? undefined : r2.includes(t8)) ?? e2.find(({ extensions: r2 }) => r2 == null ? undefined : r2.includes(`.${t8}`));
}
function pi2(e2, t8) {
  let r2 = e2.plugins.flatMap((u) => u.languages ?? []), n2 = di(r2, t8.language) ?? dn2(r2, t8.physicalFile) ?? dn2(r2, t8.file) ?? (t8.physicalFile, undefined);
  return n2 == null ? undefined : n2.parsers[0];
}
function Cn2(e2, t8, r2, n2) {
  return [`Invalid ${ce2.default.red(n2.key(e2))} value.`, `Expected ${ce2.default.blue(r2)},`, `but received ${t8 === st2 ? ce2.default.gray("nothing") : ce2.default.red(n2.value(t8))}.`].join(" ");
}
function yn2({ text: e2, list: t8 }, r2) {
  let n2 = [];
  return e2 && n2.push(`- ${ce2.default.blue(e2)}`), t8 && n2.push([`- ${ce2.default.blue(t8.title)}:`].concat(t8.values.map((u) => yn2(u, r2 - En2.length).replace(/^|\n/g, `$&${En2}`))).join(`
`)), An2(n2, r2);
}
function An2(e2, t8) {
  if (e2.length === 1)
    return e2[0];
  let [r2, n2] = e2, [u, i] = e2.map((o2) => o2.split(`
`, 1)[0].length);
  return u > t8 && u > i ? n2 : r2;
}
function Gt2(e2, t8) {
  if (e2 === t8)
    return 0;
  let r2 = e2;
  e2.length > t8.length && (e2 = t8, t8 = r2);
  let n2 = e2.length, u = t8.length;
  for (;n2 > 0 && e2.charCodeAt(~-n2) === t8.charCodeAt(~-u); )
    n2--, u--;
  let i = 0;
  for (;i < n2 && e2.charCodeAt(i) === t8.charCodeAt(i); )
    i++;
  if (n2 -= i, u -= i, n2 === 0)
    return u;
  let o2, s2, a, D, l2 = 0, p = 0;
  for (;l2 < n2; )
    vn2[l2] = e2.charCodeAt(i + l2), zt2[l2] = ++l2;
  for (;p < u; )
    for (o2 = t8.charCodeAt(i + p), a = p++, s2 = p, l2 = 0;l2 < n2; l2++)
      D = o2 === vn2[l2] ? a : a + 1, a = zt2[l2], s2 = zt2[l2] = a > s2 ? D > s2 ? s2 + 1 : D : D > a ? a + 1 : D;
  return s2;
}
function mi2(e2, t8) {
  let r2 = new e2(t8), n2 = Object.create(r2);
  for (let u of Fi2)
    u in t8 && (n2[u] = hi2(t8[u], r2, x.prototype[u].length));
  return n2;
}
function hi2(e2, t8, r2) {
  return typeof e2 == "function" ? (...n2) => e2(...n2.slice(0, r2 - 1), t8, ...n2.slice(r2 - 1)) : () => e2;
}
function Bn2({ from: e2, to: t8 }) {
  return { from: [e2], to: t8 };
}
function _n2(e2, t8) {
  let r2 = Object.create(null);
  for (let n2 of e2) {
    let u = n2[t8];
    if (r2[u])
      throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r2[u] = n2;
  }
  return r2;
}
function xn2(e2, t8) {
  let r2 = new Map;
  for (let n2 of e2) {
    let u = n2[t8];
    if (r2.has(u))
      throw new Error(`Duplicate ${t8} ${JSON.stringify(u)}`);
    r2.set(u, n2);
  }
  return r2;
}
function bn2() {
  let e2 = Object.create(null);
  return (t8) => {
    let r2 = JSON.stringify(t8);
    return e2[r2] ? true : (e2[r2] = true, false);
  };
}
function Nn2(e2, t8) {
  let r2 = [], n2 = [];
  for (let u of e2)
    t8(u) ? r2.push(u) : n2.push(u);
  return [r2, n2];
}
function On2(e2) {
  return e2 === Math.floor(e2);
}
function Sn2(e2, t8) {
  if (e2 === t8)
    return 0;
  let r2 = typeof e2, n2 = typeof t8, u = ["undefined", "object", "boolean", "number", "string"];
  return r2 !== n2 ? u.indexOf(r2) - u.indexOf(n2) : r2 !== "string" ? Number(e2) - Number(t8) : e2.localeCompare(t8);
}
function Tn2(e2) {
  return (...t8) => {
    let r2 = e2(...t8);
    return typeof r2 == "string" ? new Error(r2) : r2;
  };
}
function Jt(e2) {
  return e2 === undefined ? {} : e2;
}
function qt2(e2) {
  if (typeof e2 == "string")
    return { text: e2 };
  let { text: t8, list: r2 } = e2;
  return Ei2((t8 || r2) !== undefined, "Unexpected `expected` result, there should be at least one field."), r2 ? { text: t8, list: { title: r2.title, values: r2.values.map(qt2) } } : { text: t8 };
}
function Xt(e2, t8) {
  return e2 === true ? true : e2 === false ? { value: t8 } : e2;
}
function Qt2(e2, t8, r2 = false) {
  return e2 === false ? false : e2 === true ? r2 ? true : [{ value: t8 }] : ("value" in e2) ? [e2] : e2.length === 0 ? false : e2;
}
function wn2(e2, t8) {
  return typeof e2 == "string" || "key" in e2 ? { from: t8, to: e2 } : ("from" in e2) ? { from: e2.from, to: e2.to } : { from: t8, to: e2.to };
}
function dt(e2, t8) {
  return e2 === undefined ? [] : Array.isArray(e2) ? e2.map((r2) => wn2(r2, t8)) : [wn2(e2, t8)];
}
function Zt(e2, t8) {
  let r2 = dt(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t8);
  return r2.length === 0 ? { remain: t8, redirect: r2 } : typeof e2 == "object" && ("remain" in e2) ? { remain: e2.remain, redirect: r2 } : { redirect: r2 };
}
function Ei2(e2, t8) {
  if (!e2)
    throw new Error(t8);
}
function gi2(e2, t8, { logger: r2 = false, isCLI: n2 = false, passThrough: u = false, FlagSchema: i, descriptor: o2 } = {}) {
  if (n2) {
    if (!i)
      throw new Error("'FlagSchema' option is required.");
    if (!o2)
      throw new Error("'descriptor' option is required.");
  } else
    o2 = oe;
  let s2 = u ? Array.isArray(u) ? (f, d) => u.includes(f) ? { [f]: d } : undefined : (f, d) => ({ [f]: d }) : (f, d, c2) => {
    let { _: F, ...m2 } = c2.schemas;
    return at2(f, d, { ...c2, schemas: m2 });
  }, a = yi2(t8, { isCLI: n2, FlagSchema: i }), D = new ht2(a, { logger: r2, unknown: s2, descriptor: o2 }), l2 = r2 !== false;
  l2 && er && (D._hasDeprecationWarned = er);
  let p = D.normalize(e2);
  return l2 && (er = D._hasDeprecationWarned), p;
}
function yi2(e2, { isCLI: t8, FlagSchema: r2 }) {
  let n2 = [];
  t8 && n2.push(lt3.create({ name: "_" }));
  for (let u of e2)
    n2.push(Ai2(u, { isCLI: t8, optionInfos: e2, FlagSchema: r2 })), u.alias && t8 && n2.push(Dt2.create({ name: u.alias, sourceName: u.name }));
  return n2;
}
function Ai2(e2, { isCLI: t8, optionInfos: r2, FlagSchema: n2 }) {
  let { name: u } = e2, i = { name: u }, o2, s2 = {};
  switch (e2.type) {
    case "int":
      o2 = mt2, t8 && (i.preprocess = Number);
      break;
    case "string":
      o2 = je2;
      break;
    case "choice":
      o2 = pt2, i.choices = e2.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e2.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      o2 = ft2;
      break;
    case "flag":
      o2 = n2, i.flags = r2.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      o2 = je2;
      break;
    default:
      throw new Error(`Unexpected type ${e2.type}`);
  }
  if (e2.exception ? i.validate = (a, D, l2) => e2.exception(a) || D.validate(a, l2) : i.validate = (a, D, l2) => a === undefined || D.validate(a, l2), e2.redirect && (s2.redirect = (a) => a ? { to: typeof e2.redirect == "string" ? e2.redirect : { key: e2.redirect.option, value: e2.redirect.value } } : undefined), e2.deprecated && (s2.deprecated = true), t8 && !e2.array) {
    let a = i.preprocess || ((D) => D);
    i.preprocess = (D, l2, p) => l2.preprocess(a(Array.isArray(D) ? A(false, D, -1) : D), p);
  }
  return e2.array ? ct2.create({ ...t8 ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s2, valueSchema: o2.create(i) }) : o2.create({ ...i, ...s2 });
}
function rr2(e2, t8) {
  if (!t8)
    throw new Error("parserName is required.");
  let r2 = tr2(false, e2, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t8));
  if (r2)
    return r2;
  let n2 = `Couldn't resolve parser "${t8}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new Re2(n2);
}
function Yn2(e2, t8) {
  if (!t8)
    throw new Error("astFormat is required.");
  let r2 = tr2(false, e2, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t8));
  if (r2)
    return r2;
  let n2 = `Couldn't find plugin for AST format "${t8}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new Re2(n2);
}
function Et2({ plugins: e2, parser: t8 }) {
  let r2 = rr2(e2, t8);
  return nr2(r2, t8);
}
function nr2(e2, t8) {
  let r2 = e2.parsers[t8];
  return typeof r2 == "function" ? r2() : r2;
}
function jn2(e2, t8) {
  let r2 = e2.printers[t8];
  return typeof r2 == "function" ? r2() : r2;
}
async function Bi2(e2, t8 = {}) {
  var p;
  let r2 = { ...e2 };
  if (!r2.parser)
    if (r2.filepath) {
      if (r2.parser = pn2(r2, { physicalFile: r2.filepath }), !r2.parser)
        throw new Ye2(`No parser could be inferred for file "${r2.filepath}".`);
    } else
      throw new Ye2("No parser and no file path given, couldn't infer a parser.");
  let n2 = it2({ plugins: e2.plugins, showDeprecated: true }).options, u = { ...Hn2, ...Object.fromEntries(n2.filter((f) => f.default !== undefined).map((f) => [f.name, f.default])) }, i = rr2(r2.plugins, r2.parser), o2 = await nr2(i, r2.parser);
  r2.astFormat = o2.astFormat, r2.locEnd = o2.locEnd, r2.locStart = o2.locStart;
  let s2 = (p = i.printers) != null && p[o2.astFormat] ? i : Yn2(r2.plugins, o2.astFormat), a = await jn2(s2, o2.astFormat);
  r2.printer = a;
  let D = s2.defaultOptions ? Object.fromEntries(Object.entries(s2.defaultOptions).filter(([, f]) => f !== undefined)) : {}, l2 = { ...u, ...D };
  for (let [f, d] of Object.entries(l2))
    (r2[f] === null || r2[f] === undefined) && (r2[f] = d);
  return r2.parser === "json" && (r2.trailingComma = "none"), Rn2(r2, n2, { passThrough: Object.keys(Hn2), ...t8 });
}
async function bi2(e2, t8) {
  let r2 = await Et2(t8), n2 = r2.preprocess ? r2.preprocess(e2, t8) : e2;
  t8.originalText = n2;
  let u;
  try {
    u = await r2.parse(n2, t8, t8);
  } catch (i) {
    Ni2(i, e2);
  }
  return { text: n2, ast: u };
}
function Ni2(e2, t8) {
  let { loc: r2 } = e2;
  if (r2) {
    let n2 = (0, Mn2.codeFrameColumns)(t8, r2, { highlightCode: true });
    throw e2.message += `
` + n2, e2.codeFrame = n2, e2;
  }
  throw e2;
}
async function Vn2(e2, t8, r2, n2, u) {
  let { embeddedLanguageFormatting: i, printer: { embed: o2, hasPrettierIgnore: s2 = () => false, getVisitorKeys: a } } = r2;
  if (!o2 || i !== "auto")
    return;
  if (o2.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let D = q(o2.getVisitorKeys ?? a), l2 = [];
  d();
  let p = e2.stack;
  for (let { print: c2, node: F, pathStack: m2 } of l2)
    try {
      e2.stack = m2;
      let h2 = await c2(f, t8, e2, r2);
      h2 && u.set(F, h2);
    } catch (h2) {
      if (globalThis.PRETTIER_DEBUG)
        throw h2;
    }
  e2.stack = p;
  function f(c2, F) {
    return Oi2(c2, F, r2, n2);
  }
  function d() {
    let { node: c2 } = e2;
    if (c2 === null || typeof c2 != "object" || s2(e2))
      return;
    for (let m2 of D(c2))
      Array.isArray(c2[m2]) ? e2.each(d, m2) : e2.call(d, m2);
    let F = o2(e2, r2);
    if (F) {
      if (typeof F == "function") {
        l2.push({ print: F, node: c2, pathStack: [...e2.stack] });
        return;
      }
      u.set(c2, F);
    }
  }
}
async function Oi2(e2, t8, r2, n2) {
  let u = await se2({ ...r2, ...t8, parentParser: r2.parser, originalText: e2 }, { passThrough: true }), { ast: i } = await fe2(e2, u), o2 = await n2(i, u);
  return qe2(o2);
}
function Si2(e2, t8) {
  let { originalText: r2, [Symbol.for("comments")]: n2, locStart: u, locEnd: i, [Symbol.for("printedComments")]: o2 } = t8, { node: s2 } = e2, a = u(s2), D = i(s2);
  for (let l2 of n2)
    u(l2) >= a && i(l2) <= D && o2.add(l2);
  return r2.slice(a, D);
}
async function He2(e2, t8) {
  ({ ast: e2 } = await ir2(e2, t8));
  let r2 = new Map, n2 = new qr(e2), u = cn2(t8), i = new Map;
  await Vn2(n2, s2, t8, He2, i);
  let o2 = await zn2(n2, t8, s2, undefined, i);
  if (ln2(t8), t8.nodeAfterCursor && !t8.nodeBeforeCursor)
    return [Z2, o2];
  if (t8.nodeBeforeCursor && !t8.nodeAfterCursor)
    return [o2, Z2];
  return o2;
  function s2(D, l2) {
    return D === undefined || D === n2 ? a(l2) : Array.isArray(D) ? n2.call(() => a(l2), ...D) : n2.call(() => a(l2), D);
  }
  function a(D) {
    u(n2);
    let l2 = n2.node;
    if (l2 == null)
      return "";
    let p = l2 && typeof l2 == "object" && D === undefined;
    if (p && r2.has(l2))
      return r2.get(l2);
    let f = zn2(n2, t8, s2, D, i);
    return p && r2.set(l2, f), f;
  }
}
function zn2(e2, t8, r2, n2, u) {
  var a;
  let { node: i } = e2, { printer: o2 } = t8, s2;
  switch ((a = o2.hasPrettierIgnore) != null && a.call(o2, e2) ? s2 = Un2(e2, t8) : u.has(i) ? s2 = u.get(i) : s2 = o2.print(e2, t8, r2, n2), i) {
    case t8.cursorNode:
      s2 = me2(s2, (D) => [Z2, D, Z2]);
      break;
    case t8.nodeBeforeCursor:
      s2 = me2(s2, (D) => [D, Z2]);
      break;
    case t8.nodeAfterCursor:
      s2 = me2(s2, (D) => [Z2, D]);
      break;
  }
  return o2.printComment && (!o2.willPrintOwnComments || !o2.willPrintOwnComments(e2, t8)) && (s2 = Dn2(e2, s2, t8)), s2;
}
async function ir2(e2, t8) {
  let r2 = e2.comments ?? [];
  t8[Symbol.for("comments")] = r2, t8[Symbol.for("tokens")] = e2.tokens ?? [], t8[Symbol.for("printedComments")] = new Set, on2(e2, t8);
  let { printer: { preprocess: n2 } } = t8;
  return e2 = n2 ? await n2(e2, t8) : e2, { ast: e2, comments: r2 };
}
function Ti2(e2, t8) {
  let { cursorOffset: r2, locStart: n2, locEnd: u } = t8, i = q(t8.printer.getVisitorKeys), o2 = (d) => n2(d) <= r2 && u(d) >= r2, s2 = e2, a = [e2];
  for (let d of Zr2(e2, { getVisitorKeys: i, filter: o2 }))
    a.push(d), s2 = d;
  if (en2(s2, { getVisitorKeys: i }))
    return { cursorNode: s2 };
  let D, l2, p = -1, f = Number.POSITIVE_INFINITY;
  for (;a.length > 0 && (D === undefined || l2 === undefined); ) {
    s2 = a.pop();
    let d = D !== undefined, c2 = l2 !== undefined;
    for (let F of ye2(s2, { getVisitorKeys: i })) {
      if (!d) {
        let m2 = u(F);
        m2 <= r2 && m2 > p && (D = F, p = m2);
      }
      if (!c2) {
        let m2 = n2(F);
        m2 >= r2 && m2 < f && (l2 = F, f = m2);
      }
    }
  }
  return { nodeBeforeCursor: D, nodeAfterCursor: l2 };
}
function ki2(e2, t8) {
  let { printer: { massageAstNode: r2, getVisitorKeys: n2 } } = t8;
  if (!r2)
    return e2;
  let u = q(n2), i = r2.ignoredProperties ?? new Set;
  return o2(e2);
  function o2(s2, a) {
    if (!(s2 !== null && typeof s2 == "object"))
      return s2;
    if (Array.isArray(s2))
      return s2.map((f) => o2(f, a)).filter(Boolean);
    let D = {}, l2 = new Set(u(s2));
    for (let f in s2)
      !Object.prototype.hasOwnProperty.call(s2, f) || i.has(f) || (l2.has(f) ? D[f] = o2(s2[f], s2) : D[f] = s2[f]);
    let p = r2(s2, D, a);
    if (p !== null)
      return p ?? D;
  }
}
function Ii2(e2, t8) {
  let r2 = [e2.node, ...e2.parentNodes], n2 = new Set([t8.node, ...t8.parentNodes]);
  return r2.find((u) => Qn2.has(u.type) && n2.has(u));
}
function qn2(e2) {
  let t8 = Jn2(false, e2, (r2) => r2.type !== "Program" && r2.type !== "File");
  return t8 === -1 ? e2 : e2.slice(0, t8 + 1);
}
function Ri2(e2, t8, { locStart: r2, locEnd: n2 }) {
  let u = e2.node, i = t8.node;
  if (u === i)
    return { startNode: u, endNode: i };
  let o2 = r2(e2.node);
  for (let a of qn2(t8.parentNodes))
    if (r2(a) >= o2)
      i = a;
    else
      break;
  let s2 = n2(t8.node);
  for (let a of qn2(e2.parentNodes)) {
    if (n2(a) <= s2)
      u = a;
    else
      break;
    if (u === i)
      break;
  }
  return { startNode: u, endNode: i };
}
function or3(e2, t8, r2, n2, u = [], i) {
  let { locStart: o2, locEnd: s2 } = r2, a = o2(e2), D = s2(e2);
  if (!(t8 > D || t8 < a || i === "rangeEnd" && t8 === a || i === "rangeStart" && t8 === D)) {
    for (let l2 of ut2(e2, r2)) {
      let p = or3(l2, t8, r2, n2, [e2, ...u], i);
      if (p)
        return p;
    }
    if (!n2 || n2(e2, u[0]))
      return { node: e2, parentNodes: u };
  }
}
function Yi2(e2, t8) {
  return t8 !== "DeclareExportDeclaration" && e2 !== "TypeParameterDeclaration" && (e2 === "Directive" || e2 === "TypeAlias" || e2 === "TSExportAssignment" || e2.startsWith("Declare") || e2.startsWith("TSDeclare") || e2.endsWith("Statement") || e2.endsWith("Declaration"));
}
function Xn2(e2, t8, r2) {
  if (!t8)
    return false;
  switch (e2.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return Yi2(t8.type, r2 == null ? undefined : r2.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Qn2.has(t8.type);
    case "graphql":
      return ji2.has(t8.kind);
    case "vue":
      return t8.tag !== "root";
  }
  return false;
}
function Zn2(e2, t8, r2) {
  let { rangeStart: n2, rangeEnd: u, locStart: i, locEnd: o2 } = t8;
  Pe2.ok(u > n2);
  let s2 = e2.slice(n2, u).search(/\S/u), a = s2 === -1;
  if (!a)
    for (n2 += s2;u > n2 && !/\S/u.test(e2[u - 1]); --u)
      ;
  let D = or3(r2, n2, t8, (d, c2) => Xn2(t8, d, c2), [], "rangeStart"), l2 = a ? D : or3(r2, u, t8, (d) => Xn2(t8, d), [], "rangeEnd");
  if (!D || !l2)
    return { rangeStart: 0, rangeEnd: 0 };
  let p, f;
  if (Pi2(t8)) {
    let d = Ii2(D, l2);
    p = d, f = d;
  } else
    ({ startNode: p, endNode: f } = Ri2(D, l2, t8));
  return { rangeStart: Math.min(i(p), i(f)), rangeEnd: Math.max(o2(p), o2(f)) };
}
async function uu(e2, t8, r2 = 0) {
  if (!e2 || e2.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n2, text: u } = await fe2(e2, t8);
  t8.cursorOffset >= 0 && (t8 = { ...t8, ...Gn2(n2, t8) });
  let i = await He2(n2, t8, r2);
  r2 > 0 && (i = Ze2([K2, i], r2, t8.tabWidth));
  let o2 = Ce2(i, t8);
  if (r2 > 0) {
    let a = o2.formatted.trim();
    o2.cursorNodeStart !== undefined && (o2.cursorNodeStart -= o2.formatted.indexOf(a), o2.cursorNodeStart < 0 && (o2.cursorNodeStart = 0, o2.cursorNodeText = o2.cursorNodeText.trimStart()), o2.cursorNodeStart + o2.cursorNodeText.length > a.length && (o2.cursorNodeText = o2.cursorNodeText.trimEnd())), o2.formatted = a + be2(t8.endOfLine);
  }
  let s2 = t8[Symbol.for("comments")];
  if (t8.cursorOffset >= 0) {
    let a, D, l2, p;
    if ((t8.cursorNode || t8.nodeBeforeCursor || t8.nodeAfterCursor) && o2.cursorNodeText)
      if (l2 = o2.cursorNodeStart, p = o2.cursorNodeText, t8.cursorNode)
        a = t8.locStart(t8.cursorNode), D = u.slice(a, t8.locEnd(t8.cursorNode));
      else {
        if (!t8.nodeBeforeCursor && !t8.nodeAfterCursor)
          throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
        a = t8.nodeBeforeCursor ? t8.locEnd(t8.nodeBeforeCursor) : 0;
        let h2 = t8.nodeAfterCursor ? t8.locStart(t8.nodeAfterCursor) : u.length;
        D = u.slice(a, h2);
      }
    else
      a = 0, D = u, l2 = 0, p = o2.formatted;
    let f = t8.cursorOffset - a;
    if (D === p)
      return { formatted: o2.formatted, cursorOffset: l2 + f, comments: s2 };
    let d = D.split("");
    d.splice(f, 0, eu);
    let c2 = p.split(""), F = yr2(d, c2), m2 = l2;
    for (let h2 of F)
      if (h2.removed) {
        if (h2.value.includes(eu))
          break;
      } else
        m2 += h2.count;
    return { formatted: o2.formatted, cursorOffset: m2, comments: s2 };
  }
  return { formatted: o2.formatted, cursorOffset: -1, comments: s2 };
}
async function Hi2(e2, t8) {
  let { ast: r2, text: n2 } = await fe2(e2, t8), { rangeStart: u, rangeEnd: i } = Zn2(n2, t8, r2), o2 = n2.slice(u, i), s2 = Math.min(u, n2.lastIndexOf(`
`, u) + 1), a = n2.slice(s2, u).match(/^\s*/u)[0], D = ge2(a, t8.tabWidth), l2 = await uu(o2, { ...t8, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t8.cursorOffset > u && t8.cursorOffset <= i ? t8.cursorOffset - u : -1, endOfLine: "lf" }, D), p = l2.formatted.trimEnd(), { cursorOffset: f } = t8;
  f > i ? f += p.length - o2.length : l2.cursorOffset >= 0 && (f = l2.cursorOffset + u);
  let d = n2.slice(0, u) + p + n2.slice(i);
  if (t8.endOfLine !== "lf") {
    let c2 = be2(t8.endOfLine);
    f >= 0 && c2 === `\r
` && (f += Nt2(d.slice(0, f), `
`)), d = ne3(false, d, `
`, c2);
  }
  return { formatted: d, cursorOffset: f, comments: l2.comments };
}
function sr2(e2, t8, r2) {
  return typeof t8 != "number" || Number.isNaN(t8) || t8 < 0 || t8 > e2.length ? r2 : t8;
}
function tu(e2, t8) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: u } = t8;
  return r2 = sr2(e2, r2, -1), n2 = sr2(e2, n2, 0), u = sr2(e2, u, e2.length), { ...t8, cursorOffset: r2, rangeStart: n2, rangeEnd: u };
}
function iu(e2, t8) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: u, endOfLine: i } = tu(e2, t8), o2 = e2.charAt(0) === nu;
  if (o2 && (e2 = e2.slice(1), r2--, n2--, u--), i === "auto" && (i = Ar2(e2)), e2.includes("\r")) {
    let s2 = (a) => Nt2(e2.slice(0, Math.max(a, 0)), `\r
`);
    r2 -= s2(r2), n2 -= s2(n2), u -= s2(u), e2 = vr2(e2);
  }
  return { hasBOM: o2, text: e2, options: tu(e2, { ...t8, cursorOffset: r2, rangeStart: n2, rangeEnd: u, endOfLine: i }) };
}
async function ru(e2, t8) {
  let r2 = await Et2(t8);
  return !r2.hasPragma || r2.hasPragma(e2);
}
async function ar2(e2, t8) {
  let { hasBOM: r2, text: n2, options: u } = iu(e2, await se2(t8));
  if (u.rangeStart >= u.rangeEnd && n2 !== "" || u.requirePragma && !await ru(n2, u))
    return { formatted: e2, cursorOffset: t8.cursorOffset, comments: [] };
  let i;
  return u.rangeStart > 0 || u.rangeEnd < n2.length ? i = await Hi2(n2, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await ru(n2, u) && (n2 = u.printer.insertPragma(n2)), i = await uu(n2, u)), r2 && (i.formatted = nu + i.formatted, i.cursorOffset >= 0 && i.cursorOffset++), i;
}
async function ou(e2, t8, r2) {
  let { text: n2, options: u } = iu(e2, await se2(t8)), i = await fe2(n2, u);
  return r2 && (r2.preprocessForPrint && (i.ast = await ir2(i.ast, u)), r2.massage && (i.ast = Kn2(i.ast, u))), i;
}
async function su(e2, t8) {
  t8 = await se2(t8);
  let r2 = await He2(e2, t8);
  return Ce2(r2, t8);
}
async function au(e2, t8) {
  let r2 = Vr2(e2), { formatted: n2 } = await ar2(r2, { ...t8, parser: "__js_expression" });
  return n2;
}
async function Du(e2, t8) {
  t8 = await se2(t8);
  let { ast: r2 } = await fe2(e2, t8);
  return He2(r2, t8);
}
async function lu(e2, t8) {
  return Ce2(e2, await se2(t8));
}
function Ui2(e2, t8) {
  if (t8 === false)
    return false;
  if (e2.charAt(t8) === "/" && e2.charAt(t8 + 1) === "*") {
    for (let r2 = t8 + 2;r2 < e2.length; ++r2)
      if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
        return r2 + 2;
  }
  return t8;
}
function zi2(e2, t8) {
  return t8 === false ? false : e2.charAt(t8) === "/" && e2.charAt(t8 + 1) === "/" ? nt2(e2, t8) : t8;
}
function Gi2(e2, t8) {
  let r2 = null, n2 = t8;
  for (;n2 !== r2; )
    r2 = n2, n2 = S2(e2, n2), n2 = Be2(e2, n2), n2 = we2(e2, n2), n2 = W2(e2, n2);
  return n2;
}
function Ki2(e2, t8) {
  let r2 = null, n2 = t8;
  for (;n2 !== r2; )
    r2 = n2, n2 = rt2(e2, n2), n2 = Be2(e2, n2), n2 = S2(e2, n2);
  return n2 = we2(e2, n2), n2 = W2(e2, n2), n2 !== false && V3(e2, n2);
}
function Ji2(e2, t8) {
  let r2 = e2.lastIndexOf(`
`);
  return r2 === -1 ? 0 : ge2(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t8);
}
function lr2(e2) {
  if (typeof e2 != "string")
    throw new TypeError("Expected a string");
  return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function qi2(e2, t8) {
  let r2 = e2.match(new RegExp(`(${lr2(t8)})+`, "gu"));
  return r2 === null ? 0 : r2.reduce((n2, u) => Math.max(n2, u.length / t8.length), 0);
}
function Xi2(e2, t8) {
  let r2 = We(e2, t8);
  return r2 === false ? "" : e2.charAt(r2);
}
function Qi2(e2, t8) {
  let r2 = t8 === true || t8 === gt3 ? gt3 : Fu, n2 = r2 === gt3 ? Fu : gt3, u = 0, i = 0;
  for (let o2 of e2)
    o2 === r2 ? u++ : o2 === n2 && i++;
  return u > i ? n2 : r2;
}
function Zi2(e2, t8, r2) {
  for (let n2 = t8;n2 < r2; ++n2)
    if (e2.charAt(n2) === `
`)
      return true;
  return false;
}
function eo(e2, t8, r2 = {}) {
  return S2(e2, r2.backwards ? t8 - 1 : t8, r2) !== t8;
}
function to(e2, t8, r2) {
  let n2 = t8 === '"' ? "'" : '"', i = ne3(false, e2, /\\(.)|(["'])/gsu, (o2, s2, a) => s2 === n2 ? s2 : a === t8 ? "\\" + a : a || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s2) ? s2 : "\\" + s2));
  return t8 + i + t8;
}
function ro(e2, t8, r2) {
  return We(e2, r2(t8));
}
function no(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? We(e2, t8) : ro(...arguments);
}
function uo(e2, t8, r2) {
  return Ie2(e2, r2(t8));
}
function io(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? Ie2(e2, t8) : uo(...arguments);
}
function oo(e2, t8, r2) {
  return Ct2(e2, r2(t8));
}
function so(e2, t8) {
  return arguments.length === 2 || typeof t8 == "number" ? Ct2(e2, t8) : oo(...arguments);
}
function de2(e2, t8 = 1) {
  return async (...r2) => {
    let n2 = r2[t8] ?? {}, u = n2.plugins ?? [];
    return r2[t8] = { ...n2, plugins: Array.isArray(u) ? u : Object.values(u) }, e2(...r2);
  };
}
async function yu(e2, t8) {
  let { formatted: r2 } = await gu(e2, { ...t8, cursorOffset: -1 });
  return r2;
}
async function ao(e2, t8) {
  return await yu(e2, t8) === e2;
}
var Au, At2, vu, Bu, wu, _u, dr2 = (e2) => {
  throw TypeError(e2);
}, pr2 = (e2, t8) => () => (t8 || e2((t8 = { exports: {} }).exports, t8), t8.exports), vt2 = (e2, t8) => {
  for (var r2 in t8)
    At2(e2, r2, { get: t8[r2], enumerable: true });
}, xu = (e2, t8, r2, n2) => {
  if (t8 && typeof t8 == "object" || typeof t8 == "function")
    for (let u of Bu(t8))
      !_u.call(e2, u) && u !== r2 && At2(e2, u, { get: () => t8[u], enumerable: !(n2 = vu(t8, u)) || n2.enumerable });
  return e2;
}, Me2 = (e2, t8, r2) => (r2 = e2 != null ? Au(wu(e2)) : {}, xu(t8 || !e2 || !e2.__esModule ? At2(r2, "default", { value: e2, enumerable: true }) : r2, e2)), bu = (e2, t8, r2) => t8.has(e2) || dr2("Cannot " + r2), Fr2 = (e2, t8, r2) => t8.has(e2) ? dr2("Cannot add the same private member more than once") : t8 instanceof WeakSet ? t8.add(e2) : t8.set(e2, r2), pe2 = (e2, t8, r2) => (bu(e2, t8, "access private method"), r2), ot2, $n2, fr2, Nu = (e2, t8, r2, n2) => {
  if (!(e2 && t8 == null))
    return t8.replaceAll ? t8.replaceAll(r2, n2) : r2.global ? t8.replace(r2, n2) : t8.split(r2).join(n2);
}, ne3, mo, Ue2 = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}", Su, Ge2, Tu, bt2, ku, Lu, xe2, ze3, $2 = "string", H2 = "array", z2 = "cursor", T2 = "indent", k2 = "align", L2 = "trim", B2 = "group", N2 = "fill", w2 = "if-break", P2 = "indent-if-break", I2 = "line-suffix", R2 = "line-suffix-boundary", y = "line", O2 = "label", _2 = "break-parent", Ke2, Pu = (e2, t8, r2) => {
  if (!(e2 && t8 == null))
    return Array.isArray(t8) || typeof t8 == "string" ? t8[r2 < 0 ? t8.length + r2 : r2] : t8.at(r2);
}, A, M, Ru = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2), Ot2, Q2, Br2, Fe2, St2 = () => {}, G2, Tt2, Tr2, Hr, he2, Wr2, ke2, Lt2, Qe2, $r2, K2, Xe2, Z2, Ur2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, Kr2 = (e2) => !(zr(e2) || Gr(e2)), Uu, Le2, Y2, J2, Ee2, Pt2, ge2, te2, jt2, tt2, Yt2 = class {
  constructor(t8) {
    Fr2(this, te2);
    this.stack = [t8];
  }
  get key() {
    let { stack: t8, siblings: r2 } = this;
    return A(false, t8, r2 === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : A(false, this.stack, -2);
  }
  get node() {
    return A(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t8 } = this, r2 = A(false, t8, -3);
    return Array.isArray(r2) ? r2 : null;
  }
  get next() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index + 1];
  }
  get previous() {
    let { siblings: t8 } = this;
    return t8 === null ? null : t8[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t8, index: r2 } = this;
    return t8 !== null && r2 === t8.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...pe2(this, te2, tt2).call(this)];
  }
  getName() {
    let { stack: t8 } = this, { length: r2 } = t8;
    return r2 > 1 ? A(false, t8, -2) : null;
  }
  getValue() {
    return A(false, this.stack, -1);
  }
  getNode(t8 = 0) {
    let r2 = pe2(this, te2, jt2).call(this, t8);
    return r2 === -1 ? null : this.stack[r2];
  }
  getParentNode(t8 = 0) {
    return this.getNode(t8 + 1);
  }
  call(t8, ...r2) {
    let { stack: n2 } = this, { length: u } = n2, i = A(false, n2, -1);
    for (let o2 of r2)
      i = i[o2], n2.push(o2, i);
    try {
      return t8(this);
    } finally {
      n2.length = u;
    }
  }
  callParent(t8, r2 = 0) {
    let n2 = pe2(this, te2, jt2).call(this, r2 + 1), u = this.stack.splice(n2 + 1);
    try {
      return t8(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t8, ...r2) {
    let { stack: n2 } = this, { length: u } = n2, i = A(false, n2, -1);
    for (let o2 of r2)
      i = i[o2], n2.push(o2, i);
    try {
      for (let o2 = 0;o2 < i.length; ++o2)
        n2.push(o2, i[o2]), t8(this, o2, i), n2.length -= 2;
    } finally {
      n2.length = u;
    }
  }
  map(t8, ...r2) {
    let n2 = [];
    return this.each((u, i, o2) => {
      n2[i] = t8(u, i, o2);
    }, ...r2), n2;
  }
  match(...t8) {
    let r2 = this.stack.length - 1, n2 = null, u = this.stack[r2--];
    for (let i of t8) {
      if (u === undefined)
        return false;
      let o2 = null;
      if (typeof n2 == "number" && (o2 = n2, n2 = this.stack[r2--], u = this.stack[r2--]), i && !i(u, n2, o2))
        return false;
      n2 = this.stack[r2--], u = this.stack[r2--];
    }
    return true;
  }
  findAncestor(t8) {
    for (let r2 of pe2(this, te2, tt2).call(this))
      if (t8(r2))
        return r2;
  }
  hasAncestor(t8) {
    for (let r2 of pe2(this, te2, tt2).call(this))
      if (t8(r2))
        return true;
    return false;
  }
}, qr, Xr2, Pe2, Qr2, tn, S2, rt2, nt2, W2, V3, Ht2, rn, ei2 = (e2) => Object.keys(e2).filter((t8) => !rn.has(t8)), q, $t2, Mt2 = () => false, sn2 = (e2) => !/[\S\n\u2028\u2029]/u.test(e2), Ie2, cn2, Re2, Ye2, fn2, fi2 = (e2) => String(e2).split(/[/\\]/u).pop(), pn2, oe, Ut2, hn2 = (e2, t8, { descriptor: r2 }) => {
  let n2 = [`${Ut2.default.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2))} is deprecated`];
  return t8 && n2.push(`we now treat it as ${Ut2.default.blue(typeof t8 == "string" ? r2.key(t8) : r2.pair(t8))}`), n2.join("; ") + ".";
}, ce2, st2, ve, En2, gn2 = (e2, t8, r2) => {
  let { text: n2, list: u } = r2.normalizeExpectedResult(r2.schemas[e2].expected(r2)), i = [];
  return n2 && i.push(Cn2(e2, t8, n2, r2.descriptor)), u && i.push([Cn2(e2, t8, u.title, r2.descriptor)].concat(u.values.map((o2) => yn2(o2, r2.loggerPrintWidth))).join(`
`)), An2(i, r2.loggerPrintWidth);
}, Kt2, zt2, vn2, at2 = (e2, t8, { descriptor: r2, logger: n2, schemas: u }) => {
  let i = [`Ignored unknown option ${Kt2.default.yellow(r2.pair({ key: e2, value: t8 }))}.`], o2 = Object.keys(u).sort().find((s2) => Gt2(e2, s2) < 3);
  o2 && i.push(`Did you mean ${Kt2.default.blue(r2.key(o2))}?`), n2.warn(i.join(" "));
}, Fi2, x = class {
  static create(t8) {
    return mi2(this, t8);
  }
  constructor(t8) {
    this.name = t8.name;
  }
  default(t8) {}
  expected(t8) {
    return "nothing";
  }
  validate(t8, r2) {
    return false;
  }
  deprecated(t8, r2) {
    return false;
  }
  forward(t8, r2) {}
  redirect(t8, r2) {}
  overlap(t8, r2, n2) {
    return t8;
  }
  preprocess(t8, r2) {
    return t8;
  }
  postprocess(t8, r2) {
    return ve;
  }
}, Dt2, lt3, ct2, ft2, pt2, Ft2, mt2, je2, kn2, Ln2, Pn2, In2, ht2 = class {
  constructor(t8, r2) {
    let { logger: n2 = console, loggerPrintWidth: u = 80, descriptor: i = kn2, unknown: o2 = Ln2, invalid: s2 = Pn2, deprecated: a = In2, missing: D = () => false, required: l2 = () => false, preprocess: p = (d) => d, postprocess: f = () => ve } = r2 || {};
    this._utils = { descriptor: i, logger: n2 || { warn: () => {} }, loggerPrintWidth: u, schemas: _n2(t8, "name"), normalizeDefaultResult: Jt, normalizeExpectedResult: qt2, normalizeDeprecatedResult: Qt2, normalizeForwardResult: dt, normalizeRedirectResult: Zt, normalizeValidateResult: Xt }, this._unknownHandler = o2, this._invalidHandler = Tn2(s2), this._deprecatedHandler = a, this._identifyMissing = (d, c2) => !(d in c2) || D(d, c2), this._identifyRequired = l2, this._preprocess = p, this._postprocess = f, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = bn2();
  }
  normalize(t8) {
    let r2 = {}, u = [this._preprocess(t8, this._utils)], i = () => {
      for (;u.length !== 0; ) {
        let o2 = u.shift(), s2 = this._applyNormalization(o2, r2);
        u.push(...s2);
      }
    };
    i();
    for (let o2 of Object.keys(this._utils.schemas)) {
      let s2 = this._utils.schemas[o2];
      if (!(o2 in r2)) {
        let a = Jt(s2.default(this._utils));
        "value" in a && u.push({ [o2]: a.value });
      }
    }
    i();
    for (let o2 of Object.keys(this._utils.schemas)) {
      if (!(o2 in r2))
        continue;
      let s2 = this._utils.schemas[o2], a = r2[o2], D = s2.postprocess(a, this._utils);
      D !== ve && (this._applyValidation(D, o2, s2), r2[o2] = D);
    }
    return this._applyPostprocess(r2), this._applyRequiredCheck(r2), r2;
  }
  _applyNormalization(t8, r2) {
    let n2 = [], { knownKeys: u, unknownKeys: i } = this._partitionOptionKeys(t8);
    for (let o2 of u) {
      let s2 = this._utils.schemas[o2], a = s2.preprocess(t8[o2], this._utils);
      this._applyValidation(a, o2, s2);
      let D = ({ from: d, to: c2 }) => {
        n2.push(typeof c2 == "string" ? { [c2]: d } : { [c2.key]: c2.value });
      }, l2 = ({ value: d, redirectTo: c2 }) => {
        let F = Qt2(s2.deprecated(d, this._utils), a, true);
        if (F !== false)
          if (F === true)
            this._hasDeprecationWarned(o2) || this._utils.logger.warn(this._deprecatedHandler(o2, c2, this._utils));
          else
            for (let { value: m2 } of F) {
              let h2 = { key: o2, value: m2 };
              if (!this._hasDeprecationWarned(h2)) {
                let C = typeof c2 == "string" ? { key: c2, value: m2 } : c2;
                this._utils.logger.warn(this._deprecatedHandler(h2, C, this._utils));
              }
            }
      };
      dt(s2.forward(a, this._utils), a).forEach(D);
      let f = Zt(s2.redirect(a, this._utils), a);
      if (f.redirect.forEach(D), "remain" in f) {
        let d = f.remain;
        r2[o2] = o2 in r2 ? s2.overlap(r2[o2], d, this._utils) : d, l2({ value: d });
      }
      for (let { from: d, to: c2 } of f.redirect)
        l2({ value: d, redirectTo: c2 });
    }
    for (let o2 of i) {
      let s2 = t8[o2];
      this._applyUnknownHandler(o2, s2, r2, (a, D) => {
        n2.push({ [a]: D });
      });
    }
    return n2;
  }
  _applyRequiredCheck(t8) {
    for (let r2 of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r2, t8) && this._identifyRequired(r2))
        throw this._invalidHandler(r2, st2, this._utils);
  }
  _partitionOptionKeys(t8) {
    let [r2, n2] = Nn2(Object.keys(t8).filter((u) => !this._identifyMissing(u, t8)), (u) => (u in this._utils.schemas));
    return { knownKeys: r2, unknownKeys: n2 };
  }
  _applyValidation(t8, r2, n2) {
    let u = Xt(n2.validate(t8, this._utils), t8);
    if (u !== true)
      throw this._invalidHandler(r2, u.value, this._utils);
  }
  _applyUnknownHandler(t8, r2, n2, u) {
    let i = this._unknownHandler(t8, r2, this._utils);
    if (i)
      for (let o2 of Object.keys(i)) {
        if (this._identifyMissing(o2, i))
          continue;
        let s2 = i[o2];
        o2 in this._utils.schemas ? u(o2, s2) : n2[o2] = s2;
      }
  }
  _applyPostprocess(t8) {
    let r2 = this._postprocess(t8, this._utils);
    if (r2 !== ve) {
      if (r2.delete)
        for (let n2 of r2.delete)
          delete t8[n2];
      if (r2.override) {
        let { knownKeys: n2, unknownKeys: u } = this._partitionOptionKeys(r2.override);
        for (let i of n2) {
          let o2 = r2.override[i];
          this._applyValidation(o2, i, this._utils.schemas[i]), t8[i] = o2;
        }
        for (let i of u) {
          let o2 = r2.override[i];
          this._applyUnknownHandler(i, o2, t8, (s2, a) => {
            let D = this._utils.schemas[s2];
            this._applyValidation(a, s2, D), t8[s2] = a;
          });
        }
      }
    }
  }
}, er, Rn2, vi2 = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) {
    if (t8.findLast)
      return t8.findLast(r2);
    for (let n2 = t8.length - 1;n2 >= 0; n2--) {
      let u = t8[n2];
      if (r2(u, n2, t8))
        return u;
    }
  }
}, tr2, Hn2, se2, Mn2, fe2, Un2, Gn2, Kn2, Li2 = (e2, t8, r2) => {
  if (!(e2 && t8 == null)) {
    if (t8.findLastIndex)
      return t8.findLastIndex(r2);
    for (let n2 = t8.length - 1;n2 >= 0; n2--) {
      let u = t8[n2];
      if (r2(u, n2, t8))
        return n2;
    }
    return -1;
  }
}, Jn2, Pi2 = ({ parser: e2 }) => e2 === "json" || e2 === "json5" || e2 === "jsonc" || e2 === "json-stringify", Qn2, ji2, nu = "\uFEFF", eu, Dr2, $i2, Mi2, Vi2, cu = "3.5.3", cr2, Be2, we2, We, Ct2, fu, du, pu, gt3 = "'", Fu = '"', mu, hu, Eu, Cu, gu, Do2, lo;
var init_standalone = __esm(() => {
  Au = Object.create;
  At2 = Object.defineProperty;
  vu = Object.getOwnPropertyDescriptor;
  Bu = Object.getOwnPropertyNames;
  wu = Object.getPrototypeOf;
  _u = Object.prototype.hasOwnProperty;
  ot2 = pr2((Da2, mn2) => {
    var Fn2 = new Proxy(String, { get: () => Fn2 });
    mn2.exports = Fn2;
  });
  $n2 = pr2((ur2) => {
    Object.defineProperty(ur2, "__esModule", { value: true });
    function wi2() {
      return new Proxy({}, { get: () => (e2) => e2 });
    }
    var Wn2 = /\r\n|[\n\r\u2028\u2029]/;
    function _i2(e2, t8, r2) {
      let n2 = Object.assign({ column: 0, line: -1 }, e2.start), u = Object.assign({}, n2, e2.end), { linesAbove: i = 2, linesBelow: o2 = 3 } = r2 || {}, s2 = n2.line, a = n2.column, D = u.line, l2 = u.column, p = Math.max(s2 - (i + 1), 0), f = Math.min(t8.length, D + o2);
      s2 === -1 && (p = 0), D === -1 && (f = t8.length);
      let d = D - s2, c2 = {};
      if (d)
        for (let F = 0;F <= d; F++) {
          let m2 = F + s2;
          if (!a)
            c2[m2] = true;
          else if (F === 0) {
            let h2 = t8[m2 - 1].length;
            c2[m2] = [a, h2 - a + 1];
          } else if (F === d)
            c2[m2] = [0, l2];
          else {
            let h2 = t8[m2 - F].length;
            c2[m2] = [0, h2];
          }
        }
      else
        a === l2 ? a ? c2[s2] = [a, 0] : c2[s2] = true : c2[s2] = [a, l2 - a];
      return { start: p, end: f, markerLines: c2 };
    }
    function xi2(e2, t8, r2 = {}) {
      let u = wi2(false), i = e2.split(Wn2), { start: o2, end: s2, markerLines: a } = _i2(t8, i, r2), D = t8.start && typeof t8.start.column == "number", l2 = String(s2).length, f = e2.split(Wn2, s2).slice(o2, s2).map((d, c2) => {
        let F = o2 + 1 + c2, h2 = ` ${` ${F}`.slice(-l2)} |`, C = a[F], v2 = !a[F + 1];
        if (C) {
          let E2 = "";
          if (Array.isArray(C)) {
            let g = d.slice(0, Math.max(C[0] - 1, 0)).replace(/[^\t]/g, " "), j2 = C[1] || 1;
            E2 = [`
 `, u.gutter(h2.replace(/\d/g, " ")), " ", g, u.marker("^").repeat(j2)].join(""), v2 && r2.message && (E2 += " " + u.message(r2.message));
          }
          return [u.marker(">"), u.gutter(h2), d.length > 0 ? ` ${d}` : "", E2].join("");
        } else
          return ` ${u.gutter(h2)}${d.length > 0 ? ` ${d}` : ""}`;
      }).join(`
`);
      return r2.message && !D && (f = `${" ".repeat(l2 + 1)}${r2.message}
${f}`), f;
    }
    ur2.codeFrameColumns = xi2;
  });
  fr2 = {};
  vt2(fr2, { __debug: () => lo, check: () => ao, doc: () => Dr2, format: () => yu, formatWithCursor: () => gu, getSupportInfo: () => Do2, util: () => cr2, version: () => cu });
  ne3 = Nu;
  U.prototype = { diff: function(t8, r2) {
    var n2, u = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, i = u.callback;
    typeof u == "function" && (i = u, u = {});
    var o2 = this;
    function s2(E2) {
      return E2 = o2.postProcess(E2, u), i ? (setTimeout(function() {
        i(E2);
      }, 0), true) : E2;
    }
    t8 = this.castInput(t8, u), r2 = this.castInput(r2, u), t8 = this.removeEmpty(this.tokenize(t8, u)), r2 = this.removeEmpty(this.tokenize(r2, u));
    var a = r2.length, D = t8.length, l2 = 1, p = a + D;
    u.maxEditLength != null && (p = Math.min(p, u.maxEditLength));
    var f = (n2 = u.timeout) !== null && n2 !== undefined ? n2 : 1 / 0, d = Date.now() + f, c2 = [{ oldPos: -1, lastComponent: undefined }], F = this.extractCommon(c2[0], r2, t8, 0, u);
    if (c2[0].oldPos + 1 >= D && F + 1 >= a)
      return s2(mr2(o2, c2[0].lastComponent, r2, t8, o2.useLongestToken));
    var m2 = -1 / 0, h2 = 1 / 0;
    function C() {
      for (var E2 = Math.max(m2, -l2);E2 <= Math.min(h2, l2); E2 += 2) {
        var g = undefined, j2 = c2[E2 - 1], b2 = c2[E2 + 1];
        j2 && (c2[E2 - 1] = undefined);
        var X2 = false;
        if (b2) {
          var ae2 = b2.oldPos - E2;
          X2 = b2 && 0 <= ae2 && ae2 < a;
        }
        var $e = j2 && j2.oldPos + 1 < D;
        if (!X2 && !$e) {
          c2[E2] = undefined;
          continue;
        }
        if (!$e || X2 && j2.oldPos < b2.oldPos ? g = o2.addToPath(b2, true, false, 0, u) : g = o2.addToPath(j2, false, true, 1, u), F = o2.extractCommon(g, r2, t8, E2, u), g.oldPos + 1 >= D && F + 1 >= a)
          return s2(mr2(o2, g.lastComponent, r2, t8, o2.useLongestToken));
        c2[E2] = g, g.oldPos + 1 >= D && (h2 = Math.min(h2, E2 - 1)), F + 1 >= a && (m2 = Math.max(m2, E2 + 1));
      }
      l2++;
    }
    if (i)
      (function E() {
        setTimeout(function() {
          if (l2 > p || Date.now() > d)
            return i();
          C() || E();
        }, 0);
      })();
    else
      for (;l2 <= p && Date.now() <= d; ) {
        var v2 = C();
        if (v2)
          return v2;
      }
  }, addToPath: function(t8, r2, n2, u, i) {
    var o2 = t8.lastComponent;
    return o2 && !i.oneChangePerToken && o2.added === r2 && o2.removed === n2 ? { oldPos: t8.oldPos + u, lastComponent: { count: o2.count + 1, added: r2, removed: n2, previousComponent: o2.previousComponent } } : { oldPos: t8.oldPos + u, lastComponent: { count: 1, added: r2, removed: n2, previousComponent: o2 } };
  }, extractCommon: function(t8, r2, n2, u, i) {
    for (var o2 = r2.length, s2 = n2.length, a = t8.oldPos, D = a - u, l2 = 0;D + 1 < o2 && a + 1 < s2 && this.equals(n2[a + 1], r2[D + 1], i); )
      D++, a++, l2++, i.oneChangePerToken && (t8.lastComponent = { count: 1, previousComponent: t8.lastComponent, added: false, removed: false });
    return l2 && !i.oneChangePerToken && (t8.lastComponent = { count: l2, previousComponent: t8.lastComponent, added: false, removed: false }), t8.oldPos = a, D;
  }, equals: function(t8, r2, n2) {
    return n2.comparator ? n2.comparator(t8, r2) : t8 === r2 || n2.ignoreCase && t8.toLowerCase() === r2.toLowerCase();
  }, removeEmpty: function(t8) {
    for (var r2 = [], n2 = 0;n2 < t8.length; n2++)
      t8[n2] && r2.push(t8[n2]);
    return r2;
  }, castInput: function(t8) {
    return t8;
  }, tokenize: function(t8) {
    return Array.from(t8);
  }, join: function(t8) {
    return t8.join("");
  }, postProcess: function(t8) {
    return t8;
  } };
  mo = new U;
  Su = new RegExp("[".concat(Ue2, "]+|\\s+|[^").concat(Ue2, "]"), "ug");
  Ge2 = new U;
  Ge2.equals = function(e2, t8, r2) {
    return r2.ignoreCase && (e2 = e2.toLowerCase(), t8 = t8.toLowerCase()), e2.trim() === t8.trim();
  };
  Ge2.tokenize = function(e2) {
    var t8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, r2;
    if (t8.intlSegmenter) {
      if (t8.intlSegmenter.resolvedOptions().granularity != "word")
        throw new Error('The segmenter passed must have a granularity of "word"');
      r2 = Array.from(t8.intlSegmenter.segment(e2), function(i) {
        return i.segment;
      });
    } else
      r2 = e2.match(Su) || [];
    var n2 = [], u = null;
    return r2.forEach(function(i) {
      /\s/.test(i) ? u == null ? n2.push(i) : n2.push(n2.pop() + i) : /\s/.test(u) ? n2[n2.length - 1] == u ? n2.push(n2.pop() + i) : n2.push(u + i) : n2.push(i), u = i;
    }), n2;
  };
  Ge2.join = function(e2) {
    return e2.map(function(t8, r2) {
      return r2 == 0 ? t8 : t8.replace(/^\s+/, "");
    }).join("");
  };
  Ge2.postProcess = function(e2, t8) {
    if (!e2 || t8.oneChangePerToken)
      return e2;
    var r2 = null, n2 = null, u = null;
    return e2.forEach(function(i) {
      i.added ? n2 = i : i.removed ? u = i : ((n2 || u) && gr2(r2, u, n2, i), r2 = i, n2 = null, u = null);
    }), (n2 || u) && gr2(r2, u, n2, null), e2;
  };
  Tu = new U;
  Tu.tokenize = function(e2) {
    var t8 = new RegExp("(\\r?\\n)|[".concat(Ue2, "]+|[^\\S\\n\\r]+|[^").concat(Ue2, "]"), "ug");
    return e2.match(t8) || [];
  };
  bt2 = new U;
  bt2.tokenize = function(e2, t8) {
    t8.stripTrailingCr && (e2 = e2.replace(/\r\n/g, `
`));
    var r2 = [], n2 = e2.split(/(\n|\r\n)/);
    n2[n2.length - 1] || n2.pop();
    for (var u = 0;u < n2.length; u++) {
      var i = n2[u];
      u % 2 && !t8.newlineIsToken ? r2[r2.length - 1] += i : r2.push(i);
    }
    return r2;
  };
  bt2.equals = function(e2, t8, r2) {
    return r2.ignoreWhitespace ? ((!r2.newlineIsToken || !e2.includes(`
`)) && (e2 = e2.trim()), (!r2.newlineIsToken || !t8.includes(`
`)) && (t8 = t8.trim())) : r2.ignoreNewlineAtEof && !r2.newlineIsToken && (e2.endsWith(`
`) && (e2 = e2.slice(0, -1)), t8.endsWith(`
`) && (t8 = t8.slice(0, -1))), U.prototype.equals.call(this, e2, t8, r2);
  };
  ku = new U;
  ku.tokenize = function(e2) {
    return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
  Lu = new U;
  Lu.tokenize = function(e2) {
    return e2.split(/([{}:;,]|\s+)/);
  };
  xe2 = new U;
  xe2.useLongestToken = true;
  xe2.tokenize = bt2.tokenize;
  xe2.castInput = function(e2, t8) {
    var { undefinedReplacement: r2, stringifyReplacer: n2 } = t8, u = n2 === undefined ? function(i, o2) {
      return typeof o2 > "u" ? r2 : o2;
    } : n2;
    return typeof e2 == "string" ? e2 : JSON.stringify(xt2(e2, null, null, u), u, "  ");
  };
  xe2.equals = function(e2, t8, r2) {
    return U.prototype.equals.call(xe2, e2.replace(/,([\r\n])/g, "$1"), t8.replace(/,([\r\n])/g, "$1"), r2);
  };
  ze3 = new U;
  ze3.tokenize = function(e2) {
    return e2.slice();
  };
  ze3.join = ze3.removeEmpty = function(e2) {
    return e2;
  };
  Ke2 = new Set([z2, T2, k2, L2, B2, N2, w2, P2, I2, R2, y, O2, _2]);
  A = Pu;
  M = Iu;
  Ot2 = class extends Error {
    name = "InvalidDocError";
    constructor(t8) {
      super(Yu(t8)), this.doc = t8;
    }
  };
  Q2 = Ot2;
  Br2 = {};
  Fe2 = ju;
  G2 = St2;
  Tt2 = St2;
  Tr2 = St2;
  Hr = { type: R2 };
  he2 = { type: _2 };
  Wr2 = { type: L2 };
  ke2 = { type: y, hard: true };
  Lt2 = { type: y, hard: true, literal: true };
  Qe2 = { type: y };
  $r2 = { type: y, soft: true };
  K2 = [ke2, he2];
  Xe2 = [Lt2, he2];
  Z2 = { type: z2 };
  Uu = /[^\x20-\x7F]/u;
  Le2 = zu;
  Y2 = Symbol("MODE_BREAK");
  J2 = Symbol("MODE_FLAT");
  Ee2 = Symbol("cursor");
  Pt2 = Symbol("DOC_FILL_PRINTED_LENGTH");
  ge2 = Ju;
  te2 = new WeakSet, jt2 = function(t8) {
    let { stack: r2 } = this;
    for (let n2 = r2.length - 1;n2 >= 0; n2 -= 2)
      if (!Array.isArray(r2[n2]) && --t8 < 0)
        return n2;
    return -1;
  }, tt2 = function* () {
    let { stack: t8 } = this;
    for (let r2 = t8.length - 3;r2 >= 0; r2 -= 2) {
      let n2 = t8[r2];
      Array.isArray(n2) || (yield n2);
    }
  };
  qr = Yt2;
  Xr2 = new Proxy(() => {}, { get: () => Xr2 });
  Pe2 = Xr2;
  Qr2 = qu;
  tn = Ae2(/\s/u);
  S2 = Ae2(" 	");
  rt2 = Ae2(",; 	");
  nt2 = Ae2(/[^\n\r]/u);
  W2 = Xu;
  V3 = Qu;
  Ht2 = Zu;
  rn = new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
  q = ti2;
  $t2 = new WeakMap;
  Ie2 = ii2;
  cn2 = Di2;
  Re2 = class extends Error {
    name = "ConfigError";
  };
  Ye2 = class extends Error {
    name = "UndefinedParserError";
  };
  fn2 = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: undefined, description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  pn2 = pi2;
  oe = { key: (e2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e2) ? e2 : JSON.stringify(e2), value(e2) {
    if (e2 === null || typeof e2 != "object")
      return JSON.stringify(e2);
    if (Array.isArray(e2))
      return `[${e2.map((r2) => oe.value(r2)).join(", ")}]`;
    let t8 = Object.keys(e2);
    return t8.length === 0 ? "{}" : `{ ${t8.map((r2) => `${oe.key(r2)}: ${oe.value(e2[r2])}`).join(", ")} }`;
  }, pair: ({ key: e2, value: t8 }) => oe.value({ [e2]: t8 }) };
  Ut2 = Me2(ot2(), 1);
  ce2 = Me2(ot2(), 1);
  st2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
  ve = Symbol.for("vnopts.VALUE_UNCHANGED");
  En2 = " ".repeat(2);
  Kt2 = Me2(ot2(), 1);
  zt2 = [];
  vn2 = [];
  Fi2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  Dt2 = class extends x {
    constructor(t8) {
      super(t8), this._sourceName = t8.sourceName;
    }
    expected(t8) {
      return t8.schemas[this._sourceName].expected(t8);
    }
    validate(t8, r2) {
      return r2.schemas[this._sourceName].validate(t8, r2);
    }
    redirect(t8, r2) {
      return this._sourceName;
    }
  };
  lt3 = class extends x {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  };
  ct2 = class extends x {
    constructor({ valueSchema: t8, name: r2 = t8.name, ...n2 }) {
      super({ ...n2, name: r2 }), this._valueSchema = t8;
    }
    expected(t8) {
      let { text: r2, list: n2 } = t8.normalizeExpectedResult(this._valueSchema.expected(t8));
      return { text: r2 && `an array of ${r2}`, list: n2 && { title: "an array of the following values", values: [{ list: n2 }] } };
    }
    validate(t8, r2) {
      if (!Array.isArray(t8))
        return false;
      let n2 = [];
      for (let u of t8) {
        let i = r2.normalizeValidateResult(this._valueSchema.validate(u, r2), u);
        i !== true && n2.push(i.value);
      }
      return n2.length === 0 ? true : { value: n2 };
    }
    deprecated(t8, r2) {
      let n2 = [];
      for (let u of t8) {
        let i = r2.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r2), u);
        i !== false && n2.push(...i.map(({ value: o2 }) => ({ value: [o2] })));
      }
      return n2;
    }
    forward(t8, r2) {
      let n2 = [];
      for (let u of t8) {
        let i = r2.normalizeForwardResult(this._valueSchema.forward(u, r2), u);
        n2.push(...i.map(Bn2));
      }
      return n2;
    }
    redirect(t8, r2) {
      let n2 = [], u = [];
      for (let i of t8) {
        let o2 = r2.normalizeRedirectResult(this._valueSchema.redirect(i, r2), i);
        "remain" in o2 && n2.push(o2.remain), u.push(...o2.redirect.map(Bn2));
      }
      return n2.length === 0 ? { redirect: u } : { redirect: u, remain: n2 };
    }
    overlap(t8, r2) {
      return t8.concat(r2);
    }
  };
  ft2 = class extends x {
    expected() {
      return "true or false";
    }
    validate(t8) {
      return typeof t8 == "boolean";
    }
  };
  pt2 = class extends x {
    constructor(t8) {
      super(t8), this._choices = xn2(t8.choices.map((r2) => r2 && typeof r2 == "object" ? r2 : { value: r2 }), "value");
    }
    expected({ descriptor: t8 }) {
      let r2 = Array.from(this._choices.keys()).map((o2) => this._choices.get(o2)).filter(({ hidden: o2 }) => !o2).map((o2) => o2.value).sort(Sn2).map(t8.value), n2 = r2.slice(0, -2), u = r2.slice(-2);
      return { text: n2.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r2 } };
    }
    validate(t8) {
      return this._choices.has(t8);
    }
    deprecated(t8) {
      let r2 = this._choices.get(t8);
      return r2 && r2.deprecated ? { value: t8 } : false;
    }
    forward(t8) {
      let r2 = this._choices.get(t8);
      return r2 ? r2.forward : undefined;
    }
    redirect(t8) {
      let r2 = this._choices.get(t8);
      return r2 ? r2.redirect : undefined;
    }
  };
  Ft2 = class extends x {
    expected() {
      return "a number";
    }
    validate(t8, r2) {
      return typeof t8 == "number";
    }
  };
  mt2 = class extends Ft2 {
    expected() {
      return "an integer";
    }
    validate(t8, r2) {
      return r2.normalizeValidateResult(super.validate(t8, r2), t8) === true && On2(t8);
    }
  };
  je2 = class extends x {
    expected() {
      return "a string";
    }
    validate(t8) {
      return typeof t8 == "string";
    }
  };
  kn2 = oe;
  Ln2 = at2;
  Pn2 = gn2;
  In2 = hn2;
  Rn2 = gi2;
  tr2 = vi2;
  Hn2 = { astFormat: "estree", printer: {}, originalText: undefined, locStart: null, locEnd: null };
  se2 = Bi2;
  Mn2 = Me2($n2(), 1);
  fe2 = bi2;
  Un2 = Si2;
  Gn2 = Ti2;
  Kn2 = ki2;
  Jn2 = Li2;
  Qn2 = new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
  ji2 = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  eu = Symbol("cursor");
  Dr2 = {};
  vt2(Dr2, { builders: () => $i2, printer: () => Mi2, utils: () => Vi2 });
  $i2 = { join: Se2, line: Qe2, softline: $r2, hardline: K2, literalline: Xe2, group: kt2, conditionalGroup: Ir2, fill: Rr2, lineSuffix: Te2, lineSuffixBoundary: Hr, cursor: Z2, breakParent: he2, ifBreak: Yr2, trim: Wr2, indent: le2, indentIfBreak: jr2, align: De2, addAlignmentToDoc: Ze2, markAsRoot: Lr2, dedentToRoot: kr2, dedent: Pr2, hardlineWithoutBreakParent: ke2, literallineWithoutBreakParent: Lt2, label: Mr, concat: (e2) => e2 };
  Mi2 = { printDocToString: Ce2 };
  Vi2 = { willBreak: xr2, traverseDoc: Fe2, findInDoc: Je2, mapDoc: Oe2, removeLines: Nr2, stripTrailingHardline: qe2, replaceEndOfLine: Or, canBreak: Sr2 };
  cr2 = {};
  vt2(cr2, { addDanglingComment: () => re, addLeadingComment: () => ue, addTrailingComment: () => ie2, getAlignmentSize: () => ge2, getIndentSize: () => fu, getMaxContinuousCount: () => du, getNextNonSpaceNonCommentCharacter: () => pu, getNextNonSpaceNonCommentCharacterIndex: () => no, getPreferredQuote: () => mu, getStringWidth: () => Le2, hasNewline: () => V3, hasNewlineInRange: () => hu, hasSpaces: () => Eu, isNextLineEmpty: () => so, isNextLineEmptyAfterIndex: () => Ct2, isPreviousLineEmpty: () => io, makeString: () => Cu, skip: () => Ae2, skipEverythingButNewLine: () => nt2, skipInlineComment: () => Be2, skipNewline: () => W2, skipSpaces: () => S2, skipToLineEnd: () => rt2, skipTrailingComment: () => we2, skipWhitespace: () => tn });
  Be2 = Ui2;
  we2 = zi2;
  We = Gi2;
  Ct2 = Ki2;
  fu = Ji2;
  du = qi2;
  pu = Xi2;
  mu = Qi2;
  hu = Zi2;
  Eu = eo;
  Cu = to;
  gu = de2(ar2);
  Do2 = de2(it2, 0);
  lo = { parse: de2(ou), formatAST: de2(su), formatDoc: de2(au), printToDoc: de2(Du), printDocToString: de2(lu) };
});

// ../../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  (function() {
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e2) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name2 = getComponentNameFromType(type);
        return name2 ? "<" + name2 + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config2) {
      if (hasOwnProperty2.call(config2, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config2.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
      self2 = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (self2 !== undefined ? self2 : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config2, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
      var children = config2.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty2.call(config2, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config2).filter(function(k3) {
          return k3 !== "key";
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config2) && (checkKeyStringCoercion(config2.key), children = "" + config2.key);
      if ("key" in config2) {
        maybeKey = {};
        for (var propName in config2)
          propName !== "key" && (maybeKey[propName] = config2[propName]);
      } else
        maybeKey = config2;
      children && defineKeyPropWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, self2, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node2) {
      typeof node2 === "object" && node2 !== null && node2.$$typeof === REACT_ELEMENT_TYPE && node2._store && (node2._store.validated = 1);
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty2 = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React = {
      "react-stack-bottom-frame": function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function(type, config2, maybeKey, source, self2) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config2, maybeKey, false, source, self2, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function(type, config2, maybeKey, source, self2) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config2, maybeKey, true, source, self2, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// ../../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  var react_jsx_runtime_development = __toESM(require_react_jsx_runtime_development(), 1);
  if (false) {} else {
    module.exports = react_jsx_runtime_development;
  }
});

// ../../node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  (function() {
    function noop4() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e2) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    function getCrossOriginStringAs(as2, input) {
      if (as2 === "font")
        return "";
      if (typeof input === "string")
        return input === "use-credentials" ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : typeof thing === "string" ? JSON.stringify(thing) : typeof thing === "number" ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Internals = {
      d: {
        f: noop4,
        r: function() {
          throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
        },
        D: noop4,
        C: noop4,
        L: noop4,
        m: noop4,
        X: noop4,
        S: noop4,
        M: noop4
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map === "function" && Map.prototype != null && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != null && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
      if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn3) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn3)
          return fn3();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function(href, options) {
      typeof href === "string" && href ? options != null && typeof options !== "object" ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : options != null && typeof options.crossOrigin !== "string" && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      typeof href === "string" && (options ? (options = options.crossOrigin, options = typeof options === "string" ? options === "use-credentials" ? options : "" : undefined) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
      if (typeof href !== "string" || !href)
        console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      else if (1 < arguments.length) {
        var options = arguments[1];
        typeof options === "object" && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
      }
      typeof href === "string" && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
      typeof href === "string" && href ? options == null || typeof options !== "object" ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : options.as !== "style" && options.as !== "script" && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if (typeof href === "string" && options && typeof options.as === "string") {
        var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = typeof options.integrity === "string" ? options.integrity : undefined, fetchPriority = typeof options.fetchPriority === "string" ? options.fetchPriority : undefined;
        as2 === "style" ? Internals.d.S(href, typeof options.precedence === "string" ? options.precedence : undefined, {
          crossOrigin,
          integrity,
          fetchPriority
        }) : as2 === "script" && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined
        });
      }
    };
    exports.preinitModule = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && options.as !== "script" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered)
        console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);
      else
        switch (encountered = options && typeof options.as === "string" ? options.as : "script", encountered) {
          case "script":
            break;
          default:
            encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
        }
      if (typeof href === "string")
        if (typeof options === "object" && options !== null) {
          if (options.as == null || options.as === "script")
            encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
              crossOrigin: encountered,
              integrity: typeof options.integrity === "string" ? options.integrity : undefined,
              nonce: typeof options.nonce === "string" ? options.nonce : undefined
            });
        } else
          options == null && Internals.d.M(href);
    };
    exports.preload = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options == null || typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : typeof options.as === "string" && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if (typeof href === "string" && typeof options === "object" && options !== null && typeof options.as === "string") {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin,
          integrity: typeof options.integrity === "string" ? options.integrity : undefined,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined,
          type: typeof options.type === "string" ? options.type : undefined,
          fetchPriority: typeof options.fetchPriority === "string" ? options.fetchPriority : undefined,
          referrerPolicy: typeof options.referrerPolicy === "string" ? options.referrerPolicy : undefined,
          imageSrcSet: typeof options.imageSrcSet === "string" ? options.imageSrcSet : undefined,
          imageSizes: typeof options.imageSizes === "string" ? options.imageSizes : undefined,
          media: typeof options.media === "string" ? options.media : undefined
        });
      }
    };
    exports.preloadModule = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && typeof options.as !== "string" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      typeof href === "string" && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
        as: typeof options.as === "string" && options.as !== "script" ? options.as : undefined,
        crossOrigin: encountered,
        integrity: typeof options.integrity === "string" ? options.integrity : undefined
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(fn3, a) {
      return fn3(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.1.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// ../../node_modules/react-dom/index.js
var require_react_dom = __commonJS((exports, module) => {
  var react_dom_development = __toESM(require_react_dom_development(), 1);
  if (false) {} else {
    module.exports = react_dom_development;
  }
});

// ../../node_modules/react-dom/cjs/react-dom-server.bun.development.js
var exports_react_dom_server_bun_development = {};
__export(exports_react_dom_server_bun_development, {
  version: () => $version,
  renderToReadableStream: () => $renderToReadableStream
});
function objectName(object) {
  return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m2, p0) {
    return p0;
  });
}
function describeKeyForErrorMessage(key) {
  var encodedKey = JSON.stringify(key);
  return '"' + key + '"' === encodedKey ? key : encodedKey;
}
function describeValueForErrorMessage(value) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
    case "object":
      if (isArrayImpl(value))
        return "[...]";
      if (value !== null && value.$$typeof === CLIENT_REFERENCE_TAG)
        return "client";
      value = objectName(value);
      return value === "Object" ? "{...}" : value;
    case "function":
      return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
    default:
      return String(value);
  }
}
function describeElementType(type) {
  if (typeof type === "string")
    return type;
  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
  }
  if (typeof type === "object")
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeElementType(type.render);
      case REACT_MEMO_TYPE:
        return describeElementType(type.type);
      case REACT_LAZY_TYPE:
        var payload = type._payload;
        type = type._init;
        try {
          return describeElementType(type(payload));
        } catch (x2) {}
    }
  return "";
}
function describeObjectForErrorMessage(objectOrArray, expandedName) {
  var objKind = objectName(objectOrArray);
  if (objKind !== "Object" && objKind !== "Array")
    return objKind;
  var start = -1, length = 0;
  if (isArrayImpl(objectOrArray))
    if (jsxChildrenParents.has(objectOrArray)) {
      var type = jsxChildrenParents.get(objectOrArray);
      objKind = "<" + describeElementType(type) + ">";
      for (var i = 0;i < objectOrArray.length; i++) {
        var value = objectOrArray[i];
        value = typeof value === "string" ? value : typeof value === "object" && value !== null ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
        "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
      }
      objKind += "</" + describeElementType(type) + ">";
    } else {
      objKind = "[";
      for (type = 0;type < objectOrArray.length; type++)
        0 < type && (objKind += ", "), i = objectOrArray[type], i = typeof i === "object" && i !== null ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
      objKind += "]";
    }
  else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
    objKind = "<" + describeElementType(objectOrArray.type) + "/>";
  else {
    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG)
      return "client";
    if (jsxPropsParents.has(objectOrArray)) {
      objKind = jsxPropsParents.get(objectOrArray);
      objKind = "<" + (describeElementType(objKind) || "...");
      type = Object.keys(objectOrArray);
      for (i = 0;i < type.length; i++) {
        objKind += " ";
        value = type[i];
        objKind += describeKeyForErrorMessage(value) + "=";
        var _value2 = objectOrArray[value];
        var _substr2 = value === expandedName && typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
        typeof _value2 !== "string" && (_substr2 = "{" + _substr2 + "}");
        value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
      }
      objKind += ">";
    } else {
      objKind = "{";
      type = Object.keys(objectOrArray);
      for (i = 0;i < type.length; i++)
        0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
      objKind += "}";
    }
  }
  return expandedName === undefined ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), `
  ` + objKind + `
  ` + objectOrArray) : `
  ` + objKind;
}
function flushBuffered(destination) {
  typeof destination.flush === "function" && destination.flush();
}
function writeChunk(destination, chunk) {
  chunk.length !== 0 && destination.write(chunk);
}
function closeWithError(destination, error2) {
  typeof destination.error === "function" ? destination.error(error2) : destination.close();
}
function typeName(value) {
  return typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
}
function willCoercionThrow(value) {
  try {
    return testStringCoercion(value), false;
  } catch (e2) {
    return true;
  }
}
function testStringCoercion(value) {
  return "" + value;
}
function checkAttributeStringCoercion(value, attributeName) {
  if (willCoercionThrow(value))
    return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
}
function checkCSSPropertyStringCoercion(value, propName) {
  if (willCoercionThrow(value))
    return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
}
function checkHtmlStringCoercion(value) {
  if (willCoercionThrow(value))
    return console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
}
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))
    return true;
  if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName))
    return false;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return validatedAttributeNameCache[attributeName] = true;
  illegalAttributeNameCache[attributeName] = true;
  console.error("Invalid attribute name: `%s`", attributeName);
  return false;
}
function checkControlledValueProps(tagName, props) {
  hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || (tagName === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
  props.onChange || props.readOnly || props.disabled || props.checked == null || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
}
function validateProperty$1(tagName, name2) {
  if (hasOwnProperty2.call(warnedProperties$1, name2) && warnedProperties$1[name2])
    return true;
  if (rARIACamel$1.test(name2)) {
    tagName = "aria-" + name2.slice(4).toLowerCase();
    tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
    if (tagName == null)
      return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2), warnedProperties$1[name2] = true;
    if (name2 !== tagName)
      return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, tagName), warnedProperties$1[name2] = true;
  }
  if (rARIA$1.test(name2)) {
    tagName = name2.toLowerCase();
    tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
    if (tagName == null)
      return warnedProperties$1[name2] = true, false;
    name2 !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, tagName), warnedProperties$1[name2] = true);
  }
  return true;
}
function validateProperties$2(type, props) {
  var invalidProps = [], key;
  for (key in props)
    validateProperty$1(type, key) || invalidProps.push(key);
  props = invalidProps.map(function(prop) {
    return "`" + prop + "`";
  }).join(", ");
  invalidProps.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
}
function validateProperty(tagName, name2, value, eventRegistry) {
  if (hasOwnProperty2.call(warnedProperties, name2) && warnedProperties[name2])
    return true;
  var lowerCasedName = name2.toLowerCase();
  if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
    return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name2] = true;
  if (typeof value === "function" && (tagName === "form" && name2 === "action" || tagName === "input" && name2 === "formAction" || tagName === "button" && name2 === "formAction"))
    return true;
  if (eventRegistry != null) {
    tagName = eventRegistry.possibleRegistrationNames;
    if (eventRegistry.registrationNameDependencies.hasOwnProperty(name2))
      return true;
    eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
    if (eventRegistry != null)
      return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name2, eventRegistry), warnedProperties[name2] = true;
    if (EVENT_NAME_REGEX.test(name2))
      return console.error("Unknown event handler property `%s`. It will be ignored.", name2), warnedProperties[name2] = true;
  } else if (EVENT_NAME_REGEX.test(name2))
    return INVALID_EVENT_NAME_REGEX.test(name2) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2), warnedProperties[name2] = true;
  if (rARIA.test(name2) || rARIACamel.test(name2))
    return true;
  if (lowerCasedName === "innerhtml")
    return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name2] = true;
  if (lowerCasedName === "aria")
    return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name2] = true;
  if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string")
    return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name2] = true;
  if (typeof value === "number" && isNaN(value))
    return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2), warnedProperties[name2] = true;
  if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
    if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name2)
      return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name2, lowerCasedName), warnedProperties[name2] = true;
  } else if (name2 !== lowerCasedName)
    return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName), warnedProperties[name2] = true;
  switch (name2) {
    case "dangerouslySetInnerHTML":
    case "children":
    case "style":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      return true;
    case "innerText":
    case "textContent":
      return true;
  }
  switch (typeof value) {
    case "boolean":
      switch (name2) {
        case "autoFocus":
        case "checked":
        case "multiple":
        case "muted":
        case "selected":
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
        case "capture":
        case "download":
        case "inert":
          return true;
        default:
          lowerCasedName = name2.toLowerCase().slice(0, 5);
          if (lowerCasedName === "data-" || lowerCasedName === "aria-")
            return true;
          value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
          return warnedProperties[name2] = true;
      }
    case "function":
    case "symbol":
      return warnedProperties[name2] = true, false;
    case "string":
      if (value === "false" || value === "true") {
        switch (name2) {
          case "checked":
          case "selected":
          case "multiple":
          case "muted":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
          case "inert":
            break;
          default:
            return true;
        }
        console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
        warnedProperties[name2] = true;
      }
  }
  return true;
}
function warnUnknownProperties(type, props, eventRegistry) {
  var unknownProps = [], key;
  for (key in props)
    validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
  props = unknownProps.map(function(prop) {
    return "`" + prop + "`";
  }).join(", ");
  unknownProps.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
}
function camelize(string) {
  return string.replace(hyphenPattern, function(_3, character) {
    return character.toUpperCase();
  });
}
function escapeTextForBrowser(text2) {
  if (typeof text2 === "boolean" || typeof text2 === "number" || typeof text2 === "bigint")
    return "" + text2;
  checkHtmlStringCoercion(text2);
  text2 = "" + text2;
  var match = matchHtmlRegExp.exec(text2);
  if (match) {
    var html2 = "", index, lastIndex = 0;
    for (index = match.index;index < text2.length; index++) {
      switch (text2.charCodeAt(index)) {
        case 34:
          match = "&quot;";
          break;
        case 38:
          match = "&amp;";
          break;
        case 39:
          match = "&#x27;";
          break;
        case 60:
          match = "&lt;";
          break;
        case 62:
          match = "&gt;";
          break;
        default:
          continue;
      }
      lastIndex !== index && (html2 += text2.slice(lastIndex, index));
      lastIndex = index + 1;
      html2 += match;
    }
    text2 = lastIndex !== index ? html2 + text2.slice(lastIndex, index) : html2;
  }
  return text2;
}
function sanitizeURL(url2) {
  return isJavaScriptProtocol.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
}
function escapeEntireInlineScriptContent(scriptText) {
  checkHtmlStringCoercion(scriptText);
  return ("" + scriptText).replace(scriptRegex, scriptReplacer);
}
function scriptReplacer(match, prefix, s2, suffix) {
  return "" + prefix + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
}
function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
  var inlineScriptWithNonce = nonce === undefined ? "<script>" : '<script nonce="' + escapeTextForBrowser(nonce) + '">', idPrefix = resumableState.idPrefix;
  externalRuntimeConfig = [];
  var { bootstrapScriptContent, bootstrapScripts, bootstrapModules } = resumableState;
  bootstrapScriptContent !== undefined && externalRuntimeConfig.push(inlineScriptWithNonce, escapeEntireInlineScriptContent(bootstrapScriptContent), "</script>");
  bootstrapScriptContent = [];
  importMap !== undefined && (bootstrapScriptContent.push('<script type="importmap">'), bootstrapScriptContent.push(escapeEntireInlineScriptContent(JSON.stringify(importMap))), bootstrapScriptContent.push("</script>"));
  onHeaders && typeof maxHeadersLength === "number" && 0 >= maxHeadersLength && console.error("React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.", maxHeadersLength === 0 ? "zero" : maxHeadersLength);
  importMap = onHeaders ? {
    preconnects: "",
    fontPreloads: "",
    highImagePreloads: "",
    remainingCapacity: 2 + (typeof maxHeadersLength === "number" ? maxHeadersLength : 2000)
  } : null;
  onHeaders = {
    placeholderPrefix: idPrefix + "P:",
    segmentPrefix: idPrefix + "S:",
    boundaryPrefix: idPrefix + "B:",
    startInlineScript: inlineScriptWithNonce,
    preamble: createPreambleState(),
    externalRuntimeScript: null,
    bootstrapChunks: externalRuntimeConfig,
    importMapChunks: bootstrapScriptContent,
    onHeaders,
    headers: importMap,
    resets: {
      font: {},
      dns: {},
      connect: { default: {}, anonymous: {}, credentials: {} },
      image: {},
      style: {}
    },
    charsetChunks: [],
    viewportChunks: [],
    hoistableChunks: [],
    preconnects: new Set,
    fontPreloads: new Set,
    highImagePreloads: new Set,
    styles: new Map,
    bootstrapScripts: new Set,
    scripts: new Set,
    bulkPreloads: new Set,
    preloads: {
      images: new Map,
      stylesheets: new Map,
      scripts: new Map,
      moduleScripts: new Map
    },
    nonce,
    hoistableState: null,
    stylesToHoist: false
  };
  if (bootstrapScripts !== undefined)
    for (importMap = 0;importMap < bootstrapScripts.length; importMap++) {
      maxHeadersLength = bootstrapScripts[importMap];
      bootstrapScriptContent = idPrefix = undefined;
      var props = {
        rel: "preload",
        as: "script",
        fetchPriority: "low",
        nonce
      };
      typeof maxHeadersLength === "string" ? props.href = inlineScriptWithNonce = maxHeadersLength : (props.href = inlineScriptWithNonce = maxHeadersLength.src, props.integrity = bootstrapScriptContent = typeof maxHeadersLength.integrity === "string" ? maxHeadersLength.integrity : undefined, props.crossOrigin = idPrefix = typeof maxHeadersLength === "string" || maxHeadersLength.crossOrigin == null ? undefined : maxHeadersLength.crossOrigin === "use-credentials" ? "use-credentials" : "");
      preloadBootstrapScriptOrModule(resumableState, onHeaders, inlineScriptWithNonce, props);
      externalRuntimeConfig.push('<script src="', escapeTextForBrowser(inlineScriptWithNonce));
      nonce && externalRuntimeConfig.push('" nonce="', escapeTextForBrowser(nonce));
      typeof bootstrapScriptContent === "string" && externalRuntimeConfig.push('" integrity="', escapeTextForBrowser(bootstrapScriptContent));
      typeof idPrefix === "string" && externalRuntimeConfig.push('" crossorigin="', escapeTextForBrowser(idPrefix));
      externalRuntimeConfig.push('" async=""></script>');
    }
  if (bootstrapModules !== undefined)
    for (bootstrapScripts = 0;bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
      importMap = bootstrapModules[bootstrapScripts], idPrefix = inlineScriptWithNonce = undefined, bootstrapScriptContent = {
        rel: "modulepreload",
        fetchPriority: "low",
        nonce
      }, typeof importMap === "string" ? bootstrapScriptContent.href = maxHeadersLength = importMap : (bootstrapScriptContent.href = maxHeadersLength = importMap.src, bootstrapScriptContent.integrity = idPrefix = typeof importMap.integrity === "string" ? importMap.integrity : undefined, bootstrapScriptContent.crossOrigin = inlineScriptWithNonce = typeof importMap === "string" || importMap.crossOrigin == null ? undefined : importMap.crossOrigin === "use-credentials" ? "use-credentials" : ""), preloadBootstrapScriptOrModule(resumableState, onHeaders, maxHeadersLength, bootstrapScriptContent), externalRuntimeConfig.push('<script type="module" src="', escapeTextForBrowser(maxHeadersLength)), nonce && externalRuntimeConfig.push('" nonce="', escapeTextForBrowser(nonce)), typeof idPrefix === "string" && externalRuntimeConfig.push('" integrity="', escapeTextForBrowser(idPrefix)), typeof inlineScriptWithNonce === "string" && externalRuntimeConfig.push('" crossorigin="', escapeTextForBrowser(inlineScriptWithNonce)), externalRuntimeConfig.push('" async=""></script>');
  return onHeaders;
}
function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
  return {
    idPrefix: identifierPrefix === undefined ? "" : identifierPrefix,
    nextFormID: 0,
    streamingFormat: 0,
    bootstrapScriptContent,
    bootstrapScripts,
    bootstrapModules,
    instructions: NothingSent,
    hasBody: false,
    hasHtml: false,
    unknownResources: {},
    dnsResources: {},
    connectResources: { default: {}, anonymous: {}, credentials: {} },
    imageResources: {},
    styleResources: {},
    scriptResources: {},
    moduleUnknownResources: {},
    moduleScriptResources: {}
  };
}
function createPreambleState() {
  return {
    htmlChunks: null,
    headChunks: null,
    bodyChunks: null,
    contribution: NoContribution
  };
}
function createFormatContext(insertionMode, selectedValue, tagScope) {
  return {
    insertionMode,
    selectedValue,
    tagScope
  };
}
function createRootFormatContext(namespaceURI) {
  return createFormatContext(namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE, null, 0);
}
function getChildFormatContext(parentContext, type, props) {
  switch (type) {
    case "noscript":
      return createFormatContext(HTML_MODE, null, parentContext.tagScope | 1);
    case "select":
      return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, parentContext.tagScope);
    case "svg":
      return createFormatContext(SVG_MODE, null, parentContext.tagScope);
    case "picture":
      return createFormatContext(HTML_MODE, null, parentContext.tagScope | 2);
    case "math":
      return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
    case "foreignObject":
      return createFormatContext(HTML_MODE, null, parentContext.tagScope);
    case "table":
      return createFormatContext(HTML_TABLE_MODE, null, parentContext.tagScope);
    case "thead":
    case "tbody":
    case "tfoot":
      return createFormatContext(HTML_TABLE_BODY_MODE, null, parentContext.tagScope);
    case "colgroup":
      return createFormatContext(HTML_COLGROUP_MODE, null, parentContext.tagScope);
    case "tr":
      return createFormatContext(HTML_TABLE_ROW_MODE, null, parentContext.tagScope);
    case "head":
      if (parentContext.insertionMode < HTML_MODE)
        return createFormatContext(HTML_HEAD_MODE, null, parentContext.tagScope);
      break;
    case "html":
      if (parentContext.insertionMode === ROOT_HTML_MODE)
        return createFormatContext(HTML_HTML_MODE, null, parentContext.tagScope);
  }
  return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
}
function pushTextInstance(target, text2, renderState, textEmbedded) {
  if (text2 === "")
    return textEmbedded;
  textEmbedded && target.push("<!-- -->");
  target.push(escapeTextForBrowser(text2));
  return true;
}
function pushStyleAttribute(target, style) {
  if (typeof style !== "object")
    throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
  var isFirst = true, styleName;
  for (styleName in style)
    if (hasOwnProperty2.call(style, styleName)) {
      var styleValue = style[styleName];
      if (styleValue != null && typeof styleValue !== "boolean" && styleValue !== "") {
        if (styleName.indexOf("--") === 0) {
          var nameChunk = escapeTextForBrowser(styleName);
          checkCSSPropertyStringCoercion(styleValue, styleName);
          styleValue = escapeTextForBrowser(("" + styleValue).trim());
        } else {
          nameChunk = styleName;
          var value = styleValue;
          if (-1 < nameChunk.indexOf("-")) {
            var name2 = nameChunk;
            warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = true, console.error("Unsupported style property %s. Did you mean %s?", name2, camelize(name2.replace(msPattern$1, "ms-"))));
          } else if (badVendoredStyleNamePattern.test(nameChunk))
            name2 = nameChunk, warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = true, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1)));
          else if (badStyleValueWithSemicolonPattern.test(value)) {
            name2 = nameChunk;
            var value$jscomp$0 = value;
            warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value$jscomp$0.replace(badStyleValueWithSemicolonPattern, "")));
          }
          typeof value === "number" && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error("`NaN` is an invalid value for the `%s` css style property.", nameChunk)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error("`Infinity` is an invalid value for the `%s` css style property.", nameChunk)));
          nameChunk = styleName;
          value = styleNameCache.get(nameChunk);
          value !== undefined ? nameChunk = value : (value = escapeTextForBrowser(nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")), styleNameCache.set(nameChunk, value), nameChunk = value);
          typeof styleValue === "number" ? styleValue = styleValue === 0 || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(("" + styleValue).trim()));
        }
        isFirst ? (isFirst = false, target.push(styleAttributeStart, nameChunk, styleAssign, styleValue)) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
      }
    }
  isFirst || target.push(attributeEnd);
}
function pushBooleanAttribute(target, name2, value) {
  value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name2, attributeEmptyString);
}
function pushStringAttribute(target, name2, value) {
  typeof value !== "function" && typeof value !== "symbol" && typeof value !== "boolean" && target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
}
function pushAdditionalFormField(value, key) {
  this.push('<input type="hidden"');
  validateAdditionalFormField(value);
  pushStringAttribute(this, "name", key);
  pushStringAttribute(this, "value", value);
  this.push(endOfStartTagSelfClosing);
}
function validateAdditionalFormField(value) {
  if (typeof value !== "string")
    throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
}
function getCustomFormFields(resumableState, formAction) {
  if (typeof formAction.$$FORM_ACTION === "function") {
    var id = resumableState.nextFormID++;
    resumableState = resumableState.idPrefix + id;
    try {
      var customFields = formAction.$$FORM_ACTION(resumableState);
      if (customFields) {
        var formData = customFields.data;
        formData != null && formData.forEach(validateAdditionalFormField);
      }
      return customFields;
    } catch (x2) {
      if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function")
        throw x2;
      console.error(`Failed to serialize an action for progressive enhancement:
%s`, x2);
    }
  }
  return null;
}
function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2) {
  var formData = null;
  if (typeof formAction === "function") {
    name2 === null || didWarnFormActionName || (didWarnFormActionName = true, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'));
    formEncType === null && formMethod === null || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."));
    formTarget === null || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."));
    var customFields = getCustomFormFields(resumableState, formAction);
    customFields !== null ? (name2 = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator, "formAction", attributeAssign, actionJavaScriptURL, attributeEnd), formTarget = formMethod = formEncType = formAction = name2 = null, injectFormReplayingRuntime(resumableState, renderState));
  }
  name2 != null && pushAttribute(target, "name", name2);
  formAction != null && pushAttribute(target, "formAction", formAction);
  formEncType != null && pushAttribute(target, "formEncType", formEncType);
  formMethod != null && pushAttribute(target, "formMethod", formMethod);
  formTarget != null && pushAttribute(target, "formTarget", formTarget);
  return formData;
}
function pushAttribute(target, name2, value) {
  switch (name2) {
    case "className":
      pushStringAttribute(target, "class", value);
      break;
    case "tabIndex":
      pushStringAttribute(target, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      pushStringAttribute(target, name2, value);
      break;
    case "style":
      pushStyleAttribute(target, value);
      break;
    case "src":
    case "href":
      if (value === "") {
        name2 === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name2, name2) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name2, name2);
        break;
      }
    case "action":
    case "formAction":
      if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
        break;
      checkAttributeStringCoercion(value, name2);
      value = sanitizeURL("" + value);
      target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "ref":
      break;
    case "autoFocus":
    case "multiple":
    case "muted":
      pushBooleanAttribute(target, name2.toLowerCase(), value);
      break;
    case "xlinkHref":
      if (typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
        break;
      checkAttributeStringCoercion(value, name2);
      value = sanitizeURL("" + value);
      target.push(attributeSeparator, "xlink:href", attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "inert":
      value !== "" || didWarnForNewBooleanPropsWithEmptyValue[name2] || (didWarnForNewBooleanPropsWithEmptyValue[name2] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", name2));
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name2, attributeEmptyString);
      break;
    case "capture":
    case "download":
      value === true ? target.push(attributeSeparator, name2, attributeEmptyString) : value !== false && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value && target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "rowSpan":
    case "start":
      typeof value === "function" || typeof value === "symbol" || isNaN(value) || target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "xlinkActuate":
      pushStringAttribute(target, "xlink:actuate", value);
      break;
    case "xlinkArcrole":
      pushStringAttribute(target, "xlink:arcrole", value);
      break;
    case "xlinkRole":
      pushStringAttribute(target, "xlink:role", value);
      break;
    case "xlinkShow":
      pushStringAttribute(target, "xlink:show", value);
      break;
    case "xlinkTitle":
      pushStringAttribute(target, "xlink:title", value);
      break;
    case "xlinkType":
      pushStringAttribute(target, "xlink:type", value);
      break;
    case "xmlBase":
      pushStringAttribute(target, "xml:base", value);
      break;
    case "xmlLang":
      pushStringAttribute(target, "xml:lang", value);
      break;
    case "xmlSpace":
      pushStringAttribute(target, "xml:space", value);
      break;
    default:
      if (!(2 < name2.length) || name2[0] !== "o" && name2[0] !== "O" || name2[1] !== "n" && name2[1] !== "N") {
        if (name2 = aliases.get(name2) || name2, isAttributeNameSafe(name2)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              var prefix = name2.toLowerCase().slice(0, 5);
              if (prefix !== "data-" && prefix !== "aria-")
                return;
          }
          target.push(attributeSeparator, name2, attributeAssign, escapeTextForBrowser(value), attributeEnd);
        }
      }
  }
}
function pushInnerHTML(target, innerHTML, children) {
  if (innerHTML != null) {
    if (children != null)
      throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
    if (typeof innerHTML !== "object" || !("__html" in innerHTML))
      throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
    innerHTML = innerHTML.__html;
    innerHTML !== null && innerHTML !== undefined && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
  }
}
function checkSelectProp(props, propName) {
  var value = props[propName];
  value != null && (value = isArrayImpl(value), props.multiple && !value ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && value && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName));
}
function flattenOptionChildren(children) {
  var content = "";
  React.Children.forEach(children, function(child) {
    child != null && (content += child, didWarnInvalidOptionChildren || typeof child === "string" || typeof child === "number" || typeof child === "bigint" || (didWarnInvalidOptionChildren = true, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
  });
  return content;
}
function injectFormReplayingRuntime(resumableState, renderState) {
  (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(renderState.startInlineScript, formReplayingRuntimeScript, "</script>"));
}
function pushLinkImpl(target, props) {
  target.push(startChunkForTag("link"));
  for (var propKey in props)
    if (hasOwnProperty2.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTagSelfClosing);
  return null;
}
function escapeStyleTextContent(styleText) {
  checkHtmlStringCoercion(styleText);
  return ("" + styleText).replace(styleRegex, styleReplacer);
}
function styleReplacer(match, prefix, s2, suffix) {
  return "" + prefix + (s2 === "s" ? "\\73 " : "\\53 ") + suffix;
}
function pushSelfClosing(target, props, tag2) {
  target.push(startChunkForTag(tag2));
  for (var propKey in props)
    if (hasOwnProperty2.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(tag2 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTagSelfClosing);
  return null;
}
function pushTitleImpl(target, props) {
  target.push(startChunkForTag("title"));
  var children = null, innerHTML = null, propKey;
  for (propKey in props)
    if (hasOwnProperty2.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            children = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
  typeof props !== "function" && typeof props !== "symbol" && props !== null && props !== undefined && target.push(escapeTextForBrowser("" + props));
  pushInnerHTML(target, innerHTML, children);
  target.push(endChunkForTag("title"));
  return null;
}
function pushScriptImpl(target, props) {
  target.push(startChunkForTag("script"));
  var children = null, innerHTML = null, propKey;
  for (propKey in props)
    if (hasOwnProperty2.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            children = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  children != null && typeof children !== "string" && (props = typeof children === "number" ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error("A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.", props));
  pushInnerHTML(target, innerHTML, children);
  typeof children === "string" && target.push(escapeEntireInlineScriptContent(children));
  target.push(endChunkForTag("script"));
  return null;
}
function pushStartSingletonElement(target, props, tag2) {
  target.push(startChunkForTag(tag2));
  var innerHTML = tag2 = null, propKey;
  for (propKey in props)
    if (hasOwnProperty2.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            tag2 = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  pushInnerHTML(target, innerHTML, tag2);
  return tag2;
}
function pushStartGenericElement(target, props, tag2) {
  target.push(startChunkForTag(tag2));
  var innerHTML = tag2 = null, propKey;
  for (propKey in props)
    if (hasOwnProperty2.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            tag2 = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  pushInnerHTML(target, innerHTML, tag2);
  return typeof tag2 === "string" ? (target.push(escapeTextForBrowser(tag2)), null) : tag2;
}
function startChunkForTag(tag2) {
  var tagStartChunk = validatedTagCache.get(tag2);
  if (tagStartChunk === undefined) {
    if (!VALID_TAG_REGEX.test(tag2))
      throw Error("Invalid tag: " + tag2);
    tagStartChunk = "<" + tag2;
    validatedTagCache.set(tag2, tagStartChunk);
  }
  return tagStartChunk;
}
function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
  validateProperties$2(type, props);
  type !== "input" && type !== "textarea" && type !== "select" || props == null || props.value !== null || didWarnValueNull || (didWarnValueNull = true, type === "select" && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
  b:
    if (type.indexOf("-") === -1)
      var JSCompiler_inline_result = false;
    else
      switch (type) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          JSCompiler_inline_result = false;
          break b;
        default:
          JSCompiler_inline_result = true;
      }
  JSCompiler_inline_result || typeof props.is === "string" || warnUnknownProperties(type, props, null);
  !props.suppressContentEditableWarning && props.contentEditable && props.children != null && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
  formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && type.indexOf("-") === -1 && type.toLowerCase() !== type && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
  switch (type) {
    case "div":
    case "span":
    case "svg":
    case "path":
      break;
    case "a":
      target$jscomp$0.push(startChunkForTag("a"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "href":
                propValue === "" ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                break;
              default:
                pushAttribute(target$jscomp$0, propKey, propValue);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML, children);
      if (typeof children === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children));
        var JSCompiler_inline_result$jscomp$0 = null;
      } else
        JSCompiler_inline_result$jscomp$0 = children;
      return JSCompiler_inline_result$jscomp$0;
    case "g":
    case "p":
    case "li":
      break;
    case "select":
      checkControlledValueProps("select", props);
      checkSelectProp(props, "value");
      checkSelectProp(props, "defaultValue");
      props.value === undefined || props.defaultValue === undefined || didWarnDefaultSelectValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultSelectValue = true);
      target$jscomp$0.push(startChunkForTag("select"));
      var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
      for (propKey$jscomp$0 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$0)) {
          var propValue$jscomp$0 = props[propKey$jscomp$0];
          if (propValue$jscomp$0 != null)
            switch (propKey$jscomp$0) {
              case "children":
                children$jscomp$0 = propValue$jscomp$0;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$0 = propValue$jscomp$0;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
      return children$jscomp$0;
    case "option":
      var selectedValue = formatContext.selectedValue;
      target$jscomp$0.push(startChunkForTag("option"));
      var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
      for (propKey$jscomp$1 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$1)) {
          var propValue$jscomp$1 = props[propKey$jscomp$1];
          if (propValue$jscomp$1 != null)
            switch (propKey$jscomp$1) {
              case "children":
                children$jscomp$1 = propValue$jscomp$1;
                break;
              case "selected":
                selected = propValue$jscomp$1;
                didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = true);
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$1 = propValue$jscomp$1;
                break;
              case "value":
                value = propValue$jscomp$1;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
            }
        }
      if (selectedValue != null) {
        if (value !== null) {
          checkAttributeStringCoercion(value, "value");
          var stringValue = "" + value;
        } else
          innerHTML$jscomp$1 === null || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")), stringValue = flattenOptionChildren(children$jscomp$1);
        if (isArrayImpl(selectedValue))
          for (var i = 0;i < selectedValue.length; i++) {
            if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
              target$jscomp$0.push(' selected=""');
              break;
            }
          }
        else
          checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
      } else
        selected && target$jscomp$0.push(' selected=""');
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
      return children$jscomp$1;
    case "textarea":
      checkControlledValueProps("textarea", props);
      props.value === undefined || props.defaultValue === undefined || didWarnDefaultTextareaValue || (console.error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultTextareaValue = true);
      target$jscomp$0.push(startChunkForTag("textarea"));
      var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
      for (propKey$jscomp$2 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$2)) {
          var propValue$jscomp$2 = props[propKey$jscomp$2];
          if (propValue$jscomp$2 != null)
            switch (propKey$jscomp$2) {
              case "children":
                children$jscomp$2 = propValue$jscomp$2;
                break;
              case "value":
                value$jscomp$0 = propValue$jscomp$2;
                break;
              case "defaultValue":
                defaultValue = propValue$jscomp$2;
                break;
              case "dangerouslySetInnerHTML":
                throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
            }
        }
      value$jscomp$0 === null && defaultValue !== null && (value$jscomp$0 = defaultValue);
      target$jscomp$0.push(endOfStartTag);
      if (children$jscomp$2 != null) {
        console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
        if (value$jscomp$0 != null)
          throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (isArrayImpl(children$jscomp$2)) {
          if (1 < children$jscomp$2.length)
            throw Error("<textarea> can only have at most one child.");
          checkHtmlStringCoercion(children$jscomp$2[0]);
          value$jscomp$0 = "" + children$jscomp$2[0];
        }
        checkHtmlStringCoercion(children$jscomp$2);
        value$jscomp$0 = "" + children$jscomp$2;
      }
      typeof value$jscomp$0 === "string" && value$jscomp$0[0] === `
` && target$jscomp$0.push(`
`);
      value$jscomp$0 !== null && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
      return null;
    case "input":
      checkControlledValueProps("input", props);
      target$jscomp$0.push(startChunkForTag("input"));
      var name2 = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
      for (propKey$jscomp$3 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$3)) {
          var propValue$jscomp$3 = props[propKey$jscomp$3];
          if (propValue$jscomp$3 != null)
            switch (propKey$jscomp$3) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "name":
                name2 = propValue$jscomp$3;
                break;
              case "formAction":
                formAction = propValue$jscomp$3;
                break;
              case "formEncType":
                formEncType = propValue$jscomp$3;
                break;
              case "formMethod":
                formMethod = propValue$jscomp$3;
                break;
              case "formTarget":
                formTarget = propValue$jscomp$3;
                break;
              case "defaultChecked":
                defaultChecked = propValue$jscomp$3;
                break;
              case "defaultValue":
                defaultValue$jscomp$0 = propValue$jscomp$3;
                break;
              case "checked":
                checked = propValue$jscomp$3;
                break;
              case "value":
                value$jscomp$1 = propValue$jscomp$3;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
            }
        }
      formAction === null || props.type === "image" || props.type === "submit" || didWarnFormActionType || (didWarnFormActionType = true, console.error('An input can only specify a formAction along with type="submit" or type="image".'));
      var formData = pushFormActionAttribute(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2);
      checked === null || defaultChecked === null || didWarnDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultChecked = true);
      value$jscomp$1 === null || defaultValue$jscomp$0 === null || didWarnDefaultInputValue || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = true);
      checked !== null ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : defaultChecked !== null && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
      value$jscomp$1 !== null ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : defaultValue$jscomp$0 !== null && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
      target$jscomp$0.push(endOfStartTagSelfClosing);
      formData != null && formData.forEach(pushAdditionalFormField, target$jscomp$0);
      return null;
    case "button":
      target$jscomp$0.push(startChunkForTag("button"));
      var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
      for (propKey$jscomp$4 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$4)) {
          var propValue$jscomp$4 = props[propKey$jscomp$4];
          if (propValue$jscomp$4 != null)
            switch (propKey$jscomp$4) {
              case "children":
                children$jscomp$3 = propValue$jscomp$4;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$2 = propValue$jscomp$4;
                break;
              case "name":
                name$jscomp$0 = propValue$jscomp$4;
                break;
              case "formAction":
                formAction$jscomp$0 = propValue$jscomp$4;
                break;
              case "formEncType":
                formEncType$jscomp$0 = propValue$jscomp$4;
                break;
              case "formMethod":
                formMethod$jscomp$0 = propValue$jscomp$4;
                break;
              case "formTarget":
                formTarget$jscomp$0 = propValue$jscomp$4;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
            }
        }
      formAction$jscomp$0 === null || props.type == null || props.type === "submit" || didWarnFormActionType || (didWarnFormActionType = true, console.error('A button can only specify a formAction along with type="submit" or no type.'));
      var formData$jscomp$0 = pushFormActionAttribute(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
      target$jscomp$0.push(endOfStartTag);
      formData$jscomp$0 != null && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
      if (typeof children$jscomp$3 === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
        var JSCompiler_inline_result$jscomp$1 = null;
      } else
        JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
      return JSCompiler_inline_result$jscomp$1;
    case "form":
      target$jscomp$0.push(startChunkForTag("form"));
      var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
      for (propKey$jscomp$5 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$5)) {
          var propValue$jscomp$5 = props[propKey$jscomp$5];
          if (propValue$jscomp$5 != null)
            switch (propKey$jscomp$5) {
              case "children":
                children$jscomp$4 = propValue$jscomp$5;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$3 = propValue$jscomp$5;
                break;
              case "action":
                formAction$jscomp$1 = propValue$jscomp$5;
                break;
              case "encType":
                formEncType$jscomp$1 = propValue$jscomp$5;
                break;
              case "method":
                formMethod$jscomp$1 = propValue$jscomp$5;
                break;
              case "target":
                formTarget$jscomp$1 = propValue$jscomp$5;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
            }
        }
      var formData$jscomp$1 = null, formActionName = null;
      if (typeof formAction$jscomp$1 === "function") {
        formEncType$jscomp$1 === null && formMethod$jscomp$1 === null || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."));
        formTarget$jscomp$1 === null || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."));
        var customFields = getCustomFormFields(resumableState, formAction$jscomp$1);
        customFields !== null ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator, "action", attributeAssign, actionJavaScriptURL, attributeEnd), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
      }
      formAction$jscomp$1 != null && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
      formEncType$jscomp$1 != null && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
      formMethod$jscomp$1 != null && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
      formTarget$jscomp$1 != null && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
      target$jscomp$0.push(endOfStartTag);
      formActionName !== null && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), formData$jscomp$1 != null && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
      if (typeof children$jscomp$4 === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
        var JSCompiler_inline_result$jscomp$2 = null;
      } else
        JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
      return JSCompiler_inline_result$jscomp$2;
    case "menuitem":
      target$jscomp$0.push(startChunkForTag("menuitem"));
      for (var propKey$jscomp$6 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$6)) {
          var propValue$jscomp$6 = props[propKey$jscomp$6];
          if (propValue$jscomp$6 != null)
            switch (propKey$jscomp$6) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      return null;
    case "object":
      target$jscomp$0.push(startChunkForTag("object"));
      var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
      for (propKey$jscomp$7 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$7)) {
          var propValue$jscomp$7 = props[propKey$jscomp$7];
          if (propValue$jscomp$7 != null)
            switch (propKey$jscomp$7) {
              case "children":
                children$jscomp$5 = propValue$jscomp$7;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$4 = propValue$jscomp$7;
                break;
              case "data":
                checkAttributeStringCoercion(propValue$jscomp$7, "data");
                var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                if (sanitizedValue === "") {
                  console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', propKey$jscomp$7, propKey$jscomp$7);
                  break;
                }
                target$jscomp$0.push(attributeSeparator, "data", attributeAssign, escapeTextForBrowser(sanitizedValue), attributeEnd);
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
      if (typeof children$jscomp$5 === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
        var JSCompiler_inline_result$jscomp$3 = null;
      } else
        JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
      return JSCompiler_inline_result$jscomp$3;
    case "title":
      var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
      if (hasOwnProperty2.call(props, "children")) {
        var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
        Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.", children$jscomp$6.length) : typeof child === "function" || typeof child === "symbol" ? console.error("React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.", typeof child === "function" ? "a Function" : "a Sybmol") : child && child.toString === {}.toString && (child.$$typeof != null ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.") : console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."));
      }
      if (insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null)
        var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(target$jscomp$0, props);
      else
        isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = undefined);
      return JSCompiler_inline_result$jscomp$4;
    case "link":
      var { rel, href, precedence } = props;
      if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || props.itemProp != null || typeof rel !== "string" || typeof href !== "string" || href === "") {
        rel === "stylesheet" && typeof props.precedence === "string" && (typeof href === "string" && href || console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', href === null ? "`null`" : href === undefined ? "`undefined`" : href === "" ? "an empty string" : 'something with type "' + typeof href + '"'));
        pushLinkImpl(target$jscomp$0, props);
        var JSCompiler_inline_result$jscomp$5 = null;
      } else if (props.rel === "stylesheet")
        if (typeof precedence !== "string" || props.disabled != null || props.onLoad || props.onError) {
          if (typeof precedence === "string") {
            if (props.disabled != null)
              console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');
            else if (props.onLoad || props.onError) {
              var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
              console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);
            }
          }
          JSCompiler_inline_result$jscomp$5 = pushLinkImpl(target$jscomp$0, props);
        } else {
          var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
          if (resourceState !== EXISTS) {
            resumableState.styleResources[href] = EXISTS;
            styleQueue || (styleQueue = {
              precedence: escapeTextForBrowser(precedence),
              rules: [],
              hrefs: [],
              sheets: new Map
            }, renderState.styles.set(precedence, styleQueue));
            var resource = {
              state: PENDING$1,
              props: assign({}, props, {
                "data-precedence": props.precedence,
                precedence: null
              })
            };
            if (resourceState) {
              resourceState.length === 2 && adoptPreloadCredentials(resource.props, resourceState);
              var preloadResource = renderState.preloads.stylesheets.get(href);
              preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
            }
            styleQueue.sheets.set(href, resource);
            hoistableState && hoistableState.stylesheets.add(resource);
          } else if (styleQueue) {
            var _resource = styleQueue.sheets.get(href);
            _resource && hoistableState && hoistableState.stylesheets.add(_resource);
          }
          textEmbedded && target$jscomp$0.push("<!-- -->");
          JSCompiler_inline_result$jscomp$5 = null;
        }
      else
        props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
      return JSCompiler_inline_result$jscomp$5;
    case "script":
      var asyncProp = props.async;
      if (typeof props.src !== "string" || !props.src || !asyncProp || typeof asyncProp === "function" || typeof asyncProp === "symbol" || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || props.itemProp != null)
        var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(target$jscomp$0, props);
      else {
        var key = props.src;
        if (props.type === "module") {
          var resources = resumableState.moduleScriptResources;
          var preloads = renderState.preloads.moduleScripts;
        } else
          resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
        var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : undefined;
        if (resourceState$jscomp$0 !== EXISTS) {
          resources[key] = EXISTS;
          var scriptProps = props;
          if (resourceState$jscomp$0) {
            resourceState$jscomp$0.length === 2 && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
            var preloadResource$jscomp$0 = preloads.get(key);
            preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
          }
          var resource$jscomp$0 = [];
          renderState.scripts.add(resource$jscomp$0);
          pushScriptImpl(resource$jscomp$0, scriptProps);
        }
        textEmbedded && target$jscomp$0.push("<!-- -->");
        JSCompiler_inline_result$jscomp$6 = null;
      }
      return JSCompiler_inline_result$jscomp$6;
    case "style":
      var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
      if (hasOwnProperty2.call(props, "children")) {
        var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
        (typeof child$jscomp$0 === "function" || typeof child$jscomp$0 === "symbol" || Array.isArray(child$jscomp$0)) && console.error("React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.", typeof child$jscomp$0 === "function" ? "a Function" : typeof child$jscomp$0 === "symbol" ? "a Sybmol" : "an Array");
      }
      var { precedence: precedence$jscomp$0, href: href$jscomp$0 } = props;
      if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || props.itemProp != null || typeof precedence$jscomp$0 !== "string" || typeof href$jscomp$0 !== "string" || href$jscomp$0 === "") {
        target$jscomp$0.push(startChunkForTag("style"));
        var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
        for (propKey$jscomp$8 in props)
          if (hasOwnProperty2.call(props, propKey$jscomp$8)) {
            var propValue$jscomp$8 = props[propKey$jscomp$8];
            if (propValue$jscomp$8 != null)
              switch (propKey$jscomp$8) {
                case "children":
                  children$jscomp$8 = propValue$jscomp$8;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$5 = propValue$jscomp$8;
                  break;
                default:
                  pushAttribute(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
              }
          }
        target$jscomp$0.push(endOfStartTag);
        var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
        typeof child$jscomp$1 !== "function" && typeof child$jscomp$1 !== "symbol" && child$jscomp$1 !== null && child$jscomp$1 !== undefined && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$8);
        target$jscomp$0.push(endChunkForTag("style"));
        var JSCompiler_inline_result$jscomp$7 = null;
      } else {
        href$jscomp$0.includes(" ") && console.error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".', href$jscomp$0);
        var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : undefined;
        if (resourceState$jscomp$1 !== EXISTS) {
          resumableState.styleResources[href$jscomp$0] = EXISTS;
          resourceState$jscomp$1 && console.error('React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.', href$jscomp$0);
          styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser(href$jscomp$0)) : (styleQueue$jscomp$0 = {
            precedence: escapeTextForBrowser(precedence$jscomp$0),
            rules: [],
            hrefs: [escapeTextForBrowser(href$jscomp$0)],
            sheets: new Map
          }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
          var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
          for (propKey$jscomp$9 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$9)) {
              var propValue$jscomp$9 = props[propKey$jscomp$9];
              if (propValue$jscomp$9 != null)
                switch (propKey$jscomp$9) {
                  case "children":
                    children$jscomp$9 = propValue$jscomp$9;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$6 = propValue$jscomp$9;
                }
            }
          var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
          typeof child$jscomp$2 !== "function" && typeof child$jscomp$2 !== "symbol" && child$jscomp$2 !== null && child$jscomp$2 !== undefined && target.push(escapeStyleTextContent(child$jscomp$2));
          pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
        }
        styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
        textEmbedded && target$jscomp$0.push("<!-- -->");
        JSCompiler_inline_result$jscomp$7 = undefined;
      }
      return JSCompiler_inline_result$jscomp$7;
    case "meta":
      if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || props.itemProp != null)
        var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(target$jscomp$0, props, "meta");
      else
        textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback ? null : typeof props.charSet === "string" ? pushSelfClosing(renderState.charsetChunks, props, "meta") : props.name === "viewport" ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
      return JSCompiler_inline_result$jscomp$8;
    case "listing":
    case "pre":
      target$jscomp$0.push(startChunkForTag(type));
      var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
      for (propKey$jscomp$10 in props)
        if (hasOwnProperty2.call(props, propKey$jscomp$10)) {
          var propValue$jscomp$10 = props[propKey$jscomp$10];
          if (propValue$jscomp$10 != null)
            switch (propKey$jscomp$10) {
              case "children":
                children$jscomp$10 = propValue$jscomp$10;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$7 = propValue$jscomp$10;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      if (innerHTML$jscomp$7 != null) {
        if (children$jscomp$10 != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof innerHTML$jscomp$7 !== "object" || !("__html" in innerHTML$jscomp$7))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
        var html2 = innerHTML$jscomp$7.__html;
        html2 !== null && html2 !== undefined && (typeof html2 === "string" && 0 < html2.length && html2[0] === `
` ? target$jscomp$0.push(`
`, html2) : (checkHtmlStringCoercion(html2), target$jscomp$0.push("" + html2)));
      }
      typeof children$jscomp$10 === "string" && children$jscomp$10[0] === `
` && target$jscomp$0.push(`
`);
      return children$jscomp$10;
    case "img":
      var { src, srcSet } = props;
      if (!(props.loading === "lazy" || !src && !srcSet || typeof src !== "string" && src != null || typeof srcSet !== "string" && srcSet != null) && props.fetchPriority !== "low" && !!(formatContext.tagScope & 3) === false && (typeof src !== "string" || src[4] !== ":" || src[0] !== "d" && src[0] !== "D" || src[1] !== "a" && src[1] !== "A" || src[2] !== "t" && src[2] !== "T" || src[3] !== "a" && src[3] !== "A") && (typeof srcSet !== "string" || srcSet[4] !== ":" || srcSet[0] !== "d" && srcSet[0] !== "D" || srcSet[1] !== "a" && srcSet[1] !== "A" || srcSet[2] !== "t" && srcSet[2] !== "T" || srcSet[3] !== "a" && srcSet[3] !== "A")) {
        var sizes = typeof props.sizes === "string" ? props.sizes : undefined, key$jscomp$0 = srcSet ? srcSet + `
` + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
        if (resource$jscomp$1) {
          if (props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size)
            promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
        } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
          resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
          var input = props.crossOrigin;
          var crossOrigin = typeof input === "string" ? input === "use-credentials" ? input : "" : undefined;
          var headers = renderState.headers, header;
          headers && 0 < headers.remainingCapacity && typeof props.srcSet !== "string" && (props.fetchPriority === "high" || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
            imageSrcSet: props.srcSet,
            imageSizes: props.sizes,
            crossOrigin,
            integrity: props.integrity,
            nonce: props.nonce,
            type: props.type,
            fetchPriority: props.fetchPriority,
            referrerPolicy: props.refererPolicy
          }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
            rel: "preload",
            as: "image",
            href: srcSet ? undefined : src,
            imageSrcSet: srcSet,
            imageSizes: sizes,
            crossOrigin,
            integrity: props.integrity,
            type: props.type,
            fetchPriority: props.fetchPriority,
            referrerPolicy: props.referrerPolicy
          }), props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
        }
      }
      return pushSelfClosing(target$jscomp$0, props, "img");
    case "base":
    case "area":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "param":
    case "source":
    case "track":
    case "wbr":
      return pushSelfClosing(target$jscomp$0, props, type);
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      break;
    case "head":
      if (formatContext.insertionMode < HTML_MODE) {
        var preamble = preambleState || renderState.preamble;
        if (preamble.headChunks)
          throw Error("The `<head>` tag may only be rendered once.");
        preamble.headChunks = [];
        var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(preamble.headChunks, props, "head");
      } else
        JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(target$jscomp$0, props, "head");
      return JSCompiler_inline_result$jscomp$9;
    case "body":
      if (formatContext.insertionMode < HTML_MODE) {
        var preamble$jscomp$0 = preambleState || renderState.preamble;
        if (preamble$jscomp$0.bodyChunks)
          throw Error("The `<body>` tag may only be rendered once.");
        preamble$jscomp$0.bodyChunks = [];
        var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(preamble$jscomp$0.bodyChunks, props, "body");
      } else
        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(target$jscomp$0, props, "body");
      return JSCompiler_inline_result$jscomp$10;
    case "html":
      if (formatContext.insertionMode === ROOT_HTML_MODE) {
        var preamble$jscomp$1 = preambleState || renderState.preamble;
        if (preamble$jscomp$1.htmlChunks)
          throw Error("The `<html>` tag may only be rendered once.");
        preamble$jscomp$1.htmlChunks = ["<!DOCTYPE html>"];
        var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(preamble$jscomp$1.htmlChunks, props, "html");
      } else
        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(target$jscomp$0, props, "html");
      return JSCompiler_inline_result$jscomp$11;
    default:
      if (type.indexOf("-") !== -1) {
        target$jscomp$0.push(startChunkForTag(type));
        var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
        for (propKey$jscomp$11 in props)
          if (hasOwnProperty2.call(props, propKey$jscomp$11)) {
            var propValue$jscomp$11 = props[propKey$jscomp$11];
            if (propValue$jscomp$11 != null) {
              var attributeName = propKey$jscomp$11;
              switch (propKey$jscomp$11) {
                case "children":
                  children$jscomp$11 = propValue$jscomp$11;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$8 = propValue$jscomp$11;
                  break;
                case "style":
                  pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "ref":
                  break;
                case "className":
                  attributeName = "class";
                default:
                  if (isAttributeNameSafe(propKey$jscomp$11) && typeof propValue$jscomp$11 !== "function" && typeof propValue$jscomp$11 !== "symbol" && propValue$jscomp$11 !== false) {
                    if (propValue$jscomp$11 === true)
                      propValue$jscomp$11 = "";
                    else if (typeof propValue$jscomp$11 === "object")
                      continue;
                    target$jscomp$0.push(attributeSeparator, attributeName, attributeAssign, escapeTextForBrowser(propValue$jscomp$11), attributeEnd);
                  }
              }
            }
          }
        target$jscomp$0.push(endOfStartTag);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$11);
        return children$jscomp$11;
      }
  }
  return pushStartGenericElement(target$jscomp$0, props, type);
}
function endChunkForTag(tag2) {
  var chunk = endTagCache.get(tag2);
  chunk === undefined && (chunk = "</" + tag2 + ">", endTagCache.set(tag2, chunk));
  return chunk;
}
function hoistPreambleState(renderState, preambleState) {
  renderState = renderState.preamble;
  renderState.htmlChunks === null && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
  renderState.headChunks === null && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
  renderState.bodyChunks === null && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
}
function writeBootstrap(destination, renderState) {
  renderState = renderState.bootstrapChunks;
  for (var i = 0;i < renderState.length - 1; i++)
    writeChunk(destination, renderState[i]);
  return i < renderState.length ? (i = renderState[i], renderState.length = 0, !!destination.write(i)) : true;
}
function writeStartPendingSuspenseBoundary(destination, renderState, id) {
  writeChunk(destination, startPendingSuspenseBoundary1);
  if (id === null)
    throw Error("An ID must have been assigned before we can complete the boundary.");
  writeChunk(destination, renderState.boundaryPrefix);
  writeChunk(destination, id.toString(16));
  return !!destination.write(startPendingSuspenseBoundary2);
}
function writePreambleContribution(destination, preambleState) {
  preambleState = preambleState.contribution;
  preambleState !== NoContribution && (writeChunk(destination, boundaryPreambleContributionChunkStart), writeChunk(destination, "" + preambleState), writeChunk(destination, boundaryPreambleContributionChunkEnd));
}
function writeStartSegment(destination, renderState, formatContext, id) {
  switch (formatContext.insertionMode) {
    case ROOT_HTML_MODE:
    case HTML_HTML_MODE:
    case HTML_HEAD_MODE:
    case HTML_MODE:
      return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentHTML2);
    case SVG_MODE:
      return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentSVG2);
    case MATHML_MODE:
      return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentMathML2);
    case HTML_TABLE_MODE:
      return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentTable2);
    case HTML_TABLE_BODY_MODE:
      return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentTableBody2);
    case HTML_TABLE_ROW_MODE:
      return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentTableRow2);
    case HTML_COLGROUP_MODE:
      return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentColGroup2);
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function writeEndSegment(destination, formatContext) {
  switch (formatContext.insertionMode) {
    case ROOT_HTML_MODE:
    case HTML_HTML_MODE:
    case HTML_HEAD_MODE:
    case HTML_MODE:
      return !!destination.write(endSegmentHTML);
    case SVG_MODE:
      return !!destination.write(endSegmentSVG);
    case MATHML_MODE:
      return !!destination.write(endSegmentMathML);
    case HTML_TABLE_MODE:
      return !!destination.write(endSegmentTable);
    case HTML_TABLE_BODY_MODE:
      return !!destination.write(endSegmentTableBody);
    case HTML_TABLE_ROW_MODE:
      return !!destination.write(endSegmentTableRow);
    case HTML_COLGROUP_MODE:
      return !!destination.write(endSegmentColGroup);
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function escapeJSStringsForInstructionScripts(input) {
  return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts, function(match) {
    switch (match) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function escapeJSObjectForInstructionScripts(input) {
  return JSON.stringify(input).replace(regexForJSStringsInScripts, function(match) {
    switch (match) {
      case "&":
        return "\\u0026";
      case ">":
        return "\\u003e";
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function flushStyleTagsLateForBoundary(styleQueue) {
  var { rules, hrefs } = styleQueue;
  0 < rules.length && hrefs.length === 0 && console.error("React expected to have at least one href for an a hoistable style but found none. This is a bug in React.");
  var i = 0;
  if (hrefs.length) {
    writeChunk(this, lateStyleTagResourceOpen1);
    writeChunk(this, styleQueue.precedence);
    for (writeChunk(this, lateStyleTagResourceOpen2);i < hrefs.length - 1; i++)
      writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);
    writeChunk(this, hrefs[i]);
    writeChunk(this, lateStyleTagResourceOpen3);
    for (i = 0;i < rules.length; i++)
      writeChunk(this, rules[i]);
    destinationHasCapacity = !!this.write(lateStyleTagTemplateClose);
    currentlyRenderingBoundaryHasStylesToHoist = true;
    rules.length = 0;
    hrefs.length = 0;
  }
}
function hasStylesToHoist(stylesheet) {
  return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
}
function writeHoistablesForBoundary(destination, hoistableState, renderState) {
  currentlyRenderingBoundaryHasStylesToHoist = false;
  destinationHasCapacity = true;
  hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
  hoistableState.stylesheets.forEach(hasStylesToHoist);
  currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
  return destinationHasCapacity;
}
function flushResource(resource) {
  for (var i = 0;i < resource.length; i++)
    writeChunk(this, resource[i]);
  resource.length = 0;
}
function flushStyleInPreamble(stylesheet) {
  pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
  for (var i = 0;i < stylesheetFlushingQueue.length; i++)
    writeChunk(this, stylesheetFlushingQueue[i]);
  stylesheetFlushingQueue.length = 0;
  stylesheet.state = PREAMBLE;
}
function flushStylesInPreamble(styleQueue) {
  var hasStylesheets = 0 < styleQueue.sheets.size;
  styleQueue.sheets.forEach(flushStyleInPreamble, this);
  styleQueue.sheets.clear();
  var { rules, hrefs } = styleQueue;
  if (!hasStylesheets || hrefs.length) {
    writeChunk(this, styleTagResourceOpen1);
    writeChunk(this, styleQueue.precedence);
    styleQueue = 0;
    if (hrefs.length) {
      for (writeChunk(this, styleTagResourceOpen2);styleQueue < hrefs.length - 1; styleQueue++)
        writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
      writeChunk(this, hrefs[styleQueue]);
    }
    writeChunk(this, styleTagResourceOpen3);
    for (styleQueue = 0;styleQueue < rules.length; styleQueue++)
      writeChunk(this, rules[styleQueue]);
    writeChunk(this, styleTagResourceClose);
    rules.length = 0;
    hrefs.length = 0;
  }
}
function preloadLateStyle(stylesheet) {
  if (stylesheet.state === PENDING$1) {
    stylesheet.state = PRELOADED;
    var props = stylesheet.props;
    pushLinkImpl(stylesheetFlushingQueue, {
      rel: "preload",
      as: "style",
      href: stylesheet.props.href,
      crossOrigin: props.crossOrigin,
      fetchPriority: props.fetchPriority,
      integrity: props.integrity,
      media: props.media,
      hrefLang: props.hrefLang,
      referrerPolicy: props.referrerPolicy
    });
    for (stylesheet = 0;stylesheet < stylesheetFlushingQueue.length; stylesheet++)
      writeChunk(this, stylesheetFlushingQueue[stylesheet]);
    stylesheetFlushingQueue.length = 0;
  }
}
function preloadLateStyles(styleQueue) {
  styleQueue.sheets.forEach(preloadLateStyle, this);
  styleQueue.sheets.clear();
}
function writeStyleResourceDependenciesInJS(destination, hoistableState) {
  writeChunk(destination, arrayFirstOpenBracket);
  var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
  hoistableState.stylesheets.forEach(function(resource) {
    if (resource.state !== PREAMBLE)
      if (resource.state === LATE)
        writeChunk(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk(destination, escapeJSObjectForInstructionScripts("" + resource)), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
      else {
        writeChunk(destination, nextArrayOpenBrackChunk);
        var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
        writeChunk(destination, escapeJSObjectForInstructionScripts(coercedHref));
        checkAttributeStringCoercion(precedence, "precedence");
        precedence = "" + precedence;
        writeChunk(destination, arrayInterstitial);
        writeChunk(destination, escapeJSObjectForInstructionScripts(precedence));
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey) && (precedence = props[propKey], precedence != null))
            switch (propKey) {
              case "href":
              case "rel":
              case "precedence":
              case "data-precedence":
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                writeStyleResourceAttributeInJS(destination, propKey, precedence);
            }
        writeChunk(destination, arrayCloseBracket);
        nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
        resource.state = LATE;
      }
  });
  writeChunk(destination, arrayCloseBracket);
}
function writeStyleResourceAttributeInJS(destination, name2, value) {
  var attributeName = name2.toLowerCase();
  switch (typeof value) {
    case "function":
    case "symbol":
      return;
  }
  switch (name2) {
    case "innerHTML":
    case "dangerouslySetInnerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "style":
    case "ref":
      return;
    case "className":
      attributeName = "class";
      checkAttributeStringCoercion(value, attributeName);
      name2 = "" + value;
      break;
    case "hidden":
      if (value === false)
        return;
      name2 = "";
      break;
    case "src":
    case "href":
      value = sanitizeURL(value);
      checkAttributeStringCoercion(value, attributeName);
      name2 = "" + value;
      break;
    default:
      if (2 < name2.length && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N") || !isAttributeNameSafe(name2))
        return;
      checkAttributeStringCoercion(value, attributeName);
      name2 = "" + value;
  }
  writeChunk(destination, arrayInterstitial);
  writeChunk(destination, escapeJSObjectForInstructionScripts(attributeName));
  writeChunk(destination, arrayInterstitial);
  writeChunk(destination, escapeJSObjectForInstructionScripts(name2));
}
function createHoistableState() {
  return { styles: new Set, stylesheets: new Set };
}
function prefetchDNS(href) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (typeof href === "string" && href) {
      if (!resumableState.dnsResources.hasOwnProperty(href)) {
        resumableState.dnsResources[href] = EXISTS;
        resumableState = renderState.headers;
        var header, JSCompiler_temp;
        if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
          JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
        JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
      }
      enqueueFlush(request);
    }
  } else
    previousDispatcher.D(href);
}
function preconnect(href, crossOrigin) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (typeof href === "string" && href) {
      var bucket = crossOrigin === "use-credentials" ? "credentials" : typeof crossOrigin === "string" ? "anonymous" : "default";
      if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
        resumableState.connectResources[bucket][href] = EXISTS;
        resumableState = renderState.headers;
        var header, JSCompiler_temp;
        if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
          JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
          if (typeof crossOrigin === "string") {
            var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, "crossOrigin");
            JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
          }
          JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
        }
        JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
          rel: "preconnect",
          href,
          crossOrigin
        }), renderState.preconnects.add(bucket));
      }
      enqueueFlush(request);
    }
  } else
    previousDispatcher.C(href, crossOrigin);
}
function preload(href, as2, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (as2 && href) {
      switch (as2) {
        case "image":
          if (options) {
            var imageSrcSet = options.imageSrcSet;
            var imageSizes = options.imageSizes;
            var fetchPriority = options.fetchPriority;
          }
          var key = imageSrcSet ? imageSrcSet + `
` + (imageSizes || "") : href;
          if (resumableState.imageResources.hasOwnProperty(key))
            return;
          resumableState.imageResources[key] = PRELOAD_NO_CREDS;
          resumableState = renderState.headers;
          var header;
          resumableState && 0 < resumableState.remainingCapacity && typeof imageSrcSet !== "string" && fetchPriority === "high" && (header = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(resumableState, assign({ rel: "preload", href: imageSrcSet ? undefined : href, as: as2 }, options)), fetchPriority === "high" ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
          break;
        case "style":
          if (resumableState.styleResources.hasOwnProperty(href))
            return;
          imageSrcSet = [];
          pushLinkImpl(imageSrcSet, assign({ rel: "preload", href, as: as2 }, options));
          resumableState.styleResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
          renderState.preloads.stylesheets.set(href, imageSrcSet);
          renderState.bulkPreloads.add(imageSrcSet);
          break;
        case "script":
          if (resumableState.scriptResources.hasOwnProperty(href))
            return;
          imageSrcSet = [];
          renderState.preloads.scripts.set(href, imageSrcSet);
          renderState.bulkPreloads.add(imageSrcSet);
          pushLinkImpl(imageSrcSet, assign({ rel: "preload", href, as: as2 }, options));
          resumableState.scriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
          break;
        default:
          if (resumableState.unknownResources.hasOwnProperty(as2)) {
            if (imageSrcSet = resumableState.unknownResources[as2], imageSrcSet.hasOwnProperty(href))
              return;
          } else
            imageSrcSet = {}, resumableState.unknownResources[as2] = imageSrcSet;
          imageSrcSet[href] = PRELOAD_NO_CREDS;
          if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && as2 === "font" && (key = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
            renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
          else
            switch (resumableState = [], href = assign({ rel: "preload", href, as: as2 }, options), pushLinkImpl(resumableState, href), as2) {
              case "font":
                renderState.fontPreloads.add(resumableState);
                break;
              default:
                renderState.bulkPreloads.add(resumableState);
            }
      }
      enqueueFlush(request);
    }
  } else
    previousDispatcher.L(href, as2, options);
}
function preloadModule(href, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (href) {
      var as2 = options && typeof options.as === "string" ? options.as : "script";
      switch (as2) {
        case "script":
          if (resumableState.moduleScriptResources.hasOwnProperty(href))
            return;
          as2 = [];
          resumableState.moduleScriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
          renderState.preloads.moduleScripts.set(href, as2);
          break;
        default:
          if (resumableState.moduleUnknownResources.hasOwnProperty(as2)) {
            var resources = resumableState.unknownResources[as2];
            if (resources.hasOwnProperty(href))
              return;
          } else
            resources = {}, resumableState.moduleUnknownResources[as2] = resources;
          as2 = [];
          resources[href] = PRELOAD_NO_CREDS;
      }
      pushLinkImpl(as2, assign({ rel: "modulepreload", href }, options));
      renderState.bulkPreloads.add(as2);
      enqueueFlush(request);
    }
  } else
    previousDispatcher.m(href, options);
}
function preinitStyle(href, precedence, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (href) {
      precedence = precedence || "default";
      var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
      resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
        precedence: escapeTextForBrowser(precedence),
        rules: [],
        hrefs: [],
        sheets: new Map
      }, renderState.styles.set(precedence, styleQueue)), precedence = {
        state: PENDING$1,
        props: assign({ rel: "stylesheet", href, "data-precedence": precedence }, options)
      }, resourceState && (resourceState.length === 2 && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
    }
  } else
    previousDispatcher.S(href, precedence, options);
}
function preinitScript(src, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (src) {
      var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : undefined;
      resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign({ src, async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
    }
  } else
    previousDispatcher.X(src, options);
}
function preinitModuleScript(src, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (src) {
      var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : undefined;
      resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign({ src, type: "module", async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
    }
  } else
    previousDispatcher.M(src, options);
}
function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
  (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error('Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue', href);
  resumableState.scriptResources[href] = EXISTS;
  resumableState.moduleScriptResources[href] = EXISTS;
  resumableState = [];
  pushLinkImpl(resumableState, props);
  renderState.bootstrapScripts.add(resumableState);
}
function adoptPreloadCredentials(target, preloadState) {
  target.crossOrigin == null && (target.crossOrigin = preloadState[0]);
  target.integrity == null && (target.integrity = preloadState[1]);
}
function getPreloadAsHeader(href, as2, params) {
  href = escapeHrefForLinkHeaderURLContext(href);
  as2 = escapeStringForLinkHeaderQuotedParamValueContext(as2, "as");
  as2 = "<" + href + '>; rel=preload; as="' + as2 + '"';
  for (var paramName in params)
    hasOwnProperty2.call(params, paramName) && (href = params[paramName], typeof href === "string" && (as2 += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(href, paramName) + '"'));
  return as2;
}
function escapeHrefForLinkHeaderURLContext(hrefInput) {
  checkAttributeStringCoercion(hrefInput, "href");
  return ("" + hrefInput).replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);
}
function escapeHrefForLinkHeaderURLContextReplacer(match) {
  switch (match) {
    case "<":
      return "%3C";
    case ">":
      return "%3E";
    case `
`:
      return "%0A";
    case "\r":
      return "%0D";
    default:
      throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
  }
}
function escapeStringForLinkHeaderQuotedParamValueContext(value, name2) {
  willCoercionThrow(value) && (console.error("The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.", name2, typeName(value)), testStringCoercion(value));
  return ("" + value).replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);
}
function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
  switch (match) {
    case '"':
      return "%22";
    case "'":
      return "%27";
    case ";":
      return "%3B";
    case ",":
      return "%2C";
    case `
`:
      return "%0A";
    case "\r":
      return "%0D";
    default:
      throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
  }
}
function hoistStyleQueueDependency(styleQueue) {
  this.styles.add(styleQueue);
}
function hoistStylesheetDependency(stylesheet) {
  this.stylesheets.add(stylesheet);
}
function getComponentNameFromType(type) {
  if (type == null)
    return null;
  if (typeof type === "function")
    return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
  if (typeof type === "string")
    return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if (typeof type === "object")
    switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x2) {}
    }
  return null;
}
function popToNearestCommonAncestor(prev, next) {
  if (prev !== next) {
    prev.context._currentValue = prev.parentValue;
    prev = prev.parent;
    var parentNext = next.parent;
    if (prev === null) {
      if (parentNext !== null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
    } else {
      if (parentNext === null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
      popToNearestCommonAncestor(prev, parentNext);
    }
    next.context._currentValue = next.value;
  }
}
function popAllPrevious(prev) {
  prev.context._currentValue = prev.parentValue;
  prev = prev.parent;
  prev !== null && popAllPrevious(prev);
}
function pushAllNext(next) {
  var parentNext = next.parent;
  parentNext !== null && pushAllNext(parentNext);
  next.context._currentValue = next.value;
}
function popPreviousToCommonLevel(prev, next) {
  prev.context._currentValue = prev.parentValue;
  prev = prev.parent;
  if (prev === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
}
function popNextToCommonLevel(prev, next) {
  var parentNext = next.parent;
  if (parentNext === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
  next.context._currentValue = next.value;
}
function switchContext(newSnapshot) {
  var prev = currentActiveSnapshot;
  prev !== newSnapshot && (prev === null ? pushAllNext(newSnapshot) : newSnapshot === null ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
}
function warnOnInvalidCallback(callback) {
  if (callback !== null && typeof callback !== "function") {
    var key = String(callback);
    didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
  }
}
function warnNoop(publicInstance, callerName) {
  publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
  var warningKey = publicInstance + "." + callerName;
  didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(`Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, publicInstance), didWarnAboutNoopUpdateForComponent[warningKey] = true);
}
function pushTreeContext(baseContext, totalChildren, index) {
  var baseIdWithLeadingBit = baseContext.id;
  baseContext = baseContext.overflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - baseLength % 5;
    length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    return {
      id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
      overflow: length + baseContext
    };
  }
  return {
    id: 1 << length | index << baseLength | baseIdWithLeadingBit,
    overflow: baseContext
  };
}
function clz32Fallback(x2) {
  x2 >>>= 0;
  return x2 === 0 ? 32 : 31 - (log2(x2) / LN2 | 0) | 0;
}
function noop$2() {}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  index === undefined ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      typeof thenable.status === "string" ? thenable.then(noop$2, noop$2) : (thenableState = thenable, thenableState.status = "pending", thenableState.then(function(fulfilledValue) {
        if (thenable.status === "pending") {
          var fulfilledThenable = thenable;
          fulfilledThenable.status = "fulfilled";
          fulfilledThenable.value = fulfilledValue;
        }
      }, function(error2) {
        if (thenable.status === "pending") {
          var rejectedThenable = thenable;
          rejectedThenable.status = "rejected";
          rejectedThenable.reason = error2;
        }
      }));
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
function getSuspendedThenable() {
  if (suspendedThenable === null)
    throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function is4(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
function resolveCurrentlyRenderingComponent() {
  if (currentlyRenderingComponent === null)
    throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
  isInHookUserCodeInDev && console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
  return currentlyRenderingComponent;
}
function createHook() {
  if (0 < numberOfReRenders)
    throw Error("Rendered more hooks than during the previous render");
  return { memoizedState: null, queue: null, next: null };
}
function createWorkInProgressHook() {
  workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
  return workInProgressHook;
}
function getThenableStateAfterSuspending() {
  var state = thenableState;
  thenableState = null;
  return state;
}
function resetHooksState() {
  isInHookUserCodeInDev = false;
  currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
  didScheduleRenderPhaseUpdate = false;
  firstWorkInProgressHook = null;
  numberOfReRenders = 0;
  workInProgressHook = renderPhaseUpdates = null;
}
function readContext(context) {
  isInHookUserCodeInDev && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
  return context._currentValue;
}
function basicStateReducer(state, action) {
  return typeof action === "function" ? action(state) : action;
}
function useReducer(reducer, initialArg, init2) {
  reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  if (isReRender) {
    init2 = workInProgressHook.queue;
    initialArg = init2.dispatch;
    if (renderPhaseUpdates !== null) {
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(init2);
      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(init2);
        init2 = workInProgressHook.memoizedState;
        do {
          var action = firstRenderPhaseUpdate.action;
          isInHookUserCodeInDev = true;
          init2 = reducer(init2, action);
          isInHookUserCodeInDev = false;
          firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
        } while (firstRenderPhaseUpdate !== null);
        workInProgressHook.memoizedState = init2;
        return [init2, initialArg];
      }
    }
    return [workInProgressHook.memoizedState, initialArg];
  }
  isInHookUserCodeInDev = true;
  reducer = reducer === basicStateReducer ? typeof initialArg === "function" ? initialArg() : initialArg : init2 !== undefined ? init2(initialArg) : initialArg;
  isInHookUserCodeInDev = false;
  workInProgressHook.memoizedState = reducer;
  reducer = workInProgressHook.queue = { last: null, dispatch: null };
  reducer = reducer.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, reducer);
  return [workInProgressHook.memoizedState, reducer];
}
function useMemo(nextCreate, deps) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  deps = deps === undefined ? null : deps;
  if (workInProgressHook !== null) {
    var prevState = workInProgressHook.memoizedState;
    if (prevState !== null && deps !== null) {
      a: {
        var JSCompiler_inline_result = prevState[1];
        if (JSCompiler_inline_result === null)
          console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), JSCompiler_inline_result = false;
        else {
          deps.length !== JSCompiler_inline_result.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + deps.join(", ") + "]", "[" + JSCompiler_inline_result.join(", ") + "]");
          for (var i = 0;i < JSCompiler_inline_result.length && i < deps.length; i++)
            if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
              JSCompiler_inline_result = false;
              break a;
            }
          JSCompiler_inline_result = true;
        }
      }
      if (JSCompiler_inline_result)
        return prevState[0];
    }
  }
  isInHookUserCodeInDev = true;
  nextCreate = nextCreate();
  isInHookUserCodeInDev = false;
  workInProgressHook.memoizedState = [nextCreate, deps];
  return nextCreate;
}
function dispatchAction(componentIdentity, queue, action) {
  if (25 <= numberOfReRenders)
    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
  if (componentIdentity === currentlyRenderingComponent)
    if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, renderPhaseUpdates === null && (renderPhaseUpdates = new Map), action = renderPhaseUpdates.get(queue), action === undefined)
      renderPhaseUpdates.set(queue, componentIdentity);
    else {
      for (queue = action;queue.next !== null; )
        queue = queue.next;
      queue.next = componentIdentity;
    }
}
function unsupportedStartTransition() {
  throw Error("startTransition cannot be called during server rendering.");
}
function unsupportedSetOptimisticState() {
  throw Error("Cannot update optimistic state while rendering.");
}
function useActionState(action, initialState, permalink) {
  resolveCurrentlyRenderingComponent();
  var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
  if (typeof action.$$FORM_ACTION === "function") {
    var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
    request = request.formState;
    var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
    if (request !== null && typeof isSignatureEqual === "function") {
      var postbackKey = request[1];
      isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + Bun.hash(JSON.stringify([componentKeyPath, null, actionStateHookIndex])), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
    }
    var boundAction = action.bind(null, initialState);
    action = function(payload) {
      boundAction(payload);
    };
    typeof boundAction.$$FORM_ACTION === "function" && (action.$$FORM_ACTION = function(prefix) {
      prefix = boundAction.$$FORM_ACTION(prefix);
      permalink !== undefined && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix.action = permalink);
      var formData = prefix.data;
      formData && (nextPostbackStateKey === null && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + Bun.hash(JSON.stringify([
        componentKeyPath,
        null,
        actionStateHookIndex
      ]))), formData.append("$ACTION_KEY", nextPostbackStateKey));
      return prefix;
    });
    return [initialState, action, false];
  }
  var _boundAction = action.bind(null, initialState);
  return [
    initialState,
    function(payload) {
      _boundAction(payload);
    },
    false
  ];
}
function unwrapThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  thenableState === null && (thenableState = []);
  return trackUsedThenable(thenableState, thenable, index);
}
function unsupportedRefresh() {
  throw Error("Cache cannot be refreshed during server rendering.");
}
function noop$1() {}
function disabledLog() {}
function disableLogs() {
  if (disabledDepth === 0) {
    prevLog = console.log;
    prevInfo = console.info;
    prevWarn = console.warn;
    prevError = console.error;
    prevGroup = console.group;
    prevGroupCollapsed = console.groupCollapsed;
    prevGroupEnd = console.groupEnd;
    var props = {
      configurable: true,
      enumerable: true,
      value: disabledLog,
      writable: true
    };
    Object.defineProperties(console, {
      info: props,
      log: props,
      warn: props,
      error: props,
      group: props,
      groupCollapsed: props,
      groupEnd: props
    });
  }
  disabledDepth++;
}
function reenableLogs() {
  disabledDepth--;
  if (disabledDepth === 0) {
    var props = { configurable: true, enumerable: true, writable: true };
    Object.defineProperties(console, {
      log: assign({}, props, { value: prevLog }),
      info: assign({}, props, { value: prevInfo }),
      warn: assign({}, props, { value: prevWarn }),
      error: assign({}, props, { value: prevError }),
      group: assign({}, props, { value: prevGroup }),
      groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
      groupEnd: assign({}, props, { value: prevGroupEnd })
    });
  }
  0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
}
function describeBuiltInComponentFrame(name2) {
  if (prefix === undefined)
    try {
      throw Error();
    } catch (x2) {
      var match = x2.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x2.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
  return `
` + prefix + name2 + suffix;
}
function describeNativeComponentFrame(fn3, construct2) {
  if (!fn3 || reentry)
    return "";
  var frame = componentFrameCache.get(fn3);
  if (frame !== undefined)
    return frame;
  reentry = true;
  frame = Error.prepareStackTrace;
  Error.prepareStackTrace = undefined;
  var previousDispatcher2 = null;
  previousDispatcher2 = ReactSharedInternals.H;
  ReactSharedInternals.H = null;
  disableLogs();
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function() {
        try {
          if (construct2) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                var control = x2;
              }
              Reflect.construct(fn3, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$0) {
                control = x$0;
              }
              fn3.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$1) {
              control = x$1;
            }
            (Fake = fn3()) && typeof Fake.catch === "function" && Fake.catch(function() {});
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string")
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
    namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
      for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
        namePropDescriptor++;
      for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
        _RunInRootFrame$Deter++;
      if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
        for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
          _RunInRootFrame$Deter--;
      for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
        if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
          if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
            do
              if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                fn3.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn3.displayName));
                typeof fn3 === "function" && componentFrameCache.set(fn3, _frame);
                return _frame;
              }
            while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
          }
          break;
        }
    }
  } finally {
    reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
  }
  sampleLines = (sampleLines = fn3 ? fn3.displayName || fn3.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
  typeof fn3 === "function" && componentFrameCache.set(fn3, sampleLines);
  return sampleLines;
}
function formatOwnerStack(error2) {
  var prevPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = undefined;
  error2 = error2.stack;
  Error.prepareStackTrace = prevPrepareStackTrace;
  error2.startsWith(`Error: react-stack-top-frame
`) && (error2 = error2.slice(29));
  prevPrepareStackTrace = error2.indexOf(`
`);
  prevPrepareStackTrace !== -1 && (error2 = error2.slice(prevPrepareStackTrace + 1));
  prevPrepareStackTrace = error2.indexOf("react-stack-bottom-frame");
  prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error2.lastIndexOf(`
`, prevPrepareStackTrace));
  if (prevPrepareStackTrace !== -1)
    error2 = error2.slice(0, prevPrepareStackTrace);
  else
    return "";
  return error2;
}
function describeComponentStackByType(type) {
  if (typeof type === "string")
    return describeBuiltInComponentFrame(type);
  if (typeof type === "function")
    return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
  if (typeof type === "object" && type !== null) {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeNativeComponentFrame(type.render, false);
      case REACT_MEMO_TYPE:
        return describeNativeComponentFrame(type.type, false);
      case REACT_LAZY_TYPE:
        var lazyComponent = type, payload = lazyComponent._payload;
        lazyComponent = lazyComponent._init;
        try {
          type = lazyComponent(payload);
        } catch (x2) {
          return describeBuiltInComponentFrame("Lazy");
        }
        return describeComponentStackByType(type);
    }
    if (typeof type.name === "string")
      return payload = type.env, describeBuiltInComponentFrame(type.name + (payload ? " [" + payload + "]" : ""));
  }
  switch (type) {
    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame("SuspenseList");
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame("Suspense");
  }
  return "";
}
function defaultErrorHandler(error2) {
  if (typeof error2 === "object" && error2 !== null && typeof error2.environmentName === "string") {
    var JSCompiler_inline_result = error2.environmentName;
    error2 = [error2].slice(0);
    typeof error2[0] === "string" ? error2.splice(0, 1, "%c%s%c " + error2[0], "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "") : error2.splice(0, 0, "%c%s%c ", "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "");
    error2.unshift(console);
    JSCompiler_inline_result = bind2.apply(console.error, error2);
    JSCompiler_inline_result();
  } else
    console.error(error2);
  return null;
}
function noop4() {}
function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
  var abortSet = new Set;
  this.destination = null;
  this.flushScheduled = false;
  this.resumableState = resumableState;
  this.renderState = renderState;
  this.rootFormatContext = rootFormatContext;
  this.progressiveChunkSize = progressiveChunkSize === undefined ? 12800 : progressiveChunkSize;
  this.status = 10;
  this.fatalError = null;
  this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
  this.completedPreambleSegments = this.completedRootSegment = null;
  this.abortableTasks = abortSet;
  this.pingedTasks = [];
  this.clientRenderedBoundaries = [];
  this.completedBoundaries = [];
  this.partialBoundaries = [];
  this.trackedPostpones = null;
  this.onError = onError === undefined ? defaultErrorHandler : onError;
  this.onPostpone = onPostpone === undefined ? noop4 : onPostpone;
  this.onAllReady = onAllReady === undefined ? noop4 : onAllReady;
  this.onShellReady = onShellReady === undefined ? noop4 : onShellReady;
  this.onShellError = onShellError === undefined ? noop4 : onShellError;
  this.onFatalError = onFatalError === undefined ? noop4 : onFatalError;
  this.formState = formState === undefined ? null : formState;
  this.didWarnForKey = null;
}
function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
  var now = getCurrentTime();
  1000 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
  resumableState = new RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
  renderState = createPendingSegment(resumableState, 0, null, rootFormatContext, false, false);
  renderState.parentFlushed = true;
  children = createRenderTask(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext, null, false, emptyContextObject, null);
  pushComponentStack(children);
  resumableState.pingedTasks.push(children);
  return resumableState;
}
function pingTask(request, task) {
  request.pingedTasks.push(task);
  request.pingedTasks.length === 1 && (request.flushScheduled = request.destination !== null, request.trackedPostpones !== null || request.status === 10 ? scheduleMicrotask(function() {
    return performWork(request);
  }) : setTimeout(function() {
    return performWork(request);
  }, 0));
}
function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
  return {
    status: PENDING,
    rootSegmentID: -1,
    parentFlushed: false,
    pendingTasks: 0,
    completedSegments: [],
    byteSize: 0,
    fallbackAbortableTasks,
    errorDigest: null,
    contentState: createHoistableState(),
    fallbackState: createHoistableState(),
    contentPreamble,
    fallbackPreamble,
    trackedContentKeyPath: null,
    trackedFallbackNode: null,
    errorMessage: null,
    errorStack: null,
    errorComponentStack: null
  };
}
function createRenderTask(request, thenableState2, node2, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
  request.allPendingTasks++;
  blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
  var task = {
    replay: null,
    node: node2,
    childIndex,
    ping: function() {
      return pingTask(request, task);
    },
    blockedBoundary,
    blockedSegment,
    blockedPreamble,
    hoistableState,
    abortSet,
    keyPath,
    formatContext,
    context,
    treeContext,
    componentStack,
    thenableState: thenableState2,
    isFallback
  };
  task.debugTask = debugTask;
  abortSet.add(task);
  return task;
}
function createReplayTask(request, thenableState2, replay, node2, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
  request.allPendingTasks++;
  blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
  replay.pendingTasks++;
  var task = {
    replay,
    node: node2,
    childIndex,
    ping: function() {
      return pingTask(request, task);
    },
    blockedBoundary,
    blockedSegment: null,
    blockedPreamble: null,
    hoistableState,
    abortSet,
    keyPath,
    formatContext,
    context,
    treeContext,
    componentStack,
    thenableState: thenableState2,
    isFallback
  };
  task.debugTask = debugTask;
  abortSet.add(task);
  return task;
}
function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
  return {
    status: PENDING,
    parentFlushed: false,
    id: -1,
    index,
    chunks: [],
    children: [],
    preambleChildren: [],
    parentFormatContext,
    boundary,
    lastPushedText,
    textEmbedded
  };
}
function getCurrentStackInDEV() {
  if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null)
    return "";
  var componentStack = currentTaskInDEV.componentStack;
  try {
    var info = "";
    if (typeof componentStack.type === "string")
      info += describeBuiltInComponentFrame(componentStack.type);
    else if (typeof componentStack.type === "function") {
      if (!componentStack.owner) {
        var JSCompiler_temp_const = info, fn3 = componentStack.type, name2 = fn3 ? fn3.displayName || fn3.name : "";
        var JSCompiler_inline_result = name2 ? describeBuiltInComponentFrame(name2) : "";
        info = JSCompiler_temp_const + JSCompiler_inline_result;
      }
    } else
      componentStack.owner || (info += describeComponentStackByType(componentStack.type));
    for (;componentStack; )
      JSCompiler_temp_const = null, componentStack.debugStack != null ? JSCompiler_temp_const = formatOwnerStack(componentStack.debugStack) : (JSCompiler_inline_result = componentStack, JSCompiler_inline_result.stack != null && (JSCompiler_temp_const = typeof JSCompiler_inline_result.stack !== "string" ? JSCompiler_inline_result.stack = formatOwnerStack(JSCompiler_inline_result.stack) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += `
` + JSCompiler_temp_const);
    var JSCompiler_inline_result$jscomp$0 = info;
  } catch (x2) {
    JSCompiler_inline_result$jscomp$0 = `
Error generating stack: ` + x2.message + `
` + x2.stack;
  }
  return JSCompiler_inline_result$jscomp$0;
}
function pushServerComponentStack(task, debugInfo) {
  if (debugInfo != null)
    for (var i = 0;i < debugInfo.length; i++) {
      var componentInfo = debugInfo[i];
      typeof componentInfo.name === "string" && componentInfo.debugStack !== undefined && (task.componentStack = {
        parent: task.componentStack,
        type: componentInfo,
        owner: componentInfo.owner,
        stack: componentInfo.debugStack
      }, task.debugTask = componentInfo.debugTask);
    }
}
function pushComponentStack(task) {
  var node2 = task.node;
  if (typeof node2 === "object" && node2 !== null)
    switch (node2.$$typeof) {
      case REACT_ELEMENT_TYPE:
        var { type, _owner: owner, _debugStack: stack } = node2;
        pushServerComponentStack(task, node2._debugInfo);
        task.debugTask = node2._debugTask;
        task.componentStack = {
          parent: task.componentStack,
          type,
          owner,
          stack
        };
        break;
      case REACT_LAZY_TYPE:
        pushServerComponentStack(task, node2._debugInfo);
        break;
      default:
        typeof node2.then === "function" && pushServerComponentStack(task, node2._debugInfo);
    }
}
function getThrownInfo(node$jscomp$0) {
  var errorInfo = {};
  node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
    configurable: true,
    enumerable: true,
    get: function() {
      try {
        var info = "", node2 = node$jscomp$0;
        do
          info += describeComponentStackByType(node2.type), node2 = node2.parent;
        while (node2);
        var stack = info;
      } catch (x2) {
        stack = `
Error generating stack: ` + x2.message + `
` + x2.stack;
      }
      Object.defineProperty(errorInfo, "componentStack", { value: stack });
      return stack;
    }
  });
  return errorInfo;
}
function encodeErrorForBoundary(boundary, digest, error2, thrownInfo, wasAborted) {
  boundary.errorDigest = digest;
  error2 instanceof Error ? (digest = String(error2.message), error2 = String(error2.stack)) : (digest = typeof error2 === "object" && error2 !== null ? describeObjectForErrorMessage(error2) : String(error2), error2 = null);
  wasAborted = wasAborted ? `Switched to client rendering because the server rendering aborted due to:

` : `Switched to client rendering because the server rendering errored:

`;
  boundary.errorMessage = wasAborted + digest;
  boundary.errorStack = error2 !== null ? wasAborted + error2 : null;
  boundary.errorComponentStack = thrownInfo.componentStack;
}
function logRecoverableError(request, error2, errorInfo, debugTask) {
  request = request.onError;
  error2 = debugTask ? debugTask.run(request.bind(null, error2, errorInfo)) : request(error2, errorInfo);
  if (error2 != null && typeof error2 !== "string")
    console.error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead', typeof error2);
  else
    return error2;
}
function fatalError(request, error2, errorInfo, debugTask) {
  errorInfo = request.onShellError;
  var onFatalError = request.onFatalError;
  debugTask ? (debugTask.run(errorInfo.bind(null, error2)), debugTask.run(onFatalError.bind(null, error2))) : (errorInfo(error2), onFatalError(error2));
  request.destination !== null ? (request.status = CLOSED, closeWithError(request.destination, error2)) : (request.status = 13, request.fatalError = error2);
}
function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
  var prevThenableState = task.thenableState;
  task.thenableState = null;
  currentlyRenderingComponent = {};
  currentlyRenderingTask = task;
  currentlyRenderingRequest = request;
  currentlyRenderingKeyPath = keyPath;
  isInHookUserCodeInDev = false;
  actionStateCounter = localIdCounter = 0;
  actionStateMatchingIndex = -1;
  thenableIndexCounter = 0;
  thenableState = prevThenableState;
  for (request = callComponentInDEV(Component, props, secondArg);didScheduleRenderPhaseUpdate; )
    didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
  resetHooksState();
  return request;
}
function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
  var didEmitActionStateMarkers = false;
  if (actionStateCount !== 0 && request.formState !== null) {
    var segment = task.blockedSegment;
    if (segment !== null) {
      didEmitActionStateMarkers = true;
      segment = segment.chunks;
      for (var i = 0;i < actionStateCount; i++)
        i === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
    }
  }
  actionStateCount = task.keyPath;
  task.keyPath = keyPath;
  hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode2(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
  task.keyPath = actionStateCount;
}
function renderElement(request, task, keyPath, type, props, ref) {
  if (typeof type === "function")
    if (type.prototype && type.prototype.isReactComponent) {
      var newProps = props;
      if ("ref" in props) {
        newProps = {};
        for (var propName in props)
          propName !== "ref" && (newProps[propName] = props[propName]);
      }
      var defaultProps = type.defaultProps;
      if (defaultProps) {
        newProps === props && (newProps = assign({}, newProps, props));
        for (var _propName in defaultProps)
          newProps[_propName] === undefined && (newProps[_propName] = defaultProps[_propName]);
      }
      var resolvedProps = newProps;
      var context = emptyContextObject, contextType = type.contextType;
      if ("contextType" in type && contextType !== null && (contextType === undefined || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type)) {
        didWarnAboutInvalidateContextType.add(type);
        var addendum = contextType === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType !== "object" ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
        console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(type) || "Component", addendum);
      }
      typeof contextType === "object" && contextType !== null && (context = contextType._currentValue);
      var instance = new type(resolvedProps, context);
      if (typeof type.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
        var componentName = getComponentNameFromType(type) || "Component";
        didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
      }
      if (typeof type.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
        var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
        typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount === "function" && (foundWillMountName = "UNSAFE_componentWillMount");
        typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps === "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
        typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
        if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
          var _componentName = getComponentNameFromType(type) || "Component", newApiName = typeof type.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
          didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
        }
      }
      var name2 = getComponentNameFromType(type) || "Component";
      instance.render || (type.prototype && typeof type.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", name2) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", name2));
      !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
      instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
      instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
      type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", name2));
      type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", name2));
      typeof instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
      type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(type) || "A pure component");
      typeof instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
      typeof instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
      typeof instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
      typeof instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
      var hasMutatedProps = instance.props !== resolvedProps;
      instance.props !== undefined && hasMutatedProps && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2);
      instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
      typeof instance.getSnapshotBeforeUpdate !== "function" || typeof instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(type)));
      typeof instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
      typeof instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
      typeof type.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
      var state = instance.state;
      state && (typeof state !== "object" || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name2);
      typeof instance.getChildContext === "function" && typeof type.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
      var initialState = instance.state !== undefined ? instance.state : null;
      instance.updater = classComponentUpdater;
      instance.props = resolvedProps;
      instance.state = initialState;
      var internalInstance = { queue: [], replace: false };
      instance._reactInternals = internalInstance;
      var contextType$jscomp$0 = type.contextType;
      instance.context = typeof contextType$jscomp$0 === "object" && contextType$jscomp$0 !== null ? contextType$jscomp$0._currentValue : emptyContextObject;
      if (instance.state === resolvedProps) {
        var componentName$jscomp$0 = getComponentNameFromType(type) || "Component";
        didWarnAboutDirectlyAssigningPropsToState.has(componentName$jscomp$0) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName$jscomp$0), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName$jscomp$0));
      }
      var getDerivedStateFromProps = type.getDerivedStateFromProps;
      if (typeof getDerivedStateFromProps === "function") {
        var partialState = getDerivedStateFromProps(resolvedProps, initialState);
        if (partialState === undefined) {
          var componentName$jscomp$1 = getComponentNameFromType(type) || "Component";
          didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName$jscomp$1));
        }
        var JSCompiler_inline_result = partialState === null || partialState === undefined ? initialState : assign({}, initialState, partialState);
        instance.state = JSCompiler_inline_result;
      }
      if (typeof type.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
            var componentName$jscomp$2 = getComponentNameFromType(type) || "Unknown";
            didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`, componentName$jscomp$2), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
          }
          instance.componentWillMount();
        }
        typeof instance.UNSAFE_componentWillMount === "function" && instance.UNSAFE_componentWillMount();
        oldState !== instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
        if (internalInstance.queue !== null && 0 < internalInstance.queue.length) {
          var { queue: oldQueue, replace: oldReplace } = internalInstance;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1)
            instance.state = oldQueue[0];
          else {
            for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial = oldQueue[i], partialState$jscomp$0 = typeof partial === "function" ? partial.call(instance, nextState, resolvedProps, undefined) : partial;
              partialState$jscomp$0 != null && (dontMutate ? (dontMutate = false, nextState = assign({}, nextState, partialState$jscomp$0)) : assign(nextState, partialState$jscomp$0));
            }
            instance.state = nextState;
          }
        } else
          internalInstance.queue = null;
      }
      var nextChildren = callRenderInDEV(instance);
      if (request.status === 12)
        throw null;
      instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(type) || "a component"), didWarnAboutReassigningProps = true);
      var prevKeyPath = task.keyPath;
      task.keyPath = keyPath;
      renderNodeDestructive(request, task, nextChildren, -1);
      task.keyPath = prevKeyPath;
    } else {
      if (type.prototype && typeof type.prototype.render === "function") {
        var componentName$jscomp$3 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutBadClass[componentName$jscomp$3] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName$jscomp$3, componentName$jscomp$3), didWarnAboutBadClass[componentName$jscomp$3] = true);
      }
      var value = renderWithHooks(request, task, keyPath, type, props, undefined);
      if (request.status === 12)
        throw null;
      var hasId = localIdCounter !== 0, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
      if (type.contextTypes) {
        var _componentName$jscomp$0 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", _componentName$jscomp$0));
      }
      type && type.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, type.displayName || type.name || "Component");
      if (typeof type.getDerivedStateFromProps === "function") {
        var _componentName2 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error("%s: Function components do not support getDerivedStateFromProps.", _componentName2), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
      }
      if (typeof type.contextType === "object" && type.contextType !== null) {
        var _componentName3 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error("%s: Function components do not support contextType.", _componentName3), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
      }
      finishFunctionComponent(request, task, keyPath, value, hasId, actionStateCount, actionStateMatchingIndex$jscomp$0);
    }
  else if (typeof type === "string") {
    var segment = task.blockedSegment;
    if (segment === null) {
      var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
      task.formatContext = getChildFormatContext(prevContext, type, props);
      task.keyPath = keyPath;
      renderNode2(request, task, children, -1);
      task.formatContext = prevContext;
      task.keyPath = prevKeyPath$jscomp$0;
    } else {
      var _children = pushStartInstance(segment.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, segment.lastPushedText, task.isFallback);
      segment.lastPushedText = false;
      var { formatContext: _prevContext, keyPath: _prevKeyPath2 } = task;
      task.keyPath = keyPath;
      if ((task.formatContext = getChildFormatContext(_prevContext, type, props)).insertionMode === HTML_HEAD_MODE) {
        var preambleSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);
        segment.preambleChildren.push(preambleSegment);
        var preambleTask = createRenderTask(request, null, _children, -1, task.blockedBoundary, preambleSegment, task.blockedPreamble, task.hoistableState, request.abortableTasks, task.keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject, task.debugTask);
        pushComponentStack(preambleTask);
        request.pingedTasks.push(preambleTask);
      } else
        renderNode2(request, task, _children, -1);
      task.formatContext = _prevContext;
      task.keyPath = _prevKeyPath2;
      a: {
        var target = segment.chunks, resumableState = request.resumableState;
        switch (type) {
          case "title":
          case "style":
          case "script":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break a;
          case "body":
            if (_prevContext.insertionMode <= HTML_HTML_MODE) {
              resumableState.hasBody = true;
              break a;
            }
            break;
          case "html":
            if (_prevContext.insertionMode === ROOT_HTML_MODE) {
              resumableState.hasHtml = true;
              break a;
            }
            break;
          case "head":
            if (_prevContext.insertionMode <= HTML_HTML_MODE)
              break a;
        }
        target.push(endChunkForTag(type));
      }
      segment.lastPushedText = false;
    }
  } else {
    switch (type) {
      case REACT_LEGACY_HIDDEN_TYPE:
      case REACT_STRICT_MODE_TYPE:
      case REACT_PROFILER_TYPE:
      case REACT_FRAGMENT_TYPE:
        var prevKeyPath$jscomp$1 = task.keyPath;
        task.keyPath = keyPath;
        renderNodeDestructive(request, task, props.children, -1);
        task.keyPath = prevKeyPath$jscomp$1;
        return;
      case REACT_ACTIVITY_TYPE:
        if (props.mode !== "hidden") {
          var prevKeyPath$jscomp$2 = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, props.children, -1);
          task.keyPath = prevKeyPath$jscomp$2;
        }
        return;
      case REACT_SUSPENSE_LIST_TYPE:
        var _prevKeyPath3 = task.keyPath;
        task.keyPath = keyPath;
        renderNodeDestructive(request, task, props.children, -1);
        task.keyPath = _prevKeyPath3;
        return;
      case REACT_VIEW_TRANSITION_TYPE:
      case REACT_SCOPE_TYPE:
        throw Error("ReactDOMServer does not yet support scope components.");
      case REACT_SUSPENSE_TYPE:
        a:
          if (task.replay !== null) {
            var _prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            var _content = props.children;
            try {
              renderNode2(request, task, _content, -1);
            } finally {
              task.keyPath = _prevKeyPath;
            }
          } else {
            var { keyPath: prevKeyPath$jscomp$3, blockedBoundary: parentBoundary, blockedPreamble: parentPreamble, hoistableState: parentHoistableState, blockedSegment: parentSegment } = task, fallback = props.fallback, content = props.children, fallbackAbortSet = new Set;
            var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(request, fallbackAbortSet, createPreambleState(), createPreambleState()) : createSuspenseBoundary(request, fallbackAbortSet, null, null);
            request.trackedPostpones !== null && (newBoundary.trackedContentKeyPath = keyPath);
            var boundarySegment = createPendingSegment(request, parentSegment.chunks.length, newBoundary, task.formatContext, false, false);
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);
            contentRootSegment.parentFlushed = true;
            if (request.trackedPostpones !== null) {
              var fallbackKeyPath = [keyPath[0], "Suspense Fallback", keyPath[2]], fallbackReplayNode = [
                fallbackKeyPath[1],
                fallbackKeyPath[2],
                [],
                null
              ];
              request.trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);
              newBoundary.trackedFallbackNode = fallbackReplayNode;
              task.blockedSegment = boundarySegment;
              task.blockedPreamble = newBoundary.fallbackPreamble;
              task.keyPath = fallbackKeyPath;
              boundarySegment.status = 6;
              try {
                renderNode2(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push("<!-- -->"), boundarySegment.status = COMPLETED;
              } catch (thrownValue) {
                throw boundarySegment.status = request.status === 12 ? 3 : 4, thrownValue;
              } finally {
                task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
              }
              var suspendedPrimaryTask = createRenderTask(request, null, content, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject, task.debugTask);
              pushComponentStack(suspendedPrimaryTask);
              request.pingedTasks.push(suspendedPrimaryTask);
            } else {
              task.blockedBoundary = newBoundary;
              task.blockedPreamble = newBoundary.contentPreamble;
              task.hoistableState = newBoundary.contentState;
              task.blockedSegment = contentRootSegment;
              task.keyPath = keyPath;
              contentRootSegment.status = 6;
              try {
                if (renderNode2(request, task, content, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push("<!-- -->"), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0 && newBoundary.status === PENDING) {
                  newBoundary.status = COMPLETED;
                  request.pendingRootTasks === 0 && task.blockedPreamble && preparePreamble(request);
                  break a;
                }
              } catch (thrownValue$2) {
                newBoundary.status = CLIENT_RENDERED;
                if (request.status === 12) {
                  contentRootSegment.status = 3;
                  var error2 = request.fatalError;
                } else
                  contentRootSegment.status = 4, error2 = thrownValue$2;
                var thrownInfo = getThrownInfo(task.componentStack);
                var errorDigest = logRecoverableError(request, error2, thrownInfo, task.debugTask);
                encodeErrorForBoundary(newBoundary, errorDigest, error2, thrownInfo, false);
                untrackBoundary(request, newBoundary);
              } finally {
                task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
              }
              var suspendedFallbackTask = createRenderTask(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], task.formatContext, task.context, task.treeContext, task.componentStack, true, emptyContextObject, task.debugTask);
              pushComponentStack(suspendedFallbackTask);
              request.pingedTasks.push(suspendedFallbackTask);
            }
          }
        return;
    }
    if (typeof type === "object" && type !== null)
      switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          if ("ref" in props) {
            var propsWithoutRef = {};
            for (var key in props)
              key !== "ref" && (propsWithoutRef[key] = props[key]);
          } else
            propsWithoutRef = props;
          var children$jscomp$0 = renderWithHooks(request, task, keyPath, type.render, propsWithoutRef, ref);
          finishFunctionComponent(request, task, keyPath, children$jscomp$0, localIdCounter !== 0, actionStateCounter, actionStateMatchingIndex);
          return;
        case REACT_MEMO_TYPE:
          renderElement(request, task, keyPath, type.type, props, ref);
          return;
        case REACT_PROVIDER_TYPE:
        case REACT_CONTEXT_TYPE:
          var { value: value$jscomp$0, children: children$jscomp$1 } = props;
          var prevSnapshot = task.context;
          var prevKeyPath$jscomp$4 = task.keyPath;
          var prevValue = type._currentValue;
          type._currentValue = value$jscomp$0;
          type._currentRenderer !== undefined && type._currentRenderer !== null && type._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
          type._currentRenderer = rendererSigil;
          var prevNode = currentActiveSnapshot, newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: type,
            parentValue: prevValue,
            value: value$jscomp$0
          };
          currentActiveSnapshot = newNode;
          task.context = newNode;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, children$jscomp$1, -1);
          var prevSnapshot$jscomp$0 = currentActiveSnapshot;
          if (prevSnapshot$jscomp$0 === null)
            throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          prevSnapshot$jscomp$0.context !== type && console.error("The parent context is not the expected context. This is probably a bug in React.");
          prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
          type._currentRenderer !== undefined && type._currentRenderer !== null && type._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
          type._currentRenderer = rendererSigil;
          var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
          task.context = JSCompiler_inline_result$jscomp$0;
          task.keyPath = prevKeyPath$jscomp$4;
          prevSnapshot !== task.context && console.error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          return;
        case REACT_CONSUMER_TYPE:
          var context$jscomp$0 = type._context, render2 = props.children;
          typeof render2 !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          var newChildren = render2(context$jscomp$0._currentValue), prevKeyPath$jscomp$5 = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, newChildren, -1);
          task.keyPath = prevKeyPath$jscomp$5;
          return;
        case REACT_LAZY_TYPE:
          var Component = callLazyInitInDEV(type);
          if (request.status === 12)
            throw null;
          renderElement(request, task, keyPath, Component, props, ref);
          return;
      }
    var info = "";
    if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
    throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((type == null ? type : typeof type) + "." + info));
  }
}
function resumeNode(request, task, segmentId, node2, childIndex) {
  var { replay: prevReplay, blockedBoundary } = task, resumedSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);
  resumedSegment.id = segmentId;
  resumedSegment.parentFlushed = true;
  try {
    task.replay = null, task.blockedSegment = resumedSegment, renderNode2(request, task, node2, childIndex), resumedSegment.status = COMPLETED, blockedBoundary === null ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
  } finally {
    task.replay = prevReplay, task.blockedSegment = null;
  }
}
function replayElement(request, task, keyPath, name2, keyOrIndex, childIndex, type, props, ref, replay) {
  childIndex = replay.nodes;
  for (var i = 0;i < childIndex.length; i++) {
    var node2 = childIndex[i];
    if (keyOrIndex === node2[1]) {
      if (node2.length === 4) {
        if (name2 !== null && name2 !== node2[0])
          throw Error("Expected the resume to render <" + node2[0] + "> in this slot but instead it rendered <" + name2 + ">. The tree doesn't match so React will fallback to client rendering.");
        var childNodes = node2[2];
        node2 = node2[3];
        name2 = task.node;
        task.replay = { nodes: childNodes, slots: node2, pendingTasks: 1 };
        try {
          renderElement(request, task, keyPath, type, props, ref);
          if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
            throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
          task.replay.pendingTasks--;
        } catch (x2) {
          if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException || typeof x2.then === "function"))
            throw task.node === name2 && (task.replay = replay), x2;
          task.replay.pendingTasks--;
          type = getThrownInfo(task.componentStack);
          props = request;
          request = task.blockedBoundary;
          keyPath = x2;
          ref = node2;
          node2 = logRecoverableError(props, keyPath, type, task.debugTask);
          abortRemainingReplayNodes(props, request, childNodes, ref, keyPath, node2, type, false);
        }
        task.replay = replay;
      } else {
        if (type !== REACT_SUSPENSE_TYPE)
          throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
        a: {
          replay = undefined;
          type = node2[5];
          ref = node2[2];
          name2 = node2[3];
          keyOrIndex = node2[4] === null ? [] : node2[4][2];
          node2 = node2[4] === null ? null : node2[4][3];
          var { keyPath: prevKeyPath, replay: previousReplaySet, blockedBoundary: parentBoundary, hoistableState: parentHoistableState } = task, content = props.children, fallback = props.fallback, fallbackAbortSet = new Set;
          props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(request, fallbackAbortSet, createPreambleState(), createPreambleState()) : createSuspenseBoundary(request, fallbackAbortSet, null, null);
          props.parentFlushed = true;
          props.rootSegmentID = type;
          task.blockedBoundary = props;
          task.hoistableState = props.contentState;
          task.keyPath = keyPath;
          task.replay = { nodes: ref, slots: name2, pendingTasks: 1 };
          try {
            renderNode2(request, task, content, -1);
            if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
              throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
            task.replay.pendingTasks--;
            if (props.pendingTasks === 0 && props.status === PENDING) {
              props.status = COMPLETED;
              request.completedBoundaries.push(props);
              break a;
            }
          } catch (error2) {
            props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(request, error2, childNodes, task.debugTask), encodeErrorForBoundary(props, replay, error2, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
          } finally {
            task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
          }
          props = createReplayTask(request, null, { nodes: keyOrIndex, slots: node2, pendingTasks: 0 }, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], task.formatContext, task.context, task.treeContext, task.componentStack, true, emptyContextObject, task.debugTask);
          pushComponentStack(props);
          request.pingedTasks.push(props);
        }
      }
      childIndex.splice(i, 1);
      break;
    }
  }
}
function renderNodeDestructive(request, task, node2, childIndex) {
  task.replay !== null && typeof task.replay.slots === "number" ? resumeNode(request, task, task.replay.slots, node2, childIndex) : (task.node = node2, task.childIndex = childIndex, node2 = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node2, task.debugTask = childIndex);
}
function retryNode(request, task) {
  var { node: node2, childIndex } = task;
  if (node2 !== null) {
    if (typeof node2 === "object") {
      switch (node2.$$typeof) {
        case REACT_ELEMENT_TYPE:
          var { type, key } = node2;
          node2 = node2.props;
          var refProp = node2.ref;
          refProp = refProp !== undefined ? refProp : null;
          var debugTask = task.debugTask, name2 = getComponentNameFromType(type);
          key = key == null ? childIndex === -1 ? 0 : childIndex : key;
          var keyPath = [task.keyPath, name2, key];
          task.replay !== null ? debugTask ? debugTask.run(replayElement.bind(null, request, task, keyPath, name2, key, childIndex, type, node2, refProp, task.replay)) : replayElement(request, task, keyPath, name2, key, childIndex, type, node2, refProp, task.replay) : debugTask ? debugTask.run(renderElement.bind(null, request, task, keyPath, type, node2, refProp)) : renderElement(request, task, keyPath, type, node2, refProp);
          return;
        case REACT_PORTAL_TYPE:
          throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
        case REACT_LAZY_TYPE:
          node2 = callLazyInitInDEV(node2);
          if (request.status === 12)
            throw null;
          renderNodeDestructive(request, task, node2, childIndex);
          return;
      }
      if (isArrayImpl(node2)) {
        renderChildrenArray(request, task, node2, childIndex);
        return;
      }
      node2 === null || typeof node2 !== "object" ? key = null : (type = MAYBE_ITERATOR_SYMBOL && node2[MAYBE_ITERATOR_SYMBOL] || node2["@@iterator"], key = typeof type === "function" ? type : null);
      if (key && (type = key.call(node2))) {
        if (type === node2) {
          if (childIndex !== -1 || task.componentStack === null || typeof task.componentStack.type !== "function" || Object.prototype.toString.call(task.componentStack.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(type) !== "[object Generator]")
            didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = true;
        } else
          node2.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true);
        node2 = type.next();
        if (!node2.done) {
          key = [];
          do
            key.push(node2.value), node2 = type.next();
          while (!node2.done);
          renderChildrenArray(request, task, key, childIndex);
        }
        return;
      }
      if (typeof node2.then === "function")
        return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node2), childIndex);
      if (node2.$$typeof === REACT_CONTEXT_TYPE)
        return renderNodeDestructive(request, task, node2._currentValue, childIndex);
      request = Object.prototype.toString.call(node2);
      throw Error("Objects are not valid as a React child (found: " + (request === "[object Object]" ? "object with keys {" + Object.keys(node2).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead.");
    }
    typeof node2 === "string" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance(task.chunks, node2, request.renderState, task.lastPushedText))) : typeof node2 === "number" || typeof node2 === "bigint" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance(task.chunks, "" + node2, request.renderState, task.lastPushedText))) : (typeof node2 === "function" && (request = node2.displayName || node2.name || "Component", console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.", request, request)), typeof node2 === "symbol" && console.error(`Symbols are not valid as a React child.
  %s`, String(node2)));
  }
}
function renderChildrenArray(request, task, children, childIndex) {
  var { keyPath: prevKeyPath, componentStack: previousComponentStack } = task;
  var previousDebugTask = task.debugTask;
  pushServerComponentStack(task, task.node._debugInfo);
  if (childIndex !== -1 && (task.keyPath = [task.keyPath, "Fragment", childIndex], task.replay !== null)) {
    for (var replay = task.replay, replayNodes = replay.nodes, j2 = 0;j2 < replayNodes.length; j2++) {
      var node2 = replayNodes[j2];
      if (node2[1] === childIndex) {
        childIndex = node2[2];
        node2 = node2[3];
        task.replay = { nodes: childIndex, slots: node2, pendingTasks: 1 };
        try {
          renderChildrenArray(request, task, children, -1);
          if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
            throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
          task.replay.pendingTasks--;
        } catch (x2) {
          if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException || typeof x2.then === "function"))
            throw x2;
          task.replay.pendingTasks--;
          var thrownInfo = getThrownInfo(task.componentStack);
          children = task.blockedBoundary;
          var error2 = x2, resumeSlots = node2;
          node2 = logRecoverableError(request, error2, thrownInfo, task.debugTask);
          abortRemainingReplayNodes(request, children, childIndex, resumeSlots, error2, node2, thrownInfo, false);
        }
        task.replay = replay;
        replayNodes.splice(j2, 1);
        break;
      }
    }
    task.keyPath = prevKeyPath;
    task.componentStack = previousComponentStack;
    task.debugTask = previousDebugTask;
    return;
  }
  replay = task.treeContext;
  replayNodes = children.length;
  if (task.replay !== null && (j2 = task.replay.slots, j2 !== null && typeof j2 === "object")) {
    for (childIndex = 0;childIndex < replayNodes; childIndex++)
      node2 = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), error2 = j2[childIndex], typeof error2 === "number" ? (resumeNode(request, task, error2, node2, childIndex), delete j2[childIndex]) : renderNode2(request, task, node2, childIndex);
    task.treeContext = replay;
    task.keyPath = prevKeyPath;
    task.componentStack = previousComponentStack;
    task.debugTask = previousDebugTask;
    return;
  }
  for (j2 = 0;j2 < replayNodes; j2++) {
    childIndex = children[j2];
    resumeSlots = request;
    node2 = task;
    error2 = childIndex;
    if (error2 !== null && typeof error2 === "object" && (error2.$$typeof === REACT_ELEMENT_TYPE || error2.$$typeof === REACT_PORTAL_TYPE) && error2._store && (!error2._store.validated && error2.key == null || error2._store.validated === 2)) {
      if (typeof error2._store !== "object")
        throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
      error2._store.validated = 1;
      thrownInfo = resumeSlots.didWarnForKey;
      thrownInfo == null && (thrownInfo = resumeSlots.didWarnForKey = new WeakSet);
      resumeSlots = node2.componentStack;
      if (resumeSlots !== null && !thrownInfo.has(resumeSlots)) {
        thrownInfo.add(resumeSlots);
        var componentName = getComponentNameFromType(error2.type);
        thrownInfo = error2._owner;
        var parentOwner = resumeSlots.owner;
        resumeSlots = "";
        if (parentOwner && typeof parentOwner.type !== "undefined") {
          var name2 = getComponentNameFromType(parentOwner.type);
          name2 && (resumeSlots = `

Check the render method of \`` + name2 + "`.");
        }
        resumeSlots || componentName && (resumeSlots = `

Check the top-level render call using <` + componentName + ">.");
        componentName = "";
        thrownInfo != null && parentOwner !== thrownInfo && (parentOwner = null, typeof thrownInfo.type !== "undefined" ? parentOwner = getComponentNameFromType(thrownInfo.type) : typeof thrownInfo.name === "string" && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
        thrownInfo = node2.componentStack;
        node2.componentStack = {
          parent: node2.componentStack,
          type: error2.type,
          owner: error2._owner,
          stack: error2._debugStack
        };
        console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', resumeSlots, componentName);
        node2.componentStack = thrownInfo;
      }
    }
    task.treeContext = pushTreeContext(replay, replayNodes, j2);
    renderNode2(request, task, childIndex, j2);
  }
  task.treeContext = replay;
  task.keyPath = prevKeyPath;
  task.componentStack = previousComponentStack;
  task.debugTask = previousDebugTask;
}
function untrackBoundary(request, boundary) {
  request = request.trackedPostpones;
  request !== null && (boundary = boundary.trackedContentKeyPath, boundary !== null && (boundary = request.workingMap.get(boundary), boundary !== undefined && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
}
function spawnNewSuspendedReplayTask(request, task, thenableState2) {
  return createReplayTask(request, thenableState2, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject, task.debugTask);
}
function spawnNewSuspendedRenderTask(request, task, thenableState2) {
  var segment = task.blockedSegment, newSegment = createPendingSegment(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, true);
  segment.children.push(newSegment);
  segment.lastPushedText = false;
  return createRenderTask(request, thenableState2, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject, task.debugTask);
}
function renderNode2(request, task, node2, childIndex) {
  var { formatContext: previousFormatContext, context: previousContext, keyPath: previousKeyPath, treeContext: previousTreeContext, componentStack: previousComponentStack, debugTask: previousDebugTask, blockedSegment: segment } = task;
  if (segment === null)
    try {
      return renderNodeDestructive(request, task, node2, childIndex);
    } catch (thrownValue) {
      if (resetHooksState(), node2 = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, typeof node2 === "object" && node2 !== null) {
        if (typeof node2.then === "function") {
          childIndex = getThenableStateAfterSuspending();
          request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
          node2.then(request, request);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
        if (node2.message === "Maximum call stack size exceeded") {
          node2 = getThenableStateAfterSuspending();
          node2 = spawnNewSuspendedReplayTask(request, task, node2);
          request.pingedTasks.push(node2);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
      }
    }
  else {
    var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
    try {
      return renderNodeDestructive(request, task, node2, childIndex);
    } catch (thrownValue$3) {
      if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node2 = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, typeof node2 === "object" && node2 !== null) {
        if (typeof node2.then === "function") {
          childIndex = getThenableStateAfterSuspending();
          request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;
          node2.then(request, request);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
        if (node2.message === "Maximum call stack size exceeded") {
          node2 = getThenableStateAfterSuspending();
          node2 = spawnNewSuspendedRenderTask(request, task, node2);
          request.pingedTasks.push(node2);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
      }
    }
  }
  task.formatContext = previousFormatContext;
  task.context = previousContext;
  task.keyPath = previousKeyPath;
  task.treeContext = previousTreeContext;
  switchContext(previousContext);
  throw node2;
}
function abortTaskSoft(task) {
  var boundary = task.blockedBoundary;
  task = task.blockedSegment;
  task !== null && (task.status = 3, finishedTask(this, boundary, task));
}
function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
  for (var i = 0;i < nodes.length; i++) {
    var node2 = nodes[i];
    if (node2.length === 4)
      abortRemainingReplayNodes(request$jscomp$0, boundary, node2[2], node2[3], error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted);
    else {
      var request = request$jscomp$0;
      node2 = node2[5];
      var error2 = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(request, new Set, null, null);
      resumedBoundary.parentFlushed = true;
      resumedBoundary.rootSegmentID = node2;
      resumedBoundary.status = CLIENT_RENDERED;
      encodeErrorForBoundary(resumedBoundary, errorDigest, error2, errorInfo, wasAborted);
      resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
    }
  }
  nodes.length = 0;
  if (slots !== null) {
    if (boundary === null)
      throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
    boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, errorDigest$jscomp$0, error$jscomp$0, errorInfo$jscomp$0, aborted), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
    if (typeof slots === "object")
      for (var index in slots)
        delete slots[index];
  }
}
function abortTask(task, request, error2) {
  var { blockedBoundary: boundary, blockedSegment: segment } = task;
  if (segment !== null) {
    if (segment.status === 6)
      return;
    segment.status = 3;
  }
  segment = getThrownInfo(task.componentStack);
  if (boundary === null) {
    if (request.status !== 13 && request.status !== CLOSED) {
      boundary = task.replay;
      if (boundary === null) {
        logRecoverableError(request, error2, segment, null);
        fatalError(request, error2, segment, null);
        return;
      }
      boundary.pendingTasks--;
      boundary.pendingTasks === 0 && 0 < boundary.nodes.length && (task = logRecoverableError(request, error2, segment, null), abortRemainingReplayNodes(request, null, boundary.nodes, boundary.slots, error2, task, segment, true));
      request.pendingRootTasks--;
      request.pendingRootTasks === 0 && completeShell(request);
    }
  } else
    boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error2, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error2, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
      return abortTask(fallbackTask, request, error2);
    }), boundary.fallbackAbortableTasks.clear();
  request.allPendingTasks--;
  request.allPendingTasks === 0 && completeAll(request);
}
function safelyEmitEarlyPreloads(request, shellComplete) {
  try {
    var renderState = request.renderState, onHeaders = renderState.onHeaders;
    if (onHeaders) {
      var headers = renderState.headers;
      if (headers) {
        renderState.headers = null;
        var linkHeader = headers.preconnects;
        headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
        headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
        if (!shellComplete) {
          var queueIter = renderState.styles.values(), queueStep = queueIter.next();
          b:
            for (;0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
              for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next();0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                var header = getPreloadAsHeader(props$jscomp$0.href, "style", {
                  crossOrigin: props$jscomp$0.crossOrigin,
                  integrity: props$jscomp$0.integrity,
                  nonce: props$jscomp$0.nonce,
                  type: props$jscomp$0.type,
                  fetchPriority: props$jscomp$0.fetchPriority,
                  referrerPolicy: props$jscomp$0.referrerPolicy,
                  media: props$jscomp$0.media
                });
                if (0 <= (headers.remainingCapacity -= header.length + 2))
                  renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = typeof props.crossOrigin === "string" || typeof props.integrity === "string" ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                else
                  break b;
              }
        }
        linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
      }
    }
  } catch (error2) {
    logRecoverableError(request, error2, {}, null);
  }
}
function completeShell(request) {
  request.trackedPostpones === null && safelyEmitEarlyPreloads(request, true);
  request.trackedPostpones === null && preparePreamble(request);
  request.onShellError = noop4;
  request = request.onShellReady;
  request();
}
function completeAll(request) {
  safelyEmitEarlyPreloads(request, request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED);
  preparePreamble(request);
  request = request.onAllReady;
  request();
}
function queueCompletedSegment(boundary, segment) {
  if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {
    var childSegment = segment.children[0];
    childSegment.id = segment.id;
    childSegment.parentFlushed = true;
    childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
  } else
    boundary.completedSegments.push(segment);
}
function finishedTask(request, boundary, segment) {
  if (boundary === null) {
    if (segment !== null && segment.parentFlushed) {
      if (request.completedRootSegment !== null)
        throw Error("There can only be one root segment. This is a bug in React.");
      request.completedRootSegment = segment;
    }
    request.pendingRootTasks--;
    request.pendingRootTasks === 0 && completeShell(request);
  } else
    boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.pendingTasks === 0 ? (boundary.status === PENDING && (boundary.status = COMPLETED), segment !== null && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary.contentPreamble !== null && preparePreamble(request))) : segment !== null && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), boundary.completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
  request.allPendingTasks--;
  request.allPendingTasks === 0 && completeAll(request);
}
function performWork(request$jscomp$2) {
  if (request$jscomp$2.status !== CLOSED && request$jscomp$2.status !== 13) {
    var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = HooksDispatcher;
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    var prevRequest = currentRequest;
    currentRequest = request$jscomp$2;
    var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
    ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
    var prevResumableState = currentResumableState;
    currentResumableState = request$jscomp$2.resumableState;
    try {
      var pingedTasks = request$jscomp$2.pingedTasks, i;
      for (i = 0;i < pingedTasks.length; i++) {
        var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
        if (segment === null) {
          var prevTaskInDEV = undefined, request$jscomp$0 = request;
          request = task;
          if (request.replay.pendingTasks !== 0) {
            switchContext(request.context);
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = request;
            try {
              typeof request.replay.slots === "number" ? resumeNode(request$jscomp$0, request, request.replay.slots, request.node, request.childIndex) : retryNode(request$jscomp$0, request);
              if (request.replay.pendingTasks === 1 && 0 < request.replay.nodes.length)
                throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
              request.replay.pendingTasks--;
              request.abortSet.delete(request);
              finishedTask(request$jscomp$0, request.blockedBoundary, null);
            } catch (thrownValue) {
              resetHooksState();
              var x2 = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
              if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function") {
                var ping = request.ping;
                x2.then(ping, ping);
                request.thenableState = getThenableStateAfterSuspending();
              } else {
                request.replay.pendingTasks--;
                request.abortSet.delete(request);
                var errorInfo = getThrownInfo(request.componentStack), errorDigest = undefined, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = request$jscomp$0.status === 12 ? request$jscomp$0.fatalError : x2, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                errorDigest = logRecoverableError(request$jscomp$1, error$jscomp$0, errorInfo$jscomp$0, request.debugTask);
                abortRemainingReplayNodes(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, errorDigest, errorInfo$jscomp$0, false);
                request$jscomp$0.pendingRootTasks--;
                request$jscomp$0.pendingRootTasks === 0 && completeShell(request$jscomp$0);
                request$jscomp$0.allPendingTasks--;
                request$jscomp$0.allPendingTasks === 0 && completeAll(request$jscomp$0);
              }
            } finally {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        } else if (request$jscomp$0 = prevTaskInDEV = undefined, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
          request$jscomp$1.status = 6;
          switchContext(errorDigest.context);
          request$jscomp$0 = currentTaskInDEV;
          currentTaskInDEV = errorDigest;
          var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
          try {
            retryNode(request, errorDigest), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push("<!-- -->"), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(request, errorDigest.blockedBoundary, request$jscomp$1);
          } catch (thrownValue) {
            resetHooksState();
            request$jscomp$1.children.length = childrenLength;
            request$jscomp$1.chunks.length = chunkLength;
            var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : request.status === 12 ? request.fatalError : thrownValue;
            if (typeof x$jscomp$0 === "object" && x$jscomp$0 !== null && typeof x$jscomp$0.then === "function") {
              request$jscomp$1.status = PENDING;
              errorDigest.thenableState = getThenableStateAfterSuspending();
              var ping$jscomp$0 = errorDigest.ping;
              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
            } else {
              var errorInfo$jscomp$1 = getThrownInfo(errorDigest.componentStack);
              errorDigest.abortSet.delete(errorDigest);
              request$jscomp$1.status = 4;
              var { blockedBoundary: boundary$jscomp$0, debugTask } = errorDigest;
              prevTaskInDEV = logRecoverableError(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
              boundary$jscomp$0 === null ? fatalError(request, x$jscomp$0, errorInfo$jscomp$1, debugTask) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary$jscomp$0, prevTaskInDEV, x$jscomp$0, errorInfo$jscomp$1, false), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0), request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary$jscomp$0.contentPreamble !== null && preparePreamble(request)));
              request.allPendingTasks--;
              request.allPendingTasks === 0 && completeAll(request);
            }
          } finally {
            currentTaskInDEV = request$jscomp$0;
          }
        }
      }
      pingedTasks.splice(0, i);
      request$jscomp$2.destination !== null && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
    } catch (error2) {
      pingedTasks = {}, logRecoverableError(request$jscomp$2, error2, pingedTasks, null), fatalError(request$jscomp$2, error2, pingedTasks, null);
    } finally {
      currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
    }
  }
}
function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
  segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
  for (var pendingPreambles = false, i = 0;i < segment.children.length; i++)
    pendingPreambles = preparePreambleFromSegment(request, segment.children[i], collectedPreambleSegments) || pendingPreambles;
  return pendingPreambles;
}
function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
  var boundary = segment.boundary;
  if (boundary === null)
    return preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
  var { contentPreamble: preamble, fallbackPreamble } = boundary;
  if (preamble === null || fallbackPreamble === null)
    return false;
  switch (boundary.status) {
    case COMPLETED:
      hoistPreambleState(request.renderState, preamble);
      segment = boundary.completedSegments[0];
      if (!segment)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      return preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
    case POSTPONED:
      if (request.trackedPostpones !== null)
        return true;
    case CLIENT_RENDERED:
      if (segment.status === COMPLETED)
        return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
    default:
      return true;
  }
}
function preparePreamble(request) {
  if (request.completedRootSegment && request.completedPreambleSegments === null) {
    var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
    if (hasPendingPreambles === false || preamble.headChunks && preamble.bodyChunks)
      request.completedPreambleSegments = collectedPreambleSegments;
  }
}
function flushSubtree(request, destination, segment, hoistableState) {
  segment.parentFlushed = true;
  switch (segment.status) {
    case PENDING:
      segment.id = request.nextSegmentId++;
    case POSTPONED:
      return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = hoistableState.toString(16), writeChunk(destination, request), !!destination.write(placeholder2);
    case COMPLETED:
      segment.status = FLUSHED;
      var r2 = true, chunks = segment.chunks, chunkIdx = 0;
      segment = segment.children;
      for (var childIdx = 0;childIdx < segment.length; childIdx++) {
        for (r2 = segment[childIdx];chunkIdx < r2.index; chunkIdx++)
          writeChunk(destination, chunks[chunkIdx]);
        r2 = flushSegment(request, destination, r2, hoistableState);
      }
      for (;chunkIdx < chunks.length - 1; chunkIdx++)
        writeChunk(destination, chunks[chunkIdx]);
      chunkIdx < chunks.length && (r2 = !!destination.write(chunks[chunkIdx]));
      return r2;
    default:
      throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
  }
}
function flushSegment(request, destination, segment, hoistableState) {
  var boundary = segment.boundary;
  if (boundary === null)
    return flushSubtree(request, destination, segment, hoistableState);
  boundary.parentFlushed = true;
  if (boundary.status === CLIENT_RENDERED) {
    var { errorDigest, errorMessage, errorStack, errorComponentStack } = boundary;
    destination.write(startClientRenderedSuspenseBoundary);
    writeChunk(destination, clientRenderedSuspenseBoundaryError1);
    errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(errorDigest)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    errorMessage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, escapeTextForBrowser(errorMessage)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    errorStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, escapeTextForBrowser(errorStack)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1D), writeChunk(destination, escapeTextForBrowser(errorComponentStack)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    destination.write(clientRenderedSuspenseBoundaryError2);
    flushSubtree(request, destination, segment, hoistableState);
    (request = boundary.fallbackPreamble) && writePreambleContribution(destination, request);
    return !!destination.write(endSuspenseBoundary);
  }
  if (boundary.status !== COMPLETED)
    return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(hoistStylesheetDependency, hoistableState)), flushSubtree(request, destination, segment, hoistableState), !!destination.write(endSuspenseBoundary);
  if (boundary.byteSize > request.progressiveChunkSize)
    return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID), flushSubtree(request, destination, segment, hoistableState), !!destination.write(endSuspenseBoundary);
  hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
  destination.write(startCompletedSuspenseBoundary);
  segment = boundary.completedSegments;
  if (segment.length !== 1)
    throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
  flushSegment(request, destination, segment[0], hoistableState);
  (request = boundary.contentPreamble) && writePreambleContribution(destination, request);
  return !!destination.write(endSuspenseBoundary);
}
function flushSegmentContainer(request, destination, segment, hoistableState) {
  writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);
  flushSegment(request, destination, segment, hoistableState);
  return writeEndSegment(destination, segment.parentFormatContext);
}
function flushCompletedBoundary(request, destination, boundary) {
  for (var completedSegments = boundary.completedSegments, i = 0;i < completedSegments.length; i++)
    flushPartiallyCompletedSegment(request, destination, boundary, completedSegments[i]);
  completedSegments.length = 0;
  writeHoistablesForBoundary(destination, boundary.contentState, request.renderState);
  completedSegments = request.resumableState;
  request = request.renderState;
  i = boundary.rootSegmentID;
  boundary = boundary.contentState;
  var requiresStyleInsertion = request.stylesToHoist;
  request.stylesToHoist = false;
  writeChunk(destination, request.startInlineScript);
  requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk(destination, completeBoundaryWithStylesScript1FullPartial)) : writeChunk(destination, completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScript1Full)) : writeChunk(destination, completeBoundaryScript1Partial);
  completedSegments = i.toString(16);
  writeChunk(destination, request.boundaryPrefix);
  writeChunk(destination, completedSegments);
  writeChunk(destination, completeBoundaryScript2);
  writeChunk(destination, request.segmentPrefix);
  writeChunk(destination, completedSegments);
  requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
  boundary = !!destination.write(completeBoundaryScriptEnd);
  return writeBootstrap(destination, request) && boundary;
}
function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
  if (segment.status === FLUSHED)
    return true;
  var hoistableState = boundary.contentState, segmentID = segment.id;
  if (segmentID === -1) {
    if ((segment.id = boundary.rootSegmentID) === -1)
      throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
    return flushSegmentContainer(request, destination, segment, hoistableState);
  }
  if (segmentID === boundary.rootSegmentID)
    return flushSegmentContainer(request, destination, segment, hoistableState);
  flushSegmentContainer(request, destination, segment, hoistableState);
  boundary = request.resumableState;
  request = request.renderState;
  writeChunk(destination, request.startInlineScript);
  (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
  writeChunk(destination, request.segmentPrefix);
  segmentID = segmentID.toString(16);
  writeChunk(destination, segmentID);
  writeChunk(destination, completeSegmentScript2);
  writeChunk(destination, request.placeholderPrefix);
  writeChunk(destination, segmentID);
  destination = !!destination.write(completeSegmentScriptEnd);
  return destination;
}
function flushCompletedQueues(request, destination) {
  try {
    if (!(0 < request.pendingRootTasks)) {
      var i, completedRootSegment = request.completedRootSegment;
      if (completedRootSegment !== null) {
        if (completedRootSegment.status === POSTPONED)
          return;
        var completedPreambleSegments = request.completedPreambleSegments;
        if (completedPreambleSegments === null)
          return;
        var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
        if (htmlChunks) {
          for (i$jscomp$0 = 0;i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
            writeChunk(destination, htmlChunks[i$jscomp$0]);
          if (headChunks)
            for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
              writeChunk(destination, headChunks[i$jscomp$0]);
          else
            writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
        } else if (headChunks)
          for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
            writeChunk(destination, headChunks[i$jscomp$0]);
        var charsetChunks = renderState.charsetChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
          writeChunk(destination, charsetChunks[i$jscomp$0]);
        charsetChunks.length = 0;
        renderState.preconnects.forEach(flushResource, destination);
        renderState.preconnects.clear();
        var viewportChunks = renderState.viewportChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
          writeChunk(destination, viewportChunks[i$jscomp$0]);
        viewportChunks.length = 0;
        renderState.fontPreloads.forEach(flushResource, destination);
        renderState.fontPreloads.clear();
        renderState.highImagePreloads.forEach(flushResource, destination);
        renderState.highImagePreloads.clear();
        renderState.styles.forEach(flushStylesInPreamble, destination);
        var importMapChunks = renderState.importMapChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
          writeChunk(destination, importMapChunks[i$jscomp$0]);
        importMapChunks.length = 0;
        renderState.bootstrapScripts.forEach(flushResource, destination);
        renderState.scripts.forEach(flushResource, destination);
        renderState.scripts.clear();
        renderState.bulkPreloads.forEach(flushResource, destination);
        renderState.bulkPreloads.clear();
        var hoistableChunks = renderState.hoistableChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
          writeChunk(destination, hoistableChunks[i$jscomp$0]);
        for (renderState = hoistableChunks.length = 0;renderState < completedPreambleSegments.length; renderState++) {
          var segments = completedPreambleSegments[renderState];
          for (preamble = 0;preamble < segments.length; preamble++)
            flushSegment(request, destination, segments[preamble], null);
        }
        var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
        var bodyChunks = preamble$jscomp$0.bodyChunks;
        if (bodyChunks)
          for (completedPreambleSegments = 0;completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
            writeChunk(destination, bodyChunks[completedPreambleSegments]);
        flushSegment(request, destination, completedRootSegment, null);
        request.completedRootSegment = null;
        writeBootstrap(destination, request.renderState);
      }
      var renderState$jscomp$0 = request.renderState;
      completedRootSegment = 0;
      var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
      for (completedRootSegment = 0;completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
        writeChunk(destination, viewportChunks$jscomp$0[completedRootSegment]);
      viewportChunks$jscomp$0.length = 0;
      renderState$jscomp$0.preconnects.forEach(flushResource, destination);
      renderState$jscomp$0.preconnects.clear();
      renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
      renderState$jscomp$0.fontPreloads.clear();
      renderState$jscomp$0.highImagePreloads.forEach(flushResource, destination);
      renderState$jscomp$0.highImagePreloads.clear();
      renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
      renderState$jscomp$0.scripts.forEach(flushResource, destination);
      renderState$jscomp$0.scripts.clear();
      renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
      renderState$jscomp$0.bulkPreloads.clear();
      var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
      for (completedRootSegment = 0;completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
        writeChunk(destination, hoistableChunks$jscomp$0[completedRootSegment]);
      hoistableChunks$jscomp$0.length = 0;
      var clientRenderedBoundaries = request.clientRenderedBoundaries;
      for (i = 0;i < clientRenderedBoundaries.length; i++) {
        var boundary = clientRenderedBoundaries[i];
        renderState$jscomp$0 = destination;
        var { resumableState, renderState: renderState$jscomp$1 } = request, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
        writeChunk(renderState$jscomp$0, renderState$jscomp$1.startInlineScript);
        (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, writeChunk(renderState$jscomp$0, clientRenderScript1Full)) : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
        writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);
        writeChunk(renderState$jscomp$0, id.toString(16));
        writeChunk(renderState$jscomp$0, clientRenderScript1A);
        if (errorDigest || errorMessage || errorStack || errorComponentStack)
          writeChunk(renderState$jscomp$0, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$0, escapeJSStringsForInstructionScripts(errorDigest || ""));
        if (errorMessage || errorStack || errorComponentStack)
          writeChunk(renderState$jscomp$0, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$0, escapeJSStringsForInstructionScripts(errorMessage || ""));
        if (errorStack || errorComponentStack)
          writeChunk(renderState$jscomp$0, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$0, escapeJSStringsForInstructionScripts(errorStack || ""));
        errorComponentStack && (writeChunk(renderState$jscomp$0, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$0, escapeJSStringsForInstructionScripts(errorComponentStack)));
        var JSCompiler_inline_result = !!renderState$jscomp$0.write(clientRenderScriptEnd);
        if (!JSCompiler_inline_result) {
          request.destination = null;
          i++;
          clientRenderedBoundaries.splice(0, i);
          return;
        }
      }
      clientRenderedBoundaries.splice(0, i);
      var completedBoundaries = request.completedBoundaries;
      for (i = 0;i < completedBoundaries.length; i++)
        if (!flushCompletedBoundary(request, destination, completedBoundaries[i])) {
          request.destination = null;
          i++;
          completedBoundaries.splice(0, i);
          return;
        }
      completedBoundaries.splice(0, i);
      var partialBoundaries = request.partialBoundaries;
      for (i = 0;i < partialBoundaries.length; i++) {
        a: {
          clientRenderedBoundaries = request;
          boundary = destination;
          var boundary$jscomp$0 = partialBoundaries[i], completedSegments = boundary$jscomp$0.completedSegments;
          for (JSCompiler_inline_result = 0;JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
            if (!flushPartiallyCompletedSegment(clientRenderedBoundaries, boundary, boundary$jscomp$0, completedSegments[JSCompiler_inline_result])) {
              JSCompiler_inline_result++;
              completedSegments.splice(0, JSCompiler_inline_result);
              var JSCompiler_inline_result$jscomp$0 = false;
              break a;
            }
          completedSegments.splice(0, JSCompiler_inline_result);
          JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(boundary, boundary$jscomp$0.contentState, clientRenderedBoundaries.renderState);
        }
        if (!JSCompiler_inline_result$jscomp$0) {
          request.destination = null;
          i++;
          partialBoundaries.splice(0, i);
          return;
        }
      }
      partialBoundaries.splice(0, i);
      var largeBoundaries = request.completedBoundaries;
      for (i = 0;i < largeBoundaries.length; i++)
        if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
          request.destination = null;
          i++;
          largeBoundaries.splice(0, i);
          return;
        }
      largeBoundaries.splice(0, i);
    }
  } finally {
    request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 ? (request.flushScheduled = false, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag("body")), i.hasHtml && writeChunk(destination, endChunkForTag("html")), flushBuffered(destination), request.abortableTasks.size !== 0 && console.error("There was still abortable task at the root when we closed. This is a bug in React."), request.status = CLOSED, destination.end(), request.destination = null) : flushBuffered(destination);
  }
}
function startWork(request) {
  request.flushScheduled = request.destination !== null;
  scheduleMicrotask(function() {
    return performWork(request);
  });
  setTimeout(function() {
    request.status === 10 && (request.status = 11);
    request.trackedPostpones === null && safelyEmitEarlyPreloads(request, request.pendingRootTasks === 0);
  }, 0);
}
function enqueueFlush(request) {
  request.flushScheduled === false && request.pingedTasks.length === 0 && request.destination !== null && (request.flushScheduled = true, setTimeout(function() {
    var destination = request.destination;
    destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
  }, 0));
}
function abort(request, reason) {
  if (request.status === 11 || request.status === 10)
    request.status = 12;
  try {
    var abortableTasks = request.abortableTasks;
    if (0 < abortableTasks.size) {
      var error2 = reason === undefined ? Error("The render was aborted by the server without a reason.") : typeof reason === "object" && reason !== null && typeof reason.then === "function" ? Error("The render was aborted by the server with a promise.") : reason;
      request.fatalError = error2;
      abortableTasks.forEach(function(task) {
        return abortTask(task, request, error2);
      });
      abortableTasks.clear();
    }
    request.destination !== null && flushCompletedQueues(request, request.destination);
  } catch (error$4) {
    reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
  }
}
var React, ReactDOM, REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE, REACT_FRAGMENT_TYPE, REACT_STRICT_MODE_TYPE, REACT_PROFILER_TYPE, REACT_PROVIDER_TYPE, REACT_CONSUMER_TYPE, REACT_CONTEXT_TYPE, REACT_FORWARD_REF_TYPE, REACT_SUSPENSE_TYPE, REACT_SUSPENSE_LIST_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE, REACT_SCOPE_TYPE, REACT_ACTIVITY_TYPE, REACT_LEGACY_HIDDEN_TYPE, REACT_MEMO_CACHE_SENTINEL, REACT_VIEW_TRANSITION_TYPE, MAYBE_ITERATOR_SYMBOL, isArrayImpl, jsxPropsParents, jsxChildrenParents, CLIENT_REFERENCE_TAG, scheduleMicrotask, assign, hasOwnProperty2, VALID_ATTRIBUTE_NAME_REGEX, illegalAttributeNameCache, validatedAttributeNameCache, unitlessNumbers, aliases, hasReadOnlyValue, ariaProperties, warnedProperties$1, rARIA$1, rARIACamel$1, didWarnValueNull = false, possibleStandardNames, warnedProperties, EVENT_NAME_REGEX, INVALID_EVENT_NAME_REGEX, rARIA, rARIACamel, badVendoredStyleNamePattern, msPattern$1, hyphenPattern, badStyleValueWithSemicolonPattern, warnedStyleNames, warnedStyleValues, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp, uppercasePattern, msPattern, isJavaScriptProtocol, ReactSharedInternals, ReactDOMSharedInternals, NotPending, previousDispatcher, NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS, scriptRegex, didWarnForNewBooleanPropsWithEmptyValue, NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache, styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";", attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""', actionJavaScriptURL, endOfStartTag = ">", endOfStartTagSelfClosing = "/>", didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, formReplayingRuntimeScript = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex, VALID_TAG_REGEX, validatedTagCache, endTagCache, placeholder1 = '<template id="', placeholder2 = '"></template>', startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError1D = ' data-cstck="', clientRenderedSuspenseBoundaryError2 = "></template>", boundaryPreambleContributionChunkStart = "<!--", boundaryPreambleContributionChunkEnd = "-->", startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>", completeSegmentScript1Full = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScriptEnd = '")</script>', completeBoundaryScript1Full = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("', completeBoundaryScript1Partial = '$RC("', completeBoundaryWithStylesScript1FullBoth = `$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;
$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=
d;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,
t,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("`, completeBoundaryWithStylesScript1FullPartial = `$RM=new Map;
$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=
d;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,
t,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("`, completeBoundaryWithStylesScript1Partial = '$RR("', completeBoundaryScript2 = '","', completeBoundaryScript3a = '",', completeBoundaryScript3b = '"', completeBoundaryScriptEnd = ")</script>", clientRenderScript1Full = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderErrorScriptArgInterstitial = ",", clientRenderScriptEnd = ")</script>", regexForJSStringsInInstructionScripts, regexForJSStringsInScripts, lateStyleTagResourceOpen1 = '<style media="not all" data-precedence="', lateStyleTagResourceOpen2 = '" data-href="', lateStyleTagResourceOpen3 = '">', lateStyleTagTemplateClose = "</style>", currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue, styleTagResourceOpen1 = '<style data-precedence="', styleTagResourceOpen2 = '" data-href="', spaceSeparator = " ", styleTagResourceOpen3 = '">', styleTagResourceClose = "</style>", arrayFirstOpenBracket = "[", arraySubsequentOpenBracket = ",[", arrayInterstitial = ",", arrayCloseBracket = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext, regexForLinkHeaderQuotedParamValueContext, bind2, REACT_CLIENT_REFERENCE, emptyContextObject, rendererSigil, currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent, didWarnAboutDeprecatedWillMount, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypes$1, didWarnAboutChildContextTypes, didWarnAboutInvalidateContextType, didWarnOnInvalidCallback, classComponentUpdater, emptyTreeContext, clz32, log2, LN2, SuspenseException, suspendedThenable = null, objectIs, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd, prefix, suffix, reentry = false, componentFrameCache, callComponent, callComponentInDEV, callRender, callRenderInDEV, callLazyInit, callLazyInitInDEV, lastResetTime = 0, getCurrentTime, localPerformance, localDate, CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass, didWarnAboutContextTypes, didWarnAboutContextTypeOnFunctionComponent, didWarnAboutGetDerivedStateOnFunctionComponent, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false, isomorphicReactPackageVersion$jscomp$inline_743, $renderToReadableStream = function(children, options) {
  return new Promise(function(resolve, reject) {
    var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
      onAllReady = res;
      onFatalError = rej;
    }), onHeaders = options ? options.onHeaders : undefined, onHeadersImpl;
    onHeaders && (onHeadersImpl = function(headersDescriptor) {
      onHeaders(new Headers(headersDescriptor));
    });
    var resumableState = createResumableState(options ? options.identifierPrefix : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), request$jscomp$0 = createRequest(children, resumableState, createRenderState(resumableState, options ? options.nonce : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.importMap : undefined, onHeadersImpl, options ? options.maxHeadersLength : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, onAllReady, function() {
      var stream4 = new ReadableStream({
        type: "direct",
        pull: function(controller) {
          var request = request$jscomp$0;
          if (request.status === 13)
            request.status = CLOSED, closeWithError(controller, request.fatalError);
          else if (request.status !== CLOSED && request.destination === null) {
            request.destination = controller;
            try {
              flushCompletedQueues(request, controller);
            } catch (error2) {
              controller = {}, logRecoverableError(request, error2, controller, null), fatalError(request, error2, controller, null);
            }
          }
        },
        cancel: function(reason) {
          request$jscomp$0.destination = null;
          abort(request$jscomp$0, reason);
        }
      }, { highWaterMark: 2048 });
      stream4.allReady = allReady;
      resolve(stream4);
    }, function(error2) {
      allReady.catch(function() {});
      reject(error2);
    }, onFatalError, options ? options.onPostpone : undefined, options ? options.formState : undefined);
    if (options && options.signal) {
      var signal = options.signal;
      if (signal.aborted)
        abort(request$jscomp$0, signal.reason);
      else {
        var listener = function() {
          abort(request$jscomp$0, signal.reason);
          signal.removeEventListener("abort", listener);
        };
        signal.addEventListener("abort", listener);
      }
    }
    startWork(request$jscomp$0);
  });
}, $version = "19.1.0";
var init_react_dom_server_bun_development = __esm(() => {
  React = __toESM(require_react(), 1);
  ReactDOM = __toESM(require_react_dom(), 1);
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
  REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  REACT_PROVIDER_TYPE = Symbol.for("react.provider");
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
  REACT_CONTEXT_TYPE = Symbol.for("react.context");
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
  REACT_MEMO_TYPE = Symbol.for("react.memo");
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
  REACT_SCOPE_TYPE = Symbol.for("react.scope");
  REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition");
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  isArrayImpl = Array.isArray;
  jsxPropsParents = new WeakMap;
  jsxChildrenParents = new WeakMap;
  CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
  scheduleMicrotask = queueMicrotask;
  assign = Object.assign;
  hasOwnProperty2 = Object.prototype.hasOwnProperty;
  VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  illegalAttributeNameCache = {};
  validatedAttributeNameCache = {};
  unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
  aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]);
  hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };
  ariaProperties = {
    "aria-current": 0,
    "aria-description": 0,
    "aria-details": 0,
    "aria-disabled": 0,
    "aria-hidden": 0,
    "aria-invalid": 0,
    "aria-keyshortcuts": 0,
    "aria-label": 0,
    "aria-roledescription": 0,
    "aria-autocomplete": 0,
    "aria-checked": 0,
    "aria-expanded": 0,
    "aria-haspopup": 0,
    "aria-level": 0,
    "aria-modal": 0,
    "aria-multiline": 0,
    "aria-multiselectable": 0,
    "aria-orientation": 0,
    "aria-placeholder": 0,
    "aria-pressed": 0,
    "aria-readonly": 0,
    "aria-required": 0,
    "aria-selected": 0,
    "aria-sort": 0,
    "aria-valuemax": 0,
    "aria-valuemin": 0,
    "aria-valuenow": 0,
    "aria-valuetext": 0,
    "aria-atomic": 0,
    "aria-busy": 0,
    "aria-live": 0,
    "aria-relevant": 0,
    "aria-dropeffect": 0,
    "aria-grabbed": 0,
    "aria-activedescendant": 0,
    "aria-colcount": 0,
    "aria-colindex": 0,
    "aria-colspan": 0,
    "aria-controls": 0,
    "aria-describedby": 0,
    "aria-errormessage": 0,
    "aria-flowto": 0,
    "aria-labelledby": 0,
    "aria-owns": 0,
    "aria-posinset": 0,
    "aria-rowcount": 0,
    "aria-rowindex": 0,
    "aria-rowspan": 0,
    "aria-setsize": 0
  };
  warnedProperties$1 = {};
  rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  possibleStandardNames = {
    accept: "accept",
    acceptcharset: "acceptCharset",
    "accept-charset": "acceptCharset",
    accesskey: "accessKey",
    action: "action",
    allowfullscreen: "allowFullScreen",
    alt: "alt",
    as: "as",
    async: "async",
    autocapitalize: "autoCapitalize",
    autocomplete: "autoComplete",
    autocorrect: "autoCorrect",
    autofocus: "autoFocus",
    autoplay: "autoPlay",
    autosave: "autoSave",
    capture: "capture",
    cellpadding: "cellPadding",
    cellspacing: "cellSpacing",
    challenge: "challenge",
    charset: "charSet",
    checked: "checked",
    children: "children",
    cite: "cite",
    class: "className",
    classid: "classID",
    classname: "className",
    cols: "cols",
    colspan: "colSpan",
    content: "content",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    controls: "controls",
    controlslist: "controlsList",
    coords: "coords",
    crossorigin: "crossOrigin",
    dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
    data: "data",
    datetime: "dateTime",
    default: "default",
    defaultchecked: "defaultChecked",
    defaultvalue: "defaultValue",
    defer: "defer",
    dir: "dir",
    disabled: "disabled",
    disablepictureinpicture: "disablePictureInPicture",
    disableremoteplayback: "disableRemotePlayback",
    download: "download",
    draggable: "draggable",
    enctype: "encType",
    enterkeyhint: "enterKeyHint",
    fetchpriority: "fetchPriority",
    for: "htmlFor",
    form: "form",
    formmethod: "formMethod",
    formaction: "formAction",
    formenctype: "formEncType",
    formnovalidate: "formNoValidate",
    formtarget: "formTarget",
    frameborder: "frameBorder",
    headers: "headers",
    height: "height",
    hidden: "hidden",
    high: "high",
    href: "href",
    hreflang: "hrefLang",
    htmlfor: "htmlFor",
    httpequiv: "httpEquiv",
    "http-equiv": "httpEquiv",
    icon: "icon",
    id: "id",
    imagesizes: "imageSizes",
    imagesrcset: "imageSrcSet",
    inert: "inert",
    innerhtml: "innerHTML",
    inputmode: "inputMode",
    integrity: "integrity",
    is: "is",
    itemid: "itemID",
    itemprop: "itemProp",
    itemref: "itemRef",
    itemscope: "itemScope",
    itemtype: "itemType",
    keyparams: "keyParams",
    keytype: "keyType",
    kind: "kind",
    label: "label",
    lang: "lang",
    list: "list",
    loop: "loop",
    low: "low",
    manifest: "manifest",
    marginwidth: "marginWidth",
    marginheight: "marginHeight",
    max: "max",
    maxlength: "maxLength",
    media: "media",
    mediagroup: "mediaGroup",
    method: "method",
    min: "min",
    minlength: "minLength",
    multiple: "multiple",
    muted: "muted",
    name: "name",
    nomodule: "noModule",
    nonce: "nonce",
    novalidate: "noValidate",
    open: "open",
    optimum: "optimum",
    pattern: "pattern",
    placeholder: "placeholder",
    playsinline: "playsInline",
    poster: "poster",
    preload: "preload",
    profile: "profile",
    radiogroup: "radioGroup",
    readonly: "readOnly",
    referrerpolicy: "referrerPolicy",
    rel: "rel",
    required: "required",
    reversed: "reversed",
    role: "role",
    rows: "rows",
    rowspan: "rowSpan",
    sandbox: "sandbox",
    scope: "scope",
    scoped: "scoped",
    scrolling: "scrolling",
    seamless: "seamless",
    selected: "selected",
    shape: "shape",
    size: "size",
    sizes: "sizes",
    span: "span",
    spellcheck: "spellCheck",
    src: "src",
    srcdoc: "srcDoc",
    srclang: "srcLang",
    srcset: "srcSet",
    start: "start",
    step: "step",
    style: "style",
    summary: "summary",
    tabindex: "tabIndex",
    target: "target",
    title: "title",
    type: "type",
    usemap: "useMap",
    value: "value",
    width: "width",
    wmode: "wmode",
    wrap: "wrap",
    about: "about",
    accentheight: "accentHeight",
    "accent-height": "accentHeight",
    accumulate: "accumulate",
    additive: "additive",
    alignmentbaseline: "alignmentBaseline",
    "alignment-baseline": "alignmentBaseline",
    allowreorder: "allowReorder",
    alphabetic: "alphabetic",
    amplitude: "amplitude",
    arabicform: "arabicForm",
    "arabic-form": "arabicForm",
    ascent: "ascent",
    attributename: "attributeName",
    attributetype: "attributeType",
    autoreverse: "autoReverse",
    azimuth: "azimuth",
    basefrequency: "baseFrequency",
    baselineshift: "baselineShift",
    "baseline-shift": "baselineShift",
    baseprofile: "baseProfile",
    bbox: "bbox",
    begin: "begin",
    bias: "bias",
    by: "by",
    calcmode: "calcMode",
    capheight: "capHeight",
    "cap-height": "capHeight",
    clip: "clip",
    clippath: "clipPath",
    "clip-path": "clipPath",
    clippathunits: "clipPathUnits",
    cliprule: "clipRule",
    "clip-rule": "clipRule",
    color: "color",
    colorinterpolation: "colorInterpolation",
    "color-interpolation": "colorInterpolation",
    colorinterpolationfilters: "colorInterpolationFilters",
    "color-interpolation-filters": "colorInterpolationFilters",
    colorprofile: "colorProfile",
    "color-profile": "colorProfile",
    colorrendering: "colorRendering",
    "color-rendering": "colorRendering",
    contentscripttype: "contentScriptType",
    contentstyletype: "contentStyleType",
    cursor: "cursor",
    cx: "cx",
    cy: "cy",
    d: "d",
    datatype: "datatype",
    decelerate: "decelerate",
    descent: "descent",
    diffuseconstant: "diffuseConstant",
    direction: "direction",
    display: "display",
    divisor: "divisor",
    dominantbaseline: "dominantBaseline",
    "dominant-baseline": "dominantBaseline",
    dur: "dur",
    dx: "dx",
    dy: "dy",
    edgemode: "edgeMode",
    elevation: "elevation",
    enablebackground: "enableBackground",
    "enable-background": "enableBackground",
    end: "end",
    exponent: "exponent",
    externalresourcesrequired: "externalResourcesRequired",
    fill: "fill",
    fillopacity: "fillOpacity",
    "fill-opacity": "fillOpacity",
    fillrule: "fillRule",
    "fill-rule": "fillRule",
    filter: "filter",
    filterres: "filterRes",
    filterunits: "filterUnits",
    floodopacity: "floodOpacity",
    "flood-opacity": "floodOpacity",
    floodcolor: "floodColor",
    "flood-color": "floodColor",
    focusable: "focusable",
    fontfamily: "fontFamily",
    "font-family": "fontFamily",
    fontsize: "fontSize",
    "font-size": "fontSize",
    fontsizeadjust: "fontSizeAdjust",
    "font-size-adjust": "fontSizeAdjust",
    fontstretch: "fontStretch",
    "font-stretch": "fontStretch",
    fontstyle: "fontStyle",
    "font-style": "fontStyle",
    fontvariant: "fontVariant",
    "font-variant": "fontVariant",
    fontweight: "fontWeight",
    "font-weight": "fontWeight",
    format: "format",
    from: "from",
    fx: "fx",
    fy: "fy",
    g1: "g1",
    g2: "g2",
    glyphname: "glyphName",
    "glyph-name": "glyphName",
    glyphorientationhorizontal: "glyphOrientationHorizontal",
    "glyph-orientation-horizontal": "glyphOrientationHorizontal",
    glyphorientationvertical: "glyphOrientationVertical",
    "glyph-orientation-vertical": "glyphOrientationVertical",
    glyphref: "glyphRef",
    gradienttransform: "gradientTransform",
    gradientunits: "gradientUnits",
    hanging: "hanging",
    horizadvx: "horizAdvX",
    "horiz-adv-x": "horizAdvX",
    horizoriginx: "horizOriginX",
    "horiz-origin-x": "horizOriginX",
    ideographic: "ideographic",
    imagerendering: "imageRendering",
    "image-rendering": "imageRendering",
    in2: "in2",
    in: "in",
    inlist: "inlist",
    intercept: "intercept",
    k1: "k1",
    k2: "k2",
    k3: "k3",
    k4: "k4",
    k: "k",
    kernelmatrix: "kernelMatrix",
    kernelunitlength: "kernelUnitLength",
    kerning: "kerning",
    keypoints: "keyPoints",
    keysplines: "keySplines",
    keytimes: "keyTimes",
    lengthadjust: "lengthAdjust",
    letterspacing: "letterSpacing",
    "letter-spacing": "letterSpacing",
    lightingcolor: "lightingColor",
    "lighting-color": "lightingColor",
    limitingconeangle: "limitingConeAngle",
    local: "local",
    markerend: "markerEnd",
    "marker-end": "markerEnd",
    markerheight: "markerHeight",
    markermid: "markerMid",
    "marker-mid": "markerMid",
    markerstart: "markerStart",
    "marker-start": "markerStart",
    markerunits: "markerUnits",
    markerwidth: "markerWidth",
    mask: "mask",
    maskcontentunits: "maskContentUnits",
    maskunits: "maskUnits",
    mathematical: "mathematical",
    mode: "mode",
    numoctaves: "numOctaves",
    offset: "offset",
    opacity: "opacity",
    operator: "operator",
    order: "order",
    orient: "orient",
    orientation: "orientation",
    origin: "origin",
    overflow: "overflow",
    overlineposition: "overlinePosition",
    "overline-position": "overlinePosition",
    overlinethickness: "overlineThickness",
    "overline-thickness": "overlineThickness",
    paintorder: "paintOrder",
    "paint-order": "paintOrder",
    panose1: "panose1",
    "panose-1": "panose1",
    pathlength: "pathLength",
    patterncontentunits: "patternContentUnits",
    patterntransform: "patternTransform",
    patternunits: "patternUnits",
    pointerevents: "pointerEvents",
    "pointer-events": "pointerEvents",
    points: "points",
    pointsatx: "pointsAtX",
    pointsaty: "pointsAtY",
    pointsatz: "pointsAtZ",
    popover: "popover",
    popovertarget: "popoverTarget",
    popovertargetaction: "popoverTargetAction",
    prefix: "prefix",
    preservealpha: "preserveAlpha",
    preserveaspectratio: "preserveAspectRatio",
    primitiveunits: "primitiveUnits",
    property: "property",
    r: "r",
    radius: "radius",
    refx: "refX",
    refy: "refY",
    renderingintent: "renderingIntent",
    "rendering-intent": "renderingIntent",
    repeatcount: "repeatCount",
    repeatdur: "repeatDur",
    requiredextensions: "requiredExtensions",
    requiredfeatures: "requiredFeatures",
    resource: "resource",
    restart: "restart",
    result: "result",
    results: "results",
    rotate: "rotate",
    rx: "rx",
    ry: "ry",
    scale: "scale",
    security: "security",
    seed: "seed",
    shaperendering: "shapeRendering",
    "shape-rendering": "shapeRendering",
    slope: "slope",
    spacing: "spacing",
    specularconstant: "specularConstant",
    specularexponent: "specularExponent",
    speed: "speed",
    spreadmethod: "spreadMethod",
    startoffset: "startOffset",
    stddeviation: "stdDeviation",
    stemh: "stemh",
    stemv: "stemv",
    stitchtiles: "stitchTiles",
    stopcolor: "stopColor",
    "stop-color": "stopColor",
    stopopacity: "stopOpacity",
    "stop-opacity": "stopOpacity",
    strikethroughposition: "strikethroughPosition",
    "strikethrough-position": "strikethroughPosition",
    strikethroughthickness: "strikethroughThickness",
    "strikethrough-thickness": "strikethroughThickness",
    string: "string",
    stroke: "stroke",
    strokedasharray: "strokeDasharray",
    "stroke-dasharray": "strokeDasharray",
    strokedashoffset: "strokeDashoffset",
    "stroke-dashoffset": "strokeDashoffset",
    strokelinecap: "strokeLinecap",
    "stroke-linecap": "strokeLinecap",
    strokelinejoin: "strokeLinejoin",
    "stroke-linejoin": "strokeLinejoin",
    strokemiterlimit: "strokeMiterlimit",
    "stroke-miterlimit": "strokeMiterlimit",
    strokewidth: "strokeWidth",
    "stroke-width": "strokeWidth",
    strokeopacity: "strokeOpacity",
    "stroke-opacity": "strokeOpacity",
    suppresscontenteditablewarning: "suppressContentEditableWarning",
    suppresshydrationwarning: "suppressHydrationWarning",
    surfacescale: "surfaceScale",
    systemlanguage: "systemLanguage",
    tablevalues: "tableValues",
    targetx: "targetX",
    targety: "targetY",
    textanchor: "textAnchor",
    "text-anchor": "textAnchor",
    textdecoration: "textDecoration",
    "text-decoration": "textDecoration",
    textlength: "textLength",
    textrendering: "textRendering",
    "text-rendering": "textRendering",
    to: "to",
    transform: "transform",
    transformorigin: "transformOrigin",
    "transform-origin": "transformOrigin",
    typeof: "typeof",
    u1: "u1",
    u2: "u2",
    underlineposition: "underlinePosition",
    "underline-position": "underlinePosition",
    underlinethickness: "underlineThickness",
    "underline-thickness": "underlineThickness",
    unicode: "unicode",
    unicodebidi: "unicodeBidi",
    "unicode-bidi": "unicodeBidi",
    unicoderange: "unicodeRange",
    "unicode-range": "unicodeRange",
    unitsperem: "unitsPerEm",
    "units-per-em": "unitsPerEm",
    unselectable: "unselectable",
    valphabetic: "vAlphabetic",
    "v-alphabetic": "vAlphabetic",
    values: "values",
    vectoreffect: "vectorEffect",
    "vector-effect": "vectorEffect",
    version: "version",
    vertadvy: "vertAdvY",
    "vert-adv-y": "vertAdvY",
    vertoriginx: "vertOriginX",
    "vert-origin-x": "vertOriginX",
    vertoriginy: "vertOriginY",
    "vert-origin-y": "vertOriginY",
    vhanging: "vHanging",
    "v-hanging": "vHanging",
    videographic: "vIdeographic",
    "v-ideographic": "vIdeographic",
    viewbox: "viewBox",
    viewtarget: "viewTarget",
    visibility: "visibility",
    vmathematical: "vMathematical",
    "v-mathematical": "vMathematical",
    vocab: "vocab",
    widths: "widths",
    wordspacing: "wordSpacing",
    "word-spacing": "wordSpacing",
    writingmode: "writingMode",
    "writing-mode": "writingMode",
    x1: "x1",
    x2: "x2",
    x: "x",
    xchannelselector: "xChannelSelector",
    xheight: "xHeight",
    "x-height": "xHeight",
    xlinkactuate: "xlinkActuate",
    "xlink:actuate": "xlinkActuate",
    xlinkarcrole: "xlinkArcrole",
    "xlink:arcrole": "xlinkArcrole",
    xlinkhref: "xlinkHref",
    "xlink:href": "xlinkHref",
    xlinkrole: "xlinkRole",
    "xlink:role": "xlinkRole",
    xlinkshow: "xlinkShow",
    "xlink:show": "xlinkShow",
    xlinktitle: "xlinkTitle",
    "xlink:title": "xlinkTitle",
    xlinktype: "xlinkType",
    "xlink:type": "xlinkType",
    xmlbase: "xmlBase",
    "xml:base": "xmlBase",
    xmllang: "xmlLang",
    "xml:lang": "xmlLang",
    xmlns: "xmlns",
    "xml:space": "xmlSpace",
    xmlnsxlink: "xmlnsXlink",
    "xmlns:xlink": "xmlnsXlink",
    xmlspace: "xmlSpace",
    y1: "y1",
    y2: "y2",
    y: "y",
    ychannelselector: "yChannelSelector",
    z: "z",
    zoomandpan: "zoomAndPan"
  };
  warnedProperties = {};
  EVENT_NAME_REGEX = /^on./;
  INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  msPattern$1 = /^-ms-/;
  hyphenPattern = /-(.)/g;
  badStyleValueWithSemicolonPattern = /;\s*$/;
  warnedStyleNames = {};
  warnedStyleValues = {};
  matchHtmlRegExp = /["'&<>]/;
  uppercasePattern = /([A-Z])/g;
  msPattern = /^ms-/;
  isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  NotPending = Object.freeze({
    pending: false,
    data: null,
    method: null,
    action: null
  });
  previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: previousDispatcher.f,
    r: previousDispatcher.r,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  PRELOAD_NO_CREDS = [];
  Object.freeze(PRELOAD_NO_CREDS);
  scriptRegex = /(<\/|<)(s)(cript)/gi;
  didWarnForNewBooleanPropsWithEmptyValue = {};
  styleNameCache = new Map;
  actionJavaScriptURL = escapeTextForBrowser("javascript:throw new Error('React form unexpectedly submitted.')");
  styleRegex = /(<\/|<)(s)(tyle)/gi;
  VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
  validatedTagCache = new Map;
  endTagCache = new Map;
  regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
  regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
  stylesheetFlushingQueue = [];
  regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
  regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
  bind2 = Function.prototype.bind;
  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  emptyContextObject = {};
  Object.freeze(emptyContextObject);
  rendererSigil = {};
  didWarnAboutNoopUpdateForComponent = {};
  didWarnAboutDeprecatedWillMount = {};
  didWarnAboutUninitializedState = new Set;
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
  didWarnAboutDirectlyAssigningPropsToState = new Set;
  didWarnAboutUndefinedDerivedState = new Set;
  didWarnAboutContextTypes$1 = new Set;
  didWarnAboutChildContextTypes = new Set;
  didWarnAboutInvalidateContextType = new Set;
  didWarnOnInvalidCallback = new Set;
  classComponentUpdater = {
    enqueueSetState: function(inst, payload, callback) {
      var internals = inst._reactInternals;
      internals.queue === null ? warnNoop(inst, "setState") : (internals.queue.push(payload), callback !== undefined && callback !== null && warnOnInvalidCallback(callback));
    },
    enqueueReplaceState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      inst.replace = true;
      inst.queue = [payload];
      callback !== undefined && callback !== null && warnOnInvalidCallback(callback);
    },
    enqueueForceUpdate: function(inst, callback) {
      inst._reactInternals.queue === null ? warnNoop(inst, "forceUpdate") : callback !== undefined && callback !== null && warnOnInvalidCallback(callback);
    }
  };
  emptyTreeContext = { id: 1, overflow: "" };
  clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
  log2 = Math.log;
  LN2 = Math.LN2;
  SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.");
  objectIs = typeof Object.is === "function" ? Object.is : is4;
  HooksDispatcher = {
    readContext,
    use: function(usable) {
      if (usable !== null && typeof usable === "object") {
        if (typeof usable.then === "function")
          return unwrapThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    },
    useContext: function(context) {
      currentHookNameInDev = "useContext";
      resolveCurrentlyRenderingComponent();
      return context._currentValue;
    },
    useMemo,
    useReducer,
    useRef: function(initialValue) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      var previousRef = workInProgressHook.memoizedState;
      return previousRef === null ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
    },
    useState: function(initialState) {
      currentHookNameInDev = "useState";
      return useReducer(basicStateReducer, initialState);
    },
    useInsertionEffect: noop$1,
    useLayoutEffect: noop$1,
    useCallback: function(callback, deps) {
      return useMemo(function() {
        return callback;
      }, deps);
    },
    useImperativeHandle: noop$1,
    useEffect: noop$1,
    useDebugValue: noop$1,
    useDeferredValue: function(value, initialValue) {
      resolveCurrentlyRenderingComponent();
      return initialValue !== undefined ? initialValue : value;
    },
    useTransition: function() {
      resolveCurrentlyRenderingComponent();
      return [false, unsupportedStartTransition];
    },
    useId: function() {
      var treeId = currentlyRenderingTask.treeContext;
      var overflow = treeId.overflow;
      treeId = treeId.id;
      treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
      var resumableState = currentResumableState;
      if (resumableState === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      overflow = localIdCounter++;
      treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
      0 < overflow && (treeId += "H" + overflow.toString(32));
      return treeId + "\xBB";
    },
    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
      if (getServerSnapshot === undefined)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return getServerSnapshot();
    },
    useOptimistic: function(passthrough) {
      resolveCurrentlyRenderingComponent();
      return [passthrough, unsupportedSetOptimisticState];
    },
    useActionState,
    useFormState: useActionState,
    useHostTransitionStatus: function() {
      resolveCurrentlyRenderingComponent();
      return NotPending;
    },
    useMemoCache: function(size) {
      for (var data = Array(size), i = 0;i < size; i++)
        data[i] = REACT_MEMO_CACHE_SENTINEL;
      return data;
    },
    useCacheRefresh: function() {
      return unsupportedRefresh;
    }
  };
  DefaultAsyncDispatcher = {
    getCacheForType: function() {
      throw Error("Not implemented.");
    },
    getOwner: function() {
      return currentTaskInDEV === null ? null : currentTaskInDEV.componentStack;
    }
  };
  disabledLog.__reactDisabledLog = true;
  componentFrameCache = new (typeof WeakMap === "function" ? WeakMap : Map);
  callComponent = {
    "react-stack-bottom-frame": function(Component, props, secondArg) {
      return Component(props, secondArg);
    }
  };
  callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent);
  callRender = {
    "react-stack-bottom-frame": function(instance) {
      return instance.render();
    }
  };
  callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender);
  callLazyInit = {
    "react-stack-bottom-frame": function(lazy) {
      var init2 = lazy._init;
      return init2(lazy._payload);
    }
  };
  callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit);
  if (typeof performance === "object" && typeof performance.now === "function") {
    localPerformance = performance;
    getCurrentTime = function() {
      return localPerformance.now();
    };
  } else {
    localDate = Date;
    getCurrentTime = function() {
      return localDate.now();
    };
  }
  didWarnAboutBadClass = {};
  didWarnAboutContextTypes = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  isomorphicReactPackageVersion$jscomp$inline_743 = React.version;
  if (isomorphicReactPackageVersion$jscomp$inline_743 !== "19.1.0")
    throw Error(`Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (isomorphicReactPackageVersion$jscomp$inline_743 + `
  - react-dom:  19.1.0
Learn more: https://react.dev/warnings/version-mismatch`));
});

// ../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS((exports) => {
  var React2 = __toESM(require_react(), 1);
  var ReactDOM2 = __toESM(require_react_dom(), 1);
  (function() {
    function styleReplacer2(match, prefix3, s2, suffix3) {
      return "" + prefix3 + (s2 === "s" ? "\\73 " : "\\53 ") + suffix3;
    }
    function scriptReplacer2(match, prefix3, s2, suffix3) {
      return "" + prefix3 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix3;
    }
    function objectName2(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m2, p0) {
        return p0;
      });
    }
    function describeKeyForErrorMessage2(key) {
      var encodedKey = JSON.stringify(key);
      return '"' + key + '"' === encodedKey ? key : encodedKey;
    }
    function describeValueForErrorMessage2(value) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
        case "object":
          if (isArrayImpl2(value))
            return "[...]";
          if (value !== null && value.$$typeof === CLIENT_REFERENCE_TAG2)
            return "client";
          value = objectName2(value);
          return value === "Object" ? "{...}" : value;
        case "function":
          return value.$$typeof === CLIENT_REFERENCE_TAG2 ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
        default:
          return String(value);
      }
    }
    function describeElementType2(type) {
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_SUSPENSE_TYPE2:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE2:
          return "SuspenseList";
      }
      if (typeof type === "object")
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE2:
            return describeElementType2(type.render);
          case REACT_MEMO_TYPE2:
            return describeElementType2(type.type);
          case REACT_LAZY_TYPE2:
            var payload = type._payload;
            type = type._init;
            try {
              return describeElementType2(type(payload));
            } catch (x2) {}
        }
      return "";
    }
    function describeObjectForErrorMessage2(objectOrArray, expandedName) {
      var objKind = objectName2(objectOrArray);
      if (objKind !== "Object" && objKind !== "Array")
        return objKind;
      var start = -1, length = 0;
      if (isArrayImpl2(objectOrArray))
        if (jsxChildrenParents2.has(objectOrArray)) {
          var type = jsxChildrenParents2.get(objectOrArray);
          objKind = "<" + describeElementType2(type) + ">";
          for (var i = 0;i < objectOrArray.length; i++) {
            var value = objectOrArray[i];
            value = typeof value === "string" ? value : typeof value === "object" && value !== null ? "{" + describeObjectForErrorMessage2(value) + "}" : "{" + describeValueForErrorMessage2(value) + "}";
            "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
          }
          objKind += "</" + describeElementType2(type) + ">";
        } else {
          objKind = "[";
          for (type = 0;type < objectOrArray.length; type++)
            0 < type && (objKind += ", "), i = objectOrArray[type], i = typeof i === "object" && i !== null ? describeObjectForErrorMessage2(i) : describeValueForErrorMessage2(i), "" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
          objKind += "]";
        }
      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE2)
        objKind = "<" + describeElementType2(objectOrArray.type) + "/>";
      else {
        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG2)
          return "client";
        if (jsxPropsParents2.has(objectOrArray)) {
          objKind = jsxPropsParents2.get(objectOrArray);
          objKind = "<" + (describeElementType2(objKind) || "...");
          type = Object.keys(objectOrArray);
          for (i = 0;i < type.length; i++) {
            objKind += " ";
            value = type[i];
            objKind += describeKeyForErrorMessage2(value) + "=";
            var _value2 = objectOrArray[value];
            var _substr2 = value === expandedName && typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage2(_value2) : describeValueForErrorMessage2(_value2);
            typeof _value2 !== "string" && (_substr2 = "{" + _substr2 + "}");
            value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
          }
          objKind += ">";
        } else {
          objKind = "{";
          type = Object.keys(objectOrArray);
          for (i = 0;i < type.length; i++)
            0 < i && (objKind += ", "), value = type[i], objKind += describeKeyForErrorMessage2(value) + ": ", _value2 = objectOrArray[value], _value2 = typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage2(_value2) : describeValueForErrorMessage2(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
          objKind += "}";
        }
      }
      return expandedName === undefined ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), `
  ` + objKind + `
  ` + objectOrArray) : `
  ` + objKind;
    }
    function murmurhash3_32_gc(key, seed) {
      var remainder = key.length & 3;
      var bytes = key.length - remainder;
      var h1 = seed;
      for (seed = 0;seed < bytes; ) {
        var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
        ++seed;
        k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
        case 2:
          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
        case 1:
          k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      }
      h1 ^= key.length;
      h1 ^= h1 >>> 16;
      h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      h1 ^= h1 >>> 13;
      h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      return (h1 ^ h1 >>> 16) >>> 0;
    }
    function typeName2(value) {
      return typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow2(value) {
      try {
        return testStringCoercion2(value), false;
      } catch (e2) {
        return true;
      }
    }
    function testStringCoercion2(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion2(value, attributeName) {
      if (willCoercionThrow2(value))
        return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName2(value)), testStringCoercion2(value);
    }
    function checkCSSPropertyStringCoercion2(value, propName) {
      if (willCoercionThrow2(value))
        return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName2(value)), testStringCoercion2(value);
    }
    function checkHtmlStringCoercion2(value) {
      if (willCoercionThrow2(value))
        return console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName2(value)), testStringCoercion2(value);
    }
    function isAttributeNameSafe2(attributeName) {
      if (hasOwnProperty3.call(validatedAttributeNameCache2, attributeName))
        return true;
      if (hasOwnProperty3.call(illegalAttributeNameCache2, attributeName))
        return false;
      if (VALID_ATTRIBUTE_NAME_REGEX2.test(attributeName))
        return validatedAttributeNameCache2[attributeName] = true;
      illegalAttributeNameCache2[attributeName] = true;
      console.error("Invalid attribute name: `%s`", attributeName);
      return false;
    }
    function checkControlledValueProps2(tagName, props) {
      hasReadOnlyValue2[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || (tagName === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
      props.onChange || props.readOnly || props.disabled || props.checked == null || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function validateProperty$12(tagName, name2) {
      if (hasOwnProperty3.call(warnedProperties$12, name2) && warnedProperties$12[name2])
        return true;
      if (rARIACamel$12.test(name2)) {
        tagName = "aria-" + name2.slice(4).toLowerCase();
        tagName = ariaProperties2.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == null)
          return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2), warnedProperties$12[name2] = true;
        if (name2 !== tagName)
          return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, tagName), warnedProperties$12[name2] = true;
      }
      if (rARIA$12.test(name2)) {
        tagName = name2.toLowerCase();
        tagName = ariaProperties2.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == null)
          return warnedProperties$12[name2] = true, false;
        name2 !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, tagName), warnedProperties$12[name2] = true);
      }
      return true;
    }
    function validateProperties$22(type, props) {
      var invalidProps = [], key;
      for (key in props)
        validateProperty$12(type, key) || invalidProps.push(key);
      props = invalidProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      invalidProps.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
    }
    function validateProperty2(tagName, name2, value, eventRegistry) {
      if (hasOwnProperty3.call(warnedProperties2, name2) && warnedProperties2[name2])
        return true;
      var lowerCasedName = name2.toLowerCase();
      if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
        return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties2[name2] = true;
      if (typeof value === "function" && (tagName === "form" && name2 === "action" || tagName === "input" && name2 === "formAction" || tagName === "button" && name2 === "formAction"))
        return true;
      if (eventRegistry != null) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name2))
          return true;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
        if (eventRegistry != null)
          return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name2, eventRegistry), warnedProperties2[name2] = true;
        if (EVENT_NAME_REGEX2.test(name2))
          return console.error("Unknown event handler property `%s`. It will be ignored.", name2), warnedProperties2[name2] = true;
      } else if (EVENT_NAME_REGEX2.test(name2))
        return INVALID_EVENT_NAME_REGEX2.test(name2) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2), warnedProperties2[name2] = true;
      if (rARIA2.test(name2) || rARIACamel2.test(name2))
        return true;
      if (lowerCasedName === "innerhtml")
        return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties2[name2] = true;
      if (lowerCasedName === "aria")
        return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties2[name2] = true;
      if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string")
        return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties2[name2] = true;
      if (typeof value === "number" && isNaN(value))
        return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2), warnedProperties2[name2] = true;
      if (possibleStandardNames2.hasOwnProperty(lowerCasedName)) {
        if (lowerCasedName = possibleStandardNames2[lowerCasedName], lowerCasedName !== name2)
          return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name2, lowerCasedName), warnedProperties2[name2] = true;
      } else if (name2 !== lowerCasedName)
        return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName), warnedProperties2[name2] = true;
      switch (name2) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return true;
        case "innerText":
        case "textContent":
          return true;
      }
      switch (typeof value) {
        case "boolean":
          switch (name2) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return true;
            default:
              lowerCasedName = name2.toLowerCase().slice(0, 5);
              if (lowerCasedName === "data-" || lowerCasedName === "aria-")
                return true;
              value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
              return warnedProperties2[name2] = true;
          }
        case "function":
        case "symbol":
          return warnedProperties2[name2] = true, false;
        case "string":
          if (value === "false" || value === "true") {
            switch (name2) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return true;
            }
            console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
            warnedProperties2[name2] = true;
          }
      }
      return true;
    }
    function warnUnknownProperties2(type, props, eventRegistry) {
      var unknownProps = [], key;
      for (key in props)
        validateProperty2(type, key, props[key], eventRegistry) || unknownProps.push(key);
      props = unknownProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      unknownProps.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
    }
    function camelize2(string) {
      return string.replace(hyphenPattern2, function(_3, character) {
        return character.toUpperCase();
      });
    }
    function escapeTextForBrowser2(text2) {
      if (typeof text2 === "boolean" || typeof text2 === "number" || typeof text2 === "bigint")
        return "" + text2;
      checkHtmlStringCoercion2(text2);
      text2 = "" + text2;
      var match = matchHtmlRegExp2.exec(text2);
      if (match) {
        var html2 = "", index, lastIndex = 0;
        for (index = match.index;index < text2.length; index++) {
          switch (text2.charCodeAt(index)) {
            case 34:
              match = "&quot;";
              break;
            case 38:
              match = "&amp;";
              break;
            case 39:
              match = "&#x27;";
              break;
            case 60:
              match = "&lt;";
              break;
            case 62:
              match = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html2 += text2.slice(lastIndex, index));
          lastIndex = index + 1;
          html2 += match;
        }
        text2 = lastIndex !== index ? html2 + text2.slice(lastIndex, index) : html2;
      }
      return text2;
    }
    function sanitizeURL2(url2) {
      return isJavaScriptProtocol2.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
    }
    function escapeEntireInlineScriptContent2(scriptText) {
      checkHtmlStringCoercion2(scriptText);
      return ("" + scriptText).replace(scriptRegex2, scriptReplacer2);
    }
    function createResumableState2(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
      return {
        idPrefix: identifierPrefix === undefined ? "" : identifierPrefix,
        nextFormID: 0,
        streamingFormat: 0,
        bootstrapScriptContent,
        bootstrapScripts,
        bootstrapModules,
        instructions: NothingSent2,
        hasBody: false,
        hasHtml: false,
        unknownResources: {},
        dnsResources: {},
        connectResources: { default: {}, anonymous: {}, credentials: {} },
        imageResources: {},
        styleResources: {},
        scriptResources: {},
        moduleUnknownResources: {},
        moduleScriptResources: {}
      };
    }
    function createPreambleState2() {
      return {
        htmlChunks: null,
        headChunks: null,
        bodyChunks: null,
        contribution: NoContribution2
      };
    }
    function createFormatContext2(insertionMode, selectedValue, tagScope) {
      return {
        insertionMode,
        selectedValue,
        tagScope
      };
    }
    function getChildFormatContext2(parentContext, type, props) {
      switch (type) {
        case "noscript":
          return createFormatContext2(HTML_MODE2, null, parentContext.tagScope | 1);
        case "select":
          return createFormatContext2(HTML_MODE2, props.value != null ? props.value : props.defaultValue, parentContext.tagScope);
        case "svg":
          return createFormatContext2(SVG_MODE2, null, parentContext.tagScope);
        case "picture":
          return createFormatContext2(HTML_MODE2, null, parentContext.tagScope | 2);
        case "math":
          return createFormatContext2(MATHML_MODE2, null, parentContext.tagScope);
        case "foreignObject":
          return createFormatContext2(HTML_MODE2, null, parentContext.tagScope);
        case "table":
          return createFormatContext2(HTML_TABLE_MODE2, null, parentContext.tagScope);
        case "thead":
        case "tbody":
        case "tfoot":
          return createFormatContext2(HTML_TABLE_BODY_MODE2, null, parentContext.tagScope);
        case "colgroup":
          return createFormatContext2(HTML_COLGROUP_MODE2, null, parentContext.tagScope);
        case "tr":
          return createFormatContext2(HTML_TABLE_ROW_MODE2, null, parentContext.tagScope);
        case "head":
          if (parentContext.insertionMode < HTML_MODE2)
            return createFormatContext2(HTML_HEAD_MODE2, null, parentContext.tagScope);
          break;
        case "html":
          if (parentContext.insertionMode === ROOT_HTML_MODE2)
            return createFormatContext2(HTML_HTML_MODE2, null, parentContext.tagScope);
      }
      return parentContext.insertionMode >= HTML_TABLE_MODE2 || parentContext.insertionMode < HTML_MODE2 ? createFormatContext2(HTML_MODE2, null, parentContext.tagScope) : parentContext;
    }
    function pushStyleAttribute2(target, style) {
      if (typeof style !== "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var isFirst = true, styleName;
      for (styleName in style)
        if (hasOwnProperty3.call(style, styleName)) {
          var styleValue = style[styleName];
          if (styleValue != null && typeof styleValue !== "boolean" && styleValue !== "") {
            if (styleName.indexOf("--") === 0) {
              var nameChunk = escapeTextForBrowser2(styleName);
              checkCSSPropertyStringCoercion2(styleValue, styleName);
              styleValue = escapeTextForBrowser2(("" + styleValue).trim());
            } else {
              nameChunk = styleName;
              var value = styleValue;
              if (-1 < nameChunk.indexOf("-")) {
                var name2 = nameChunk;
                warnedStyleNames2.hasOwnProperty(name2) && warnedStyleNames2[name2] || (warnedStyleNames2[name2] = true, console.error("Unsupported style property %s. Did you mean %s?", name2, camelize2(name2.replace(msPattern$12, "ms-"))));
              } else if (badVendoredStyleNamePattern2.test(nameChunk))
                name2 = nameChunk, warnedStyleNames2.hasOwnProperty(name2) && warnedStyleNames2[name2] || (warnedStyleNames2[name2] = true, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1)));
              else if (badStyleValueWithSemicolonPattern2.test(value)) {
                name2 = nameChunk;
                var value$jscomp$0 = value;
                warnedStyleValues2.hasOwnProperty(value$jscomp$0) && warnedStyleValues2[value$jscomp$0] || (warnedStyleValues2[value$jscomp$0] = true, console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value$jscomp$0.replace(badStyleValueWithSemicolonPattern2, "")));
              }
              typeof value === "number" && (isNaN(value) ? warnedForNaNValue2 || (warnedForNaNValue2 = true, console.error("`NaN` is an invalid value for the `%s` css style property.", nameChunk)) : isFinite(value) || warnedForInfinityValue2 || (warnedForInfinityValue2 = true, console.error("`Infinity` is an invalid value for the `%s` css style property.", nameChunk)));
              nameChunk = styleName;
              value = styleNameCache2.get(nameChunk);
              value !== undefined ? nameChunk = value : (value = escapeTextForBrowser2(nameChunk.replace(uppercasePattern2, "-$1").toLowerCase().replace(msPattern2, "-ms-")), styleNameCache2.set(nameChunk, value), nameChunk = value);
              typeof styleValue === "number" ? styleValue = styleValue === 0 || unitlessNumbers2.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion2(styleValue, styleName), styleValue = escapeTextForBrowser2(("" + styleValue).trim()));
            }
            isFirst ? (isFirst = false, target.push(styleAttributeStart2, nameChunk, styleAssign2, styleValue)) : target.push(styleSeparator2, nameChunk, styleAssign2, styleValue);
          }
        }
      isFirst || target.push(attributeEnd2);
    }
    function pushBooleanAttribute2(target, name2, value) {
      value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name2, attributeEmptyString2);
    }
    function pushStringAttribute2(target, name2, value) {
      typeof value !== "function" && typeof value !== "symbol" && typeof value !== "boolean" && target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
    }
    function pushAdditionalFormField2(value, key) {
      this.push('<input type="hidden"');
      validateAdditionalFormField2(value);
      pushStringAttribute2(this, "name", key);
      pushStringAttribute2(this, "value", value);
      this.push(endOfStartTagSelfClosing2);
    }
    function validateAdditionalFormField2(value) {
      if (typeof value !== "string")
        throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
    }
    function getCustomFormFields2(resumableState, formAction) {
      if (typeof formAction.$$FORM_ACTION === "function") {
        var id = resumableState.nextFormID++;
        resumableState = resumableState.idPrefix + id;
        try {
          var customFields = formAction.$$FORM_ACTION(resumableState);
          if (customFields) {
            var formData = customFields.data;
            formData != null && formData.forEach(validateAdditionalFormField2);
          }
          return customFields;
        } catch (x2) {
          if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function")
            throw x2;
          console.error(`Failed to serialize an action for progressive enhancement:
%s`, x2);
        }
      }
      return null;
    }
    function pushFormActionAttribute2(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2) {
      var formData = null;
      if (typeof formAction === "function") {
        name2 === null || didWarnFormActionName2 || (didWarnFormActionName2 = true, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'));
        formEncType === null && formMethod === null || didWarnFormActionMethod2 || (didWarnFormActionMethod2 = true, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."));
        formTarget === null || didWarnFormActionTarget2 || (didWarnFormActionTarget2 = true, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."));
        var customFields = getCustomFormFields2(resumableState, formAction);
        customFields !== null ? (name2 = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator2, "formAction", attributeAssign2, actionJavaScriptURL2, attributeEnd2), formTarget = formMethod = formEncType = formAction = name2 = null, injectFormReplayingRuntime2(resumableState, renderState));
      }
      name2 != null && pushAttribute2(target, "name", name2);
      formAction != null && pushAttribute2(target, "formAction", formAction);
      formEncType != null && pushAttribute2(target, "formEncType", formEncType);
      formMethod != null && pushAttribute2(target, "formMethod", formMethod);
      formTarget != null && pushAttribute2(target, "formTarget", formTarget);
      return formData;
    }
    function pushAttribute2(target, name2, value) {
      switch (name2) {
        case "className":
          pushStringAttribute2(target, "class", value);
          break;
        case "tabIndex":
          pushStringAttribute2(target, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          pushStringAttribute2(target, name2, value);
          break;
        case "style":
          pushStyleAttribute2(target, value);
          break;
        case "src":
        case "href":
          if (value === "") {
            name2 === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name2, name2) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name2, name2);
            break;
          }
        case "action":
        case "formAction":
          if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
            break;
          checkAttributeStringCoercion2(value, name2);
          value = sanitizeURL2("" + value);
          target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "ref":
          break;
        case "autoFocus":
        case "multiple":
        case "muted":
          pushBooleanAttribute2(target, name2.toLowerCase(), value);
          break;
        case "xlinkHref":
          if (typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
            break;
          checkAttributeStringCoercion2(value, name2);
          value = sanitizeURL2("" + value);
          target.push(attributeSeparator2, "xlink:href", attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "inert":
          value !== "" || didWarnForNewBooleanPropsWithEmptyValue2[name2] || (didWarnForNewBooleanPropsWithEmptyValue2[name2] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", name2));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name2, attributeEmptyString2);
          break;
        case "capture":
        case "download":
          value === true ? target.push(attributeSeparator2, name2, attributeEmptyString2) : value !== false && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value && target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "rowSpan":
        case "start":
          typeof value === "function" || typeof value === "symbol" || isNaN(value) || target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "xlinkActuate":
          pushStringAttribute2(target, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          pushStringAttribute2(target, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          pushStringAttribute2(target, "xlink:role", value);
          break;
        case "xlinkShow":
          pushStringAttribute2(target, "xlink:show", value);
          break;
        case "xlinkTitle":
          pushStringAttribute2(target, "xlink:title", value);
          break;
        case "xlinkType":
          pushStringAttribute2(target, "xlink:type", value);
          break;
        case "xmlBase":
          pushStringAttribute2(target, "xml:base", value);
          break;
        case "xmlLang":
          pushStringAttribute2(target, "xml:lang", value);
          break;
        case "xmlSpace":
          pushStringAttribute2(target, "xml:space", value);
          break;
        default:
          if (!(2 < name2.length) || name2[0] !== "o" && name2[0] !== "O" || name2[1] !== "n" && name2[1] !== "N") {
            if (name2 = aliases2.get(name2) || name2, isAttributeNameSafe2(name2)) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean":
                  var prefix3 = name2.toLowerCase().slice(0, 5);
                  if (prefix3 !== "data-" && prefix3 !== "aria-")
                    return;
              }
              target.push(attributeSeparator2, name2, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
            }
          }
      }
    }
    function pushInnerHTML2(target, innerHTML, children) {
      if (innerHTML != null) {
        if (children != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof innerHTML !== "object" || !("__html" in innerHTML))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
        innerHTML = innerHTML.__html;
        innerHTML !== null && innerHTML !== undefined && (checkHtmlStringCoercion2(innerHTML), target.push("" + innerHTML));
      }
    }
    function checkSelectProp2(props, propName) {
      var value = props[propName];
      value != null && (value = isArrayImpl2(value), props.multiple && !value ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && value && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName));
    }
    function flattenOptionChildren2(children) {
      var content = "";
      React2.Children.forEach(children, function(child) {
        child != null && (content += child, didWarnInvalidOptionChildren2 || typeof child === "string" || typeof child === "number" || typeof child === "bigint" || (didWarnInvalidOptionChildren2 = true, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      });
      return content;
    }
    function injectFormReplayingRuntime2(resumableState, renderState) {
      (resumableState.instructions & 16) === NothingSent2 && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(renderState.startInlineScript, formReplayingRuntimeScript2, "</script>"));
    }
    function pushLinkImpl2(target, props) {
      target.push(startChunkForTag2("link"));
      for (var propKey in props)
        if (hasOwnProperty3.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTagSelfClosing2);
      return null;
    }
    function escapeStyleTextContent2(styleText) {
      checkHtmlStringCoercion2(styleText);
      return ("" + styleText).replace(styleRegex2, styleReplacer2);
    }
    function pushSelfClosing2(target, props, tag2) {
      target.push(startChunkForTag2(tag2));
      for (var propKey in props)
        if (hasOwnProperty3.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(tag2 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTagSelfClosing2);
      return null;
    }
    function pushTitleImpl2(target, props) {
      target.push(startChunkForTag2("title"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty3.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
      typeof props !== "function" && typeof props !== "symbol" && props !== null && props !== undefined && target.push(escapeTextForBrowser2("" + props));
      pushInnerHTML2(target, innerHTML, children);
      target.push(endChunkForTag2("title"));
      return null;
    }
    function pushScriptImpl2(target, props) {
      target.push(startChunkForTag2("script"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty3.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      children != null && typeof children !== "string" && (props = typeof children === "number" ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error("A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.", props));
      pushInnerHTML2(target, innerHTML, children);
      typeof children === "string" && target.push(escapeEntireInlineScriptContent2(children));
      target.push(endChunkForTag2("script"));
      return null;
    }
    function pushStartSingletonElement2(target, props, tag2) {
      target.push(startChunkForTag2(tag2));
      var innerHTML = tag2 = null, propKey;
      for (propKey in props)
        if (hasOwnProperty3.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                tag2 = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      pushInnerHTML2(target, innerHTML, tag2);
      return tag2;
    }
    function pushStartGenericElement2(target, props, tag2) {
      target.push(startChunkForTag2(tag2));
      var innerHTML = tag2 = null, propKey;
      for (propKey in props)
        if (hasOwnProperty3.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                tag2 = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      pushInnerHTML2(target, innerHTML, tag2);
      return typeof tag2 === "string" ? (target.push(escapeTextForBrowser2(tag2)), null) : tag2;
    }
    function startChunkForTag2(tag2) {
      var tagStartChunk = validatedTagCache2.get(tag2);
      if (tagStartChunk === undefined) {
        if (!VALID_TAG_REGEX2.test(tag2))
          throw Error("Invalid tag: " + tag2);
        tagStartChunk = "<" + tag2;
        validatedTagCache2.set(tag2, tagStartChunk);
      }
      return tagStartChunk;
    }
    function pushStartInstance2(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
      validateProperties$22(type, props);
      type !== "input" && type !== "textarea" && type !== "select" || props == null || props.value !== null || didWarnValueNull2 || (didWarnValueNull2 = true, type === "select" && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      b:
        if (type.indexOf("-") === -1)
          var JSCompiler_inline_result = false;
        else
          switch (type) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              JSCompiler_inline_result = false;
              break b;
            default:
              JSCompiler_inline_result = true;
          }
      JSCompiler_inline_result || typeof props.is === "string" || warnUnknownProperties2(type, props, null);
      !props.suppressContentEditableWarning && props.contentEditable && props.children != null && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
      formatContext.insertionMode !== SVG_MODE2 && formatContext.insertionMode !== MATHML_MODE2 && type.indexOf("-") === -1 && type.toLowerCase() !== type && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
      switch (type) {
        case "div":
        case "span":
        case "svg":
        case "path":
          break;
        case "a":
          target$jscomp$0.push(startChunkForTag2("a"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty3.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue != null)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "href":
                    propValue === "" ? pushStringAttribute2(target$jscomp$0, "href", "") : pushAttribute2(target$jscomp$0, propKey, propValue);
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey, propValue);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML, children);
          if (typeof children === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children));
            var JSCompiler_inline_result$jscomp$0 = null;
          } else
            JSCompiler_inline_result$jscomp$0 = children;
          return JSCompiler_inline_result$jscomp$0;
        case "g":
        case "p":
        case "li":
          break;
        case "select":
          checkControlledValueProps2("select", props);
          checkSelectProp2(props, "value");
          checkSelectProp2(props, "defaultValue");
          props.value === undefined || props.defaultValue === undefined || didWarnDefaultSelectValue2 || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultSelectValue2 = true);
          target$jscomp$0.push(startChunkForTag2("select"));
          var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
          for (propKey$jscomp$0 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$0)) {
              var propValue$jscomp$0 = props[propKey$jscomp$0];
              if (propValue$jscomp$0 != null)
                switch (propKey$jscomp$0) {
                  case "children":
                    children$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
          return children$jscomp$0;
        case "option":
          var selectedValue = formatContext.selectedValue;
          target$jscomp$0.push(startChunkForTag2("option"));
          var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
          for (propKey$jscomp$1 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$1)) {
              var propValue$jscomp$1 = props[propKey$jscomp$1];
              if (propValue$jscomp$1 != null)
                switch (propKey$jscomp$1) {
                  case "children":
                    children$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "selected":
                    selected = propValue$jscomp$1;
                    didWarnSelectedSetOnOption2 || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption2 = true);
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "value":
                    value = propValue$jscomp$1;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
                }
            }
          if (selectedValue != null) {
            if (value !== null) {
              checkAttributeStringCoercion2(value, "value");
              var stringValue = "" + value;
            } else
              innerHTML$jscomp$1 === null || didWarnInvalidOptionInnerHTML2 || (didWarnInvalidOptionInnerHTML2 = true, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")), stringValue = flattenOptionChildren2(children$jscomp$1);
            if (isArrayImpl2(selectedValue))
              for (var i = 0;i < selectedValue.length; i++) {
                if (checkAttributeStringCoercion2(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                  target$jscomp$0.push(' selected=""');
                  break;
                }
              }
            else
              checkAttributeStringCoercion2(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
          } else
            selected && target$jscomp$0.push(' selected=""');
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
          return children$jscomp$1;
        case "textarea":
          checkControlledValueProps2("textarea", props);
          props.value === undefined || props.defaultValue === undefined || didWarnDefaultTextareaValue2 || (console.error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultTextareaValue2 = true);
          target$jscomp$0.push(startChunkForTag2("textarea"));
          var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
          for (propKey$jscomp$2 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$2)) {
              var propValue$jscomp$2 = props[propKey$jscomp$2];
              if (propValue$jscomp$2 != null)
                switch (propKey$jscomp$2) {
                  case "children":
                    children$jscomp$2 = propValue$jscomp$2;
                    break;
                  case "value":
                    value$jscomp$0 = propValue$jscomp$2;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$jscomp$2;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
                }
            }
          value$jscomp$0 === null && defaultValue !== null && (value$jscomp$0 = defaultValue);
          target$jscomp$0.push(endOfStartTag2);
          if (children$jscomp$2 != null) {
            console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            if (value$jscomp$0 != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (isArrayImpl2(children$jscomp$2)) {
              if (1 < children$jscomp$2.length)
                throw Error("<textarea> can only have at most one child.");
              checkHtmlStringCoercion2(children$jscomp$2[0]);
              value$jscomp$0 = "" + children$jscomp$2[0];
            }
            checkHtmlStringCoercion2(children$jscomp$2);
            value$jscomp$0 = "" + children$jscomp$2;
          }
          typeof value$jscomp$0 === "string" && value$jscomp$0[0] === `
` && target$jscomp$0.push(leadingNewline);
          value$jscomp$0 !== null && (checkAttributeStringCoercion2(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser2("" + value$jscomp$0)));
          return null;
        case "input":
          checkControlledValueProps2("input", props);
          target$jscomp$0.push(startChunkForTag2("input"));
          var name2 = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
          for (propKey$jscomp$3 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$3)) {
              var propValue$jscomp$3 = props[propKey$jscomp$3];
              if (propValue$jscomp$3 != null)
                switch (propKey$jscomp$3) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  case "name":
                    name2 = propValue$jscomp$3;
                    break;
                  case "formAction":
                    formAction = propValue$jscomp$3;
                    break;
                  case "formEncType":
                    formEncType = propValue$jscomp$3;
                    break;
                  case "formMethod":
                    formMethod = propValue$jscomp$3;
                    break;
                  case "formTarget":
                    formTarget = propValue$jscomp$3;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$jscomp$3;
                    break;
                  case "defaultValue":
                    defaultValue$jscomp$0 = propValue$jscomp$3;
                    break;
                  case "checked":
                    checked = propValue$jscomp$3;
                    break;
                  case "value":
                    value$jscomp$1 = propValue$jscomp$3;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
                }
            }
          formAction === null || props.type === "image" || props.type === "submit" || didWarnFormActionType2 || (didWarnFormActionType2 = true, console.error('An input can only specify a formAction along with type="submit" or type="image".'));
          var formData = pushFormActionAttribute2(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name2);
          checked === null || defaultChecked === null || didWarnDefaultChecked2 || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultChecked2 = true);
          value$jscomp$1 === null || defaultValue$jscomp$0 === null || didWarnDefaultInputValue2 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultInputValue2 = true);
          checked !== null ? pushBooleanAttribute2(target$jscomp$0, "checked", checked) : defaultChecked !== null && pushBooleanAttribute2(target$jscomp$0, "checked", defaultChecked);
          value$jscomp$1 !== null ? pushAttribute2(target$jscomp$0, "value", value$jscomp$1) : defaultValue$jscomp$0 !== null && pushAttribute2(target$jscomp$0, "value", defaultValue$jscomp$0);
          target$jscomp$0.push(endOfStartTagSelfClosing2);
          formData != null && formData.forEach(pushAdditionalFormField2, target$jscomp$0);
          return null;
        case "button":
          target$jscomp$0.push(startChunkForTag2("button"));
          var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
          for (propKey$jscomp$4 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$4)) {
              var propValue$jscomp$4 = props[propKey$jscomp$4];
              if (propValue$jscomp$4 != null)
                switch (propKey$jscomp$4) {
                  case "children":
                    children$jscomp$3 = propValue$jscomp$4;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$2 = propValue$jscomp$4;
                    break;
                  case "name":
                    name$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formAction":
                    formAction$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formEncType":
                    formEncType$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formMethod":
                    formMethod$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formTarget":
                    formTarget$jscomp$0 = propValue$jscomp$4;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
                }
            }
          formAction$jscomp$0 === null || props.type == null || props.type === "submit" || didWarnFormActionType2 || (didWarnFormActionType2 = true, console.error('A button can only specify a formAction along with type="submit" or no type.'));
          var formData$jscomp$0 = pushFormActionAttribute2(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
          target$jscomp$0.push(endOfStartTag2);
          formData$jscomp$0 != null && formData$jscomp$0.forEach(pushAdditionalFormField2, target$jscomp$0);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
          if (typeof children$jscomp$3 === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children$jscomp$3));
            var JSCompiler_inline_result$jscomp$1 = null;
          } else
            JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
          return JSCompiler_inline_result$jscomp$1;
        case "form":
          target$jscomp$0.push(startChunkForTag2("form"));
          var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
          for (propKey$jscomp$5 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$5)) {
              var propValue$jscomp$5 = props[propKey$jscomp$5];
              if (propValue$jscomp$5 != null)
                switch (propKey$jscomp$5) {
                  case "children":
                    children$jscomp$4 = propValue$jscomp$5;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$3 = propValue$jscomp$5;
                    break;
                  case "action":
                    formAction$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "encType":
                    formEncType$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "method":
                    formMethod$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "target":
                    formTarget$jscomp$1 = propValue$jscomp$5;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
                }
            }
          var formData$jscomp$1 = null, formActionName = null;
          if (typeof formAction$jscomp$1 === "function") {
            formEncType$jscomp$1 === null && formMethod$jscomp$1 === null || didWarnFormActionMethod2 || (didWarnFormActionMethod2 = true, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."));
            formTarget$jscomp$1 === null || didWarnFormActionTarget2 || (didWarnFormActionTarget2 = true, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."));
            var customFields = getCustomFormFields2(resumableState, formAction$jscomp$1);
            customFields !== null ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator2, "action", attributeAssign2, actionJavaScriptURL2, attributeEnd2), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime2(resumableState, renderState));
          }
          formAction$jscomp$1 != null && pushAttribute2(target$jscomp$0, "action", formAction$jscomp$1);
          formEncType$jscomp$1 != null && pushAttribute2(target$jscomp$0, "encType", formEncType$jscomp$1);
          formMethod$jscomp$1 != null && pushAttribute2(target$jscomp$0, "method", formMethod$jscomp$1);
          formTarget$jscomp$1 != null && pushAttribute2(target$jscomp$0, "target", formTarget$jscomp$1);
          target$jscomp$0.push(endOfStartTag2);
          formActionName !== null && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute2(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing2), formData$jscomp$1 != null && formData$jscomp$1.forEach(pushAdditionalFormField2, target$jscomp$0));
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
          if (typeof children$jscomp$4 === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children$jscomp$4));
            var JSCompiler_inline_result$jscomp$2 = null;
          } else
            JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
          return JSCompiler_inline_result$jscomp$2;
        case "menuitem":
          target$jscomp$0.push(startChunkForTag2("menuitem"));
          for (var propKey$jscomp$6 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$6)) {
              var propValue$jscomp$6 = props[propKey$jscomp$6];
              if (propValue$jscomp$6 != null)
                switch (propKey$jscomp$6) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          return null;
        case "object":
          target$jscomp$0.push(startChunkForTag2("object"));
          var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
          for (propKey$jscomp$7 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$7)) {
              var propValue$jscomp$7 = props[propKey$jscomp$7];
              if (propValue$jscomp$7 != null)
                switch (propKey$jscomp$7) {
                  case "children":
                    children$jscomp$5 = propValue$jscomp$7;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$4 = propValue$jscomp$7;
                    break;
                  case "data":
                    checkAttributeStringCoercion2(propValue$jscomp$7, "data");
                    var sanitizedValue = sanitizeURL2("" + propValue$jscomp$7);
                    if (sanitizedValue === "") {
                      console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', propKey$jscomp$7, propKey$jscomp$7);
                      break;
                    }
                    target$jscomp$0.push(attributeSeparator2, "data", attributeAssign2, escapeTextForBrowser2(sanitizedValue), attributeEnd2);
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
          if (typeof children$jscomp$5 === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children$jscomp$5));
            var JSCompiler_inline_result$jscomp$3 = null;
          } else
            JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
          return JSCompiler_inline_result$jscomp$3;
        case "title":
          var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
          if (hasOwnProperty3.call(props, "children")) {
            var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.", children$jscomp$6.length) : typeof child === "function" || typeof child === "symbol" ? console.error("React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.", typeof child === "function" ? "a Function" : "a Sybmol") : child && child.toString === {}.toString && (child.$$typeof != null ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.") : console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."));
          }
          if (insertionMode === SVG_MODE2 || noscriptTagInScope || props.itemProp != null)
            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl2(target$jscomp$0, props);
          else
            isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl2(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = undefined);
          return JSCompiler_inline_result$jscomp$4;
        case "link":
          var { rel, href, precedence } = props;
          if (formatContext.insertionMode === SVG_MODE2 || formatContext.tagScope & 1 || props.itemProp != null || typeof rel !== "string" || typeof href !== "string" || href === "") {
            rel === "stylesheet" && typeof props.precedence === "string" && (typeof href === "string" && href || console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', href === null ? "`null`" : href === undefined ? "`undefined`" : href === "" ? "an empty string" : 'something with type "' + typeof href + '"'));
            pushLinkImpl2(target$jscomp$0, props);
            var JSCompiler_inline_result$jscomp$5 = null;
          } else if (props.rel === "stylesheet")
            if (typeof precedence !== "string" || props.disabled != null || props.onLoad || props.onError) {
              if (typeof precedence === "string") {
                if (props.disabled != null)
                  console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');
                else if (props.onLoad || props.onError) {
                  var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                  console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);
                }
              }
              JSCompiler_inline_result$jscomp$5 = pushLinkImpl2(target$jscomp$0, props);
            } else {
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
              if (resourceState !== EXISTS2) {
                resumableState.styleResources[href] = EXISTS2;
                styleQueue || (styleQueue = {
                  precedence: escapeTextForBrowser2(precedence),
                  rules: [],
                  hrefs: [],
                  sheets: new Map
                }, renderState.styles.set(precedence, styleQueue));
                var resource = {
                  state: PENDING$12,
                  props: assign2({}, props, {
                    "data-precedence": props.precedence,
                    precedence: null
                  })
                };
                if (resourceState) {
                  resourceState.length === 2 && adoptPreloadCredentials2(resource.props, resourceState);
                  var preloadResource = renderState.preloads.stylesheets.get(href);
                  preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED2;
                }
                styleQueue.sheets.set(href, resource);
                hoistableState && hoistableState.stylesheets.add(resource);
              } else if (styleQueue) {
                var _resource = styleQueue.sheets.get(href);
                _resource && hoistableState && hoistableState.stylesheets.add(_resource);
              }
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$5 = null;
            }
          else
            props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl2(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl2(renderState.hoistableChunks, props));
          return JSCompiler_inline_result$jscomp$5;
        case "script":
          var asyncProp = props.async;
          if (typeof props.src !== "string" || !props.src || !asyncProp || typeof asyncProp === "function" || typeof asyncProp === "symbol" || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE2 || formatContext.tagScope & 1 || props.itemProp != null)
            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl2(target$jscomp$0, props);
          else {
            var key = props.src;
            if (props.type === "module") {
              var resources = resumableState.moduleScriptResources;
              var preloads = renderState.preloads.moduleScripts;
            } else
              resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
            var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : undefined;
            if (resourceState$jscomp$0 !== EXISTS2) {
              resources[key] = EXISTS2;
              var scriptProps = props;
              if (resourceState$jscomp$0) {
                resourceState$jscomp$0.length === 2 && (scriptProps = assign2({}, props), adoptPreloadCredentials2(scriptProps, resourceState$jscomp$0));
                var preloadResource$jscomp$0 = preloads.get(key);
                preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
              }
              var resource$jscomp$0 = [];
              renderState.scripts.add(resource$jscomp$0);
              pushScriptImpl2(resource$jscomp$0, scriptProps);
            }
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$6 = null;
          }
          return JSCompiler_inline_result$jscomp$6;
        case "style":
          var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
          if (hasOwnProperty3.call(props, "children")) {
            var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
            (typeof child$jscomp$0 === "function" || typeof child$jscomp$0 === "symbol" || Array.isArray(child$jscomp$0)) && console.error("React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.", typeof child$jscomp$0 === "function" ? "a Function" : typeof child$jscomp$0 === "symbol" ? "a Sybmol" : "an Array");
          }
          var { precedence: precedence$jscomp$0, href: href$jscomp$0 } = props;
          if (insertionMode$jscomp$0 === SVG_MODE2 || noscriptTagInScope$jscomp$0 || props.itemProp != null || typeof precedence$jscomp$0 !== "string" || typeof href$jscomp$0 !== "string" || href$jscomp$0 === "") {
            target$jscomp$0.push(startChunkForTag2("style"));
            var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
            for (propKey$jscomp$8 in props)
              if (hasOwnProperty3.call(props, propKey$jscomp$8)) {
                var propValue$jscomp$8 = props[propKey$jscomp$8];
                if (propValue$jscomp$8 != null)
                  switch (propKey$jscomp$8) {
                    case "children":
                      children$jscomp$8 = propValue$jscomp$8;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$5 = propValue$jscomp$8;
                      break;
                    default:
                      pushAttribute2(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
                  }
              }
            target$jscomp$0.push(endOfStartTag2);
            var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
            typeof child$jscomp$1 !== "function" && typeof child$jscomp$1 !== "symbol" && child$jscomp$1 !== null && child$jscomp$1 !== undefined && target$jscomp$0.push(escapeStyleTextContent2(child$jscomp$1));
            pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$8);
            target$jscomp$0.push(endChunkForTag2("style"));
            var JSCompiler_inline_result$jscomp$7 = null;
          } else {
            href$jscomp$0.includes(" ") && console.error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".', href$jscomp$0);
            var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : undefined;
            if (resourceState$jscomp$1 !== EXISTS2) {
              resumableState.styleResources[href$jscomp$0] = EXISTS2;
              resourceState$jscomp$1 && console.error('React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.', href$jscomp$0);
              styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser2(href$jscomp$0)) : (styleQueue$jscomp$0 = {
                precedence: escapeTextForBrowser2(precedence$jscomp$0),
                rules: [],
                hrefs: [escapeTextForBrowser2(href$jscomp$0)],
                sheets: new Map
              }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
              var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
              for (propKey$jscomp$9 in props)
                if (hasOwnProperty3.call(props, propKey$jscomp$9)) {
                  var propValue$jscomp$9 = props[propKey$jscomp$9];
                  if (propValue$jscomp$9 != null)
                    switch (propKey$jscomp$9) {
                      case "children":
                        children$jscomp$9 = propValue$jscomp$9;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$6 = propValue$jscomp$9;
                    }
                }
              var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
              typeof child$jscomp$2 !== "function" && typeof child$jscomp$2 !== "symbol" && child$jscomp$2 !== null && child$jscomp$2 !== undefined && target.push(escapeStyleTextContent2(child$jscomp$2));
              pushInnerHTML2(target, innerHTML$jscomp$6, children$jscomp$9);
            }
            styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$7 = undefined;
          }
          return JSCompiler_inline_result$jscomp$7;
        case "meta":
          if (formatContext.insertionMode === SVG_MODE2 || formatContext.tagScope & 1 || props.itemProp != null)
            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing2(target$jscomp$0, props, "meta");
          else
            textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback ? null : typeof props.charSet === "string" ? pushSelfClosing2(renderState.charsetChunks, props, "meta") : props.name === "viewport" ? pushSelfClosing2(renderState.viewportChunks, props, "meta") : pushSelfClosing2(renderState.hoistableChunks, props, "meta");
          return JSCompiler_inline_result$jscomp$8;
        case "listing":
        case "pre":
          target$jscomp$0.push(startChunkForTag2(type));
          var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
          for (propKey$jscomp$10 in props)
            if (hasOwnProperty3.call(props, propKey$jscomp$10)) {
              var propValue$jscomp$10 = props[propKey$jscomp$10];
              if (propValue$jscomp$10 != null)
                switch (propKey$jscomp$10) {
                  case "children":
                    children$jscomp$10 = propValue$jscomp$10;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$7 = propValue$jscomp$10;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          if (innerHTML$jscomp$7 != null) {
            if (children$jscomp$10 != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof innerHTML$jscomp$7 !== "object" || !("__html" in innerHTML$jscomp$7))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            var html2 = innerHTML$jscomp$7.__html;
            html2 !== null && html2 !== undefined && (typeof html2 === "string" && 0 < html2.length && html2[0] === `
` ? target$jscomp$0.push(leadingNewline, html2) : (checkHtmlStringCoercion2(html2), target$jscomp$0.push("" + html2)));
          }
          typeof children$jscomp$10 === "string" && children$jscomp$10[0] === `
` && target$jscomp$0.push(leadingNewline);
          return children$jscomp$10;
        case "img":
          var { src, srcSet } = props;
          if (!(props.loading === "lazy" || !src && !srcSet || typeof src !== "string" && src != null || typeof srcSet !== "string" && srcSet != null) && props.fetchPriority !== "low" && !!(formatContext.tagScope & 3) === false && (typeof src !== "string" || src[4] !== ":" || src[0] !== "d" && src[0] !== "D" || src[1] !== "a" && src[1] !== "A" || src[2] !== "t" && src[2] !== "T" || src[3] !== "a" && src[3] !== "A") && (typeof srcSet !== "string" || srcSet[4] !== ":" || srcSet[0] !== "d" && srcSet[0] !== "D" || srcSet[1] !== "a" && srcSet[1] !== "A" || srcSet[2] !== "t" && srcSet[2] !== "T" || srcSet[3] !== "a" && srcSet[3] !== "A")) {
            var sizes = typeof props.sizes === "string" ? props.sizes : undefined, key$jscomp$0 = srcSet ? srcSet + `
` + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
            if (resource$jscomp$1) {
              if (props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size)
                promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
            } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS2;
              var input = props.crossOrigin;
              var crossOrigin = typeof input === "string" ? input === "use-credentials" ? input : "" : undefined;
              var headers = renderState.headers, header;
              headers && 0 < headers.remainingCapacity && typeof props.srcSet !== "string" && (props.fetchPriority === "high" || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader2(src, "image", {
                imageSrcSet: props.srcSet,
                imageSizes: props.sizes,
                crossOrigin,
                integrity: props.integrity,
                nonce: props.nonce,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.refererPolicy
              }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS2, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl2(resource$jscomp$1, {
                rel: "preload",
                as: "image",
                href: srcSet ? undefined : src,
                imageSrcSet: srcSet,
                imageSizes: sizes,
                crossOrigin,
                integrity: props.integrity,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.referrerPolicy
              }), props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
            }
          }
          return pushSelfClosing2(target$jscomp$0, props, "img");
        case "base":
        case "area":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return pushSelfClosing2(target$jscomp$0, props, type);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          break;
        case "head":
          if (formatContext.insertionMode < HTML_MODE2) {
            var preamble = preambleState || renderState.preamble;
            if (preamble.headChunks)
              throw Error("The `<head>` tag may only be rendered once.");
            preamble.headChunks = [];
            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement2(preamble.headChunks, props, "head");
          } else
            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement2(target$jscomp$0, props, "head");
          return JSCompiler_inline_result$jscomp$9;
        case "body":
          if (formatContext.insertionMode < HTML_MODE2) {
            var preamble$jscomp$0 = preambleState || renderState.preamble;
            if (preamble$jscomp$0.bodyChunks)
              throw Error("The `<body>` tag may only be rendered once.");
            preamble$jscomp$0.bodyChunks = [];
            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement2(preamble$jscomp$0.bodyChunks, props, "body");
          } else
            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement2(target$jscomp$0, props, "body");
          return JSCompiler_inline_result$jscomp$10;
        case "html":
          if (formatContext.insertionMode === ROOT_HTML_MODE2) {
            var preamble$jscomp$1 = preambleState || renderState.preamble;
            if (preamble$jscomp$1.htmlChunks)
              throw Error("The `<html>` tag may only be rendered once.");
            preamble$jscomp$1.htmlChunks = [doctypeChunk];
            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement2(preamble$jscomp$1.htmlChunks, props, "html");
          } else
            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement2(target$jscomp$0, props, "html");
          return JSCompiler_inline_result$jscomp$11;
        default:
          if (type.indexOf("-") !== -1) {
            target$jscomp$0.push(startChunkForTag2(type));
            var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
            for (propKey$jscomp$11 in props)
              if (hasOwnProperty3.call(props, propKey$jscomp$11)) {
                var propValue$jscomp$11 = props[propKey$jscomp$11];
                if (propValue$jscomp$11 != null) {
                  var attributeName = propKey$jscomp$11;
                  switch (propKey$jscomp$11) {
                    case "children":
                      children$jscomp$11 = propValue$jscomp$11;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$8 = propValue$jscomp$11;
                      break;
                    case "style":
                      pushStyleAttribute2(target$jscomp$0, propValue$jscomp$11);
                      break;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "ref":
                      break;
                    case "className":
                      attributeName = "class";
                    default:
                      if (isAttributeNameSafe2(propKey$jscomp$11) && typeof propValue$jscomp$11 !== "function" && typeof propValue$jscomp$11 !== "symbol" && propValue$jscomp$11 !== false) {
                        if (propValue$jscomp$11 === true)
                          propValue$jscomp$11 = "";
                        else if (typeof propValue$jscomp$11 === "object")
                          continue;
                        target$jscomp$0.push(attributeSeparator2, attributeName, attributeAssign2, escapeTextForBrowser2(propValue$jscomp$11), attributeEnd2);
                      }
                  }
                }
              }
            target$jscomp$0.push(endOfStartTag2);
            pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$11);
            return children$jscomp$11;
          }
      }
      return pushStartGenericElement2(target$jscomp$0, props, type);
    }
    function endChunkForTag2(tag2) {
      var chunk = endTagCache2.get(tag2);
      chunk === undefined && (chunk = "</" + tag2 + ">", endTagCache2.set(tag2, chunk));
      return chunk;
    }
    function hoistPreambleState2(renderState, preambleState) {
      renderState = renderState.preamble;
      renderState.htmlChunks === null && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
      renderState.headChunks === null && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
      renderState.bodyChunks === null && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
    }
    function writeBootstrap2(destination, renderState) {
      renderState = renderState.bootstrapChunks;
      for (var i = 0;i < renderState.length - 1; i++)
        destination.push(renderState[i]);
      return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : true;
    }
    function writeStartPendingSuspenseBoundary2(destination, renderState, id) {
      destination.push(startPendingSuspenseBoundary12);
      if (id === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      destination.push(renderState.boundaryPrefix);
      renderState = id.toString(16);
      destination.push(renderState);
      return destination.push(startPendingSuspenseBoundary22);
    }
    function writePreambleContribution2(destination, preambleState) {
      preambleState = preambleState.contribution;
      preambleState !== NoContribution2 && (destination.push(boundaryPreambleContributionChunkStart2), destination.push("" + preambleState), destination.push(boundaryPreambleContributionChunkEnd2));
    }
    function writeStartSegment2(destination, renderState, formatContext, id) {
      switch (formatContext.insertionMode) {
        case ROOT_HTML_MODE2:
        case HTML_HTML_MODE2:
        case HTML_HEAD_MODE2:
        case HTML_MODE2:
          return destination.push(startSegmentHTML3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentHTML22);
        case SVG_MODE2:
          return destination.push(startSegmentSVG3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentSVG22);
        case MATHML_MODE2:
          return destination.push(startSegmentMathML3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentMathML22);
        case HTML_TABLE_MODE2:
          return destination.push(startSegmentTable3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTable22);
        case HTML_TABLE_BODY_MODE2:
          return destination.push(startSegmentTableBody3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableBody22);
        case HTML_TABLE_ROW_MODE2:
          return destination.push(startSegmentTableRow3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableRow22);
        case HTML_COLGROUP_MODE2:
          return destination.push(startSegmentColGroup3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentColGroup22);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function writeEndSegment2(destination, formatContext) {
      switch (formatContext.insertionMode) {
        case ROOT_HTML_MODE2:
        case HTML_HTML_MODE2:
        case HTML_HEAD_MODE2:
        case HTML_MODE2:
          return destination.push(endSegmentHTML2);
        case SVG_MODE2:
          return destination.push(endSegmentSVG2);
        case MATHML_MODE2:
          return destination.push(endSegmentMathML2);
        case HTML_TABLE_MODE2:
          return destination.push(endSegmentTable2);
        case HTML_TABLE_BODY_MODE2:
          return destination.push(endSegmentTableBody2);
        case HTML_TABLE_ROW_MODE2:
          return destination.push(endSegmentTableRow2);
        case HTML_COLGROUP_MODE2:
          return destination.push(endSegmentColGroup2);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function escapeJSStringsForInstructionScripts2(input) {
      return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts2, function(match) {
        switch (match) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function escapeJSObjectForInstructionScripts2(input) {
      return JSON.stringify(input).replace(regexForJSStringsInScripts2, function(match) {
        switch (match) {
          case "&":
            return "\\u0026";
          case ">":
            return "\\u003e";
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function flushStyleTagsLateForBoundary2(styleQueue) {
      var { rules, hrefs } = styleQueue;
      0 < rules.length && hrefs.length === 0 && console.error("React expected to have at least one href for an a hoistable style but found none. This is a bug in React.");
      var i = 0;
      if (hrefs.length) {
        this.push(lateStyleTagResourceOpen12);
        this.push(styleQueue.precedence);
        for (this.push(lateStyleTagResourceOpen22);i < hrefs.length - 1; i++)
          this.push(hrefs[i]), this.push(spaceSeparator2);
        this.push(hrefs[i]);
        this.push(lateStyleTagResourceOpen32);
        for (i = 0;i < rules.length; i++)
          this.push(rules[i]);
        destinationHasCapacity2 = this.push(lateStyleTagTemplateClose2);
        currentlyRenderingBoundaryHasStylesToHoist2 = true;
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function hasStylesToHoist2(stylesheet) {
      return stylesheet.state !== PREAMBLE2 ? currentlyRenderingBoundaryHasStylesToHoist2 = true : false;
    }
    function writeHoistablesForBoundary2(destination, hoistableState, renderState) {
      currentlyRenderingBoundaryHasStylesToHoist2 = false;
      destinationHasCapacity2 = true;
      hoistableState.styles.forEach(flushStyleTagsLateForBoundary2, destination);
      hoistableState.stylesheets.forEach(hasStylesToHoist2);
      currentlyRenderingBoundaryHasStylesToHoist2 && (renderState.stylesToHoist = true);
      return destinationHasCapacity2;
    }
    function flushResource2(resource) {
      for (var i = 0;i < resource.length; i++)
        this.push(resource[i]);
      resource.length = 0;
    }
    function flushStyleInPreamble2(stylesheet) {
      pushLinkImpl2(stylesheetFlushingQueue2, stylesheet.props);
      for (var i = 0;i < stylesheetFlushingQueue2.length; i++)
        this.push(stylesheetFlushingQueue2[i]);
      stylesheetFlushingQueue2.length = 0;
      stylesheet.state = PREAMBLE2;
    }
    function flushStylesInPreamble2(styleQueue) {
      var hasStylesheets = 0 < styleQueue.sheets.size;
      styleQueue.sheets.forEach(flushStyleInPreamble2, this);
      styleQueue.sheets.clear();
      var { rules, hrefs } = styleQueue;
      if (!hasStylesheets || hrefs.length) {
        this.push(styleTagResourceOpen12);
        this.push(styleQueue.precedence);
        styleQueue = 0;
        if (hrefs.length) {
          for (this.push(styleTagResourceOpen22);styleQueue < hrefs.length - 1; styleQueue++)
            this.push(hrefs[styleQueue]), this.push(spaceSeparator2);
          this.push(hrefs[styleQueue]);
        }
        this.push(styleTagResourceOpen32);
        for (styleQueue = 0;styleQueue < rules.length; styleQueue++)
          this.push(rules[styleQueue]);
        this.push(styleTagResourceClose2);
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function preloadLateStyle2(stylesheet) {
      if (stylesheet.state === PENDING$12) {
        stylesheet.state = PRELOADED2;
        var props = stylesheet.props;
        pushLinkImpl2(stylesheetFlushingQueue2, {
          rel: "preload",
          as: "style",
          href: stylesheet.props.href,
          crossOrigin: props.crossOrigin,
          fetchPriority: props.fetchPriority,
          integrity: props.integrity,
          media: props.media,
          hrefLang: props.hrefLang,
          referrerPolicy: props.referrerPolicy
        });
        for (stylesheet = 0;stylesheet < stylesheetFlushingQueue2.length; stylesheet++)
          this.push(stylesheetFlushingQueue2[stylesheet]);
        stylesheetFlushingQueue2.length = 0;
      }
    }
    function preloadLateStyles2(styleQueue) {
      styleQueue.sheets.forEach(preloadLateStyle2, this);
      styleQueue.sheets.clear();
    }
    function writeStyleResourceDependenciesInJS2(destination, hoistableState) {
      destination.push(arrayFirstOpenBracket2);
      var nextArrayOpenBrackChunk = arrayFirstOpenBracket2;
      hoistableState.stylesheets.forEach(function(resource) {
        if (resource.state !== PREAMBLE2)
          if (resource.state === LATE2)
            destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion2(resource, "href"), resource = escapeJSObjectForInstructionScripts2("" + resource), destination.push(resource), destination.push(arrayCloseBracket2), nextArrayOpenBrackChunk = arraySubsequentOpenBracket2;
          else {
            destination.push(nextArrayOpenBrackChunk);
            var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL2("" + resource.props.href);
            coercedHref = escapeJSObjectForInstructionScripts2(coercedHref);
            destination.push(coercedHref);
            checkAttributeStringCoercion2(precedence, "precedence");
            precedence = "" + precedence;
            destination.push(arrayInterstitial2);
            precedence = escapeJSObjectForInstructionScripts2(precedence);
            destination.push(precedence);
            for (var propKey in props)
              if (hasOwnProperty3.call(props, propKey) && (precedence = props[propKey], precedence != null))
                switch (propKey) {
                  case "href":
                  case "rel":
                  case "precedence":
                  case "data-precedence":
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    writeStyleResourceAttributeInJS2(destination, propKey, precedence);
                }
            destination.push(arrayCloseBracket2);
            nextArrayOpenBrackChunk = arraySubsequentOpenBracket2;
            resource.state = LATE2;
          }
      });
      destination.push(arrayCloseBracket2);
    }
    function writeStyleResourceAttributeInJS2(destination, name2, value) {
      var attributeName = name2.toLowerCase();
      switch (typeof value) {
        case "function":
        case "symbol":
          return;
      }
      switch (name2) {
        case "innerHTML":
        case "dangerouslySetInnerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "style":
        case "ref":
          return;
        case "className":
          attributeName = "class";
          checkAttributeStringCoercion2(value, attributeName);
          name2 = "" + value;
          break;
        case "hidden":
          if (value === false)
            return;
          name2 = "";
          break;
        case "src":
        case "href":
          value = sanitizeURL2(value);
          checkAttributeStringCoercion2(value, attributeName);
          name2 = "" + value;
          break;
        default:
          if (2 < name2.length && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N") || !isAttributeNameSafe2(name2))
            return;
          checkAttributeStringCoercion2(value, attributeName);
          name2 = "" + value;
      }
      destination.push(arrayInterstitial2);
      attributeName = escapeJSObjectForInstructionScripts2(attributeName);
      destination.push(attributeName);
      destination.push(arrayInterstitial2);
      attributeName = escapeJSObjectForInstructionScripts2(name2);
      destination.push(attributeName);
    }
    function createHoistableState2() {
      return { styles: new Set, stylesheets: new Set };
    }
    function preloadBootstrapScriptOrModule2(resumableState, renderState, href, props) {
      (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error('Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue', href);
      resumableState.scriptResources[href] = EXISTS2;
      resumableState.moduleScriptResources[href] = EXISTS2;
      resumableState = [];
      pushLinkImpl2(resumableState, props);
      renderState.bootstrapScripts.add(resumableState);
    }
    function adoptPreloadCredentials2(target, preloadState) {
      target.crossOrigin == null && (target.crossOrigin = preloadState[0]);
      target.integrity == null && (target.integrity = preloadState[1]);
    }
    function getPreloadAsHeader2(href, as2, params) {
      href = escapeHrefForLinkHeaderURLContext2(href);
      as2 = escapeStringForLinkHeaderQuotedParamValueContext2(as2, "as");
      as2 = "<" + href + '>; rel=preload; as="' + as2 + '"';
      for (var paramName in params)
        hasOwnProperty3.call(params, paramName) && (href = params[paramName], typeof href === "string" && (as2 += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext2(href, paramName) + '"'));
      return as2;
    }
    function escapeHrefForLinkHeaderURLContext2(hrefInput) {
      checkAttributeStringCoercion2(hrefInput, "href");
      return ("" + hrefInput).replace(regexForHrefInLinkHeaderURLContext2, escapeHrefForLinkHeaderURLContextReplacer2);
    }
    function escapeHrefForLinkHeaderURLContextReplacer2(match) {
      switch (match) {
        case "<":
          return "%3C";
        case ">":
          return "%3E";
        case `
`:
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    }
    function escapeStringForLinkHeaderQuotedParamValueContext2(value, name2) {
      willCoercionThrow2(value) && (console.error("The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.", name2, typeName2(value)), testStringCoercion2(value));
      return ("" + value).replace(regexForLinkHeaderQuotedParamValueContext2, escapeStringForLinkHeaderQuotedParamValueContextReplacer2);
    }
    function escapeStringForLinkHeaderQuotedParamValueContextReplacer2(match) {
      switch (match) {
        case '"':
          return "%22";
        case "'":
          return "%27";
        case ";":
          return "%3B";
        case ",":
          return "%2C";
        case `
`:
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    }
    function hoistStyleQueueDependency2(styleQueue) {
      this.styles.add(styleQueue);
    }
    function hoistStylesheetDependency2(stylesheet) {
      this.stylesheets.add(stylesheet);
    }
    function createRenderState2(resumableState, generateStaticMarkup) {
      var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
      bootstrapScriptContent !== undefined && bootstrapChunks.push("<script>", escapeEntireInlineScriptContent2(bootstrapScriptContent), "</script>");
      idPrefix = {
        placeholderPrefix: idPrefix + "P:",
        segmentPrefix: idPrefix + "S:",
        boundaryPrefix: idPrefix + "B:",
        startInlineScript: "<script>",
        preamble: createPreambleState2(),
        externalRuntimeScript: null,
        bootstrapChunks,
        importMapChunks: [],
        onHeaders: undefined,
        headers: null,
        resets: {
          font: {},
          dns: {},
          connect: { default: {}, anonymous: {}, credentials: {} },
          image: {},
          style: {}
        },
        charsetChunks: [],
        viewportChunks: [],
        hoistableChunks: [],
        preconnects: new Set,
        fontPreloads: new Set,
        highImagePreloads: new Set,
        styles: new Map,
        bootstrapScripts: new Set,
        scripts: new Set,
        bulkPreloads: new Set,
        preloads: {
          images: new Map,
          stylesheets: new Map,
          scripts: new Map,
          moduleScripts: new Map
        },
        nonce: undefined,
        hoistableState: null,
        stylesToHoist: false
      };
      if (bootstrapScripts !== undefined)
        for (bootstrapScriptContent = 0;bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
          var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = undefined, integrity = undefined, props = {
            rel: "preload",
            as: "script",
            fetchPriority: "low",
            nonce: undefined
          };
          typeof scriptConfig === "string" ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = typeof scriptConfig.integrity === "string" ? scriptConfig.integrity : undefined, props.crossOrigin = crossOrigin = typeof scriptConfig === "string" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === "use-credentials" ? "use-credentials" : "");
          preloadBootstrapScriptOrModule2(resumableState, idPrefix, src, props);
          bootstrapChunks.push('<script src="', escapeTextForBrowser2(src));
          typeof integrity === "string" && bootstrapChunks.push('" integrity="', escapeTextForBrowser2(integrity));
          typeof crossOrigin === "string" && bootstrapChunks.push('" crossorigin="', escapeTextForBrowser2(crossOrigin));
          bootstrapChunks.push('" async=""></script>');
        }
      if (bootstrapModules !== undefined)
        for (bootstrapScripts = 0;bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
          bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = undefined, integrity = {
            rel: "modulepreload",
            fetchPriority: "low",
            nonce: undefined
          }, typeof bootstrapScriptContent === "string" ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = typeof bootstrapScriptContent.integrity === "string" ? bootstrapScriptContent.integrity : undefined, integrity.crossOrigin = src = typeof bootstrapScriptContent === "string" || bootstrapScriptContent.crossOrigin == null ? undefined : bootstrapScriptContent.crossOrigin === "use-credentials" ? "use-credentials" : ""), preloadBootstrapScriptOrModule2(resumableState, idPrefix, scriptConfig, integrity), bootstrapChunks.push('<script type="module" src="', escapeTextForBrowser2(scriptConfig)), typeof crossOrigin === "string" && bootstrapChunks.push('" integrity="', escapeTextForBrowser2(crossOrigin)), typeof src === "string" && bootstrapChunks.push('" crossorigin="', escapeTextForBrowser2(src)), bootstrapChunks.push('" async=""></script>');
      return {
        placeholderPrefix: idPrefix.placeholderPrefix,
        segmentPrefix: idPrefix.segmentPrefix,
        boundaryPrefix: idPrefix.boundaryPrefix,
        startInlineScript: idPrefix.startInlineScript,
        preamble: idPrefix.preamble,
        externalRuntimeScript: idPrefix.externalRuntimeScript,
        bootstrapChunks: idPrefix.bootstrapChunks,
        importMapChunks: idPrefix.importMapChunks,
        onHeaders: idPrefix.onHeaders,
        headers: idPrefix.headers,
        resets: idPrefix.resets,
        charsetChunks: idPrefix.charsetChunks,
        viewportChunks: idPrefix.viewportChunks,
        hoistableChunks: idPrefix.hoistableChunks,
        preconnects: idPrefix.preconnects,
        fontPreloads: idPrefix.fontPreloads,
        highImagePreloads: idPrefix.highImagePreloads,
        styles: idPrefix.styles,
        bootstrapScripts: idPrefix.bootstrapScripts,
        scripts: idPrefix.scripts,
        bulkPreloads: idPrefix.bulkPreloads,
        preloads: idPrefix.preloads,
        stylesToHoist: idPrefix.stylesToHoist,
        generateStaticMarkup
      };
    }
    function pushTextInstance2(target, text2, renderState, textEmbedded) {
      if (renderState.generateStaticMarkup)
        return target.push(escapeTextForBrowser2(text2)), false;
      text2 === "" ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser2(text2)), target = true);
      return target;
    }
    function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
      renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
    }
    function getComponentNameFromType2(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE2 ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE2:
          return "Fragment";
        case REACT_PROFILER_TYPE2:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE2:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE2:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE2:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE2:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE2:
            return "Portal";
          case REACT_CONTEXT_TYPE2:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE2:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE2:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE2:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType2(type.type) || "Memo";
          case REACT_LAZY_TYPE2:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType2(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function popToNearestCommonAncestor2(prev, next) {
      if (prev !== next) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        var parentNext = next.parent;
        if (prev === null) {
          if (parentNext !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (parentNext === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          popToNearestCommonAncestor2(prev, parentNext);
        }
        next.context._currentValue2 = next.value;
      }
    }
    function popAllPrevious2(prev) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      prev !== null && popAllPrevious2(prev);
    }
    function pushAllNext2(next) {
      var parentNext = next.parent;
      parentNext !== null && pushAllNext2(parentNext);
      next.context._currentValue2 = next.value;
    }
    function popPreviousToCommonLevel2(prev, next) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      if (prev === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      prev.depth === next.depth ? popToNearestCommonAncestor2(prev, next) : popPreviousToCommonLevel2(prev, next);
    }
    function popNextToCommonLevel2(prev, next) {
      var parentNext = next.parent;
      if (parentNext === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      prev.depth === parentNext.depth ? popToNearestCommonAncestor2(prev, parentNext) : popNextToCommonLevel2(prev, parentNext);
      next.context._currentValue2 = next.value;
    }
    function switchContext2(newSnapshot) {
      var prev = currentActiveSnapshot2;
      prev !== newSnapshot && (prev === null ? pushAllNext2(newSnapshot) : newSnapshot === null ? popAllPrevious2(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor2(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel2(prev, newSnapshot) : popNextToCommonLevel2(prev, newSnapshot), currentActiveSnapshot2 = newSnapshot);
    }
    function warnOnInvalidCallback2(callback) {
      if (callback !== null && typeof callback !== "function") {
        var key = String(callback);
        didWarnOnInvalidCallback2.has(key) || (didWarnOnInvalidCallback2.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function warnNoop2(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType2(publicInstance) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnAboutNoopUpdateForComponent2[warningKey] || (console.error(`Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, publicInstance), didWarnAboutNoopUpdateForComponent2[warningKey] = true);
    }
    function pushTreeContext2(baseContext, totalChildren, index) {
      var baseIdWithLeadingBit = baseContext.id;
      baseContext = baseContext.overflow;
      var baseLength = 32 - clz322(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz322(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        return {
          id: 1 << 32 - clz322(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
          overflow: length + baseContext
        };
      }
      return {
        id: 1 << length | index << baseLength | baseIdWithLeadingBit,
        overflow: baseContext
      };
    }
    function clz32Fallback2(x2) {
      x2 >>>= 0;
      return x2 === 0 ? 32 : 31 - (log3(x2) / LN22 | 0) | 0;
    }
    function noop$22() {}
    function trackUsedThenable2(thenableState3, thenable, index) {
      index = thenableState3[index];
      index === undefined ? thenableState3.push(thenable) : index !== thenable && (thenable.then(noop$22, noop$22), thenable = index);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          typeof thenable.status === "string" ? thenable.then(noop$22, noop$22) : (thenableState3 = thenable, thenableState3.status = "pending", thenableState3.then(function(fulfilledValue) {
            if (thenable.status === "pending") {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          }, function(error2) {
            if (thenable.status === "pending") {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error2;
            }
          }));
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
          suspendedThenable2 = thenable;
          throw SuspenseException2;
      }
    }
    function getSuspendedThenable2() {
      if (suspendedThenable2 === null)
        throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable2;
      suspendedThenable2 = null;
      return thenable;
    }
    function is5(x2, y2) {
      return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    function resolveCurrentlyRenderingComponent2() {
      if (currentlyRenderingComponent2 === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      isInHookUserCodeInDev2 && console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
      return currentlyRenderingComponent2;
    }
    function createHook2() {
      if (0 < numberOfReRenders2)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function createWorkInProgressHook2() {
      workInProgressHook2 === null ? firstWorkInProgressHook2 === null ? (isReRender2 = false, firstWorkInProgressHook2 = workInProgressHook2 = createHook2()) : (isReRender2 = true, workInProgressHook2 = firstWorkInProgressHook2) : workInProgressHook2.next === null ? (isReRender2 = false, workInProgressHook2 = workInProgressHook2.next = createHook2()) : (isReRender2 = true, workInProgressHook2 = workInProgressHook2.next);
      return workInProgressHook2;
    }
    function getThenableStateAfterSuspending2() {
      var state = thenableState2;
      thenableState2 = null;
      return state;
    }
    function resetHooksState2() {
      isInHookUserCodeInDev2 = false;
      currentlyRenderingKeyPath2 = currentlyRenderingRequest2 = currentlyRenderingTask2 = currentlyRenderingComponent2 = null;
      didScheduleRenderPhaseUpdate2 = false;
      firstWorkInProgressHook2 = null;
      numberOfReRenders2 = 0;
      workInProgressHook2 = renderPhaseUpdates2 = null;
    }
    function readContext2(context) {
      isInHookUserCodeInDev2 && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return context._currentValue2;
    }
    function basicStateReducer2(state, action) {
      return typeof action === "function" ? action(state) : action;
    }
    function useReducer2(reducer, initialArg, init2) {
      reducer !== basicStateReducer2 && (currentHookNameInDev2 = "useReducer");
      currentlyRenderingComponent2 = resolveCurrentlyRenderingComponent2();
      workInProgressHook2 = createWorkInProgressHook2();
      if (isReRender2) {
        init2 = workInProgressHook2.queue;
        initialArg = init2.dispatch;
        if (renderPhaseUpdates2 !== null) {
          var firstRenderPhaseUpdate = renderPhaseUpdates2.get(init2);
          if (firstRenderPhaseUpdate !== undefined) {
            renderPhaseUpdates2.delete(init2);
            init2 = workInProgressHook2.memoizedState;
            do {
              var action = firstRenderPhaseUpdate.action;
              isInHookUserCodeInDev2 = true;
              init2 = reducer(init2, action);
              isInHookUserCodeInDev2 = false;
              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
            } while (firstRenderPhaseUpdate !== null);
            workInProgressHook2.memoizedState = init2;
            return [init2, initialArg];
          }
        }
        return [workInProgressHook2.memoizedState, initialArg];
      }
      isInHookUserCodeInDev2 = true;
      reducer = reducer === basicStateReducer2 ? typeof initialArg === "function" ? initialArg() : initialArg : init2 !== undefined ? init2(initialArg) : initialArg;
      isInHookUserCodeInDev2 = false;
      workInProgressHook2.memoizedState = reducer;
      reducer = workInProgressHook2.queue = { last: null, dispatch: null };
      reducer = reducer.dispatch = dispatchAction2.bind(null, currentlyRenderingComponent2, reducer);
      return [workInProgressHook2.memoizedState, reducer];
    }
    function useMemo2(nextCreate, deps) {
      currentlyRenderingComponent2 = resolveCurrentlyRenderingComponent2();
      workInProgressHook2 = createWorkInProgressHook2();
      deps = deps === undefined ? null : deps;
      if (workInProgressHook2 !== null) {
        var prevState = workInProgressHook2.memoizedState;
        if (prevState !== null && deps !== null) {
          a: {
            var JSCompiler_inline_result = prevState[1];
            if (JSCompiler_inline_result === null)
              console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev2), JSCompiler_inline_result = false;
            else {
              deps.length !== JSCompiler_inline_result.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev2, "[" + deps.join(", ") + "]", "[" + JSCompiler_inline_result.join(", ") + "]");
              for (var i = 0;i < JSCompiler_inline_result.length && i < deps.length; i++)
                if (!objectIs2(deps[i], JSCompiler_inline_result[i])) {
                  JSCompiler_inline_result = false;
                  break a;
                }
              JSCompiler_inline_result = true;
            }
          }
          if (JSCompiler_inline_result)
            return prevState[0];
        }
      }
      isInHookUserCodeInDev2 = true;
      nextCreate = nextCreate();
      isInHookUserCodeInDev2 = false;
      workInProgressHook2.memoizedState = [nextCreate, deps];
      return nextCreate;
    }
    function dispatchAction2(componentIdentity, queue, action) {
      if (25 <= numberOfReRenders2)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (componentIdentity === currentlyRenderingComponent2)
        if (didScheduleRenderPhaseUpdate2 = true, componentIdentity = { action, next: null }, renderPhaseUpdates2 === null && (renderPhaseUpdates2 = new Map), action = renderPhaseUpdates2.get(queue), action === undefined)
          renderPhaseUpdates2.set(queue, componentIdentity);
        else {
          for (queue = action;queue.next !== null; )
            queue = queue.next;
          queue.next = componentIdentity;
        }
    }
    function unsupportedStartTransition2() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function unsupportedSetOptimisticState2() {
      throw Error("Cannot update optimistic state while rendering.");
    }
    function useActionState2(action, initialState, permalink) {
      resolveCurrentlyRenderingComponent2();
      var actionStateHookIndex = actionStateCounter2++, request = currentlyRenderingRequest2;
      if (typeof action.$$FORM_ACTION === "function") {
        var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath2;
        request = request.formState;
        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
        if (request !== null && typeof isSignatureEqual === "function") {
          var postbackKey = request[1];
          isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + murmurhash3_32_gc(JSON.stringify([
            componentKeyPath,
            null,
            actionStateHookIndex
          ]), 0), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex2 = actionStateHookIndex, initialState = request[0]));
        }
        var boundAction = action.bind(null, initialState);
        action = function(payload) {
          boundAction(payload);
        };
        typeof boundAction.$$FORM_ACTION === "function" && (action.$$FORM_ACTION = function(prefix3) {
          prefix3 = boundAction.$$FORM_ACTION(prefix3);
          permalink !== undefined && (checkAttributeStringCoercion2(permalink, "target"), permalink += "", prefix3.action = permalink);
          var formData = prefix3.data;
          formData && (nextPostbackStateKey === null && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + murmurhash3_32_gc(JSON.stringify([
            componentKeyPath,
            null,
            actionStateHookIndex
          ]), 0)), formData.append("$ACTION_KEY", nextPostbackStateKey));
          return prefix3;
        });
        return [initialState, action, false];
      }
      var _boundAction = action.bind(null, initialState);
      return [
        initialState,
        function(payload) {
          _boundAction(payload);
        },
        false
      ];
    }
    function unwrapThenable2(thenable) {
      var index = thenableIndexCounter2;
      thenableIndexCounter2 += 1;
      thenableState2 === null && (thenableState2 = []);
      return trackUsedThenable2(thenableState2, thenable, index);
    }
    function unsupportedRefresh2() {
      throw Error("Cache cannot be refreshed during server rendering.");
    }
    function noop$12() {}
    function disabledLog2() {}
    function disableLogs2() {
      if (disabledDepth2 === 0) {
        prevLog2 = console.log;
        prevInfo2 = console.info;
        prevWarn2 = console.warn;
        prevError2 = console.error;
        prevGroup2 = console.group;
        prevGroupCollapsed2 = console.groupCollapsed;
        prevGroupEnd2 = console.groupEnd;
        var props = {
          configurable: true,
          enumerable: true,
          value: disabledLog2,
          writable: true
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth2++;
    }
    function reenableLogs2() {
      disabledDepth2--;
      if (disabledDepth2 === 0) {
        var props = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, {
          log: assign2({}, props, { value: prevLog2 }),
          info: assign2({}, props, { value: prevInfo2 }),
          warn: assign2({}, props, { value: prevWarn2 }),
          error: assign2({}, props, { value: prevError2 }),
          group: assign2({}, props, { value: prevGroup2 }),
          groupCollapsed: assign2({}, props, { value: prevGroupCollapsed2 }),
          groupEnd: assign2({}, props, { value: prevGroupEnd2 })
        });
      }
      0 > disabledDepth2 && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame2(name2) {
      if (prefix2 === undefined)
        try {
          throw Error();
        } catch (x2) {
          var match = x2.stack.trim().match(/\n( *(at )?)/);
          prefix2 = match && match[1] || "";
          suffix2 = -1 < x2.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + prefix2 + name2 + suffix2;
    }
    function describeNativeComponentFrame2(fn3, construct2) {
      if (!fn3 || reentry2)
        return "";
      var frame = componentFrameCache2.get(fn3);
      if (frame !== undefined)
        return frame;
      reentry2 = true;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      var previousDispatcher3 = null;
      previousDispatcher3 = ReactSharedInternals2.H;
      ReactSharedInternals2.H = null;
      disableLogs2();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct2) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    var control = x2;
                  }
                  Reflect.construct(fn3, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn3.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn3()) && typeof Fake.catch === "function" && Fake.catch(function() {});
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string")
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
          for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
            namePropDescriptor++;
          for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
            _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
            for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
              _RunInRootFrame$Deter--;
          for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
            if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
                do
                  if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                    fn3.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn3.displayName));
                    typeof fn3 === "function" && componentFrameCache2.set(fn3, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        reentry2 = false, ReactSharedInternals2.H = previousDispatcher3, reenableLogs2(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn3 ? fn3.displayName || fn3.name : "") ? describeBuiltInComponentFrame2(sampleLines) : "";
      typeof fn3 === "function" && componentFrameCache2.set(fn3, sampleLines);
      return sampleLines;
    }
    function formatOwnerStack2(error2) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      error2 = error2.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error2.startsWith(`Error: react-stack-top-frame
`) && (error2 = error2.slice(29));
      prevPrepareStackTrace = error2.indexOf(`
`);
      prevPrepareStackTrace !== -1 && (error2 = error2.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error2.indexOf("react-stack-bottom-frame");
      prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error2.lastIndexOf(`
`, prevPrepareStackTrace));
      if (prevPrepareStackTrace !== -1)
        error2 = error2.slice(0, prevPrepareStackTrace);
      else
        return "";
      return error2;
    }
    function describeComponentStackByType2(type) {
      if (typeof type === "string")
        return describeBuiltInComponentFrame2(type);
      if (typeof type === "function")
        return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame2(type, true) : describeNativeComponentFrame2(type, false);
      if (typeof type === "object" && type !== null) {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE2:
            return describeNativeComponentFrame2(type.render, false);
          case REACT_MEMO_TYPE2:
            return describeNativeComponentFrame2(type.type, false);
          case REACT_LAZY_TYPE2:
            var lazyComponent = type, payload = lazyComponent._payload;
            lazyComponent = lazyComponent._init;
            try {
              type = lazyComponent(payload);
            } catch (x2) {
              return describeBuiltInComponentFrame2("Lazy");
            }
            return describeComponentStackByType2(type);
        }
        if (typeof type.name === "string")
          return payload = type.env, describeBuiltInComponentFrame2(type.name + (payload ? " [" + payload + "]" : ""));
      }
      switch (type) {
        case REACT_SUSPENSE_LIST_TYPE2:
          return describeBuiltInComponentFrame2("SuspenseList");
        case REACT_SUSPENSE_TYPE2:
          return describeBuiltInComponentFrame2("Suspense");
      }
      return "";
    }
    function defaultErrorHandler2(error2) {
      if (typeof error2 === "object" && error2 !== null && typeof error2.environmentName === "string") {
        var JSCompiler_inline_result = error2.environmentName;
        error2 = [error2].slice(0);
        typeof error2[0] === "string" ? error2.splice(0, 1, "[%s] " + error2[0], " " + JSCompiler_inline_result + " ") : error2.splice(0, 0, "[%s] ", " " + JSCompiler_inline_result + " ");
        error2.unshift(console);
        JSCompiler_inline_result = bind3.apply(console.error, error2);
        JSCompiler_inline_result();
      } else
        console.error(error2);
      return null;
    }
    function noop5() {}
    function RequestInstance2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      var abortSet = new Set;
      this.destination = null;
      this.flushScheduled = false;
      this.resumableState = resumableState;
      this.renderState = renderState;
      this.rootFormatContext = rootFormatContext;
      this.progressiveChunkSize = progressiveChunkSize === undefined ? 12800 : progressiveChunkSize;
      this.status = 10;
      this.fatalError = null;
      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
      this.completedPreambleSegments = this.completedRootSegment = null;
      this.abortableTasks = abortSet;
      this.pingedTasks = [];
      this.clientRenderedBoundaries = [];
      this.completedBoundaries = [];
      this.partialBoundaries = [];
      this.trackedPostpones = null;
      this.onError = onError2 === undefined ? defaultErrorHandler2 : onError2;
      this.onPostpone = onPostpone === undefined ? noop5 : onPostpone;
      this.onAllReady = onAllReady === undefined ? noop5 : onAllReady;
      this.onShellReady = onShellReady === undefined ? noop5 : onShellReady;
      this.onShellError = onShellError === undefined ? noop5 : onShellError;
      this.onFatalError = onFatalError === undefined ? noop5 : onFatalError;
      this.formState = formState === undefined ? null : formState;
      this.didWarnForKey = null;
    }
    function createRequest2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      var now = getCurrentTime2();
      1000 < now - lastResetTime2 && (ReactSharedInternals2.recentlyCreatedOwnerStacks = 0, lastResetTime2 = now);
      resumableState = new RequestInstance2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
      renderState = createPendingSegment2(resumableState, 0, null, rootFormatContext, false, false);
      renderState.parentFlushed = true;
      children = createRenderTask2(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext2, null, false, emptyContextObject2, null);
      pushComponentStack2(children);
      resumableState.pingedTasks.push(children);
      return resumableState;
    }
    function pingTask2(request, task) {
      request.pingedTasks.push(task);
      request.pingedTasks.length === 1 && (request.flushScheduled = request.destination !== null, performWork2(request));
    }
    function createSuspenseBoundary2(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
      return {
        status: PENDING2,
        rootSegmentID: -1,
        parentFlushed: false,
        pendingTasks: 0,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks,
        errorDigest: null,
        contentState: createHoistableState2(),
        fallbackState: createHoistableState2(),
        contentPreamble,
        fallbackPreamble,
        trackedContentKeyPath: null,
        trackedFallbackNode: null,
        errorMessage: null,
        errorStack: null,
        errorComponentStack: null
      };
    }
    function createRenderTask2(request, thenableState3, node2, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
      request.allPendingTasks++;
      blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      var task = {
        replay: null,
        node: node2,
        childIndex,
        ping: function() {
          return pingTask2(request, task);
        },
        blockedBoundary,
        blockedSegment,
        blockedPreamble,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        componentStack,
        thenableState: thenableState3,
        isFallback
      };
      task.debugTask = debugTask;
      abortSet.add(task);
      return task;
    }
    function createReplayTask2(request, thenableState3, replay, node2, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
      request.allPendingTasks++;
      blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      replay.pendingTasks++;
      var task = {
        replay,
        node: node2,
        childIndex,
        ping: function() {
          return pingTask2(request, task);
        },
        blockedBoundary,
        blockedSegment: null,
        blockedPreamble: null,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        componentStack,
        thenableState: thenableState3,
        isFallback
      };
      task.debugTask = debugTask;
      abortSet.add(task);
      return task;
    }
    function createPendingSegment2(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
      return {
        status: PENDING2,
        parentFlushed: false,
        id: -1,
        index,
        chunks: [],
        children: [],
        preambleChildren: [],
        parentFormatContext,
        boundary,
        lastPushedText,
        textEmbedded
      };
    }
    function getCurrentStackInDEV2() {
      if (currentTaskInDEV2 === null || currentTaskInDEV2.componentStack === null)
        return "";
      var componentStack = currentTaskInDEV2.componentStack;
      try {
        var info = "";
        if (typeof componentStack.type === "string")
          info += describeBuiltInComponentFrame2(componentStack.type);
        else if (typeof componentStack.type === "function") {
          if (!componentStack.owner) {
            var JSCompiler_temp_const = info, fn3 = componentStack.type, name2 = fn3 ? fn3.displayName || fn3.name : "";
            var JSCompiler_inline_result = name2 ? describeBuiltInComponentFrame2(name2) : "";
            info = JSCompiler_temp_const + JSCompiler_inline_result;
          }
        } else
          componentStack.owner || (info += describeComponentStackByType2(componentStack.type));
        for (;componentStack; )
          JSCompiler_temp_const = null, componentStack.debugStack != null ? JSCompiler_temp_const = formatOwnerStack2(componentStack.debugStack) : (JSCompiler_inline_result = componentStack, JSCompiler_inline_result.stack != null && (JSCompiler_temp_const = typeof JSCompiler_inline_result.stack !== "string" ? JSCompiler_inline_result.stack = formatOwnerStack2(JSCompiler_inline_result.stack) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += `
` + JSCompiler_temp_const);
        var JSCompiler_inline_result$jscomp$0 = info;
      } catch (x2) {
        JSCompiler_inline_result$jscomp$0 = `
Error generating stack: ` + x2.message + `
` + x2.stack;
      }
      return JSCompiler_inline_result$jscomp$0;
    }
    function pushServerComponentStack2(task, debugInfo) {
      if (debugInfo != null)
        for (var i = 0;i < debugInfo.length; i++) {
          var componentInfo = debugInfo[i];
          typeof componentInfo.name === "string" && componentInfo.debugStack !== undefined && (task.componentStack = {
            parent: task.componentStack,
            type: componentInfo,
            owner: componentInfo.owner,
            stack: componentInfo.debugStack
          }, task.debugTask = componentInfo.debugTask);
        }
    }
    function pushComponentStack2(task) {
      var node2 = task.node;
      if (typeof node2 === "object" && node2 !== null)
        switch (node2.$$typeof) {
          case REACT_ELEMENT_TYPE2:
            var { type, _owner: owner, _debugStack: stack } = node2;
            pushServerComponentStack2(task, node2._debugInfo);
            task.debugTask = node2._debugTask;
            task.componentStack = {
              parent: task.componentStack,
              type,
              owner,
              stack
            };
            break;
          case REACT_LAZY_TYPE2:
            pushServerComponentStack2(task, node2._debugInfo);
            break;
          default:
            typeof node2.then === "function" && pushServerComponentStack2(task, node2._debugInfo);
        }
    }
    function getThrownInfo2(node$jscomp$0) {
      var errorInfo = {};
      node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
        configurable: true,
        enumerable: true,
        get: function() {
          try {
            var info = "", node2 = node$jscomp$0;
            do
              info += describeComponentStackByType2(node2.type), node2 = node2.parent;
            while (node2);
            var stack = info;
          } catch (x2) {
            stack = `
Error generating stack: ` + x2.message + `
` + x2.stack;
          }
          Object.defineProperty(errorInfo, "componentStack", {
            value: stack
          });
          return stack;
        }
      });
      return errorInfo;
    }
    function encodeErrorForBoundary2(boundary, digest, error2, thrownInfo, wasAborted) {
      boundary.errorDigest = digest;
      error2 instanceof Error ? (digest = String(error2.message), error2 = String(error2.stack)) : (digest = typeof error2 === "object" && error2 !== null ? describeObjectForErrorMessage2(error2) : String(error2), error2 = null);
      wasAborted = wasAborted ? `Switched to client rendering because the server rendering aborted due to:

` : `Switched to client rendering because the server rendering errored:

`;
      boundary.errorMessage = wasAborted + digest;
      boundary.errorStack = error2 !== null ? wasAborted + error2 : null;
      boundary.errorComponentStack = thrownInfo.componentStack;
    }
    function logRecoverableError2(request, error2, errorInfo, debugTask) {
      request = request.onError;
      error2 = debugTask ? debugTask.run(request.bind(null, error2, errorInfo)) : request(error2, errorInfo);
      if (error2 != null && typeof error2 !== "string")
        console.error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead', typeof error2);
      else
        return error2;
    }
    function fatalError2(request, error2, errorInfo, debugTask) {
      errorInfo = request.onShellError;
      var onFatalError = request.onFatalError;
      debugTask ? (debugTask.run(errorInfo.bind(null, error2)), debugTask.run(onFatalError.bind(null, error2))) : (errorInfo(error2), onFatalError(error2));
      request.destination !== null ? (request.status = CLOSED2, request.destination.destroy(error2)) : (request.status = 13, request.fatalError = error2);
    }
    function renderWithHooks2(request, task, keyPath, Component, props, secondArg) {
      var prevThenableState = task.thenableState;
      task.thenableState = null;
      currentlyRenderingComponent2 = {};
      currentlyRenderingTask2 = task;
      currentlyRenderingRequest2 = request;
      currentlyRenderingKeyPath2 = keyPath;
      isInHookUserCodeInDev2 = false;
      actionStateCounter2 = localIdCounter2 = 0;
      actionStateMatchingIndex2 = -1;
      thenableIndexCounter2 = 0;
      thenableState2 = prevThenableState;
      for (request = callComponentInDEV2(Component, props, secondArg);didScheduleRenderPhaseUpdate2; )
        didScheduleRenderPhaseUpdate2 = false, actionStateCounter2 = localIdCounter2 = 0, actionStateMatchingIndex2 = -1, thenableIndexCounter2 = 0, numberOfReRenders2 += 1, workInProgressHook2 = null, request = Component(props, secondArg);
      resetHooksState2();
      return request;
    }
    function finishFunctionComponent2(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex3) {
      var didEmitActionStateMarkers = false;
      if (actionStateCount !== 0 && request.formState !== null) {
        var segment = task.blockedSegment;
        if (segment !== null) {
          didEmitActionStateMarkers = true;
          segment = segment.chunks;
          for (var i = 0;i < actionStateCount; i++)
            i === actionStateMatchingIndex3 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
        }
      }
      actionStateCount = task.keyPath;
      task.keyPath = keyPath;
      hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext2(keyPath, 1, 0), renderNode3(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode3(request, task, children, -1) : renderNodeDestructive2(request, task, children, -1);
      task.keyPath = actionStateCount;
    }
    function renderElement2(request, task, keyPath, type, props, ref) {
      if (typeof type === "function")
        if (type.prototype && type.prototype.isReactComponent) {
          var newProps = props;
          if ("ref" in props) {
            newProps = {};
            for (var propName in props)
              propName !== "ref" && (newProps[propName] = props[propName]);
          }
          var defaultProps = type.defaultProps;
          if (defaultProps) {
            newProps === props && (newProps = assign2({}, newProps, props));
            for (var _propName in defaultProps)
              newProps[_propName] === undefined && (newProps[_propName] = defaultProps[_propName]);
          }
          var resolvedProps = newProps;
          var context = emptyContextObject2, contextType = type.contextType;
          if ("contextType" in type && contextType !== null && (contextType === undefined || contextType.$$typeof !== REACT_CONTEXT_TYPE2) && !didWarnAboutInvalidateContextType2.has(type)) {
            didWarnAboutInvalidateContextType2.add(type);
            var addendum = contextType === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType !== "object" ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE2 ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
            console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType2(type) || "Component", addendum);
          }
          typeof contextType === "object" && contextType !== null && (context = contextType._currentValue2);
          var instance = new type(resolvedProps, context);
          if (typeof type.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType2(type) || "Component";
            didWarnAboutUninitializedState2.has(componentName) || (didWarnAboutUninitializedState2.add(componentName), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
          }
          if (typeof type.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount === "function" && (foundWillMountName = "UNSAFE_componentWillMount");
            typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps === "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
            typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType2(type) || "Component", newApiName = typeof type.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState2.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState2.add(_componentName), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
          var name2 = getComponentNameFromType2(type) || "Component";
          instance.render || (type.prototype && typeof type.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", name2) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", name2));
          !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
          instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
          instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
          type.childContextTypes && !didWarnAboutChildContextTypes2.has(type) && (didWarnAboutChildContextTypes2.add(type), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", name2));
          type.contextTypes && !didWarnAboutContextTypes$12.has(type) && (didWarnAboutContextTypes$12.add(type), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", name2));
          typeof instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
          type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType2(type) || "A pure component");
          typeof instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
          typeof instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
          typeof instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
          typeof instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
          var hasMutatedProps = instance.props !== resolvedProps;
          instance.props !== undefined && hasMutatedProps && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2);
          instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
          typeof instance.getSnapshotBeforeUpdate !== "function" || typeof instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate2.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate2.add(type), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType2(type)));
          typeof instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
          typeof instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
          typeof type.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
          var state = instance.state;
          state && (typeof state !== "object" || isArrayImpl2(state)) && console.error("%s.state: must be set to an object or null", name2);
          typeof instance.getChildContext === "function" && typeof type.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
          var initialState = instance.state !== undefined ? instance.state : null;
          instance.updater = classComponentUpdater2;
          instance.props = resolvedProps;
          instance.state = initialState;
          var internalInstance = { queue: [], replace: false };
          instance._reactInternals = internalInstance;
          var contextType$jscomp$0 = type.contextType;
          instance.context = typeof contextType$jscomp$0 === "object" && contextType$jscomp$0 !== null ? contextType$jscomp$0._currentValue2 : emptyContextObject2;
          if (instance.state === resolvedProps) {
            var componentName$jscomp$0 = getComponentNameFromType2(type) || "Component";
            didWarnAboutDirectlyAssigningPropsToState2.has(componentName$jscomp$0) || (didWarnAboutDirectlyAssigningPropsToState2.add(componentName$jscomp$0), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName$jscomp$0));
          }
          var getDerivedStateFromProps = type.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            var partialState = getDerivedStateFromProps(resolvedProps, initialState);
            if (partialState === undefined) {
              var componentName$jscomp$1 = getComponentNameFromType2(type) || "Component";
              didWarnAboutUndefinedDerivedState2.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState2.add(componentName$jscomp$1), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName$jscomp$1));
            }
            var JSCompiler_inline_result = partialState === null || partialState === undefined ? initialState : assign2({}, initialState, partialState);
            instance.state = JSCompiler_inline_result;
          }
          if (typeof type.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName$jscomp$2 = getComponentNameFromType2(type) || "Unknown";
                didWarnAboutDeprecatedWillMount2[componentName$jscomp$2] || (console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`, componentName$jscomp$2), didWarnAboutDeprecatedWillMount2[componentName$jscomp$2] = true);
              }
              instance.componentWillMount();
            }
            typeof instance.UNSAFE_componentWillMount === "function" && instance.UNSAFE_componentWillMount();
            oldState !== instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType2(type) || "Component"), classComponentUpdater2.enqueueReplaceState(instance, instance.state, null));
            if (internalInstance.queue !== null && 0 < internalInstance.queue.length) {
              var { queue: oldQueue, replace: oldReplace } = internalInstance;
              internalInstance.queue = null;
              internalInstance.replace = false;
              if (oldReplace && oldQueue.length === 1)
                instance.state = oldQueue[0];
              else {
                for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
                  var partial = oldQueue[i], partialState$jscomp$0 = typeof partial === "function" ? partial.call(instance, nextState, resolvedProps, undefined) : partial;
                  partialState$jscomp$0 != null && (dontMutate ? (dontMutate = false, nextState = assign2({}, nextState, partialState$jscomp$0)) : assign2(nextState, partialState$jscomp$0));
                }
                instance.state = nextState;
              }
            } else
              internalInstance.queue = null;
          }
          var nextChildren = callRenderInDEV2(instance);
          if (request.status === 12)
            throw null;
          instance.props !== resolvedProps && (didWarnAboutReassigningProps2 || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType2(type) || "a component"), didWarnAboutReassigningProps2 = true);
          var prevKeyPath = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive2(request, task, nextChildren, -1);
          task.keyPath = prevKeyPath;
        } else {
          if (type.prototype && typeof type.prototype.render === "function") {
            var componentName$jscomp$3 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutBadClass2[componentName$jscomp$3] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName$jscomp$3, componentName$jscomp$3), didWarnAboutBadClass2[componentName$jscomp$3] = true);
          }
          var value = renderWithHooks2(request, task, keyPath, type, props, undefined);
          if (request.status === 12)
            throw null;
          var hasId = localIdCounter2 !== 0, actionStateCount = actionStateCounter2, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex2;
          if (type.contextTypes) {
            var _componentName$jscomp$0 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutContextTypes2[_componentName$jscomp$0] || (didWarnAboutContextTypes2[_componentName$jscomp$0] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", _componentName$jscomp$0));
          }
          type && type.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, type.displayName || type.name || "Component");
          if (typeof type.getDerivedStateFromProps === "function") {
            var _componentName2 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent2[_componentName2] || (console.error("%s: Function components do not support getDerivedStateFromProps.", _componentName2), didWarnAboutGetDerivedStateOnFunctionComponent2[_componentName2] = true);
          }
          if (typeof type.contextType === "object" && type.contextType !== null) {
            var _componentName3 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent2[_componentName3] || (console.error("%s: Function components do not support contextType.", _componentName3), didWarnAboutContextTypeOnFunctionComponent2[_componentName3] = true);
          }
          finishFunctionComponent2(request, task, keyPath, value, hasId, actionStateCount, actionStateMatchingIndex$jscomp$0);
        }
      else if (typeof type === "string") {
        var segment = task.blockedSegment;
        if (segment === null) {
          var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
          task.formatContext = getChildFormatContext2(prevContext, type, props);
          task.keyPath = keyPath;
          renderNode3(request, task, children, -1);
          task.formatContext = prevContext;
          task.keyPath = prevKeyPath$jscomp$0;
        } else {
          var _children = pushStartInstance2(segment.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, segment.lastPushedText, task.isFallback);
          segment.lastPushedText = false;
          var { formatContext: _prevContext, keyPath: _prevKeyPath2 } = task;
          task.keyPath = keyPath;
          if ((task.formatContext = getChildFormatContext2(_prevContext, type, props)).insertionMode === HTML_HEAD_MODE2) {
            var preambleSegment = createPendingSegment2(request, 0, null, task.formatContext, false, false);
            segment.preambleChildren.push(preambleSegment);
            var preambleTask = createRenderTask2(request, null, _children, -1, task.blockedBoundary, preambleSegment, task.blockedPreamble, task.hoistableState, request.abortableTasks, task.keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject2, task.debugTask);
            pushComponentStack2(preambleTask);
            request.pingedTasks.push(preambleTask);
          } else
            renderNode3(request, task, _children, -1);
          task.formatContext = _prevContext;
          task.keyPath = _prevKeyPath2;
          a: {
            var target = segment.chunks, resumableState = request.resumableState;
            switch (type) {
              case "title":
              case "style":
              case "script":
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr":
                break a;
              case "body":
                if (_prevContext.insertionMode <= HTML_HTML_MODE2) {
                  resumableState.hasBody = true;
                  break a;
                }
                break;
              case "html":
                if (_prevContext.insertionMode === ROOT_HTML_MODE2) {
                  resumableState.hasHtml = true;
                  break a;
                }
                break;
              case "head":
                if (_prevContext.insertionMode <= HTML_HTML_MODE2)
                  break a;
            }
            target.push(endChunkForTag2(type));
          }
          segment.lastPushedText = false;
        }
      } else {
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE2:
          case REACT_STRICT_MODE_TYPE2:
          case REACT_PROFILER_TYPE2:
          case REACT_FRAGMENT_TYPE2:
            var prevKeyPath$jscomp$1 = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive2(request, task, props.children, -1);
            task.keyPath = prevKeyPath$jscomp$1;
            return;
          case REACT_ACTIVITY_TYPE2:
            if (props.mode !== "hidden") {
              var prevKeyPath$jscomp$2 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive2(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$2;
            }
            return;
          case REACT_SUSPENSE_LIST_TYPE2:
            var _prevKeyPath3 = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive2(request, task, props.children, -1);
            task.keyPath = _prevKeyPath3;
            return;
          case REACT_VIEW_TRANSITION_TYPE2:
          case REACT_SCOPE_TYPE2:
            throw Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE2:
            a:
              if (task.replay !== null) {
                var _prevKeyPath = task.keyPath;
                task.keyPath = keyPath;
                var _content = props.children;
                try {
                  renderNode3(request, task, _content, -1);
                } finally {
                  task.keyPath = _prevKeyPath;
                }
              } else {
                var { keyPath: prevKeyPath$jscomp$3, blockedBoundary: parentBoundary, blockedPreamble: parentPreamble, hoistableState: parentHoistableState, blockedSegment: parentSegment } = task, fallback = props.fallback, content = props.children, fallbackAbortSet = new Set;
                var newBoundary = task.formatContext.insertionMode < HTML_MODE2 ? createSuspenseBoundary2(request, fallbackAbortSet, createPreambleState2(), createPreambleState2()) : createSuspenseBoundary2(request, fallbackAbortSet, null, null);
                request.trackedPostpones !== null && (newBoundary.trackedContentKeyPath = keyPath);
                var boundarySegment = createPendingSegment2(request, parentSegment.chunks.length, newBoundary, task.formatContext, false, false);
                parentSegment.children.push(boundarySegment);
                parentSegment.lastPushedText = false;
                var contentRootSegment = createPendingSegment2(request, 0, null, task.formatContext, false, false);
                contentRootSegment.parentFlushed = true;
                if (request.trackedPostpones !== null) {
                  var fallbackKeyPath = [
                    keyPath[0],
                    "Suspense Fallback",
                    keyPath[2]
                  ], fallbackReplayNode = [
                    fallbackKeyPath[1],
                    fallbackKeyPath[2],
                    [],
                    null
                  ];
                  request.trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);
                  newBoundary.trackedFallbackNode = fallbackReplayNode;
                  task.blockedSegment = boundarySegment;
                  task.blockedPreamble = newBoundary.fallbackPreamble;
                  task.keyPath = fallbackKeyPath;
                  boundarySegment.status = 6;
                  try {
                    renderNode3(request, task, fallback, -1), pushSegmentFinale(boundarySegment.chunks, request.renderState, boundarySegment.lastPushedText, boundarySegment.textEmbedded), boundarySegment.status = COMPLETED2;
                  } catch (thrownValue) {
                    throw boundarySegment.status = request.status === 12 ? 3 : 4, thrownValue;
                  } finally {
                    task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedPrimaryTask = createRenderTask2(request, null, content, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject2, task.debugTask);
                  pushComponentStack2(suspendedPrimaryTask);
                  request.pingedTasks.push(suspendedPrimaryTask);
                } else {
                  task.blockedBoundary = newBoundary;
                  task.blockedPreamble = newBoundary.contentPreamble;
                  task.hoistableState = newBoundary.contentState;
                  task.blockedSegment = contentRootSegment;
                  task.keyPath = keyPath;
                  contentRootSegment.status = 6;
                  try {
                    if (renderNode3(request, task, content, -1), pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED2, queueCompletedSegment2(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0 && newBoundary.status === PENDING2) {
                      newBoundary.status = COMPLETED2;
                      request.pendingRootTasks === 0 && task.blockedPreamble && preparePreamble2(request);
                      break a;
                    }
                  } catch (thrownValue$2) {
                    newBoundary.status = CLIENT_RENDERED2;
                    if (request.status === 12) {
                      contentRootSegment.status = 3;
                      var error2 = request.fatalError;
                    } else
                      contentRootSegment.status = 4, error2 = thrownValue$2;
                    var thrownInfo = getThrownInfo2(task.componentStack);
                    var errorDigest = logRecoverableError2(request, error2, thrownInfo, task.debugTask);
                    encodeErrorForBoundary2(newBoundary, errorDigest, error2, thrownInfo, false);
                    untrackBoundary2(request, newBoundary);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedFallbackTask = createRenderTask2(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], task.formatContext, task.context, task.treeContext, task.componentStack, true, emptyContextObject2, task.debugTask);
                  pushComponentStack2(suspendedFallbackTask);
                  request.pingedTasks.push(suspendedFallbackTask);
                }
              }
            return;
        }
        if (typeof type === "object" && type !== null)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE2:
              if ("ref" in props) {
                var propsWithoutRef = {};
                for (var key in props)
                  key !== "ref" && (propsWithoutRef[key] = props[key]);
              } else
                propsWithoutRef = props;
              var children$jscomp$0 = renderWithHooks2(request, task, keyPath, type.render, propsWithoutRef, ref);
              finishFunctionComponent2(request, task, keyPath, children$jscomp$0, localIdCounter2 !== 0, actionStateCounter2, actionStateMatchingIndex2);
              return;
            case REACT_MEMO_TYPE2:
              renderElement2(request, task, keyPath, type.type, props, ref);
              return;
            case REACT_PROVIDER_TYPE2:
            case REACT_CONTEXT_TYPE2:
              var { value: value$jscomp$0, children: children$jscomp$1 } = props;
              var prevSnapshot = task.context;
              var prevKeyPath$jscomp$4 = task.keyPath;
              var prevValue = type._currentValue2;
              type._currentValue2 = value$jscomp$0;
              type._currentRenderer2 !== undefined && type._currentRenderer2 !== null && type._currentRenderer2 !== rendererSigil2 && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              type._currentRenderer2 = rendererSigil2;
              var prevNode = currentActiveSnapshot2, newNode = {
                parent: prevNode,
                depth: prevNode === null ? 0 : prevNode.depth + 1,
                context: type,
                parentValue: prevValue,
                value: value$jscomp$0
              };
              currentActiveSnapshot2 = newNode;
              task.context = newNode;
              task.keyPath = keyPath;
              renderNodeDestructive2(request, task, children$jscomp$1, -1);
              var prevSnapshot$jscomp$0 = currentActiveSnapshot2;
              if (prevSnapshot$jscomp$0 === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              prevSnapshot$jscomp$0.context !== type && console.error("The parent context is not the expected context. This is probably a bug in React.");
              prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
              type._currentRenderer2 !== undefined && type._currentRenderer2 !== null && type._currentRenderer2 !== rendererSigil2 && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              type._currentRenderer2 = rendererSigil2;
              var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot2 = prevSnapshot$jscomp$0.parent;
              task.context = JSCompiler_inline_result$jscomp$0;
              task.keyPath = prevKeyPath$jscomp$4;
              prevSnapshot !== task.context && console.error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
              return;
            case REACT_CONSUMER_TYPE2:
              var context$jscomp$0 = type._context, render2 = props.children;
              typeof render2 !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              var newChildren = render2(context$jscomp$0._currentValue2), prevKeyPath$jscomp$5 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive2(request, task, newChildren, -1);
              task.keyPath = prevKeyPath$jscomp$5;
              return;
            case REACT_LAZY_TYPE2:
              var Component = callLazyInitInDEV2(type);
              if (request.status === 12)
                throw null;
              renderElement2(request, task, keyPath, Component, props, ref);
              return;
          }
        var info = "";
        if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
          info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((type == null ? type : typeof type) + "." + info));
      }
    }
    function resumeNode2(request, task, segmentId, node2, childIndex) {
      var { replay: prevReplay, blockedBoundary } = task, resumedSegment = createPendingSegment2(request, 0, null, task.formatContext, false, false);
      resumedSegment.id = segmentId;
      resumedSegment.parentFlushed = true;
      try {
        task.replay = null, task.blockedSegment = resumedSegment, renderNode3(request, task, node2, childIndex), resumedSegment.status = COMPLETED2, blockedBoundary === null ? request.completedRootSegment = resumedSegment : (queueCompletedSegment2(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
      } finally {
        task.replay = prevReplay, task.blockedSegment = null;
      }
    }
    function replayElement2(request, task, keyPath, name2, keyOrIndex, childIndex, type, props, ref, replay) {
      childIndex = replay.nodes;
      for (var i = 0;i < childIndex.length; i++) {
        var node2 = childIndex[i];
        if (keyOrIndex === node2[1]) {
          if (node2.length === 4) {
            if (name2 !== null && name2 !== node2[0])
              throw Error("Expected the resume to render <" + node2[0] + "> in this slot but instead it rendered <" + name2 + ">. The tree doesn't match so React will fallback to client rendering.");
            var childNodes = node2[2];
            node2 = node2[3];
            name2 = task.node;
            task.replay = { nodes: childNodes, slots: node2, pendingTasks: 1 };
            try {
              renderElement2(request, task, keyPath, type, props, ref);
              if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
                throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
              task.replay.pendingTasks--;
            } catch (x2) {
              if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException2 || typeof x2.then === "function"))
                throw task.node === name2 && (task.replay = replay), x2;
              task.replay.pendingTasks--;
              type = getThrownInfo2(task.componentStack);
              props = request;
              request = task.blockedBoundary;
              keyPath = x2;
              ref = node2;
              node2 = logRecoverableError2(props, keyPath, type, task.debugTask);
              abortRemainingReplayNodes2(props, request, childNodes, ref, keyPath, node2, type, false);
            }
            task.replay = replay;
          } else {
            if (type !== REACT_SUSPENSE_TYPE2)
              throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType2(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
            a: {
              replay = undefined;
              type = node2[5];
              ref = node2[2];
              name2 = node2[3];
              keyOrIndex = node2[4] === null ? [] : node2[4][2];
              node2 = node2[4] === null ? null : node2[4][3];
              var { keyPath: prevKeyPath, replay: previousReplaySet, blockedBoundary: parentBoundary, hoistableState: parentHoistableState } = task, content = props.children, fallback = props.fallback, fallbackAbortSet = new Set;
              props = task.formatContext.insertionMode < HTML_MODE2 ? createSuspenseBoundary2(request, fallbackAbortSet, createPreambleState2(), createPreambleState2()) : createSuspenseBoundary2(request, fallbackAbortSet, null, null);
              props.parentFlushed = true;
              props.rootSegmentID = type;
              task.blockedBoundary = props;
              task.hoistableState = props.contentState;
              task.keyPath = keyPath;
              task.replay = { nodes: ref, slots: name2, pendingTasks: 1 };
              try {
                renderNode3(request, task, content, -1);
                if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
                  throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
                task.replay.pendingTasks--;
                if (props.pendingTasks === 0 && props.status === PENDING2) {
                  props.status = COMPLETED2;
                  request.completedBoundaries.push(props);
                  break a;
                }
              } catch (error2) {
                props.status = CLIENT_RENDERED2, childNodes = getThrownInfo2(task.componentStack), replay = logRecoverableError2(request, error2, childNodes, task.debugTask), encodeErrorForBoundary2(props, replay, error2, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
              } finally {
                task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
              }
              props = createReplayTask2(request, null, { nodes: keyOrIndex, slots: node2, pendingTasks: 0 }, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], task.formatContext, task.context, task.treeContext, task.componentStack, true, emptyContextObject2, task.debugTask);
              pushComponentStack2(props);
              request.pingedTasks.push(props);
            }
          }
          childIndex.splice(i, 1);
          break;
        }
      }
    }
    function renderNodeDestructive2(request, task, node2, childIndex) {
      task.replay !== null && typeof task.replay.slots === "number" ? resumeNode2(request, task, task.replay.slots, node2, childIndex) : (task.node = node2, task.childIndex = childIndex, node2 = task.componentStack, childIndex = task.debugTask, pushComponentStack2(task), retryNode2(request, task), task.componentStack = node2, task.debugTask = childIndex);
    }
    function retryNode2(request, task) {
      var { node: node2, childIndex } = task;
      if (node2 !== null) {
        if (typeof node2 === "object") {
          switch (node2.$$typeof) {
            case REACT_ELEMENT_TYPE2:
              var { type, key } = node2;
              node2 = node2.props;
              var refProp = node2.ref;
              refProp = refProp !== undefined ? refProp : null;
              var debugTask = task.debugTask, name2 = getComponentNameFromType2(type);
              key = key == null ? childIndex === -1 ? 0 : childIndex : key;
              var keyPath = [task.keyPath, name2, key];
              task.replay !== null ? debugTask ? debugTask.run(replayElement2.bind(null, request, task, keyPath, name2, key, childIndex, type, node2, refProp, task.replay)) : replayElement2(request, task, keyPath, name2, key, childIndex, type, node2, refProp, task.replay) : debugTask ? debugTask.run(renderElement2.bind(null, request, task, keyPath, type, node2, refProp)) : renderElement2(request, task, keyPath, type, node2, refProp);
              return;
            case REACT_PORTAL_TYPE2:
              throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE2:
              node2 = callLazyInitInDEV2(node2);
              if (request.status === 12)
                throw null;
              renderNodeDestructive2(request, task, node2, childIndex);
              return;
          }
          if (isArrayImpl2(node2)) {
            renderChildrenArray2(request, task, node2, childIndex);
            return;
          }
          node2 === null || typeof node2 !== "object" ? key = null : (type = MAYBE_ITERATOR_SYMBOL2 && node2[MAYBE_ITERATOR_SYMBOL2] || node2["@@iterator"], key = typeof type === "function" ? type : null);
          if (key && (type = key.call(node2))) {
            if (type === node2) {
              if (childIndex !== -1 || task.componentStack === null || typeof task.componentStack.type !== "function" || Object.prototype.toString.call(task.componentStack.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(type) !== "[object Generator]")
                didWarnAboutGenerators2 || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators2 = true;
            } else
              node2.entries !== key || didWarnAboutMaps2 || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps2 = true);
            node2 = type.next();
            if (!node2.done) {
              key = [];
              do
                key.push(node2.value), node2 = type.next();
              while (!node2.done);
              renderChildrenArray2(request, task, key, childIndex);
            }
            return;
          }
          if (typeof node2.then === "function")
            return task.thenableState = null, renderNodeDestructive2(request, task, unwrapThenable2(node2), childIndex);
          if (node2.$$typeof === REACT_CONTEXT_TYPE2)
            return renderNodeDestructive2(request, task, node2._currentValue2, childIndex);
          request = Object.prototype.toString.call(node2);
          throw Error("Objects are not valid as a React child (found: " + (request === "[object Object]" ? "object with keys {" + Object.keys(node2).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead.");
        }
        typeof node2 === "string" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance2(task.chunks, node2, request.renderState, task.lastPushedText))) : typeof node2 === "number" || typeof node2 === "bigint" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance2(task.chunks, "" + node2, request.renderState, task.lastPushedText))) : (typeof node2 === "function" && (request = node2.displayName || node2.name || "Component", console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.", request, request)), typeof node2 === "symbol" && console.error(`Symbols are not valid as a React child.
  %s`, String(node2)));
      }
    }
    function renderChildrenArray2(request, task, children, childIndex) {
      var { keyPath: prevKeyPath, componentStack: previousComponentStack } = task;
      var previousDebugTask = task.debugTask;
      pushServerComponentStack2(task, task.node._debugInfo);
      if (childIndex !== -1 && (task.keyPath = [task.keyPath, "Fragment", childIndex], task.replay !== null)) {
        for (var replay = task.replay, replayNodes = replay.nodes, j2 = 0;j2 < replayNodes.length; j2++) {
          var node2 = replayNodes[j2];
          if (node2[1] === childIndex) {
            childIndex = node2[2];
            node2 = node2[3];
            task.replay = { nodes: childIndex, slots: node2, pendingTasks: 1 };
            try {
              renderChildrenArray2(request, task, children, -1);
              if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
                throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
              task.replay.pendingTasks--;
            } catch (x2) {
              if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException2 || typeof x2.then === "function"))
                throw x2;
              task.replay.pendingTasks--;
              var thrownInfo = getThrownInfo2(task.componentStack);
              children = task.blockedBoundary;
              var error2 = x2, resumeSlots = node2;
              node2 = logRecoverableError2(request, error2, thrownInfo, task.debugTask);
              abortRemainingReplayNodes2(request, children, childIndex, resumeSlots, error2, node2, thrownInfo, false);
            }
            task.replay = replay;
            replayNodes.splice(j2, 1);
            break;
          }
        }
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
        return;
      }
      replay = task.treeContext;
      replayNodes = children.length;
      if (task.replay !== null && (j2 = task.replay.slots, j2 !== null && typeof j2 === "object")) {
        for (childIndex = 0;childIndex < replayNodes; childIndex++)
          node2 = children[childIndex], task.treeContext = pushTreeContext2(replay, replayNodes, childIndex), error2 = j2[childIndex], typeof error2 === "number" ? (resumeNode2(request, task, error2, node2, childIndex), delete j2[childIndex]) : renderNode3(request, task, node2, childIndex);
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
        return;
      }
      for (j2 = 0;j2 < replayNodes; j2++) {
        childIndex = children[j2];
        resumeSlots = request;
        node2 = task;
        error2 = childIndex;
        if (error2 !== null && typeof error2 === "object" && (error2.$$typeof === REACT_ELEMENT_TYPE2 || error2.$$typeof === REACT_PORTAL_TYPE2) && error2._store && (!error2._store.validated && error2.key == null || error2._store.validated === 2)) {
          if (typeof error2._store !== "object")
            throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
          error2._store.validated = 1;
          thrownInfo = resumeSlots.didWarnForKey;
          thrownInfo == null && (thrownInfo = resumeSlots.didWarnForKey = new WeakSet);
          resumeSlots = node2.componentStack;
          if (resumeSlots !== null && !thrownInfo.has(resumeSlots)) {
            thrownInfo.add(resumeSlots);
            var componentName = getComponentNameFromType2(error2.type);
            thrownInfo = error2._owner;
            var parentOwner = resumeSlots.owner;
            resumeSlots = "";
            if (parentOwner && typeof parentOwner.type !== "undefined") {
              var name2 = getComponentNameFromType2(parentOwner.type);
              name2 && (resumeSlots = `

Check the render method of \`` + name2 + "`.");
            }
            resumeSlots || componentName && (resumeSlots = `

Check the top-level render call using <` + componentName + ">.");
            componentName = "";
            thrownInfo != null && parentOwner !== thrownInfo && (parentOwner = null, typeof thrownInfo.type !== "undefined" ? parentOwner = getComponentNameFromType2(thrownInfo.type) : typeof thrownInfo.name === "string" && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
            thrownInfo = node2.componentStack;
            node2.componentStack = {
              parent: node2.componentStack,
              type: error2.type,
              owner: error2._owner,
              stack: error2._debugStack
            };
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', resumeSlots, componentName);
            node2.componentStack = thrownInfo;
          }
        }
        task.treeContext = pushTreeContext2(replay, replayNodes, j2);
        renderNode3(request, task, childIndex, j2);
      }
      task.treeContext = replay;
      task.keyPath = prevKeyPath;
      task.componentStack = previousComponentStack;
      task.debugTask = previousDebugTask;
    }
    function untrackBoundary2(request, boundary) {
      request = request.trackedPostpones;
      request !== null && (boundary = boundary.trackedContentKeyPath, boundary !== null && (boundary = request.workingMap.get(boundary), boundary !== undefined && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
    }
    function spawnNewSuspendedReplayTask2(request, task, thenableState3) {
      return createReplayTask2(request, thenableState3, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject2, task.debugTask);
    }
    function spawnNewSuspendedRenderTask2(request, task, thenableState3) {
      var segment = task.blockedSegment, newSegment = createPendingSegment2(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, true);
      segment.children.push(newSegment);
      segment.lastPushedText = false;
      return createRenderTask2(request, thenableState3, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.componentStack, task.isFallback, emptyContextObject2, task.debugTask);
    }
    function renderNode3(request, task, node2, childIndex) {
      var { formatContext: previousFormatContext, context: previousContext, keyPath: previousKeyPath, treeContext: previousTreeContext, componentStack: previousComponentStack, debugTask: previousDebugTask, blockedSegment: segment } = task;
      if (segment === null)
        try {
          return renderNodeDestructive2(request, task, node2, childIndex);
        } catch (thrownValue) {
          if (resetHooksState2(), node2 = thrownValue === SuspenseException2 ? getSuspendedThenable2() : thrownValue, typeof node2 === "object" && node2 !== null) {
            if (typeof node2.then === "function") {
              childIndex = getThenableStateAfterSuspending2();
              request = spawnNewSuspendedReplayTask2(request, task, childIndex).ping;
              node2.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
            if (node2.message === "Maximum call stack size exceeded") {
              node2 = getThenableStateAfterSuspending2();
              node2 = spawnNewSuspendedReplayTask2(request, task, node2);
              request.pingedTasks.push(node2);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
          }
        }
      else {
        var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
        try {
          return renderNodeDestructive2(request, task, node2, childIndex);
        } catch (thrownValue$3) {
          if (resetHooksState2(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node2 = thrownValue$3 === SuspenseException2 ? getSuspendedThenable2() : thrownValue$3, typeof node2 === "object" && node2 !== null) {
            if (typeof node2.then === "function") {
              childIndex = getThenableStateAfterSuspending2();
              request = spawnNewSuspendedRenderTask2(request, task, childIndex).ping;
              node2.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
            if (node2.message === "Maximum call stack size exceeded") {
              node2 = getThenableStateAfterSuspending2();
              node2 = spawnNewSuspendedRenderTask2(request, task, node2);
              request.pingedTasks.push(node2);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
          }
        }
      }
      task.formatContext = previousFormatContext;
      task.context = previousContext;
      task.keyPath = previousKeyPath;
      task.treeContext = previousTreeContext;
      switchContext2(previousContext);
      throw node2;
    }
    function abortTaskSoft2(task) {
      var boundary = task.blockedBoundary;
      task = task.blockedSegment;
      task !== null && (task.status = 3, finishedTask2(this, boundary, task));
    }
    function abortRemainingReplayNodes2(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
      for (var i = 0;i < nodes.length; i++) {
        var node2 = nodes[i];
        if (node2.length === 4)
          abortRemainingReplayNodes2(request$jscomp$0, boundary, node2[2], node2[3], error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted);
        else {
          var request = request$jscomp$0;
          node2 = node2[5];
          var error2 = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary2(request, new Set, null, null);
          resumedBoundary.parentFlushed = true;
          resumedBoundary.rootSegmentID = node2;
          resumedBoundary.status = CLIENT_RENDERED2;
          encodeErrorForBoundary2(resumedBoundary, errorDigest, error2, errorInfo, wasAborted);
          resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
        }
      }
      nodes.length = 0;
      if (slots !== null) {
        if (boundary === null)
          throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
        boundary.status !== CLIENT_RENDERED2 && (boundary.status = CLIENT_RENDERED2, encodeErrorForBoundary2(boundary, errorDigest$jscomp$0, error$jscomp$0, errorInfo$jscomp$0, aborted), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
        if (typeof slots === "object")
          for (var index in slots)
            delete slots[index];
      }
    }
    function abortTask2(task, request, error2) {
      var { blockedBoundary: boundary, blockedSegment: segment } = task;
      if (segment !== null) {
        if (segment.status === 6)
          return;
        segment.status = 3;
      }
      segment = getThrownInfo2(task.componentStack);
      if (boundary === null) {
        if (request.status !== 13 && request.status !== CLOSED2) {
          boundary = task.replay;
          if (boundary === null) {
            logRecoverableError2(request, error2, segment, null);
            fatalError2(request, error2, segment, null);
            return;
          }
          boundary.pendingTasks--;
          boundary.pendingTasks === 0 && 0 < boundary.nodes.length && (task = logRecoverableError2(request, error2, segment, null), abortRemainingReplayNodes2(request, null, boundary.nodes, boundary.slots, error2, task, segment, true));
          request.pendingRootTasks--;
          request.pendingRootTasks === 0 && completeShell2(request);
        }
      } else
        boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED2 && (boundary.status = CLIENT_RENDERED2, task = logRecoverableError2(request, error2, segment, null), boundary.status = CLIENT_RENDERED2, encodeErrorForBoundary2(boundary, task, error2, segment, true), untrackBoundary2(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
          return abortTask2(fallbackTask, request, error2);
        }), boundary.fallbackAbortableTasks.clear();
      request.allPendingTasks--;
      request.allPendingTasks === 0 && completeAll2(request);
    }
    function safelyEmitEarlyPreloads2(request, shellComplete) {
      try {
        var renderState = request.renderState, onHeaders = renderState.onHeaders;
        if (onHeaders) {
          var headers = renderState.headers;
          if (headers) {
            renderState.headers = null;
            var linkHeader = headers.preconnects;
            headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
            headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
            if (!shellComplete) {
              var queueIter = renderState.styles.values(), queueStep = queueIter.next();
              b:
                for (;0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                  for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next();0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                    var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                    var header = getPreloadAsHeader2(props$jscomp$0.href, "style", {
                      crossOrigin: props$jscomp$0.crossOrigin,
                      integrity: props$jscomp$0.integrity,
                      nonce: props$jscomp$0.nonce,
                      type: props$jscomp$0.type,
                      fetchPriority: props$jscomp$0.fetchPriority,
                      referrerPolicy: props$jscomp$0.referrerPolicy,
                      media: props$jscomp$0.media
                    });
                    if (0 <= (headers.remainingCapacity -= header.length + 2))
                      renderState.resets.style[key] = PRELOAD_NO_CREDS2, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = typeof props.crossOrigin === "string" || typeof props.integrity === "string" ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS2;
                    else
                      break b;
                  }
            }
            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
          }
        }
      } catch (error2) {
        logRecoverableError2(request, error2, {}, null);
      }
    }
    function completeShell2(request) {
      request.trackedPostpones === null && safelyEmitEarlyPreloads2(request, true);
      request.trackedPostpones === null && preparePreamble2(request);
      request.onShellError = noop5;
      request = request.onShellReady;
      request();
    }
    function completeAll2(request) {
      safelyEmitEarlyPreloads2(request, request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED2);
      preparePreamble2(request);
      request = request.onAllReady;
      request();
    }
    function queueCompletedSegment2(boundary, segment) {
      if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {
        var childSegment = segment.children[0];
        childSegment.id = segment.id;
        childSegment.parentFlushed = true;
        childSegment.status === COMPLETED2 && queueCompletedSegment2(boundary, childSegment);
      } else
        boundary.completedSegments.push(segment);
    }
    function finishedTask2(request, boundary, segment) {
      if (boundary === null) {
        if (segment !== null && segment.parentFlushed) {
          if (request.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          request.completedRootSegment = segment;
        }
        request.pendingRootTasks--;
        request.pendingRootTasks === 0 && completeShell2(request);
      } else
        boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED2 && (boundary.pendingTasks === 0 ? (boundary.status === PENDING2 && (boundary.status = COMPLETED2), segment !== null && segment.parentFlushed && segment.status === COMPLETED2 && queueCompletedSegment2(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED2 && (boundary.fallbackAbortableTasks.forEach(abortTaskSoft2, request), boundary.fallbackAbortableTasks.clear(), request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary.contentPreamble !== null && preparePreamble2(request))) : segment !== null && segment.parentFlushed && segment.status === COMPLETED2 && (queueCompletedSegment2(boundary, segment), boundary.completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
      request.allPendingTasks--;
      request.allPendingTasks === 0 && completeAll2(request);
    }
    function performWork2(request$jscomp$2) {
      if (request$jscomp$2.status !== CLOSED2 && request$jscomp$2.status !== 13) {
        var prevContext = currentActiveSnapshot2, prevDispatcher = ReactSharedInternals2.H;
        ReactSharedInternals2.H = HooksDispatcher2;
        var prevAsyncDispatcher = ReactSharedInternals2.A;
        ReactSharedInternals2.A = DefaultAsyncDispatcher2;
        var prevRequest = currentRequest2;
        currentRequest2 = request$jscomp$2;
        var prevGetCurrentStackImpl = ReactSharedInternals2.getCurrentStack;
        ReactSharedInternals2.getCurrentStack = getCurrentStackInDEV2;
        var prevResumableState = currentResumableState2;
        currentResumableState2 = request$jscomp$2.resumableState;
        try {
          var pingedTasks = request$jscomp$2.pingedTasks, i;
          for (i = 0;i < pingedTasks.length; i++) {
            var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
            if (segment === null) {
              var prevTaskInDEV = undefined, request$jscomp$0 = request;
              request = task;
              if (request.replay.pendingTasks !== 0) {
                switchContext2(request.context);
                prevTaskInDEV = currentTaskInDEV2;
                currentTaskInDEV2 = request;
                try {
                  typeof request.replay.slots === "number" ? resumeNode2(request$jscomp$0, request, request.replay.slots, request.node, request.childIndex) : retryNode2(request$jscomp$0, request);
                  if (request.replay.pendingTasks === 1 && 0 < request.replay.nodes.length)
                    throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
                  request.replay.pendingTasks--;
                  request.abortSet.delete(request);
                  finishedTask2(request$jscomp$0, request.blockedBoundary, null);
                } catch (thrownValue) {
                  resetHooksState2();
                  var x2 = thrownValue === SuspenseException2 ? getSuspendedThenable2() : thrownValue;
                  if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function") {
                    var ping = request.ping;
                    x2.then(ping, ping);
                    request.thenableState = getThenableStateAfterSuspending2();
                  } else {
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    var errorInfo = getThrownInfo2(request.componentStack), errorDigest = undefined, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = request$jscomp$0.status === 12 ? request$jscomp$0.fatalError : x2, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                    errorDigest = logRecoverableError2(request$jscomp$1, error$jscomp$0, errorInfo$jscomp$0, request.debugTask);
                    abortRemainingReplayNodes2(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, errorDigest, errorInfo$jscomp$0, false);
                    request$jscomp$0.pendingRootTasks--;
                    request$jscomp$0.pendingRootTasks === 0 && completeShell2(request$jscomp$0);
                    request$jscomp$0.allPendingTasks--;
                    request$jscomp$0.allPendingTasks === 0 && completeAll2(request$jscomp$0);
                  }
                } finally {
                  currentTaskInDEV2 = prevTaskInDEV;
                }
              }
            } else if (request$jscomp$0 = prevTaskInDEV = undefined, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING2) {
              request$jscomp$1.status = 6;
              switchContext2(errorDigest.context);
              request$jscomp$0 = currentTaskInDEV2;
              currentTaskInDEV2 = errorDigest;
              var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
              try {
                retryNode2(request, errorDigest), pushSegmentFinale(request$jscomp$1.chunks, request.renderState, request$jscomp$1.lastPushedText, request$jscomp$1.textEmbedded), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED2, finishedTask2(request, errorDigest.blockedBoundary, request$jscomp$1);
              } catch (thrownValue) {
                resetHooksState2();
                request$jscomp$1.children.length = childrenLength;
                request$jscomp$1.chunks.length = chunkLength;
                var x$jscomp$0 = thrownValue === SuspenseException2 ? getSuspendedThenable2() : request.status === 12 ? request.fatalError : thrownValue;
                if (typeof x$jscomp$0 === "object" && x$jscomp$0 !== null && typeof x$jscomp$0.then === "function") {
                  request$jscomp$1.status = PENDING2;
                  errorDigest.thenableState = getThenableStateAfterSuspending2();
                  var ping$jscomp$0 = errorDigest.ping;
                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                } else {
                  var errorInfo$jscomp$1 = getThrownInfo2(errorDigest.componentStack);
                  errorDigest.abortSet.delete(errorDigest);
                  request$jscomp$1.status = 4;
                  var { blockedBoundary: boundary$jscomp$0, debugTask } = errorDigest;
                  prevTaskInDEV = logRecoverableError2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
                  boundary$jscomp$0 === null ? fatalError2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED2 && (boundary$jscomp$0.status = CLIENT_RENDERED2, encodeErrorForBoundary2(boundary$jscomp$0, prevTaskInDEV, x$jscomp$0, errorInfo$jscomp$1, false), untrackBoundary2(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0), request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary$jscomp$0.contentPreamble !== null && preparePreamble2(request)));
                  request.allPendingTasks--;
                  request.allPendingTasks === 0 && completeAll2(request);
                }
              } finally {
                currentTaskInDEV2 = request$jscomp$0;
              }
            }
          }
          pingedTasks.splice(0, i);
          request$jscomp$2.destination !== null && flushCompletedQueues2(request$jscomp$2, request$jscomp$2.destination);
        } catch (error2) {
          pingedTasks = {}, logRecoverableError2(request$jscomp$2, error2, pingedTasks, null), fatalError2(request$jscomp$2, error2, pingedTasks, null);
        } finally {
          currentResumableState2 = prevResumableState, ReactSharedInternals2.H = prevDispatcher, ReactSharedInternals2.A = prevAsyncDispatcher, ReactSharedInternals2.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher2 && switchContext2(prevContext), currentRequest2 = prevRequest;
        }
      }
    }
    function preparePreambleFromSubtree2(request, segment, collectedPreambleSegments) {
      segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
      for (var pendingPreambles = false, i = 0;i < segment.children.length; i++)
        pendingPreambles = preparePreambleFromSegment2(request, segment.children[i], collectedPreambleSegments) || pendingPreambles;
      return pendingPreambles;
    }
    function preparePreambleFromSegment2(request, segment, collectedPreambleSegments) {
      var boundary = segment.boundary;
      if (boundary === null)
        return preparePreambleFromSubtree2(request, segment, collectedPreambleSegments);
      var { contentPreamble: preamble, fallbackPreamble } = boundary;
      if (preamble === null || fallbackPreamble === null)
        return false;
      switch (boundary.status) {
        case COMPLETED2:
          hoistPreambleState2(request.renderState, preamble);
          segment = boundary.completedSegments[0];
          if (!segment)
            throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          return preparePreambleFromSubtree2(request, segment, collectedPreambleSegments);
        case POSTPONED2:
          if (request.trackedPostpones !== null)
            return true;
        case CLIENT_RENDERED2:
          if (segment.status === COMPLETED2)
            return hoistPreambleState2(request.renderState, fallbackPreamble), preparePreambleFromSubtree2(request, segment, collectedPreambleSegments);
        default:
          return true;
      }
    }
    function preparePreamble2(request) {
      if (request.completedRootSegment && request.completedPreambleSegments === null) {
        var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment2(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
        if (hasPendingPreambles === false || preamble.headChunks && preamble.bodyChunks)
          request.completedPreambleSegments = collectedPreambleSegments;
      }
    }
    function flushSubtree2(request, destination, segment, hoistableState) {
      segment.parentFlushed = true;
      switch (segment.status) {
        case PENDING2:
          segment.id = request.nextSegmentId++;
        case POSTPONED2:
          return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push(placeholder12), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder22);
        case COMPLETED2:
          segment.status = FLUSHED2;
          var r2 = true, chunks = segment.chunks, chunkIdx = 0;
          segment = segment.children;
          for (var childIdx = 0;childIdx < segment.length; childIdx++) {
            for (r2 = segment[childIdx];chunkIdx < r2.index; chunkIdx++)
              destination.push(chunks[chunkIdx]);
            r2 = flushSegment2(request, destination, r2, hoistableState);
          }
          for (;chunkIdx < chunks.length - 1; chunkIdx++)
            destination.push(chunks[chunkIdx]);
          chunkIdx < chunks.length && (r2 = destination.push(chunks[chunkIdx]));
          return r2;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function flushSegment2(request, destination, segment, hoistableState) {
      var boundary = segment.boundary;
      if (boundary === null)
        return flushSubtree2(request, destination, segment, hoistableState);
      boundary.parentFlushed = true;
      if (boundary.status === CLIENT_RENDERED2) {
        if (!request.renderState.generateStaticMarkup) {
          var { errorDigest, errorMessage, errorStack, errorComponentStack } = boundary;
          destination.push(startClientRenderedSuspenseBoundary2);
          destination.push(clientRenderedSuspenseBoundaryError12);
          errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A2), errorDigest = escapeTextForBrowser2(errorDigest), destination.push(errorDigest), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          errorMessage && (destination.push(clientRenderedSuspenseBoundaryError1B2), errorMessage = escapeTextForBrowser2(errorMessage), destination.push(errorMessage), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          errorStack && (destination.push(clientRenderedSuspenseBoundaryError1C2), errorStack = escapeTextForBrowser2(errorStack), destination.push(errorStack), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          errorComponentStack && (destination.push(clientRenderedSuspenseBoundaryError1D2), errorComponentStack = escapeTextForBrowser2(errorComponentStack), destination.push(errorComponentStack), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          destination.push(clientRenderedSuspenseBoundaryError22);
        }
        flushSubtree2(request, destination, segment, hoistableState);
        request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.fallbackPreamble) && writePreambleContribution2(destination, request), destination = destination.push(endSuspenseBoundary2));
        return destination;
      }
      if (boundary.status !== COMPLETED2)
        return boundary.status === PENDING2 && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary2(destination, request.renderState, boundary.rootSegmentID), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency2, hoistableState), boundary.stylesheets.forEach(hoistStylesheetDependency2, hoistableState)), flushSubtree2(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary2);
      if (boundary.byteSize > request.progressiveChunkSize)
        return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary2(destination, request.renderState, boundary.rootSegmentID), flushSubtree2(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary2);
      hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency2, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency2, hoistableState));
      request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary2);
      segment = boundary.completedSegments;
      if (segment.length !== 1)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      flushSegment2(request, destination, segment[0], hoistableState);
      request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.contentPreamble) && writePreambleContribution2(destination, request), destination = destination.push(endSuspenseBoundary2));
      return destination;
    }
    function flushSegmentContainer2(request, destination, segment, hoistableState) {
      writeStartSegment2(destination, request.renderState, segment.parentFormatContext, segment.id);
      flushSegment2(request, destination, segment, hoistableState);
      return writeEndSegment2(destination, segment.parentFormatContext);
    }
    function flushCompletedBoundary2(request, destination, boundary) {
      for (var completedSegments = boundary.completedSegments, i = 0;i < completedSegments.length; i++)
        flushPartiallyCompletedSegment2(request, destination, boundary, completedSegments[i]);
      completedSegments.length = 0;
      writeHoistablesForBoundary2(destination, boundary.contentState, request.renderState);
      completedSegments = request.resumableState;
      request = request.renderState;
      i = boundary.rootSegmentID;
      boundary = boundary.contentState;
      var requiresStyleInsertion = request.stylesToHoist;
      request.stylesToHoist = false;
      destination.push(request.startInlineScript);
      requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction2) === NothingSent2 ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction2 | SentCompleteBoundaryFunction2, destination.push(completeBoundaryWithStylesScript1FullBoth2)) : (completedSegments.instructions & SentStyleInsertionFunction2) === NothingSent2 ? (completedSegments.instructions |= SentStyleInsertionFunction2, destination.push(completeBoundaryWithStylesScript1FullPartial2)) : destination.push(completeBoundaryWithStylesScript1Partial2) : (completedSegments.instructions & SentCompleteBoundaryFunction2) === NothingSent2 ? (completedSegments.instructions |= SentCompleteBoundaryFunction2, destination.push(completeBoundaryScript1Full2)) : destination.push(completeBoundaryScript1Partial2);
      completedSegments = i.toString(16);
      destination.push(request.boundaryPrefix);
      destination.push(completedSegments);
      destination.push(completeBoundaryScript22);
      destination.push(request.segmentPrefix);
      destination.push(completedSegments);
      requiresStyleInsertion ? (destination.push(completeBoundaryScript3a2), writeStyleResourceDependenciesInJS2(destination, boundary)) : destination.push(completeBoundaryScript3b2);
      boundary = destination.push(completeBoundaryScriptEnd2);
      return writeBootstrap2(destination, request) && boundary;
    }
    function flushPartiallyCompletedSegment2(request, destination, boundary, segment) {
      if (segment.status === FLUSHED2)
        return true;
      var hoistableState = boundary.contentState, segmentID = segment.id;
      if (segmentID === -1) {
        if ((segment.id = boundary.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return flushSegmentContainer2(request, destination, segment, hoistableState);
      }
      if (segmentID === boundary.rootSegmentID)
        return flushSegmentContainer2(request, destination, segment, hoistableState);
      flushSegmentContainer2(request, destination, segment, hoistableState);
      boundary = request.resumableState;
      request = request.renderState;
      destination.push(request.startInlineScript);
      (boundary.instructions & SentCompleteSegmentFunction2) === NothingSent2 ? (boundary.instructions |= SentCompleteSegmentFunction2, destination.push(completeSegmentScript1Full2)) : destination.push(completeSegmentScript1Partial2);
      destination.push(request.segmentPrefix);
      segmentID = segmentID.toString(16);
      destination.push(segmentID);
      destination.push(completeSegmentScript22);
      destination.push(request.placeholderPrefix);
      destination.push(segmentID);
      destination = destination.push(completeSegmentScriptEnd2);
      return destination;
    }
    function flushCompletedQueues2(request, destination) {
      try {
        if (!(0 < request.pendingRootTasks)) {
          var i, completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null) {
            if (completedRootSegment.status === POSTPONED2)
              return;
            var completedPreambleSegments = request.completedPreambleSegments;
            if (completedPreambleSegments === null)
              return;
            var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
            if (htmlChunks) {
              for (i$jscomp$0 = 0;i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                destination.push(htmlChunks[i$jscomp$0]);
              if (headChunks)
                for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  destination.push(headChunks[i$jscomp$0]);
              else {
                var chunk = startChunkForTag2("head");
                destination.push(chunk);
                destination.push(endOfStartTag2);
              }
            } else if (headChunks)
              for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
                destination.push(headChunks[i$jscomp$0]);
            var charsetChunks = renderState.charsetChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
              destination.push(charsetChunks[i$jscomp$0]);
            charsetChunks.length = 0;
            renderState.preconnects.forEach(flushResource2, destination);
            renderState.preconnects.clear();
            var viewportChunks = renderState.viewportChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
              destination.push(viewportChunks[i$jscomp$0]);
            viewportChunks.length = 0;
            renderState.fontPreloads.forEach(flushResource2, destination);
            renderState.fontPreloads.clear();
            renderState.highImagePreloads.forEach(flushResource2, destination);
            renderState.highImagePreloads.clear();
            renderState.styles.forEach(flushStylesInPreamble2, destination);
            var importMapChunks = renderState.importMapChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
              destination.push(importMapChunks[i$jscomp$0]);
            importMapChunks.length = 0;
            renderState.bootstrapScripts.forEach(flushResource2, destination);
            renderState.scripts.forEach(flushResource2, destination);
            renderState.scripts.clear();
            renderState.bulkPreloads.forEach(flushResource2, destination);
            renderState.bulkPreloads.clear();
            var hoistableChunks = renderState.hoistableChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
              destination.push(hoistableChunks[i$jscomp$0]);
            for (renderState = hoistableChunks.length = 0;renderState < completedPreambleSegments.length; renderState++) {
              var segments = completedPreambleSegments[renderState];
              for (preamble = 0;preamble < segments.length; preamble++)
                flushSegment2(request, destination, segments[preamble], null);
            }
            var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
              var chunk$jscomp$0 = endChunkForTag2("head");
              destination.push(chunk$jscomp$0);
            }
            var bodyChunks = preamble$jscomp$0.bodyChunks;
            if (bodyChunks)
              for (completedPreambleSegments = 0;completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                destination.push(bodyChunks[completedPreambleSegments]);
            flushSegment2(request, destination, completedRootSegment, null);
            request.completedRootSegment = null;
            writeBootstrap2(destination, request.renderState);
          }
          var renderState$jscomp$0 = request.renderState;
          completedRootSegment = 0;
          var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
          for (completedRootSegment = 0;completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
            destination.push(viewportChunks$jscomp$0[completedRootSegment]);
          viewportChunks$jscomp$0.length = 0;
          renderState$jscomp$0.preconnects.forEach(flushResource2, destination);
          renderState$jscomp$0.preconnects.clear();
          renderState$jscomp$0.fontPreloads.forEach(flushResource2, destination);
          renderState$jscomp$0.fontPreloads.clear();
          renderState$jscomp$0.highImagePreloads.forEach(flushResource2, destination);
          renderState$jscomp$0.highImagePreloads.clear();
          renderState$jscomp$0.styles.forEach(preloadLateStyles2, destination);
          renderState$jscomp$0.scripts.forEach(flushResource2, destination);
          renderState$jscomp$0.scripts.clear();
          renderState$jscomp$0.bulkPreloads.forEach(flushResource2, destination);
          renderState$jscomp$0.bulkPreloads.clear();
          var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
          for (completedRootSegment = 0;completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
          hoistableChunks$jscomp$0.length = 0;
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            renderState$jscomp$0 = destination;
            var { resumableState, renderState: renderState$jscomp$1 } = request, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
            renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
            (resumableState.instructions & SentClientRenderFunction2) === NothingSent2 ? (resumableState.instructions |= SentClientRenderFunction2, renderState$jscomp$0.push(clientRenderScript1Full2)) : renderState$jscomp$0.push(clientRenderScript1Partial2);
            renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
            var chunk$jscomp$1 = id.toString(16);
            renderState$jscomp$0.push(chunk$jscomp$1);
            renderState$jscomp$0.push(clientRenderScript1A2);
            if (errorDigest || errorMessage || errorStack || errorComponentStack) {
              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$2 = escapeJSStringsForInstructionScripts2(errorDigest || "");
              renderState$jscomp$0.push(chunk$jscomp$2);
            }
            if (errorMessage || errorStack || errorComponentStack) {
              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts2(errorMessage || "");
              renderState$jscomp$0.push(chunk$jscomp$3);
            }
            if (errorStack || errorComponentStack) {
              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts2(errorStack || "");
              renderState$jscomp$0.push(chunk$jscomp$4);
            }
            if (errorComponentStack) {
              renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$5 = escapeJSStringsForInstructionScripts2(errorComponentStack);
              renderState$jscomp$0.push(chunk$jscomp$5);
            }
            var JSCompiler_inline_result = renderState$jscomp$0.push(clientRenderScriptEnd2);
            if (!JSCompiler_inline_result) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++)
            if (!flushCompletedBoundary2(request, destination, completedBoundaries[i])) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          completedBoundaries.splice(0, i);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            a: {
              clientRenderedBoundaries = request;
              boundary = destination;
              var boundary$jscomp$0 = partialBoundaries[i], completedSegments = boundary$jscomp$0.completedSegments;
              for (JSCompiler_inline_result = 0;JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                if (!flushPartiallyCompletedSegment2(clientRenderedBoundaries, boundary, boundary$jscomp$0, completedSegments[JSCompiler_inline_result])) {
                  JSCompiler_inline_result++;
                  completedSegments.splice(0, JSCompiler_inline_result);
                  var JSCompiler_inline_result$jscomp$0 = false;
                  break a;
                }
              completedSegments.splice(0, JSCompiler_inline_result);
              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary2(boundary, boundary$jscomp$0.contentState, clientRenderedBoundaries.renderState);
            }
            if (!JSCompiler_inline_result$jscomp$0) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++)
            if (!flushCompletedBoundary2(request, destination, largeBoundaries[i])) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          largeBoundaries.splice(0, i);
        }
      } finally {
        request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 && (request.flushScheduled = false, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag2("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag2("html"), destination.push(i)), request.abortableTasks.size !== 0 && console.error("There was still abortable task at the root when we closed. This is a bug in React."), request.status = CLOSED2, destination.push(null), request.destination = null);
      }
    }
    function startWork2(request) {
      request.flushScheduled = request.destination !== null;
      performWork2(request);
      request.status === 10 && (request.status = 11);
      request.trackedPostpones === null && safelyEmitEarlyPreloads2(request, request.pendingRootTasks === 0);
    }
    function enqueueFlush2(request) {
      if (request.flushScheduled === false && request.pingedTasks.length === 0 && request.destination !== null) {
        request.flushScheduled = true;
        var destination = request.destination;
        destination ? flushCompletedQueues2(request, destination) : request.flushScheduled = false;
      }
    }
    function startFlowing(request, destination) {
      if (request.status === 13)
        request.status = CLOSED2, destination.destroy(request.fatalError);
      else if (request.status !== CLOSED2 && request.destination === null) {
        request.destination = destination;
        try {
          flushCompletedQueues2(request, destination);
        } catch (error2) {
          destination = {}, logRecoverableError2(request, error2, destination, null), fatalError2(request, error2, destination, null);
        }
      }
    }
    function abort2(request, reason) {
      if (request.status === 11 || request.status === 10)
        request.status = 12;
      try {
        var abortableTasks = request.abortableTasks;
        if (0 < abortableTasks.size) {
          var error2 = reason === undefined ? Error("The render was aborted by the server without a reason.") : typeof reason === "object" && reason !== null && typeof reason.then === "function" ? Error("The render was aborted by the server with a promise.") : reason;
          request.fatalError = error2;
          abortableTasks.forEach(function(task) {
            return abortTask2(task, request, error2);
          });
          abortableTasks.clear();
        }
        request.destination !== null && flushCompletedQueues2(request, request.destination);
      } catch (error$4) {
        reason = {}, logRecoverableError2(request, error$4, reason, null), fatalError2(request, error$4, reason, null);
      }
    }
    function onError() {}
    function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
      var didFatal = false, fatalError3 = null, result = "", readyToStream = false;
      options = createResumableState2(options ? options.identifierPrefix : undefined);
      children = createRequest2(children, options, createRenderState2(options, generateStaticMarkup), createFormatContext2(ROOT_HTML_MODE2, null, 0), Infinity, onError, undefined, function() {
        readyToStream = true;
      }, undefined, undefined, undefined);
      startWork2(children);
      abort2(children, abortReason);
      startFlowing(children, {
        push: function(chunk) {
          chunk !== null && (result += chunk);
          return true;
        },
        destroy: function(error2) {
          didFatal = true;
          fatalError3 = error2;
        }
      });
      if (didFatal && fatalError3 !== abortReason)
        throw fatalError3;
      if (!readyToStream)
        throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return result;
    }
    var REACT_ELEMENT_TYPE2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE2 = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE2 = Symbol.for("react.provider"), REACT_CONSUMER_TYPE2 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE2 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE2 = Symbol.for("react.lazy"), REACT_SCOPE_TYPE2 = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE2 = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE2 = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL2 = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE2 = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL2 = Symbol.iterator, isArrayImpl2 = Array.isArray, jsxPropsParents2 = new WeakMap, jsxChildrenParents2 = new WeakMap, CLIENT_REFERENCE_TAG2 = Symbol.for("react.client.reference"), assign2 = Object.assign, hasOwnProperty3 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX2 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache2 = {}, validatedAttributeNameCache2 = {}, unitlessNumbers2 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases2 = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), hasReadOnlyValue2 = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    }, ariaProperties2 = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, warnedProperties$12 = {}, rARIA$12 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel$12 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), didWarnValueNull2 = false, possibleStandardNames2 = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, warnedProperties2 = {}, EVENT_NAME_REGEX2 = /^on./, INVALID_EVENT_NAME_REGEX2 = /^on[^A-Z]/, rARIA2 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel2 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), badVendoredStyleNamePattern2 = /^(?:webkit|moz|o)[A-Z]/, msPattern$12 = /^-ms-/, hyphenPattern2 = /-(.)/g, badStyleValueWithSemicolonPattern2 = /;\s*$/, warnedStyleNames2 = {}, warnedStyleValues2 = {}, warnedForNaNValue2 = false, warnedForInfinityValue2 = false, matchHtmlRegExp2 = /["'&<>]/, uppercasePattern2 = /([A-Z])/g, msPattern2 = /^ms-/, isJavaScriptProtocol2 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals2 = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals2 = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending2 = Object.freeze({
      pending: false,
      data: null,
      method: null,
      action: null
    }), previousDispatcher2 = ReactDOMSharedInternals2.d;
    ReactDOMSharedInternals2.d = {
      f: previousDispatcher2.f,
      r: previousDispatcher2.r,
      D: function(href) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (typeof href === "string" && href) {
            if (!resumableState.dnsResources.hasOwnProperty(href)) {
              resumableState.dnsResources[href] = EXISTS2;
              resumableState = renderState.headers;
              var header, JSCompiler_temp;
              if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext2(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
              JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS2, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl2(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
            }
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.D(href);
      },
      C: function(href, crossOrigin) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (typeof href === "string" && href) {
            var bucket = crossOrigin === "use-credentials" ? "credentials" : typeof crossOrigin === "string" ? "anonymous" : "default";
            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
              resumableState.connectResources[bucket][href] = EXISTS2;
              resumableState = renderState.headers;
              var header, JSCompiler_temp;
              if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext2(href) + ">; rel=preconnect";
                if (typeof crossOrigin === "string") {
                  var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext2(crossOrigin, "crossOrigin");
                  JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                }
                JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
              }
              JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS2, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl2(bucket, {
                rel: "preconnect",
                href,
                crossOrigin
              }), renderState.preconnects.add(bucket));
            }
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.C(href, crossOrigin);
      },
      L: function(href, as2, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (as2 && href) {
            switch (as2) {
              case "image":
                if (options) {
                  var imageSrcSet = options.imageSrcSet;
                  var imageSizes = options.imageSizes;
                  var fetchPriority = options.fetchPriority;
                }
                var key = imageSrcSet ? imageSrcSet + `
` + (imageSizes || "") : href;
                if (resumableState.imageResources.hasOwnProperty(key))
                  return;
                resumableState.imageResources[key] = PRELOAD_NO_CREDS2;
                resumableState = renderState.headers;
                var header;
                resumableState && 0 < resumableState.remainingCapacity && typeof imageSrcSet !== "string" && fetchPriority === "high" && (header = getPreloadAsHeader2(href, as2, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS2, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl2(resumableState, assign2({
                  rel: "preload",
                  href: imageSrcSet ? undefined : href,
                  as: as2
                }, options)), fetchPriority === "high" ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                break;
              case "style":
                if (resumableState.styleResources.hasOwnProperty(href))
                  return;
                imageSrcSet = [];
                pushLinkImpl2(imageSrcSet, assign2({ rel: "preload", href, as: as2 }, options));
                resumableState.styleResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS2 : [options.crossOrigin, options.integrity];
                renderState.preloads.stylesheets.set(href, imageSrcSet);
                renderState.bulkPreloads.add(imageSrcSet);
                break;
              case "script":
                if (resumableState.scriptResources.hasOwnProperty(href))
                  return;
                imageSrcSet = [];
                renderState.preloads.scripts.set(href, imageSrcSet);
                renderState.bulkPreloads.add(imageSrcSet);
                pushLinkImpl2(imageSrcSet, assign2({ rel: "preload", href, as: as2 }, options));
                resumableState.scriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS2 : [options.crossOrigin, options.integrity];
                break;
              default:
                if (resumableState.unknownResources.hasOwnProperty(as2)) {
                  if (imageSrcSet = resumableState.unknownResources[as2], imageSrcSet.hasOwnProperty(href))
                    return;
                } else
                  imageSrcSet = {}, resumableState.unknownResources[as2] = imageSrcSet;
                imageSrcSet[href] = PRELOAD_NO_CREDS2;
                if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && as2 === "font" && (key = getPreloadAsHeader2(href, as2, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                  renderState.resets.font[href] = PRELOAD_NO_CREDS2, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                else
                  switch (resumableState = [], href = assign2({ rel: "preload", href, as: as2 }, options), pushLinkImpl2(resumableState, href), as2) {
                    case "font":
                      renderState.fontPreloads.add(resumableState);
                      break;
                    default:
                      renderState.bulkPreloads.add(resumableState);
                  }
            }
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.L(href, as2, options);
      },
      m: function(href, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (href) {
            var as2 = options && typeof options.as === "string" ? options.as : "script";
            switch (as2) {
              case "script":
                if (resumableState.moduleScriptResources.hasOwnProperty(href))
                  return;
                as2 = [];
                resumableState.moduleScriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS2 : [options.crossOrigin, options.integrity];
                renderState.preloads.moduleScripts.set(href, as2);
                break;
              default:
                if (resumableState.moduleUnknownResources.hasOwnProperty(as2)) {
                  var resources = resumableState.unknownResources[as2];
                  if (resources.hasOwnProperty(href))
                    return;
                } else
                  resources = {}, resumableState.moduleUnknownResources[as2] = resources;
                as2 = [];
                resources[href] = PRELOAD_NO_CREDS2;
            }
            pushLinkImpl2(as2, assign2({ rel: "modulepreload", href }, options));
            renderState.bulkPreloads.add(as2);
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.m(href, options);
      },
      X: function(src, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (src) {
            var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : undefined;
            resourceState !== EXISTS2 && (resumableState.scriptResources[src] = EXISTS2, options = assign2({ src, async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials2(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl2(src, options), enqueueFlush2(request));
          }
        } else
          previousDispatcher2.X(src, options);
      },
      S: function(href, precedence, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (href) {
            precedence = precedence || "default";
            var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
            resourceState !== EXISTS2 && (resumableState.styleResources[href] = EXISTS2, styleQueue || (styleQueue = {
              precedence: escapeTextForBrowser2(precedence),
              rules: [],
              hrefs: [],
              sheets: new Map
            }, renderState.styles.set(precedence, styleQueue)), precedence = {
              state: PENDING$12,
              props: assign2({
                rel: "stylesheet",
                href,
                "data-precedence": precedence
              }, options)
            }, resourceState && (resourceState.length === 2 && adoptPreloadCredentials2(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED2), styleQueue.sheets.set(href, precedence), enqueueFlush2(request));
          }
        } else
          previousDispatcher2.S(href, precedence, options);
      },
      M: function(src, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (src) {
            var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : undefined;
            resourceState !== EXISTS2 && (resumableState.moduleScriptResources[src] = EXISTS2, options = assign2({ src, type: "module", async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials2(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl2(src, options), enqueueFlush2(request));
          }
        } else
          previousDispatcher2.M(src, options);
      }
    };
    var NothingSent2 = 0, SentCompleteSegmentFunction2 = 1, SentCompleteBoundaryFunction2 = 2, SentClientRenderFunction2 = 4, SentStyleInsertionFunction2 = 8, EXISTS2 = null, PRELOAD_NO_CREDS2 = [];
    Object.freeze(PRELOAD_NO_CREDS2);
    var scriptRegex2 = /(<\/|<)(s)(cript)/gi;
    var didWarnForNewBooleanPropsWithEmptyValue2 = {};
    var NoContribution2 = 0, ROOT_HTML_MODE2 = 0, HTML_HTML_MODE2 = 1, HTML_MODE2 = 2, HTML_HEAD_MODE2 = 3, SVG_MODE2 = 4, MATHML_MODE2 = 5, HTML_TABLE_MODE2 = 6, HTML_TABLE_BODY_MODE2 = 7, HTML_TABLE_ROW_MODE2 = 8, HTML_COLGROUP_MODE2 = 9, styleNameCache2 = new Map, styleAttributeStart2 = ' style="', styleAssign2 = ":", styleSeparator2 = ";", attributeSeparator2 = " ", attributeAssign2 = '="', attributeEnd2 = '"', attributeEmptyString2 = '=""', actionJavaScriptURL2 = escapeTextForBrowser2("javascript:throw new Error('React form unexpectedly submitted.')"), endOfStartTag2 = ">", endOfStartTagSelfClosing2 = "/>", didWarnDefaultInputValue2 = false, didWarnDefaultChecked2 = false, didWarnDefaultSelectValue2 = false, didWarnDefaultTextareaValue2 = false, didWarnInvalidOptionChildren2 = false, didWarnInvalidOptionInnerHTML2 = false, didWarnSelectedSetOnOption2 = false, didWarnFormActionType2 = false, didWarnFormActionName2 = false, didWarnFormActionTarget2 = false, didWarnFormActionMethod2 = false, formReplayingRuntimeScript2 = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex2 = /(<\/|<)(s)(tyle)/gi, leadingNewline = `
`, VALID_TAG_REGEX2 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache2 = new Map, endTagCache2 = new Map, placeholder12 = '<template id="', placeholder22 = '"></template>', startCompletedSuspenseBoundary2 = "<!--$-->", startPendingSuspenseBoundary12 = '<!--$?--><template id="', startPendingSuspenseBoundary22 = '"></template>', startClientRenderedSuspenseBoundary2 = "<!--$!-->", endSuspenseBoundary2 = "<!--/$-->", clientRenderedSuspenseBoundaryError12 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial2 = '"', clientRenderedSuspenseBoundaryError1A2 = ' data-dgst="', clientRenderedSuspenseBoundaryError1B2 = ' data-msg="', clientRenderedSuspenseBoundaryError1C2 = ' data-stck="', clientRenderedSuspenseBoundaryError1D2 = ' data-cstck="', clientRenderedSuspenseBoundaryError22 = "></template>", boundaryPreambleContributionChunkStart2 = "<!--", boundaryPreambleContributionChunkEnd2 = "-->", startSegmentHTML3 = '<div hidden id="', startSegmentHTML22 = '">', endSegmentHTML2 = "</div>", startSegmentSVG3 = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG22 = '">', endSegmentSVG2 = "</svg>", startSegmentMathML3 = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML22 = '">', endSegmentMathML2 = "</math>", startSegmentTable3 = '<table hidden id="', startSegmentTable22 = '">', endSegmentTable2 = "</table>", startSegmentTableBody3 = '<table hidden><tbody id="', startSegmentTableBody22 = '">', endSegmentTableBody2 = "</tbody></table>", startSegmentTableRow3 = '<table hidden><tr id="', startSegmentTableRow22 = '">', endSegmentTableRow2 = "</tr></table>", startSegmentColGroup3 = '<table hidden><colgroup id="', startSegmentColGroup22 = '">', endSegmentColGroup2 = "</colgroup></table>", completeSegmentScript1Full2 = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial2 = '$RS("', completeSegmentScript22 = '","', completeSegmentScriptEnd2 = '")</script>', completeBoundaryScript1Full2 = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("', completeBoundaryScript1Partial2 = '$RC("', completeBoundaryWithStylesScript1FullBoth2 = `$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;
$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=
d;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,
t,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("`, completeBoundaryWithStylesScript1FullPartial2 = `$RM=new Map;
$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=
d;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,
t,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("`, completeBoundaryWithStylesScript1Partial2 = '$RR("', completeBoundaryScript22 = '","', completeBoundaryScript3a2 = '",', completeBoundaryScript3b2 = '"', completeBoundaryScriptEnd2 = ")</script>", clientRenderScript1Full2 = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial2 = '$RX("', clientRenderScript1A2 = '"', clientRenderErrorScriptArgInterstitial2 = ",", clientRenderScriptEnd2 = ")</script>", regexForJSStringsInInstructionScripts2 = /[<\u2028\u2029]/g, regexForJSStringsInScripts2 = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen12 = '<style media="not all" data-precedence="', lateStyleTagResourceOpen22 = '" data-href="', lateStyleTagResourceOpen32 = '">', lateStyleTagTemplateClose2 = "</style>", currentlyRenderingBoundaryHasStylesToHoist2 = false, destinationHasCapacity2 = true, stylesheetFlushingQueue2 = [], styleTagResourceOpen12 = '<style data-precedence="', styleTagResourceOpen22 = '" data-href="', spaceSeparator2 = " ", styleTagResourceOpen32 = '">', styleTagResourceClose2 = "</style>", arrayFirstOpenBracket2 = "[", arraySubsequentOpenBracket2 = ",[", arrayInterstitial2 = ",", arrayCloseBracket2 = "]", PENDING$12 = 0, PRELOADED2 = 1, PREAMBLE2 = 2, LATE2 = 3, regexForHrefInLinkHeaderURLContext2 = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext2 = /["';,\r\n]/g, doctypeChunk = "", bind3 = Function.prototype.bind, REACT_CLIENT_REFERENCE2 = Symbol.for("react.client.reference"), emptyContextObject2 = {};
    Object.freeze(emptyContextObject2);
    var rendererSigil2 = {};
    var currentActiveSnapshot2 = null, didWarnAboutNoopUpdateForComponent2 = {}, didWarnAboutDeprecatedWillMount2 = {};
    var didWarnAboutUninitializedState2 = new Set;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate2 = new Set;
    var didWarnAboutLegacyLifecyclesAndDerivedState2 = new Set;
    var didWarnAboutDirectlyAssigningPropsToState2 = new Set;
    var didWarnAboutUndefinedDerivedState2 = new Set;
    var didWarnAboutContextTypes$12 = new Set;
    var didWarnAboutChildContextTypes2 = new Set;
    var didWarnAboutInvalidateContextType2 = new Set;
    var didWarnOnInvalidCallback2 = new Set;
    var classComponentUpdater2 = {
      enqueueSetState: function(inst, payload, callback) {
        var internals = inst._reactInternals;
        internals.queue === null ? warnNoop2(inst, "setState") : (internals.queue.push(payload), callback !== undefined && callback !== null && warnOnInvalidCallback2(callback));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        inst.replace = true;
        inst.queue = [payload];
        callback !== undefined && callback !== null && warnOnInvalidCallback2(callback);
      },
      enqueueForceUpdate: function(inst, callback) {
        inst._reactInternals.queue === null ? warnNoop2(inst, "forceUpdate") : callback !== undefined && callback !== null && warnOnInvalidCallback2(callback);
      }
    }, emptyTreeContext2 = { id: 1, overflow: "" }, clz322 = Math.clz32 ? Math.clz32 : clz32Fallback2, log3 = Math.log, LN22 = Math.LN2, SuspenseException2 = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), suspendedThenable2 = null, objectIs2 = typeof Object.is === "function" ? Object.is : is5, currentlyRenderingComponent2 = null, currentlyRenderingTask2 = null, currentlyRenderingRequest2 = null, currentlyRenderingKeyPath2 = null, firstWorkInProgressHook2 = null, workInProgressHook2 = null, isReRender2 = false, didScheduleRenderPhaseUpdate2 = false, localIdCounter2 = 0, actionStateCounter2 = 0, actionStateMatchingIndex2 = -1, thenableIndexCounter2 = 0, thenableState2 = null, renderPhaseUpdates2 = null, numberOfReRenders2 = 0, isInHookUserCodeInDev2 = false, currentHookNameInDev2, HooksDispatcher2 = {
      readContext: readContext2,
      use: function(usable) {
        if (usable !== null && typeof usable === "object") {
          if (typeof usable.then === "function")
            return unwrapThenable2(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE2)
            return readContext2(usable);
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
      },
      useContext: function(context) {
        currentHookNameInDev2 = "useContext";
        resolveCurrentlyRenderingComponent2();
        return context._currentValue2;
      },
      useMemo: useMemo2,
      useReducer: useReducer2,
      useRef: function(initialValue) {
        currentlyRenderingComponent2 = resolveCurrentlyRenderingComponent2();
        workInProgressHook2 = createWorkInProgressHook2();
        var previousRef = workInProgressHook2.memoizedState;
        return previousRef === null ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook2.memoizedState = initialValue) : previousRef;
      },
      useState: function(initialState) {
        currentHookNameInDev2 = "useState";
        return useReducer2(basicStateReducer2, initialState);
      },
      useInsertionEffect: noop$12,
      useLayoutEffect: noop$12,
      useCallback: function(callback, deps) {
        return useMemo2(function() {
          return callback;
        }, deps);
      },
      useImperativeHandle: noop$12,
      useEffect: noop$12,
      useDebugValue: noop$12,
      useDeferredValue: function(value, initialValue) {
        resolveCurrentlyRenderingComponent2();
        return initialValue !== undefined ? initialValue : value;
      },
      useTransition: function() {
        resolveCurrentlyRenderingComponent2();
        return [false, unsupportedStartTransition2];
      },
      useId: function() {
        var treeId = currentlyRenderingTask2.treeContext;
        var overflow = treeId.overflow;
        treeId = treeId.id;
        treeId = (treeId & ~(1 << 32 - clz322(treeId) - 1)).toString(32) + overflow;
        var resumableState = currentResumableState2;
        if (resumableState === null)
          throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        overflow = localIdCounter2++;
        treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
        0 < overflow && (treeId += "H" + overflow.toString(32));
        return treeId + "\xBB";
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
      },
      useOptimistic: function(passthrough) {
        resolveCurrentlyRenderingComponent2();
        return [passthrough, unsupportedSetOptimisticState2];
      },
      useActionState: useActionState2,
      useFormState: useActionState2,
      useHostTransitionStatus: function() {
        resolveCurrentlyRenderingComponent2();
        return NotPending2;
      },
      useMemoCache: function(size) {
        for (var data = Array(size), i = 0;i < size; i++)
          data[i] = REACT_MEMO_CACHE_SENTINEL2;
        return data;
      },
      useCacheRefresh: function() {
        return unsupportedRefresh2;
      }
    }, currentResumableState2 = null, currentTaskInDEV2 = null, DefaultAsyncDispatcher2 = {
      getCacheForType: function() {
        throw Error("Not implemented.");
      },
      getOwner: function() {
        return currentTaskInDEV2 === null ? null : currentTaskInDEV2.componentStack;
      }
    }, disabledDepth2 = 0, prevLog2, prevInfo2, prevWarn2, prevError2, prevGroup2, prevGroupCollapsed2, prevGroupEnd2;
    disabledLog2.__reactDisabledLog = true;
    var prefix2, suffix2, reentry2 = false;
    var componentFrameCache2 = new (typeof WeakMap === "function" ? WeakMap : Map);
    var callComponent2 = {
      "react-stack-bottom-frame": function(Component, props, secondArg) {
        return Component(props, secondArg);
      }
    }, callComponentInDEV2 = callComponent2["react-stack-bottom-frame"].bind(callComponent2), callRender2 = {
      "react-stack-bottom-frame": function(instance) {
        return instance.render();
      }
    }, callRenderInDEV2 = callRender2["react-stack-bottom-frame"].bind(callRender2), callLazyInit2 = {
      "react-stack-bottom-frame": function(lazy) {
        var init2 = lazy._init;
        return init2(lazy._payload);
      }
    }, callLazyInitInDEV2 = callLazyInit2["react-stack-bottom-frame"].bind(callLazyInit2), lastResetTime2 = 0;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance2 = performance;
      var getCurrentTime2 = function() {
        return localPerformance2.now();
      };
    } else {
      var localDate2 = Date;
      getCurrentTime2 = function() {
        return localDate2.now();
      };
    }
    var CLIENT_RENDERED2 = 4, PENDING2 = 0, COMPLETED2 = 1, FLUSHED2 = 2, POSTPONED2 = 5, CLOSED2 = 14, currentRequest2 = null, didWarnAboutBadClass2 = {}, didWarnAboutContextTypes2 = {}, didWarnAboutContextTypeOnFunctionComponent2 = {}, didWarnAboutGetDerivedStateOnFunctionComponent2 = {}, didWarnAboutReassigningProps2 = false, didWarnAboutGenerators2 = false, didWarnAboutMaps2 = false;
    exports.renderToStaticMarkup = function(children, options) {
      return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    };
    exports.renderToString = function(children, options) {
      return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    };
    exports.version = "19.1.0";
  })();
});

// ../../node_modules/react-dom/server.bun.js
var require_server_bun = __commonJS((exports) => {
  init_react_dom_server_bun_development();
  var react_dom_server_legacy_browser_development = __toESM(require_react_dom_server_legacy_browser_development(), 1);
  var b2;
  var l2;
  if (false) {} else {
    b2 = exports_react_dom_server_bun_development;
    l2 = react_dom_server_legacy_browser_development;
  }
  exports.version = b2.version;
  exports.renderToReadableStream = b2.renderToReadableStream;
  if (b2.resume) {
    exports.resume = b2.resume;
  }
  exports.renderToString = l2.renderToString;
  exports.renderToStaticMarkup = l2.renderToStaticMarkup;
});

// ../../node_modules/@react-email/render/dist/node/index.mjs
var exports_node = {};
__export(exports_node, {
  renderAsync: () => renderAsync,
  render: () => render2,
  pretty: () => pretty,
  plainTextSelectors: () => plainTextSelectors
});
import { Writable } from "stream";
function recursivelyMapDoc(doc, callback) {
  if (Array.isArray(doc)) {
    return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  }
  if (typeof doc === "object") {
    if (doc.type === "group") {
      return __spreadProps2(__spreadValues2({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback),
        expandedStates: recursivelyMapDoc(doc.expandedStates, callback)
      });
    }
    if ("contents" in doc) {
      return __spreadProps2(__spreadValues2({}, doc), {
        contents: recursivelyMapDoc(doc.contents, callback)
      });
    }
    if ("parts" in doc) {
      return __spreadProps2(__spreadValues2({}, doc), {
        parts: recursivelyMapDoc(doc.parts, callback)
      });
    }
    if (doc.type === "if-break") {
      return __spreadProps2(__spreadValues2({}, doc), {
        breakContents: recursivelyMapDoc(doc.breakContents, callback),
        flatContents: recursivelyMapDoc(doc.flatContents, callback)
      });
    }
  }
  return callback(doc);
}
var import_react, import_jsx_runtime, __defProp3, __defProps2, __getOwnPropDescs2, __getOwnPropSymbols2, __hasOwnProp3, __propIsEnum2, __defNormalProp2 = (obj, key, value) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, __spreadValues2 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp2(a, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a, prop, b2[prop]);
    }
  return a;
}, __spreadProps2 = (a, b2) => __defProps2(a, __getOwnPropDescs2(b2)), __async = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
}, plainTextSelectors, modifiedHtml, defaults4, pretty = (str, options = {}) => {
  return yu(str.replaceAll("\x00", ""), __spreadValues2(__spreadValues2({}, defaults4), options));
}, decoder2, readStream2 = (stream4) => __async(undefined, null, function* () {
  let result = "";
  if ("pipeTo" in stream4) {
    const writableStream = new WritableStream({
      write(chunk) {
        result += decoder2.decode(chunk);
      }
    });
    yield stream4.pipeTo(writableStream);
  } else {
    const writable = new Writable({
      write(chunk, _encoding, callback) {
        result += decoder2.decode(chunk);
        callback();
      }
    });
    stream4.pipe(writable);
    yield new Promise((resolve, reject) => {
      writable.on("error", reject);
      writable.on("close", () => {
        resolve();
      });
    });
  }
  return result;
}), render2 = (node2, options) => __async(undefined, null, function* () {
  const suspendedElement = /* @__PURE__ */ import_jsx_runtime.jsx(import_react.Suspense, { children: node2 });
  const reactDOMServer = yield Promise.resolve().then(() => __toESM(require_server_bun(), 1)).then((m2) => m2.default);
  let html2;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream")) {
    html2 = yield readStream2(yield reactDOMServer.renderToReadableStream(suspendedElement));
  } else {
    yield new Promise((resolve, reject) => {
      const stream4 = reactDOMServer.renderToPipeableStream(suspendedElement, {
        onAllReady() {
          return __async(this, null, function* () {
            html2 = yield readStream2(stream4);
            resolve();
          });
        },
        onError(error2) {
          reject(error2);
        }
      });
    });
  }
  if (options == null ? undefined : options.plainText) {
    return convert(html2, __spreadValues2({
      selectors: plainTextSelectors
    }, options.htmlToTextOptions));
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document2 = `${doctype}${html2.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options == null ? undefined : options.pretty) {
    return pretty(document2);
  }
  return document2;
}), renderAsync = (element, options) => {
  return render2(element, options);
};
var init_node2 = __esm(() => {
  init_html_to_text();
  import_react = __toESM(require_react(), 1);
  init_html();
  init_standalone();
  import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  __defProp3 = Object.defineProperty;
  __defProps2 = Object.defineProperties;
  __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
  __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
  __hasOwnProp3 = Object.prototype.hasOwnProperty;
  __propIsEnum2 = Object.prototype.propertyIsEnumerable;
  plainTextSelectors = [
    { selector: "img", format: "skip" },
    { selector: "[data-skip-in-text=true]", format: "skip" },
    {
      selector: "a",
      options: { linkBrackets: false }
    }
  ];
  modifiedHtml = __spreadValues2({}, exports_html);
  if (modifiedHtml.printers) {
    const previousPrint = modifiedHtml.printers.html.print;
    modifiedHtml.printers.html.print = (path2, options, print, args) => {
      const node2 = path2.getNode();
      const rawPrintingResult = previousPrint(path2, options, print, args);
      if (node2.type === "ieConditionalComment") {
        const printingResult = recursivelyMapDoc(rawPrintingResult, (doc) => {
          if (typeof doc === "object" && doc.type === "line") {
            return doc.soft ? "" : " ";
          }
          return doc;
        });
        return printingResult;
      }
      return rawPrintingResult;
    };
  }
  defaults4 = {
    endOfLine: "lf",
    tabWidth: 2,
    plugins: [modifiedHtml],
    bracketSameLine: true,
    parser: "html"
  };
  decoder2 = new TextDecoder("utf-8");
});

// ../../node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// ../../node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// ../../node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// ../../node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// ../../node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// ../../node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// ../../node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// ../../node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// ../../node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}
class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// ../../node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// ../../node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, selection, alias, isWith = false) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: selection,
      alias,
      isWith
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// ../../node_modules/drizzle-orm/version.js
var version = "0.43.1";

// ../../node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// ../../node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// ../../node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// ../../node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// ../../node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// ../../node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// ../../node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {}
}

// ../../node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// ../../node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}

// ../../node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigint(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigserial(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config) {
    super(name, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgCharBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new PgCustomColumnBuilder(name, config, customTypeParams);
  };
}

// ../../node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// ../../node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
}
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgIntervalBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function json(name) {
  return new PgJsonBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
}
function line(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string")
      return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericNumberBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name, precision, scale) {
    super(name, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericNumber(table, this.config);
  }
}

class PgNumericNumber extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number")
      return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericBigIntBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name, precision, scale) {
    super(name, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericBigInt(table, this.config);
  }
}

class PgNumericBigInt extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);
}

// ../../node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
}
function point(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0;i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x, y];
  }
  throw new Error("Unsupported geometry type");
}

// ../../node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
}
function geometry(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// ../../node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
}
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
}
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTextBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

// ../../node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);
}

// ../../node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}

// ../../node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config) {
    super(name, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVarcharBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgBinaryVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function halfvec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgHalfVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgSparseVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function vector(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVectorBuilder(name, config);
}

// ../../node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// ../../node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// ../../node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// ../../node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// ../../node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// ../../node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// ../../node_modules/drizzle-orm/sql/functions/aggregate.js
function count(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}

// ../../node_modules/better-auth/dist/shared/better-auth.DdzSJf-n.mjs
class BetterAuthError extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "BetterAuthError";
    this.message = message;
    this.cause = cause;
    this.stack = "";
  }
}

// ../../node_modules/better-auth/dist/shared/better-auth.tB5eU6EY.mjs
function safeJSONParse(data) {
  function reviver(_, value) {
    if (typeof value === "string") {
      const iso8601Regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/;
      if (iso8601Regex.test(value)) {
        const date2 = new Date(value);
        if (!isNaN(date2.getTime())) {
          return date2;
        }
      }
    }
    return value;
  }
  try {
    return JSON.parse(data, reviver);
  } catch {
    return null;
  }
}

// ../../node_modules/better-auth/dist/shared/better-auth.DGdvqtd1.mjs
function withApplyDefault(value, field, action) {
  if (action === "update") {
    return value;
  }
  if (value === undefined || value === null) {
    if (field.defaultValue !== undefined) {
      if (typeof field.defaultValue === "function") {
        return field.defaultValue();
      }
      return field.defaultValue;
    }
  }
  return value;
}

// ../../node_modules/better-auth/dist/shared/better-auth.DORkW_Ge.mjs
var getAuthTables = (options) => {
  const pluginSchema = options.plugins?.reduce((acc, plugin) => {
    const schema = plugin.schema;
    if (!schema)
      return acc;
    for (const [key, value] of Object.entries(schema)) {
      acc[key] = {
        fields: {
          ...acc[key]?.fields,
          ...value.fields
        },
        modelName: value.modelName || key
      };
    }
    return acc;
  }, {});
  const shouldAddRateLimitTable = options.rateLimit?.storage === "database";
  const rateLimitTable = {
    rateLimit: {
      modelName: options.rateLimit?.modelName || "rateLimit",
      fields: {
        key: {
          type: "string",
          fieldName: options.rateLimit?.fields?.key || "key"
        },
        count: {
          type: "number",
          fieldName: options.rateLimit?.fields?.count || "count"
        },
        lastRequest: {
          type: "number",
          bigint: true,
          fieldName: options.rateLimit?.fields?.lastRequest || "lastRequest"
        }
      }
    }
  };
  const { user, session, account, ...pluginTables } = pluginSchema || {};
  const sessionTable = {
    session: {
      modelName: options.session?.modelName || "session",
      fields: {
        expiresAt: {
          type: "date",
          required: true,
          fieldName: options.session?.fields?.expiresAt || "expiresAt"
        },
        token: {
          type: "string",
          required: true,
          fieldName: options.session?.fields?.token || "token",
          unique: true
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options.session?.fields?.createdAt || "createdAt"
        },
        updatedAt: {
          type: "date",
          required: true,
          fieldName: options.session?.fields?.updatedAt || "updatedAt"
        },
        ipAddress: {
          type: "string",
          required: false,
          fieldName: options.session?.fields?.ipAddress || "ipAddress"
        },
        userAgent: {
          type: "string",
          required: false,
          fieldName: options.session?.fields?.userAgent || "userAgent"
        },
        userId: {
          type: "string",
          fieldName: options.session?.fields?.userId || "userId",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true
        },
        ...session?.fields,
        ...options.session?.additionalFields
      },
      order: 2
    }
  };
  return {
    user: {
      modelName: options.user?.modelName || "user",
      fields: {
        name: {
          type: "string",
          required: true,
          fieldName: options.user?.fields?.name || "name",
          sortable: true
        },
        email: {
          type: "string",
          unique: true,
          required: true,
          fieldName: options.user?.fields?.email || "email",
          sortable: true
        },
        emailVerified: {
          type: "boolean",
          defaultValue: () => false,
          required: true,
          fieldName: options.user?.fields?.emailVerified || "emailVerified"
        },
        image: {
          type: "string",
          required: false,
          fieldName: options.user?.fields?.image || "image"
        },
        createdAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date,
          required: true,
          fieldName: options.user?.fields?.createdAt || "createdAt"
        },
        updatedAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date,
          required: true,
          fieldName: options.user?.fields?.updatedAt || "updatedAt"
        },
        ...user?.fields,
        ...options.user?.additionalFields
      },
      order: 1
    },
    ...!options.secondaryStorage || options.session?.storeSessionInDatabase ? sessionTable : {},
    account: {
      modelName: options.account?.modelName || "account",
      fields: {
        accountId: {
          type: "string",
          required: true,
          fieldName: options.account?.fields?.accountId || "accountId"
        },
        providerId: {
          type: "string",
          required: true,
          fieldName: options.account?.fields?.providerId || "providerId"
        },
        userId: {
          type: "string",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true,
          fieldName: options.account?.fields?.userId || "userId"
        },
        accessToken: {
          type: "string",
          required: false,
          fieldName: options.account?.fields?.accessToken || "accessToken"
        },
        refreshToken: {
          type: "string",
          required: false,
          fieldName: options.account?.fields?.refreshToken || "refreshToken"
        },
        idToken: {
          type: "string",
          required: false,
          fieldName: options.account?.fields?.idToken || "idToken"
        },
        accessTokenExpiresAt: {
          type: "date",
          required: false,
          fieldName: options.account?.fields?.accessTokenExpiresAt || "accessTokenExpiresAt"
        },
        refreshTokenExpiresAt: {
          type: "date",
          required: false,
          fieldName: options.account?.fields?.accessTokenExpiresAt || "refreshTokenExpiresAt"
        },
        scope: {
          type: "string",
          required: false,
          fieldName: options.account?.fields?.scope || "scope"
        },
        password: {
          type: "string",
          required: false,
          fieldName: options.account?.fields?.password || "password"
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options.account?.fields?.createdAt || "createdAt"
        },
        updatedAt: {
          type: "date",
          required: true,
          fieldName: options.account?.fields?.updatedAt || "updatedAt"
        },
        ...account?.fields
      },
      order: 3
    },
    verification: {
      modelName: options.verification?.modelName || "verification",
      fields: {
        identifier: {
          type: "string",
          required: true,
          fieldName: options.verification?.fields?.identifier || "identifier"
        },
        value: {
          type: "string",
          required: true,
          fieldName: options.verification?.fields?.value || "value"
        },
        expiresAt: {
          type: "date",
          required: true,
          fieldName: options.verification?.fields?.expiresAt || "expiresAt"
        },
        createdAt: {
          type: "date",
          required: false,
          defaultValue: () => /* @__PURE__ */ new Date,
          fieldName: options.verification?.fields?.createdAt || "createdAt"
        },
        updatedAt: {
          type: "date",
          required: false,
          defaultValue: () => /* @__PURE__ */ new Date,
          fieldName: options.verification?.fields?.updatedAt || "updatedAt"
        }
      },
      order: 4
    },
    ...pluginTables,
    ...shouldAddRateLimitTable ? rateLimitTable : {}
  };
};

// ../../node_modules/uncrypto/dist/crypto.web.mjs
var webCrypto = globalThis.crypto;
var subtle = webCrypto.subtle;
var getRandomValues = (array) => {
  return webCrypto.getRandomValues(array);
};

// ../../node_modules/@better-auth/utils/dist/random.mjs
function expandAlphabet(alphabet) {
  switch (alphabet) {
    case "a-z":
      return "abcdefghijklmnopqrstuvwxyz";
    case "A-Z":
      return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    case "0-9":
      return "0123456789";
    case "-_":
      return "-_";
    default:
      throw new Error(`Unsupported alphabet: ${alphabet}`);
  }
}
function createRandomStringGenerator(...baseAlphabets) {
  const baseCharSet = baseAlphabets.map(expandAlphabet).join("");
  if (baseCharSet.length === 0) {
    throw new Error("No valid characters provided for random string generation.");
  }
  const baseCharSetLength = baseCharSet.length;
  return (length, ...alphabets) => {
    if (length <= 0) {
      throw new Error("Length must be a positive integer.");
    }
    let charSet = baseCharSet;
    let charSetLength = baseCharSetLength;
    if (alphabets.length > 0) {
      charSet = alphabets.map(expandAlphabet).join("");
      charSetLength = charSet.length;
    }
    const maxValid = Math.floor(256 / charSetLength) * charSetLength;
    const buf = new Uint8Array(length * 2);
    const bufLength = buf.length;
    let result = "";
    let bufIndex = bufLength;
    let rand;
    while (result.length < length) {
      if (bufIndex >= bufLength) {
        getRandomValues(buf);
        bufIndex = 0;
      }
      rand = buf[bufIndex++];
      if (rand < maxValid) {
        result += charSet[rand % charSetLength];
      }
    }
    return result;
  };
}

// ../../node_modules/better-auth/dist/shared/better-auth.BUPPRXfK.mjs
var generateId = (size) => {
  return createRandomStringGenerator("a-z", "A-Z", "0-9")(size || 32);
};

// ../../node_modules/zod/dist/esm/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// ../../node_modules/zod/dist/esm/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// ../../node_modules/zod/dist/esm/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// ../../node_modules/zod/dist/esm/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// ../../node_modules/zod/dist/esm/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// ../../node_modules/zod/dist/esm/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// ../../node_modules/zod/dist/esm/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// ../../node_modules/zod/dist/esm/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// ../../node_modules/rou3/dist/index.mjs
var EmptyObject = /* @__PURE__ */ (() => {
  const C = function() {};
  C.prototype = /* @__PURE__ */ Object.create(null);
  return C;
})();
function createRouter() {
  const ctx = {
    root: { key: "" },
    static: new EmptyObject
  };
  return ctx;
}
function splitPath(path) {
  return path.split("/").filter(Boolean);
}
function getMatchParams(segments, paramsMap) {
  const params = new EmptyObject;
  for (const [index, name] of paramsMap) {
    const segment = index < 0 ? segments.slice(-1 * index).join("/") : segments[index];
    if (typeof name === "string") {
      params[name] = segment;
    } else {
      const match = segment.match(name);
      if (match) {
        for (const key in match.groups) {
          params[key] = match.groups[key];
        }
      }
    }
  }
  return params;
}
function addRoute(ctx, method = "", path, data) {
  const segments = splitPath(path);
  let node = ctx.root;
  let _unnamedParamIndex = 0;
  const paramsMap = [];
  for (let i = 0;i < segments.length; i++) {
    const segment = segments[i];
    if (segment.startsWith("**")) {
      if (!node.wildcard) {
        node.wildcard = { key: "**" };
      }
      node = node.wildcard;
      paramsMap.push([
        -i,
        segment.split(":")[1] || "_",
        segment.length === 2
      ]);
      break;
    }
    if (segment === "*" || segment.includes(":")) {
      if (!node.param) {
        node.param = { key: "*" };
      }
      node = node.param;
      const isOptional = segment === "*";
      paramsMap.push([
        i,
        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),
        isOptional
      ]);
      continue;
    }
    const child = node.static?.[segment];
    if (child) {
      node = child;
    } else {
      const staticNode = { key: segment };
      if (!node.static) {
        node.static = new EmptyObject;
      }
      node.static[segment] = staticNode;
      node = staticNode;
    }
  }
  const hasParams = paramsMap.length > 0;
  if (!node.methods) {
    node.methods = new EmptyObject;
  }
  if (!node.methods[method]) {
    node.methods[method] = [];
  }
  node.methods[method].push({
    data: data || null,
    paramsMap: hasParams ? paramsMap : undefined
  });
  if (!hasParams) {
    ctx.static[path] = node;
  }
}
function _getParamMatcher(segment) {
  if (!segment.includes(":", 1)) {
    return segment.slice(1);
  }
  const regex = segment.replace(/:(\w+)/g, (_, id) => `(?<${id}>\\w+)`);
  return new RegExp(`^${regex}$`);
}
function findRoute(ctx, method = "", path, opts) {
  if (path[path.length - 1] === "/") {
    path = path.slice(0, -1);
  }
  const staticNode = ctx.static[path];
  if (staticNode && staticNode.methods) {
    const staticMatch = staticNode.methods[method] || staticNode.methods[""];
    if (staticMatch !== undefined) {
      return staticMatch[0];
    }
  }
  const segments = splitPath(path);
  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];
  if (match === undefined) {
    return;
  }
  if (opts?.params === false) {
    return match;
  }
  return {
    data: match.data,
    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : undefined
  };
}
function _lookupTree(ctx, node, method, segments, index) {
  if (index === segments.length) {
    if (node.methods) {
      const match = node.methods[method] || node.methods[""];
      if (match) {
        return match;
      }
    }
    if (node.param && node.param.methods) {
      const match = node.param.methods[method] || node.param.methods[""];
      if (match) {
        const pMap = match[0].paramsMap;
        if (pMap?.[pMap?.length - 1]?.[2]) {
          return match;
        }
      }
    }
    if (node.wildcard && node.wildcard.methods) {
      const match = node.wildcard.methods[method] || node.wildcard.methods[""];
      if (match) {
        const pMap = match[0].paramsMap;
        if (pMap?.[pMap?.length - 1]?.[2]) {
          return match;
        }
      }
    }
    return;
  }
  const segment = segments[index];
  if (node.static) {
    const staticChild = node.static[segment];
    if (staticChild) {
      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);
      if (match) {
        return match;
      }
    }
  }
  if (node.param) {
    const match = _lookupTree(ctx, node.param, method, segments, index + 1);
    if (match) {
      return match;
    }
  }
  if (node.wildcard && node.wildcard.methods) {
    return node.wildcard.methods[method] || node.wildcard.methods[""];
  }
  return;
}
function findAllRoutes(ctx, method = "", path, opts) {
  if (path[path.length - 1] === "/") {
    path = path.slice(0, -1);
  }
  const segments = splitPath(path);
  const matches = _findAll(ctx, ctx.root, method, segments, 0);
  if (opts?.params === false) {
    return matches;
  }
  return matches.map((m) => {
    return {
      data: m.data,
      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : undefined
    };
  });
}
function _findAll(ctx, node, method, segments, index, matches = []) {
  const segment = segments[index];
  if (node.wildcard && node.wildcard.methods) {
    const match = node.wildcard.methods[method] || node.wildcard.methods[""];
    if (match) {
      matches.push(...match);
    }
  }
  if (node.param) {
    _findAll(ctx, node.param, method, segments, index + 1, matches);
    if (index === segments.length && node.param.methods) {
      const match = node.param.methods[method] || node.param.methods[""];
      if (match) {
        matches.push(...match);
      }
    }
  }
  const staticChild = node.static?.[segment];
  if (staticChild) {
    _findAll(ctx, staticChild, method, segments, index + 1, matches);
  }
  if (index === segments.length && node.methods) {
    const match = node.methods[method] || node.methods[""];
    if (match) {
      matches.push(...match);
    }
  }
  return matches;
}

// ../../node_modules/better-call/dist/index.js
var _statusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NO_CONTENT: 204,
  MULTIPLE_CHOICES: 300,
  MOVED_PERMANENTLY: 301,
  FOUND: 302,
  SEE_OTHER: 303,
  NOT_MODIFIED: 304,
  TEMPORARY_REDIRECT: 307,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  PAYMENT_REQUIRED: 402,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  NOT_ACCEPTABLE: 406,
  PROXY_AUTHENTICATION_REQUIRED: 407,
  REQUEST_TIMEOUT: 408,
  CONFLICT: 409,
  GONE: 410,
  LENGTH_REQUIRED: 411,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  URI_TOO_LONG: 414,
  UNSUPPORTED_MEDIA_TYPE: 415,
  RANGE_NOT_SATISFIABLE: 416,
  EXPECTATION_FAILED: 417,
  "I'M_A_TEAPOT": 418,
  MISDIRECTED_REQUEST: 421,
  UNPROCESSABLE_ENTITY: 422,
  LOCKED: 423,
  FAILED_DEPENDENCY: 424,
  TOO_EARLY: 425,
  UPGRADE_REQUIRED: 426,
  PRECONDITION_REQUIRED: 428,
  TOO_MANY_REQUESTS: 429,
  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
  UNAVAILABLE_FOR_LEGAL_REASONS: 451,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  HTTP_VERSION_NOT_SUPPORTED: 505,
  VARIANT_ALSO_NEGOTIATES: 506,
  INSUFFICIENT_STORAGE: 507,
  LOOP_DETECTED: 508,
  NOT_EXTENDED: 510,
  NETWORK_AUTHENTICATION_REQUIRED: 511
};
var APIError = class extends Error {
  constructor(status = "INTERNAL_SERVER_ERROR", body = undefined, headers = {}, statusCode = typeof status === "number" ? status : _statusCode[status]) {
    super(body?.message);
    this.status = status;
    this.body = body;
    this.headers = headers;
    this.statusCode = statusCode;
    this.name = "APIError";
    this.status = status;
    this.headers = headers;
    this.statusCode = statusCode;
    this.body = body ? {
      code: body?.message?.toUpperCase().replace(/ /g, "_").replace(/[^A-Z0-9_]/g, ""),
      ...body
    } : undefined;
    this.stack = "";
  }
};
async function getBody(request) {
  const contentType = request.headers.get("content-type") || "";
  if (!request.body) {
    return;
  }
  if (contentType.includes("application/json")) {
    return await request.json();
  }
  if (contentType.includes("application/x-www-form-urlencoded")) {
    const formData = await request.formData();
    const result = {};
    formData.forEach((value, key) => {
      result[key] = value.toString();
    });
    return result;
  }
  if (contentType.includes("multipart/form-data")) {
    const formData = await request.formData();
    const result = {};
    formData.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  if (contentType.includes("text/plain")) {
    return await request.text();
  }
  if (contentType.includes("application/octet-stream")) {
    return await request.arrayBuffer();
  }
  if (contentType.includes("application/pdf") || contentType.includes("image/") || contentType.includes("video/")) {
    const blob = await request.blob();
    return blob;
  }
  if (contentType.includes("application/stream") || request.body instanceof ReadableStream) {
    return request.body;
  }
  return await request.text();
}
function isAPIError(error) {
  return error instanceof APIError || error?.name === "APIError";
}
function tryDecode(str) {
  try {
    return str.includes("%") ? decodeURIComponent(str) : str;
  } catch {
    return str;
  }
}
function isJSONSerializable(value) {
  if (value === undefined) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
function toResponse(data, init) {
  if (data instanceof Response) {
    if (init?.headers instanceof Headers) {
      init.headers.forEach((value, key) => {
        data.headers.set(key, value);
      });
    }
    return data;
  }
  if (data?._flag === "json") {
    const routerResponse = data.routerResponse;
    if (routerResponse instanceof Response) {
      return routerResponse;
    }
    return toResponse(data.body, {
      headers: data.headers,
      status: data.status
    });
  }
  if (isAPIError(data)) {
    return toResponse(data.body, {
      status: data.statusCode,
      statusText: data.status.toString(),
      headers: init?.headers || data.headers
    });
  }
  let body = data;
  let headers = new Headers(init?.headers);
  if (!data) {
    if (data === null) {
      body = JSON.stringify(null);
    }
    headers.set("content-type", "application/json");
  } else if (typeof data === "string") {
    body = data;
    headers.set("Content-Type", "text/plain");
  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    body = data;
    headers.set("Content-Type", "application/octet-stream");
  } else if (data instanceof Blob) {
    body = data;
    headers.set("Content-Type", data.type || "application/octet-stream");
  } else if (data instanceof FormData) {
    body = data;
  } else if (data instanceof URLSearchParams) {
    body = data;
    headers.set("Content-Type", "application/x-www-form-urlencoded");
  } else if (data instanceof ReadableStream) {
    body = data;
    headers.set("Content-Type", "application/octet-stream");
  } else if (isJSONSerializable(data)) {
    body = JSON.stringify(data);
    headers.set("Content-Type", "application/json");
  }
  return new Response(body, {
    ...init,
    headers
  });
}
async function runValidation(options, context = {}) {
  let request = {
    body: context.body,
    query: context.query
  };
  if (options.body) {
    const result = await options.body["~standard"].validate(context.body);
    if (result.issues) {
      return {
        data: null,
        error: fromError(result.issues, "body")
      };
    }
    request.body = result.value;
  }
  if (options.query) {
    const result = await options.query["~standard"].validate(context.query);
    if (result.issues) {
      return {
        data: null,
        error: fromError(result.issues, "query")
      };
    }
    request.query = result.value;
  }
  if (options.requireHeaders && !context.headers) {
    return {
      data: null,
      error: { message: "Headers is required" }
    };
  }
  if (options.requireRequest && !context.request) {
    return {
      data: null,
      error: { message: "Request is required" }
    };
  }
  return {
    data: request,
    error: null
  };
}
function fromError(error, validating) {
  const errorMessages = [];
  for (const issue of error) {
    const message = issue.message;
    errorMessages.push(message);
  }
  return {
    message: `Invalid ${validating} parameters`
  };
}
var algorithm = { name: "HMAC", hash: "SHA-256" };
var getCryptoKey = async (secret) => {
  const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  return await subtle.importKey("raw", secretBuf, algorithm, false, ["sign", "verify"]);
};
var verifySignature = async (base64Signature, value, secret) => {
  try {
    const signatureBinStr = atob(base64Signature);
    const signature = new Uint8Array(signatureBinStr.length);
    for (let i = 0, len = signatureBinStr.length;i < len; i++) {
      signature[i] = signatureBinStr.charCodeAt(i);
    }
    return await subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));
  } catch (e) {
    return false;
  }
};
var makeSignature = async (value, secret) => {
  const key = await getCryptoKey(secret);
  const signature = await subtle.sign(algorithm.name, key, new TextEncoder().encode(value));
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
};
var signCookieValue = async (value, secret) => {
  const signature = await makeSignature(value, secret);
  value = `${value}.${signature}`;
  value = encodeURIComponent(value);
  return value;
};
var getCookieKey = (key, prefix) => {
  let finalKey = key;
  if (prefix) {
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    } else {
      return;
    }
  }
  return finalKey;
};
function parseCookies(str) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  const cookies = /* @__PURE__ */ new Map;
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (!cookies.has(key)) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.codePointAt(0) === 34) {
        val = val.slice(1, -1);
      }
      cookies.set(key, tryDecode(val));
    }
    index = endIdx + 1;
  }
  return cookies;
}
var _serialize = (key, value, opt = {}) => {
  let cookie;
  if (opt?.prefix === "secure") {
    cookie = `${`__Secure-${key}`}=${value}`;
  } else if (opt?.prefix === "host") {
    cookie = `${`__Host-${key}`}=${value}`;
  } else {
    cookie = `${key}=${value}`;
  }
  if (key.startsWith("__Secure-") && !opt.secure) {
    opt.secure = true;
  }
  if (key.startsWith("__Host-")) {
    if (!opt.secure) {
      opt.secure = true;
    }
    if (opt.path !== "/") {
      opt.path = "/";
    }
    if (opt.domain) {
      opt.domain = undefined;
    }
  }
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    if (opt.maxAge > 34560000) {
      throw new Error("Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.");
    }
    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
  }
  if (opt.domain && opt.prefix !== "host") {
    cookie += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    cookie += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (opt.expires.getTime() - Date.now() > 34560000000) {
      throw new Error("Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.");
    }
    cookie += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) {
    cookie += "; HttpOnly";
  }
  if (opt.secure) {
    cookie += "; Secure";
  }
  if (opt.sameSite) {
    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
  }
  if (opt.partitioned) {
    if (!opt.secure) {
      opt.secure = true;
    }
    cookie += "; Partitioned";
  }
  return cookie;
};
var serializeCookie = (key, value, opt) => {
  value = encodeURIComponent(value);
  return _serialize(key, value, opt);
};
var serializeSignedCookie = async (key, value, secret, opt) => {
  value = await signCookieValue(value, secret);
  return _serialize(key, value, opt);
};
var createInternalContext = async (context, {
  options,
  path
}) => {
  const headers = new Headers;
  const { data, error } = await runValidation(options, context);
  if (error) {
    throw new APIError(400, {
      message: error.message,
      code: "VALIDATION_ERROR"
    });
  }
  const requestHeaders = "headers" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : ("request" in context) && context.request instanceof Request ? context.request.headers : null;
  const requestCookies = requestHeaders?.get("cookie");
  const parsedCookies = requestCookies ? parseCookies(requestCookies) : undefined;
  const internalContext = {
    ...context,
    body: data.body,
    query: data.query,
    path: context.path || path,
    context: "context" in context && context.context ? context.context : {},
    returned: undefined,
    headers: context?.headers,
    request: context?.request,
    params: "params" in context ? context.params : undefined,
    method: context.method,
    setHeader: (key, value) => {
      headers.set(key, value);
    },
    getHeader: (key) => {
      if (!requestHeaders)
        return null;
      return requestHeaders.get(key);
    },
    getCookie: (key, prefix) => {
      const finalKey = getCookieKey(key, prefix);
      if (!finalKey) {
        return null;
      }
      return parsedCookies?.get(finalKey) || null;
    },
    getSignedCookie: async (key, secret, prefix) => {
      const finalKey = getCookieKey(key, prefix);
      if (!finalKey) {
        return null;
      }
      const value = parsedCookies?.get(finalKey);
      if (!value) {
        return null;
      }
      const signatureStartPos = value.lastIndexOf(".");
      if (signatureStartPos < 1) {
        return null;
      }
      const signedValue = value.substring(0, signatureStartPos);
      const signature = value.substring(signatureStartPos + 1);
      if (signature.length !== 44 || !signature.endsWith("=")) {
        return null;
      }
      const secretKey = await getCryptoKey(secret);
      const isVerified = await verifySignature(signature, signedValue, secretKey);
      return isVerified ? signedValue : false;
    },
    setCookie: (key, value, options2) => {
      const cookie = serializeCookie(key, value, options2);
      headers.append("set-cookie", cookie);
      return cookie;
    },
    setSignedCookie: async (key, value, secret, options2) => {
      const cookie = await serializeSignedCookie(key, value, secret, options2);
      headers.append("set-cookie", cookie);
      return cookie;
    },
    redirect: (url) => {
      headers.set("location", url);
      return new APIError("FOUND", undefined, headers);
    },
    error: (status, body, headers2) => {
      return new APIError(status, body, headers2);
    },
    json: (json2, routerResponse) => {
      if (!context.asResponse) {
        return json2;
      }
      return {
        body: routerResponse?.body || json2,
        routerResponse,
        _flag: "json"
      };
    },
    responseHeaders: headers
  };
  for (const middleware of options.use || []) {
    const response = await middleware({
      ...internalContext,
      returnHeaders: true,
      asResponse: false
    });
    if (response.response) {
      Object.assign(internalContext.context, response.response);
    }
    if (response.headers) {
      response.headers.forEach((value, key) => {
        internalContext.responseHeaders.set(key, value);
      });
    }
  }
  return internalContext;
};
function createMiddleware(optionsOrHandler, handler) {
  const internalHandler = async (inputCtx) => {
    const context = inputCtx;
    const _handler = typeof optionsOrHandler === "function" ? optionsOrHandler : handler;
    const options = typeof optionsOrHandler === "function" ? {} : optionsOrHandler;
    const internalContext = await createInternalContext(context, {
      options,
      path: "/"
    });
    if (!_handler) {
      throw new Error("handler must be defined");
    }
    const response = await _handler(internalContext);
    const headers = internalContext.responseHeaders;
    return context.returnHeaders ? {
      headers,
      response
    } : response;
  };
  internalHandler.options = typeof optionsOrHandler === "function" ? {} : optionsOrHandler;
  return internalHandler;
}
createMiddleware.create = (opts) => {
  function fn(optionsOrHandler, handler) {
    if (typeof optionsOrHandler === "function") {
      return createMiddleware({
        use: opts?.use
      }, optionsOrHandler);
    }
    if (!handler) {
      throw new Error("Middleware handler is required");
    }
    const middleware = createMiddleware({
      ...optionsOrHandler,
      method: "*",
      use: [...opts?.use || [], ...optionsOrHandler.use || []]
    }, handler);
    return middleware;
  }
  return fn;
};
var createEndpoint2 = (path, options, handler) => {
  const internalHandler = async (...inputCtx) => {
    const context = inputCtx[0] || {};
    const internalContext = await createInternalContext(context, {
      options,
      path
    });
    const response = await handler(internalContext).catch(async (e) => {
      if (isAPIError(e)) {
        const onAPIError = options.onAPIError;
        if (onAPIError) {
          await onAPIError(e);
        }
        if (context.asResponse) {
          return e;
        }
      }
      throw e;
    });
    const headers = internalContext.responseHeaders;
    return context.asResponse ? toResponse(response, {
      headers
    }) : context.returnHeaders ? {
      headers,
      response
    } : response;
  };
  internalHandler.options = options;
  internalHandler.path = path;
  return internalHandler;
};
createEndpoint2.create = (opts) => {
  return (path, options, handler) => {
    return createEndpoint2(path, {
      ...options,
      use: [...options?.use || [], ...opts?.use || []]
    }, handler);
  };
};
var util3;
(function(util22) {
  util22.assertEqual = (val) => val;
  function assertIs(_arg) {}
  util22.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util22.assertNever = assertNever;
  util22.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util22.getValidEnumValues = (obj) => {
    const validKeys = util22.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util22.objectValues(filtered);
  };
  util22.objectValues = (obj) => {
    return util22.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util22.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util22.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util22.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util22.joinValues = joinValues;
  util22.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util3 || (util3 = {}));
var objectUtil2;
(function(objectUtil22) {
  objectUtil22.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil2 || (objectUtil2 = {}));
var ZodParsedType2 = util3.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType2.undefined;
    case "string":
      return ZodParsedType2.string;
    case "number":
      return isNaN(data) ? ZodParsedType2.nan : ZodParsedType2.number;
    case "boolean":
      return ZodParsedType2.boolean;
    case "function":
      return ZodParsedType2.function;
    case "bigint":
      return ZodParsedType2.bigint;
    case "symbol":
      return ZodParsedType2.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType2.array;
      }
      if (data === null) {
        return ZodParsedType2.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType2.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType2.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType2.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType2.date;
      }
      return ZodParsedType2.object;
    default:
      return ZodParsedType2.unknown;
  }
};
var ZodIssueCode2 = util3.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError3 = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util3.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError3.create = (issues) => {
  const error = new ZodError3(issues);
  return error;
};
var errorMap2 = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode2.invalid_type:
      if (issue.received === ZodParsedType2.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util3.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util3.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode2.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util3.joinValues(issue.options)}`;
      break;
    case ZodIssueCode2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util3.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode2.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode2.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode2.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode2.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util3.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode2.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode2.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util3.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap2 = errorMap2;
function getErrorMap2() {
  return overrideErrorMap2;
}
var makeIssue2 = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext2(ctx, issueData) {
  const overrideMap = getErrorMap2();
  const issue = makeIssue2({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap2 ? undefined : errorMap2
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus2 = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID2;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID2;
      if (value.status === "aborted")
        return INVALID2;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID2 = Object.freeze({
  status: "aborted"
});
var DIRTY2 = (value) => ({ status: "dirty", value });
var OK2 = (value) => ({ status: "valid", value });
var isAborted2 = (x) => x.status === "aborted";
var isDirty2 = (x) => x.status === "dirty";
var isValid2 = (x) => x.status === "valid";
var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil2;
(function(errorUtil22) {
  errorUtil22.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil22.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil2 || (errorUtil2 = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath2 = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult2 = (ctx, result) => {
  if (isValid2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError3(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams2(params) {
  if (!params)
    return {};
  const { errorMap: errorMap22, invalid_type_error, required_error, description } = params;
  if (errorMap22 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap22)
    return { errorMap: errorMap22, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType2 = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus2,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync2(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult2(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid2(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid2(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult2(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode2.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects2({
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional2.create(this, this._def);
  }
  nullable() {
    return ZodNullable2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray2.create(this);
  }
  promise() {
    return ZodPromise2.create(this, this._def);
  }
  or(option) {
    return ZodUnion2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection2.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects2({
      ...processCreateParams2(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault2({
      ...processCreateParams2(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodDefault
    });
  }
  brand() {
    return new ZodBranded2({
      typeName: ZodFirstPartyTypeKind2.ZodBranded,
      type: this,
      ...processCreateParams2(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch2({
      ...processCreateParams2(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline2.create(this, target);
  }
  readonly() {
    return ZodReadonly2.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex2 = /^c[^\s-]{8,}$/i;
var cuid2Regex2 = /^[0-9a-z]+$/;
var ulidRegex2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex2 = /^[a-z0-9_-]{21}$/i;
var jwtRegex2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex2 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex2;
var ipv4Regex2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource2 = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex2 = new RegExp(`^${dateRegexSource2}$`);
function timeRegexSource2(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex2(args) {
  return new RegExp(`^${timeRegexSource2(args)}$`);
}
function datetimeRegex2(args) {
  let regex = `${dateRegexSource2}T${timeRegexSource2(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP2(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex2.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex2.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT2(jwt, alg) {
  if (!jwtRegex2.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr2(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex2.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex2.test(ip)) {
    return true;
  }
  return false;
}
var ZodString2 = class _ZodString extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext2(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.string,
        received: ctx2.parsedType
      });
      return INVALID2;
    }
    const status = new ParseStatus2;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "email",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex2) {
          emojiRegex2 = new RegExp(_emojiRegex2, "u");
        }
        if (!emojiRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "emoji",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "uuid",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "nanoid",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "cuid",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "cuid2",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "ulid",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "url",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "regex",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex2(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex2;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex2(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "duration",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP2(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "ip",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT2(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "jwt",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr2(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "cidr",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "base64",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            validation: "base64url",
            code: ZodIssueCode2.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode2.invalid_string,
      ...errorUtil2.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil2.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil2.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil2.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil2.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil2.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil2.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil2.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil2.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil2.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil2.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil2.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil2.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil2.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil2.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil2.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil2.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil2.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil2.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil2.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil2.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil2.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil2.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil2.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil2.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString2.create = (params) => {
  var _a;
  return new ZodString2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams2(params)
  });
};
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber2 = class _ZodNumber extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext2(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.number,
        received: ctx2.parsedType
      });
      return INVALID2;
    }
    let ctx = undefined;
    const status = new ParseStatus2;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util3.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder2(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil2.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil2.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil2.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil2.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil2.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil2.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil2.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil2.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil2.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil2.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil2.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil2.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil2.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil2.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util3.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber2.create = (params) => {
  return new ZodNumber2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams2(params)
  });
};
var ZodBigInt2 = class _ZodBigInt extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus2;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util3.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext2(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType2.bigint,
      received: ctx.parsedType
    });
    return INVALID2;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil2.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil2.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil2.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil2.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil2.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil2.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil2.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil2.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil2.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil2.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt2.create = (params) => {
  var _a;
  return new ZodBigInt2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams2(params)
  });
};
var ZodBoolean2 = class extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.boolean,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
};
ZodBoolean2.create = (params) => {
  return new ZodBoolean2({
    typeName: ZodFirstPartyTypeKind2.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams2(params)
  });
};
var ZodDate2 = class _ZodDate extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext2(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.date,
        received: ctx2.parsedType
      });
      return INVALID2;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext2(ctx2, {
        code: ZodIssueCode2.invalid_date
      });
      return INVALID2;
    }
    const status = new ParseStatus2;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util3.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil2.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil2.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate2.create = (params) => {
  return new ZodDate2({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind2.ZodDate,
    ...processCreateParams2(params)
  });
};
var ZodSymbol2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.symbol,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
};
ZodSymbol2.create = (params) => {
  return new ZodSymbol2({
    typeName: ZodFirstPartyTypeKind2.ZodSymbol,
    ...processCreateParams2(params)
  });
};
var ZodUndefined2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.undefined,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
};
ZodUndefined2.create = (params) => {
  return new ZodUndefined2({
    typeName: ZodFirstPartyTypeKind2.ZodUndefined,
    ...processCreateParams2(params)
  });
};
var ZodNull2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.null,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
};
ZodNull2.create = (params) => {
  return new ZodNull2({
    typeName: ZodFirstPartyTypeKind2.ZodNull,
    ...processCreateParams2(params)
  });
};
var ZodAny2 = class extends ZodType2 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK2(input.data);
  }
};
ZodAny2.create = (params) => {
  return new ZodAny2({
    typeName: ZodFirstPartyTypeKind2.ZodAny,
    ...processCreateParams2(params)
  });
};
var ZodUnknown2 = class extends ZodType2 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK2(input.data);
  }
};
ZodUnknown2.create = (params) => {
  return new ZodUnknown2({
    typeName: ZodFirstPartyTypeKind2.ZodUnknown,
    ...processCreateParams2(params)
  });
};
var ZodNever2 = class extends ZodType2 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext2(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType2.never,
      received: ctx.parsedType
    });
    return INVALID2;
  }
};
ZodNever2.create = (params) => {
  return new ZodNever2({
    typeName: ZodFirstPartyTypeKind2.ZodNever,
    ...processCreateParams2(params)
  });
};
var ZodVoid2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.void,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
};
ZodVoid2.create = (params) => {
  return new ZodVoid2({
    typeName: ZodFirstPartyTypeKind2.ZodVoid,
    ...processCreateParams2(params)
  });
};
var ZodArray2 = class _ZodArray extends ZodType2 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType2.array) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.array,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext2(ctx, {
          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext2(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext2(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus2.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
    });
    return ParseStatus2.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil2.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil2.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil2.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray2.create = (schema, params) => {
  return new ZodArray2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind2.ZodArray,
    ...processCreateParams2(params)
  });
};
function deepPartialify2(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
    }
    return new ZodObject2({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray2) {
    return new ZodArray2({
      ...schema._def,
      type: deepPartialify2(schema.element)
    });
  } else if (schema instanceof ZodOptional2) {
    return ZodOptional2.create(deepPartialify2(schema.unwrap()));
  } else if (schema instanceof ZodNullable2) {
    return ZodNullable2.create(deepPartialify2(schema.unwrap()));
  } else if (schema instanceof ZodTuple2) {
    return ZodTuple2.create(schema.items.map((item) => deepPartialify2(item)));
  } else {
    return schema;
  }
}
var ZodObject2 = class _ZodObject extends ZodType2 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util3.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext2(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.object,
        received: ctx2.parsedType
      });
      return INVALID2;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever2) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus2.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus2.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil2.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil2.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind2.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util3.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util3.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify2(this);
  }
  partial(mask) {
    const newShape = {};
    util3.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util3.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional2) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum2(util3.objectKeys(this.shape));
  }
};
ZodObject2.create = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams2(params)
  });
};
ZodObject2.strictCreate = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams2(params)
  });
};
ZodObject2.lazycreate = (shape, params) => {
  return new ZodObject2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams2(params)
  });
};
var ZodUnion2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError3(result.ctx.common.issues));
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      });
      return INVALID2;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError3(issues2));
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      });
      return INVALID2;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion2.create = (types2, params) => {
  return new ZodUnion2({
    options: types2,
    typeName: ZodFirstPartyTypeKind2.ZodUnion,
    ...processCreateParams2(params)
  });
};
var getDiscriminator2 = (type) => {
  if (type instanceof ZodLazy2) {
    return getDiscriminator2(type.schema);
  } else if (type instanceof ZodEffects2) {
    return getDiscriminator2(type.innerType());
  } else if (type instanceof ZodLiteral2) {
    return [type.value];
  } else if (type instanceof ZodEnum2) {
    return type.options;
  } else if (type instanceof ZodNativeEnum2) {
    return util3.objectValues(type.enum);
  } else if (type instanceof ZodDefault2) {
    return getDiscriminator2(type._def.innerType);
  } else if (type instanceof ZodUndefined2) {
    return [undefined];
  } else if (type instanceof ZodNull2) {
    return [null];
  } else if (type instanceof ZodOptional2) {
    return [undefined, ...getDiscriminator2(type.unwrap())];
  } else if (type instanceof ZodNullable2) {
    return [null, ...getDiscriminator2(type.unwrap())];
  } else if (type instanceof ZodBranded2) {
    return getDiscriminator2(type.unwrap());
  } else if (type instanceof ZodReadonly2) {
    return getDiscriminator2(type.unwrap());
  } else if (type instanceof ZodCatch2) {
    return getDiscriminator2(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.object) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.object,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID2;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator2(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams2(params)
    });
  }
};
function mergeValues2(a, b) {
  const aType = getParsedType2(a);
  const bType = getParsedType2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType2.object && bType === ZodParsedType2.object) {
    const bKeys = util3.objectKeys(b);
    const sharedKeys = util3.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType2.array && bType === ZodParsedType2.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType2.date && bType === ZodParsedType2.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection2 = class extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted2(parsedLeft) || isAborted2(parsedRight)) {
        return INVALID2;
      }
      const merged = mergeValues2(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext2(ctx, {
          code: ZodIssueCode2.invalid_intersection_types
        });
        return INVALID2;
      }
      if (isDirty2(parsedLeft) || isDirty2(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection2.create = (left, right, params) => {
  return new ZodIntersection2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind2.ZodIntersection,
    ...processCreateParams2(params)
  });
};
var ZodTuple2 = class _ZodTuple extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.array) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.array,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID2;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus2.mergeArray(status, results);
      });
    } else {
      return ParseStatus2.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple2.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple2({
    items: schemas,
    typeName: ZodFirstPartyTypeKind2.ZodTuple,
    rest: null,
    ...processCreateParams2(params)
  });
};
var ZodRecord2 = class _ZodRecord extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.object) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.object,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus2.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus2.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType2) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams2(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString2.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind2.ZodRecord,
      ...processCreateParams2(second)
    });
  }
};
var ZodMap2 = class extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.map) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.map,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID2;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID2;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap2.create = (keyType, valueType, params) => {
  return new ZodMap2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind2.ZodMap,
    ...processCreateParams2(params)
  });
};
var ZodSet2 = class _ZodSet extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.set) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.set,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext2(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext2(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID2;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil2.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil2.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet2.create = (valueType, params) => {
  return new ZodSet2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind2.ZodSet,
    ...processCreateParams2(params)
  });
};
var ZodFunction2 = class _ZodFunction extends ZodType2 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.function) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.function,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    function makeArgsIssue(args, error) {
      return makeIssue2({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap2(),
          errorMap2
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue2({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap2(),
          errorMap2
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise2) {
      const me = this;
      return OK2(async function(...args) {
        const error = new ZodError3([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK2(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError3([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError3([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple2.create(items).rest(ZodUnknown2.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
      returns: returns || ZodUnknown2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodFunction,
      ...processCreateParams2(params)
    });
  }
};
var ZodLazy2 = class extends ZodType2 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy2.create = (getter, params) => {
  return new ZodLazy2({
    getter,
    typeName: ZodFirstPartyTypeKind2.ZodLazy,
    ...processCreateParams2(params)
  });
};
var ZodLiteral2 = class extends ZodType2 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_literal,
        expected: this._def.value
      });
      return INVALID2;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral2.create = (value, params) => {
  return new ZodLiteral2({
    value,
    typeName: ZodFirstPartyTypeKind2.ZodLiteral,
    ...processCreateParams2(params)
  });
};
function createZodEnum2(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodEnum,
    ...processCreateParams2(params)
  });
}
var ZodEnum2 = class _ZodEnum extends ZodType2 {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext2(ctx, {
        expected: util3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      });
      return INVALID2;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext2(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap;
ZodEnum2.create = createZodEnum2;
var ZodNativeEnum2 = class extends ZodType2 {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input) {
    const nativeEnumValues = util3.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType2.string && ctx.parsedType !== ZodParsedType2.number) {
      const expectedValues = util3.objectValues(nativeEnumValues);
      addIssueToContext2(ctx, {
        expected: util3.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      });
      return INVALID2;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util3.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util3.objectValues(nativeEnumValues);
      addIssueToContext2(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID2;
    }
    return OK2(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap;
ZodNativeEnum2.create = (values, params) => {
  return new ZodNativeEnum2({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
    ...processCreateParams2(params)
  });
};
var ZodPromise2 = class extends ZodType2 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType2.promise && ctx.common.async === false) {
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.promise,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    const promisified = ctx.parsedType === ZodParsedType2.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK2(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise2.create = (schema, params) => {
  return new ZodPromise2({
    type: schema,
    typeName: ZodFirstPartyTypeKind2.ZodPromise,
    ...processCreateParams2(params)
  });
};
var ZodEffects2 = class extends ZodType2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext2(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID2;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID2;
          if (result.status === "dirty")
            return DIRTY2(result.value);
          if (status.value === "dirty")
            return DIRTY2(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID2;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID2;
        if (result.status === "dirty")
          return DIRTY2(result.value);
        if (status.value === "dirty")
          return DIRTY2(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID2;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID2;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid2(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid2(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util3.assertNever(effect);
  }
};
ZodEffects2.create = (schema, effect, params) => {
  return new ZodEffects2({
    schema,
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    effect,
    ...processCreateParams2(params)
  });
};
ZodEffects2.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects2({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    ...processCreateParams2(params)
  });
};
var ZodOptional2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType2.undefined) {
      return OK2(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional2.create = (type, params) => {
  return new ZodOptional2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodOptional,
    ...processCreateParams2(params)
  });
};
var ZodNullable2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType2.null) {
      return OK2(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable2.create = (type, params) => {
  return new ZodNullable2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodNullable,
    ...processCreateParams2(params)
  });
};
var ZodDefault2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType2.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault2.create = (type, params) => {
  return new ZodDefault2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams2(params)
  });
};
var ZodCatch2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync2(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError3(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError3(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch2.create = (type, params) => {
  return new ZodCatch2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams2(params)
  });
};
var ZodNaN2 = class extends ZodType2 {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType2.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext2(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType2.nan,
        received: ctx.parsedType
      });
      return INVALID2;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN2.create = (params) => {
  return new ZodNaN2({
    typeName: ZodFirstPartyTypeKind2.ZodNaN,
    ...processCreateParams2(params)
  });
};
var BRAND2 = Symbol("zod_brand");
var ZodBranded2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline2 = class _ZodPipeline extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID2;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY2(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID2;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind2.ZodPipeline
    });
  }
};
var ZodReadonly2 = class extends ZodType2 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync2(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly2.create = (type, params) => {
  return new ZodReadonly2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodReadonly,
    ...processCreateParams2(params)
  });
};
var late2 = {
  object: ZodObject2.lazycreate
};
var ZodFirstPartyTypeKind2;
(function(ZodFirstPartyTypeKind22) {
  ZodFirstPartyTypeKind22["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind22["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind22["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind22["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind22["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind22["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind22["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind22["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind22["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind22["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind22["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind22["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind22["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind22["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind22["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind22["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind22["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind22["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind22["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind22["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind22["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind22["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind22["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind22["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind22["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind22["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind22["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind22["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind22["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind22["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind22["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind22["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind22["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind22["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind22["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind22["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
var stringType2 = ZodString2.create;
var numberType2 = ZodNumber2.create;
var nanType2 = ZodNaN2.create;
var bigIntType2 = ZodBigInt2.create;
var booleanType2 = ZodBoolean2.create;
var dateType2 = ZodDate2.create;
var symbolType2 = ZodSymbol2.create;
var undefinedType2 = ZodUndefined2.create;
var nullType2 = ZodNull2.create;
var anyType2 = ZodAny2.create;
var unknownType2 = ZodUnknown2.create;
var neverType2 = ZodNever2.create;
var voidType2 = ZodVoid2.create;
var arrayType2 = ZodArray2.create;
var objectType2 = ZodObject2.create;
var strictObjectType2 = ZodObject2.strictCreate;
var unionType2 = ZodUnion2.create;
var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
var intersectionType2 = ZodIntersection2.create;
var tupleType2 = ZodTuple2.create;
var recordType2 = ZodRecord2.create;
var mapType2 = ZodMap2.create;
var setType2 = ZodSet2.create;
var functionType2 = ZodFunction2.create;
var lazyType2 = ZodLazy2.create;
var literalType2 = ZodLiteral2.create;
var enumType2 = ZodEnum2.create;
var nativeEnumType2 = ZodNativeEnum2.create;
var promiseType2 = ZodPromise2.create;
var effectsType2 = ZodEffects2.create;
var optionalType2 = ZodOptional2.create;
var nullableType2 = ZodNullable2.create;
var preprocessType2 = ZodEffects2.createWithPreprocess;
var pipelineType2 = ZodPipeline2.create;
var paths = {};
function getTypeFromZodType(zodType) {
  switch (zodType.constructor.name) {
    case "ZodString":
      return "string";
    case "ZodNumber":
      return "number";
    case "ZodBoolean":
      return "boolean";
    case "ZodObject":
      return "object";
    case "ZodArray":
      return "array";
    default:
      return "string";
  }
}
function getParameters(options) {
  const parameters = [];
  if (options.metadata?.openapi?.parameters) {
    parameters.push(...options.metadata.openapi.parameters);
    return parameters;
  }
  if (options.query instanceof ZodObject2) {
    Object.entries(options.query.shape).forEach(([key, value]) => {
      if (value instanceof ZodType2) {
        parameters.push({
          name: key,
          in: "query",
          schema: {
            type: getTypeFromZodType(value),
            ..."minLength" in value && value.minLength ? {
              minLength: value.minLength
            } : {},
            description: value.description
          }
        });
      }
    });
  }
  return parameters;
}
function getRequestBody(options) {
  if (options.metadata?.openapi?.requestBody) {
    return options.metadata.openapi.requestBody;
  }
  if (!options.body)
    return;
  if (options.body instanceof ZodObject2 || options.body instanceof ZodOptional2) {
    const shape = options.body.shape;
    if (!shape)
      return;
    const properties = {};
    const required = [];
    Object.entries(shape).forEach(([key, value]) => {
      if (value instanceof ZodType2) {
        properties[key] = {
          type: getTypeFromZodType(value),
          description: value.description
        };
        if (!(value instanceof ZodOptional2)) {
          required.push(key);
        }
      }
    });
    return {
      required: options.body instanceof ZodOptional2 ? false : options.body ? true : false,
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties,
            required
          }
        }
      }
    };
  }
  return;
}
function getResponse(responses) {
  return {
    "400": {
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              message: {
                type: "string"
              }
            },
            required: ["message"]
          }
        }
      },
      description: "Bad Request. Usually due to missing parameters, or invalid parameters."
    },
    "401": {
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              message: {
                type: "string"
              }
            },
            required: ["message"]
          }
        }
      },
      description: "Unauthorized. Due to missing or invalid authentication."
    },
    "403": {
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              message: {
                type: "string"
              }
            }
          }
        }
      },
      description: "Forbidden. You do not have permission to access this resource or to perform this action."
    },
    "404": {
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              message: {
                type: "string"
              }
            }
          }
        }
      },
      description: "Not Found. The requested resource was not found."
    },
    "429": {
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              message: {
                type: "string"
              }
            }
          }
        }
      },
      description: "Too Many Requests. You have exceeded the rate limit. Try again later."
    },
    "500": {
      content: {
        "application/json": {
          schema: {
            type: "object",
            properties: {
              message: {
                type: "string"
              }
            }
          }
        }
      },
      description: "Internal Server Error. This is a problem with the server that you cannot fix."
    },
    ...responses
  };
}
async function generator(endpoints, config) {
  const components = {
    schemas: {}
  };
  Object.entries(endpoints).forEach(([_, value]) => {
    const options = value.options;
    if (options.metadata?.SERVER_ONLY)
      return;
    if (options.method === "GET") {
      paths[value.path] = {
        get: {
          tags: ["Default", ...options.metadata?.openapi?.tags || []],
          description: options.metadata?.openapi?.description,
          operationId: options.metadata?.openapi?.operationId,
          security: [
            {
              bearerAuth: []
            }
          ],
          parameters: getParameters(options),
          responses: getResponse(options.metadata?.openapi?.responses)
        }
      };
    }
    if (options.method === "POST") {
      const body = getRequestBody(options);
      paths[value.path] = {
        post: {
          tags: ["Default", ...options.metadata?.openapi?.tags || []],
          description: options.metadata?.openapi?.description,
          operationId: options.metadata?.openapi?.operationId,
          security: [
            {
              bearerAuth: []
            }
          ],
          parameters: getParameters(options),
          ...body ? { requestBody: body } : {
            requestBody: {
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {}
                  }
                }
              }
            }
          },
          responses: getResponse(options.metadata?.openapi?.responses)
        }
      };
    }
  });
  const res = {
    openapi: "3.1.1",
    info: {
      title: "Better Auth",
      description: "API Reference for your Better Auth Instance",
      version: "1.1.0"
    },
    components,
    security: [
      {
        apiKeyCookie: []
      }
    ],
    servers: [
      {
        url: config?.url
      }
    ],
    tags: [
      {
        name: "Default",
        description: "Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin."
      }
    ],
    paths
  };
  return res;
}
var getHTML = (apiReference, config) => `<!doctype html>
<html>
  <head>
    <title>Scalar API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script
      id="api-reference"
      type="application/json">
    ${JSON.stringify(apiReference)}
    </script>
	 <script>
      var configuration = {
	  	favicon: ${config?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config.logo)}` : undefined} ,
	   	theme: ${config?.theme || "saturn"},
        metaData: {
			title: ${config?.title || "Open API Reference"},
			description: ${config?.description || "Better Call Open API"},
		}
      }
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    </script>
	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
  </body>
</html>`;
var createRouter2 = (endpoints, config) => {
  if (!config?.openapi?.disabled) {
    const openapi = {
      path: "/api/reference",
      ...config?.openapi
    };
    endpoints["openapi"] = createEndpoint2(openapi.path, {
      method: "GET"
    }, async (c) => {
      const schema = await generator(endpoints);
      return new Response(getHTML(schema, openapi.scalar), {
        headers: {
          "Content-Type": "text/html"
        }
      });
    });
  }
  const router = createRouter();
  const middlewareRouter = createRouter();
  for (const endpoint of Object.values(endpoints)) {
    if (!endpoint.options) {
      continue;
    }
    if (endpoint.options?.metadata?.SERVER_ONLY)
      continue;
    const methods = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];
    for (const method of methods) {
      addRoute(router, method, endpoint.path, endpoint);
    }
  }
  if (config?.routerMiddleware?.length) {
    for (const { path, middleware } of config.routerMiddleware) {
      addRoute(middlewareRouter, "*", path, middleware);
    }
  }
  const processRequest = async (request) => {
    const url = new URL(request.url);
    const path = config?.basePath ? url.pathname.split(config.basePath)[1] : url.pathname;
    if (!path?.length) {
      config?.onError?.(new Error("NOT_FOUND"));
      return new Response(null, { status: 404, statusText: "Not Found" });
    }
    const route = findRoute(router, request.method, path);
    if (!route?.data) {
      return new Response(null, { status: 404, statusText: "Not Found" });
    }
    const query = {};
    url.searchParams.forEach((value, key) => {
      if (key in query) {
        if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      } else {
        query[key] = value;
      }
    });
    const handler = route.data;
    const context = {
      path,
      method: request.method,
      headers: request.headers,
      params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},
      request,
      body: await getBody(handler.options.cloneRequest ? request.clone() : request),
      query,
      _flag: "router",
      asResponse: true,
      context: config?.routerContext
    };
    try {
      const middlewareRoutes = findAllRoutes(middlewareRouter, "*", path);
      if (middlewareRoutes?.length) {
        for (const { data: middleware, params } of middlewareRoutes) {
          const res = await middleware({
            ...context,
            params,
            asResponse: false
          });
          if (res instanceof Response)
            return res;
        }
      }
      const response = await handler(context);
      return response;
    } catch (error) {
      if (isAPIError(error)) {
        return toResponse(error);
      }
      console.error(`# SERVER_ERROR: `, error);
      return new Response(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
  };
  return {
    handler: async (request) => {
      const onReq = await config?.onRequest?.(request);
      if (onReq instanceof Response) {
        return onReq;
      }
      const req = onReq instanceof Request ? onReq : request;
      const res = await processRequest(req);
      const onRes = await config?.onResponse?.(res);
      if (onRes instanceof Response) {
        return onRes;
      }
      return res;
    },
    endpoints
  };
};

// ../../node_modules/@better-auth/utils/dist/base64.mjs
function getAlphabet(urlSafe) {
  return urlSafe ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
}
function base64Encode(data, alphabet, padding) {
  let result = "";
  let buffer = 0;
  let shift = 0;
  for (const byte of data) {
    buffer = buffer << 8 | byte;
    shift += 8;
    while (shift >= 6) {
      shift -= 6;
      result += alphabet[buffer >> shift & 63];
    }
  }
  if (shift > 0) {
    result += alphabet[buffer << 6 - shift & 63];
  }
  if (padding) {
    const padCount = (4 - result.length % 4) % 4;
    result += "=".repeat(padCount);
  }
  return result;
}
function base64Decode(data, alphabet) {
  const decodeMap = /* @__PURE__ */ new Map;
  for (let i = 0;i < alphabet.length; i++) {
    decodeMap.set(alphabet[i], i);
  }
  const result = [];
  let buffer = 0;
  let bitsCollected = 0;
  for (const char2 of data) {
    if (char2 === "=")
      break;
    const value = decodeMap.get(char2);
    if (value === undefined) {
      throw new Error(`Invalid Base64 character: ${char2}`);
    }
    buffer = buffer << 6 | value;
    bitsCollected += 6;
    if (bitsCollected >= 8) {
      bitsCollected -= 8;
      result.push(buffer >> bitsCollected & 255);
    }
  }
  return Uint8Array.from(result);
}
var base64 = {
  encode(data, options = {}) {
    const alphabet = getAlphabet(false);
    const buffer = typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
    return base64Encode(buffer, alphabet, options.padding ?? true);
  },
  decode(data) {
    if (typeof data !== "string") {
      data = new TextDecoder().decode(data);
    }
    const urlSafe = data.includes("-") || data.includes("_");
    const alphabet = getAlphabet(urlSafe);
    return base64Decode(data, alphabet);
  }
};
var base64Url = {
  encode(data, options = {}) {
    const alphabet = getAlphabet(true);
    const buffer = typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
    return base64Encode(buffer, alphabet, options.padding ?? true);
  },
  decode(data) {
    const urlSafe = data.includes("-") || data.includes("_");
    const alphabet = getAlphabet(urlSafe);
    return base64Decode(data, alphabet);
  }
};

// ../../node_modules/@better-auth/utils/dist/hash.mjs
function createHash(algorithm2, encoding) {
  return {
    digest: async (input) => {
      const encoder = new TextEncoder;
      const data = typeof input === "string" ? encoder.encode(input) : input;
      const hashBuffer = await subtle.digest(algorithm2, data);
      if (encoding === "hex") {
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
        return hashHex;
      }
      if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
        if (encoding.includes("url")) {
          return base64Url.encode(hashBuffer, {
            padding: encoding !== "base64urlnopad"
          });
        }
        const hashBase64 = base64.encode(hashBuffer);
        return hashBase64;
      }
      return hashBuffer;
    }
  };
}

// ../../node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// ../../node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}

// ../../node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0;i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0;i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// ../../node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  constructor(message, options) {
    super(message, options);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}
JOSEError.code = "ERR_JOSE_GENERIC";

class JWTClaimValidationFailed extends JOSEError {
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
JWTClaimValidationFailed.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";

class JWTExpired extends JOSEError {
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
JWTExpired.code = "ERR_JWT_EXPIRED";

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}
JOSEAlgNotAllowed.code = "ERR_JOSE_ALG_NOT_ALLOWED";

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
}
JOSENotSupported.code = "ERR_JOSE_NOT_SUPPORTED";

class JWEDecryptionFailed extends JOSEError {
  constructor(message = "decryption operation failed", options) {
    super(message, options);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
  }
}
JWEDecryptionFailed.code = "ERR_JWE_DECRYPTION_FAILED";

class JWEInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
}
JWEInvalid.code = "ERR_JWE_INVALID";

class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
}
JWSInvalid.code = "ERR_JWS_INVALID";

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
}
JWTInvalid.code = "ERR_JWT_INVALID";

class JWKInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
}
JWKInvalid.code = "ERR_JWK_INVALID";

class JWKSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
}
JWKSInvalid.code = "ERR_JWKS_INVALID";

class JWKSNoMatchingKey extends JOSEError {
  constructor(message = "no applicable key found in the JSON Web Key Set", options) {
    super(message, options);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
  }
}
JWKSNoMatchingKey.code = "ERR_JWKS_NO_MATCHING_KEY";

class JWKSMultipleMatchingKeys extends JOSEError {
  constructor(message = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message, options);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
}
JWKSMultipleMatchingKeys.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";

class JWKSTimeout extends JOSEError {
  constructor(message = "request timed out", options) {
    super(message, options);
    this.code = "ERR_JWKS_TIMEOUT";
  }
}
JWKSTimeout.code = "ERR_JWKS_TIMEOUT";

class JWSSignatureVerificationFailed extends JOSEError {
  constructor(message = "signature verification failed", options) {
    super(message, options);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}
JWSSignatureVerificationFailed.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";

// ../../node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm2, name) {
  return algorithm2.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "Ed25519": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// ../../node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  types2 = types2.filter(Boolean);
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
};
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}

// ../../node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  if (isCryptoKey(key)) {
    return true;
  }
  return key?.[Symbol.toStringTag] === "KeyObject";
};
var types2 = ["CryptoKey"];

// ../../node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// ../../node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// ../../node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// ../../node_modules/jose/dist/browser/lib/is_jwk.js
function isJWK(key) {
  return isObject(key) && typeof key.kty === "string";
}
function isPrivateJWK(key) {
  return key.kty !== "oct" && typeof key.d === "string";
}
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined";
}
function isSecretJWK(key) {
  return isJWK(key) && key.kty === "oct" && typeof key.k === "string";
}

// ../../node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm2;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm2 = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm2 = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm2 = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm2 = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm2 = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm2 = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm2 = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
          algorithm2 = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "EdDSA":
          algorithm2 = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm2 = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm: algorithm2, keyUsages };
}
var parse = async (jwk) => {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm: algorithm2, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm2,
    jwk.ext ?? false,
    jwk.key_ops ?? keyUsages
  ];
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
};
var jwk_to_key_default = parse;

// ../../node_modules/jose/dist/browser/runtime/normalize_key.js
var exportKeyValue = (k) => decode(k);
var privCache;
var pubCache;
var isKeyObject = (key) => {
  return key?.[Symbol.toStringTag] === "KeyObject";
};
var importAndCache = async (cache, key, jwk, alg, freeze = false) => {
  let cached = cache.get(key);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const cryptoKey = await jwk_to_key_default({ ...jwk, alg });
  if (freeze)
    Object.freeze(key);
  if (!cached) {
    cache.set(key, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
var normalizePublicKey = (key, alg) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    delete jwk.d;
    delete jwk.dp;
    delete jwk.dq;
    delete jwk.p;
    delete jwk.q;
    delete jwk.qi;
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    pubCache || (pubCache = new WeakMap);
    return importAndCache(pubCache, key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode(key.k);
    pubCache || (pubCache = new WeakMap);
    const cryptoKey = importAndCache(pubCache, key, key, alg, true);
    return cryptoKey;
  }
  return key;
};
var normalizePrivateKey = (key, alg) => {
  if (isKeyObject(key)) {
    let jwk = key.export({ format: "jwk" });
    if (jwk.k) {
      return exportKeyValue(jwk.k);
    }
    privCache || (privCache = new WeakMap);
    return importAndCache(privCache, key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k)
      return decode(key.k);
    privCache || (privCache = new WeakMap);
    const cryptoKey = importAndCache(privCache, key, key, alg, true);
    return cryptoKey;
  }
  return key;
};
var normalize_key_default = { normalizePublicKey, normalizePrivateKey };

// ../../node_modules/jose/dist/browser/key/import.js
async function importJWK(jwk, alg) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if ("oth" in jwk && jwk.oth !== undefined) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}

// ../../node_modules/jose/dist/browser/lib/check_key_type.js
var tag = (key) => key?.[Symbol.toStringTag];
var jwkMatchesOp = (alg, key, usage) => {
  if (key.use !== undefined && key.use !== "sig") {
    throw new TypeError("Invalid key for this operation, when present its use must be sig");
  }
  if (key.key_ops !== undefined && key.key_ops.includes?.(usage) !== true) {
    throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
  }
  if (key.alg !== undefined && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);
  }
  return true;
};
var symmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (key instanceof Uint8Array)
    return;
  if (allowJwk && isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types2, "Uint8Array", allowJwk ? "JSON Web Key" : null));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (allowJwk && isJWK(key)) {
    switch (usage) {
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types2, allowJwk ? "JSON Web Key" : null));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
function checkKeyType(allowJwk, alg, key, usage) {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key, usage, allowJwk);
  } else {
    asymmetricTypeCheck(alg, key, usage, allowJwk);
  }
}
var check_key_type_default = checkKeyType.bind(undefined, false);
var checkKeyTypeWithJwk = checkKeyType.bind(undefined, true);

// ../../node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// ../../node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// ../../node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm2) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm2.namedCurve };
    case "Ed25519":
      return { name: "Ed25519" };
    case "EdDSA":
      return { name: algorithm2.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// ../../node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
async function getCryptoKey2(alg, key, usage) {
  if (usage === "sign") {
    key = await normalize_key_default.normalizePrivateKey(key, alg);
  }
  if (usage === "verify") {
    key = await normalize_key_default.normalizePublicKey(key, alg);
  }
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types2));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types2, "Uint8Array", "JSON Web Key"));
}

// ../../node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey2(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm2 = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm2, cryptoKey, signature, data);
  } catch {
    return false;
  }
};
var verify_default = verify;

// ../../node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
    checkKeyTypeWithJwk(alg, key, "verify");
    if (isJWK(key)) {
      key = await importJWK(key, alg);
    }
  } else {
    checkKeyTypeWithJwk(alg, key, "verify");
  }
  const data = concat(encoder.encode(jws.protected ?? ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// ../../node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// ../../node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date2) => Math.floor(date2.getTime() / 1000);

// ../../node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
};

// ../../node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {}
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== undefined)
    presenceCheck.push("iat");
  if (audience !== undefined)
    presenceCheck.push("aud");
  if (subject !== undefined)
    presenceCheck.push("sub");
  if (issuer !== undefined)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
};

// ../../node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  const verified = await compactVerify(jwt, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// ../../node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey2(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// ../../node_modules/jose/dist/browser/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options?.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    checkKeyTypeWithJwk(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// ../../node_modules/jose/dist/browser/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// ../../node_modules/jose/dist/browser/jwt/produce.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}

class ProduceJWT {
  constructor(payload = {}) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else if (input instanceof Date) {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
    } else if (typeof input === "string") {
      this._payload = {
        ...this._payload,
        iat: validateInput("setIssuedAt", epoch_default(new Date) + secs_default(input))
      };
    } else {
      this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
    }
    return this;
  }
}

// ../../node_modules/jose/dist/browser/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// ../../node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}

class LocalJWKSet {
  constructor(jwks) {
    this._cached = new WeakMap;
    if (!isJWKSLike(jwks)) {
      throw new JWKSInvalid("JSON Web Key Set malformed");
    }
    this._jwks = clone(jwks);
  }
  async getKey(protectedHeader, token) {
    const { alg, kid } = { ...protectedHeader, ...token?.header };
    const kty = getKtyFromAlg(alg);
    const candidates = this._jwks.keys.filter((jwk2) => {
      let candidate = kty === jwk2.kty;
      if (candidate && typeof kid === "string") {
        candidate = kid === jwk2.kid;
      }
      if (candidate && typeof jwk2.alg === "string") {
        candidate = alg === jwk2.alg;
      }
      if (candidate && typeof jwk2.use === "string") {
        candidate = jwk2.use === "sig";
      }
      if (candidate && Array.isArray(jwk2.key_ops)) {
        candidate = jwk2.key_ops.includes("verify");
      }
      if (candidate) {
        switch (alg) {
          case "ES256":
            candidate = jwk2.crv === "P-256";
            break;
          case "ES256K":
            candidate = jwk2.crv === "secp256k1";
            break;
          case "ES384":
            candidate = jwk2.crv === "P-384";
            break;
          case "ES512":
            candidate = jwk2.crv === "P-521";
            break;
          case "Ed25519":
            candidate = jwk2.crv === "Ed25519";
            break;
          case "EdDSA":
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
            break;
        }
      }
      return candidate;
    });
    const { 0: jwk, length } = candidates;
    if (length === 0) {
      throw new JWKSNoMatchingKey;
    }
    if (length !== 1) {
      const error = new JWKSMultipleMatchingKeys;
      const { _cached } = this;
      error[Symbol.asyncIterator] = async function* () {
        for (const jwk2 of candidates) {
          try {
            yield await importWithAlgCache(_cached, jwk2, alg);
          } catch {}
        }
      };
      throw error;
    }
    return importWithAlgCache(this._cached, jwk, alg);
  }
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === undefined) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);
  Object.defineProperties(localJWKSet, {
    jwks: {
      value: () => clone(set._jwks),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return localJWKSet;
}

// ../../node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks = async (url, timeout, options) => {
  let controller;
  let id;
  let timedOut = false;
  if (typeof AbortController === "function") {
    controller = new AbortController;
    id = setTimeout(() => {
      timedOut = true;
      controller.abort();
    }, timeout);
  }
  const response = await fetch(url.href, {
    signal: controller ? controller.signal : undefined,
    redirect: "manual",
    headers: options.headers
  }).catch((err) => {
    if (timedOut)
      throw new JWKSTimeout;
    throw err;
  });
  if (id !== undefined)
    clearTimeout(id);
  if (response.status !== 200) {
    throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
  }
  try {
    return await response.json();
  } catch {
    throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
};
var fetch_jwks_default = fetchJwks;

// ../../node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
var USER_AGENT;
if (typeof navigator === "undefined" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) {
  const NAME = "jose";
  const VERSION = "v5.10.0";
  USER_AGENT = `${NAME}/${VERSION}`;
}
var jwksCache = Symbol();
function isFreshJwksCache(input, cacheMaxAge) {
  if (typeof input !== "object" || input === null) {
    return false;
  }
  if (!("uat" in input) || typeof input.uat !== "number" || Date.now() - input.uat >= cacheMaxAge) {
    return false;
  }
  if (!("jwks" in input) || !isObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isObject)) {
    return false;
  }
  return true;
}

class RemoteJWKSet {
  constructor(url, options) {
    if (!(url instanceof URL)) {
      throw new TypeError("url must be an instance of URL");
    }
    this._url = new URL(url.href);
    this._options = { agent: options?.agent, headers: options?.headers };
    this._timeoutDuration = typeof options?.timeoutDuration === "number" ? options?.timeoutDuration : 5000;
    this._cooldownDuration = typeof options?.cooldownDuration === "number" ? options?.cooldownDuration : 30000;
    this._cacheMaxAge = typeof options?.cacheMaxAge === "number" ? options?.cacheMaxAge : 600000;
    if (options?.[jwksCache] !== undefined) {
      this._cache = options?.[jwksCache];
      if (isFreshJwksCache(options?.[jwksCache], this._cacheMaxAge)) {
        this._jwksTimestamp = this._cache.uat;
        this._local = createLocalJWKSet(this._cache.jwks);
      }
    }
  }
  coolingDown() {
    return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
  }
  fresh() {
    return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
  }
  async getKey(protectedHeader, token) {
    if (!this._local || !this.fresh()) {
      await this.reload();
    }
    try {
      return await this._local(protectedHeader, token);
    } catch (err) {
      if (err instanceof JWKSNoMatchingKey) {
        if (this.coolingDown() === false) {
          await this.reload();
          return this._local(protectedHeader, token);
        }
      }
      throw err;
    }
  }
  async reload() {
    if (this._pendingFetch && isCloudflareWorkers()) {
      this._pendingFetch = undefined;
    }
    const headers = new Headers(this._options.headers);
    if (USER_AGENT && !headers.has("User-Agent")) {
      headers.set("User-Agent", USER_AGENT);
      this._options.headers = Object.fromEntries(headers.entries());
    }
    this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json2) => {
      this._local = createLocalJWKSet(json2);
      if (this._cache) {
        this._cache.uat = Date.now();
        this._cache.jwks = json2;
      }
      this._jwksTimestamp = Date.now();
      this._pendingFetch = undefined;
    }).catch((err) => {
      this._pendingFetch = undefined;
      throw err;
    }));
    await this._pendingFetch;
  }
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);
  Object.defineProperties(remoteJWKSet, {
    coolingDown: {
      get: () => set.coolingDown(),
      enumerable: true,
      configurable: false
    },
    fresh: {
      get: () => set.fresh(),
      enumerable: true,
      configurable: false
    },
    reload: {
      value: () => set.reload(),
      enumerable: true,
      configurable: false,
      writable: false
    },
    reloading: {
      get: () => !!set._pendingFetch,
      enumerable: true,
      configurable: false
    },
    jwks: {
      value: () => set._local?.jwks(),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return remoteJWKSet;
}
// ../../node_modules/jose/dist/browser/util/base64url.js
var decode2 = decode;

// ../../node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error;
    }
    const result = JSON.parse(decoder.decode(decode2(protectedB64u)));
    if (!isObject(result)) {
      throw new Error;
    }
    return result;
  } catch {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
// ../../node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
// ../../node_modules/@noble/hashes/esm/utils.js
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0;i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0;i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char2 = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
var nextTick = async () => {};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0;i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function kdfInputToBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function checkOpts(defaults, opts) {
  if (opts !== undefined && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}

class Hash {
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// ../../node_modules/@noble/hashes/esm/hmac.js
class HMAC extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac = (hash, key, message2) => new HMAC(hash, key).update(message2).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

// ../../node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c);
  anumber(dkLen);
  anumber(asyncTick);
  if (c < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// ../../node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}

class HashMD extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);

// ../../node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);

class SHA256 extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
}
var sha256 = /* @__PURE__ */ createHasher(() => new SHA256);

// ../../node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber(N);
  anumber(r);
  anumber(p);
  anumber(dkLen);
  anumber(asyncTick);
  anumber(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  const pow32 = Math.pow(2, 32);
  if (N <= 1 || (N & N - 1) !== 0 || N > pow32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  }
  if (p < 0 || p > (pow32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " + maxmem);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {};
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  clean(B, V, tmp);
  return res;
}
async function scryptAsync(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0;pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    });
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V, tmp);
}
// ../../node_modules/@better-auth/utils/dist/hex.mjs
var hexadecimal = "0123456789abcdef";
var hex = {
  encode: (data) => {
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
    }
    if (data.byteLength === 0) {
      return "";
    }
    const buffer = new Uint8Array(data);
    let result = "";
    for (const byte of buffer) {
      result += byte.toString(16).padStart(2, "0");
    }
    return result;
  },
  decode: (data) => {
    if (!data) {
      return "";
    }
    if (typeof data === "string") {
      if (data.length % 2 !== 0) {
        throw new Error("Invalid hexadecimal string");
      }
      if (!new RegExp(`^[${hexadecimal}]+$`).test(data)) {
        throw new Error("Invalid hexadecimal string");
      }
      const result = new Uint8Array(data.length / 2);
      for (let i = 0;i < data.length; i += 2) {
        result[i / 2] = parseInt(data.slice(i, i + 2), 16);
      }
      return new TextDecoder().decode(result);
    }
    return new TextDecoder().decode(data);
  }
};

// ../../node_modules/better-auth/dist/shared/better-auth.B4Qoxdgc.mjs
var generateRandomString = createRandomStringGenerator("a-z", "0-9", "A-Z", "-_");

// ../../node_modules/better-auth/dist/shared/better-auth.Cqykj82J.mjs
var levels = ["info", "success", "warn", "error", "debug"];
function shouldPublishLog(currentLogLevel, logLevel) {
  return levels.indexOf(logLevel) <= levels.indexOf(currentLogLevel);
}
var colors = {
  reset: "\x1B[0m",
  bright: "\x1B[1m",
  dim: "\x1B[2m",
  fg: {
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m"
  }
};
var levelColors = {
  info: colors.fg.blue,
  success: colors.fg.green,
  warn: colors.fg.yellow,
  error: colors.fg.red,
  debug: colors.fg.magenta
};
var formatMessage = (level, message2) => {
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
  return `${colors.dim}${timestamp2}${colors.reset} ${levelColors[level]}${level.toUpperCase()}${colors.reset} ${colors.bright}[Better Auth]:${colors.reset} ${message2}`;
};
var createLogger = (options) => {
  const enabled = options?.disabled !== true;
  const logLevel = options?.level ?? "error";
  const LogFunc = (level, message2, args = []) => {
    if (!enabled || !shouldPublishLog(logLevel, level)) {
      return;
    }
    const formattedMessage = formatMessage(level, message2);
    if (!options || typeof options.log !== "function") {
      if (level === "error") {
        console.error(formattedMessage, ...args);
      } else if (level === "warn") {
        console.warn(formattedMessage, ...args);
      } else {
        console.log(formattedMessage, ...args);
      }
      return;
    }
    options.log(level === "success" ? "info" : level, message2, ...args);
  };
  return Object.fromEntries(levels.map((level) => [
    level,
    (...[message2, ...args]) => LogFunc(level, message2, args)
  ]));
};
var logger = createLogger();

// ../../node_modules/better-auth/dist/shared/better-auth.WByh1Fkk.mjs
var debugLogs = [];
var transactionId = -1;
var colors2 = {
  reset: "\x1B[0m",
  bright: "\x1B[1m",
  dim: "\x1B[2m",
  fg: {
    yellow: "\x1B[33m",
    magenta: "\x1B[35m"
  },
  bg: {
    black: "\x1B[40m"
  }
};
var createAdapter = ({
  adapter,
  config: cfg
}) => (options) => {
  const config = {
    ...cfg,
    supportsBooleans: cfg.supportsBooleans ?? true,
    supportsDates: cfg.supportsDates ?? true,
    supportsJSON: cfg.supportsJSON ?? false,
    adapterName: cfg.adapterName ?? cfg.adapterId,
    supportsNumericIds: cfg.supportsNumericIds ?? true
  };
  if (options.advanced?.database?.useNumberId === true && config.supportsNumericIds === false) {
    throw new Error(`[${config.adapterName}] Your database or database adapter does not support numeric ids. Please disable "useNumberId" in your config.`);
  }
  const schema = getAuthTables(options);
  const getDefaultFieldName = ({
    field,
    model: unsafe_model
  }) => {
    if (field === "id") {
      return field;
    }
    const model = getDefaultModelName(unsafe_model);
    let f = schema[model]?.fields[field];
    if (!f) {
      f = Object.values(schema[model]?.fields).find((f2) => f2.fieldName === field);
    }
    if (!f) {
      debugLog(`Field ${field} not found in model ${model}`);
      debugLog(`Schema:`, schema);
      throw new Error(`Field ${field} not found in model ${model}`);
    }
    return field;
  };
  const getDefaultModelName = (model) => {
    if (config.usePlural && model.charAt(model.length - 1) === "s") {
      let pluralessModel = model.slice(0, -1);
      let m2 = schema[pluralessModel] ? pluralessModel : undefined;
      if (!m2) {
        m2 = Object.entries(schema).find(([_, f]) => f.modelName === pluralessModel)?.[0];
      }
      if (m2) {
        return m2;
      }
    }
    let m = schema[model] ? model : undefined;
    if (!m) {
      m = Object.entries(schema).find(([_, f]) => f.modelName === model)?.[0];
    }
    if (!m) {
      debugLog(`Model "${model}" not found in schema`);
      debugLog(`Schema:`, schema);
      throw new Error(`Model "${model}" not found in schema`);
    }
    return m;
  };
  const getModelName = (model) => {
    return schema[getDefaultModelName(model)].modelName !== model ? schema[getDefaultModelName(model)].modelName : config.usePlural ? `${model}s` : model;
  };
  function getFieldName({
    model: model_name,
    field: field_name
  }) {
    const model = getDefaultModelName(model_name);
    const field = getDefaultFieldName({ model, field: field_name });
    return schema[model]?.fields[field]?.fieldName || field;
  }
  const debugLog = (...args) => {
    if (config.debugLogs === true || typeof config.debugLogs === "object") {
      if (typeof config.debugLogs === "object" && "isRunningAdapterTests" in config.debugLogs) {
        if (config.debugLogs.isRunningAdapterTests) {
          args.shift();
          debugLogs.push(args);
        }
        return;
      }
      if (typeof config.debugLogs === "object" && config.debugLogs.logCondition && !config.debugLogs.logCondition?.()) {
        return;
      }
      if (typeof args[0] === "object" && "method" in args[0]) {
        const method = args.shift().method;
        if (typeof config.debugLogs === "object") {
          if (method === "create" && !config.debugLogs.create) {
            return;
          } else if (method === "update" && !config.debugLogs.update) {
            return;
          } else if (method === "updateMany" && !config.debugLogs.updateMany) {
            return;
          } else if (method === "findOne" && !config.debugLogs.findOne) {
            return;
          } else if (method === "findMany" && !config.debugLogs.findMany) {
            return;
          } else if (method === "delete" && !config.debugLogs.delete) {
            return;
          } else if (method === "deleteMany" && !config.debugLogs.deleteMany) {
            return;
          } else if (method === "count" && !config.debugLogs.count) {
            return;
          }
        }
        logger.info(`[${config.adapterName}]`, ...args);
      } else {
        logger.info(`[${config.adapterName}]`, ...args);
      }
    }
  };
  const idField = ({
    customModelName,
    forceAllowId
  }) => {
    const shouldGenerateId = !config.disableIdGeneration && !options.advanced?.database?.useNumberId && !forceAllowId;
    const model = getDefaultModelName(customModelName ?? "id");
    return {
      type: options.advanced?.database?.useNumberId ? "number" : "string",
      required: shouldGenerateId ? true : false,
      ...shouldGenerateId ? {
        defaultValue() {
          if (config.disableIdGeneration)
            return;
          const useNumberId = options.advanced?.database?.useNumberId;
          let generateId$1 = options.advanced?.database?.generateId;
          if (options.advanced?.generateId !== undefined) {
            logger.warn("Your Better Auth config includes advanced.generateId which is deprecated. Please use advanced.database.generateId instead. This will be removed in future releases.");
            generateId$1 = options.advanced?.generateId;
          }
          if (generateId$1 === false || useNumberId)
            return;
          if (generateId$1) {
            return generateId$1({
              model
            });
          }
          if (config.customIdGenerator) {
            return config.customIdGenerator({ model });
          }
          return generateId();
        }
      } : {}
    };
  };
  const getFieldAttributes = ({
    model,
    field
  }) => {
    const defaultModelName = getDefaultModelName(model);
    const defaultFieldName = getDefaultFieldName({
      field,
      model
    });
    const fields = schema[defaultModelName].fields;
    fields.id = idField({ customModelName: defaultModelName });
    return fields[defaultFieldName];
  };
  const adapterInstance = adapter({
    options,
    schema,
    debugLog,
    getFieldName,
    getModelName,
    getDefaultModelName,
    getDefaultFieldName,
    getFieldAttributes
  });
  const transformInput = async (data, unsafe_model, action, forceAllowId) => {
    const transformedData = {};
    const fields = schema[unsafe_model].fields;
    const newMappedKeys = config.mapKeysTransformInput ?? {};
    if (!config.disableIdGeneration && !options.advanced?.database?.useNumberId) {
      fields.id = idField({ customModelName: unsafe_model, forceAllowId });
    }
    for (const field in fields) {
      const value = data[field];
      const fieldAttributes = fields[field];
      let newFieldName = newMappedKeys[field] || fields[field].fieldName || field;
      if (value === undefined && (!fieldAttributes.defaultValue && !fieldAttributes.transform?.input || action === "update")) {
        continue;
      }
      let newValue = withApplyDefault(value, fieldAttributes, action);
      if (fieldAttributes.transform?.input) {
        newValue = await fieldAttributes.transform.input(newValue);
      }
      if (fieldAttributes.references?.field === "id" && options.advanced?.database?.useNumberId) {
        if (Array.isArray(newValue)) {
          newValue = newValue.map(Number);
        } else {
          newValue = Number(newValue);
        }
      } else if (config.supportsJSON === false && typeof newValue === "object" && fieldAttributes.type === "json") {
        newValue = JSON.stringify(newValue);
      } else if (config.supportsDates === false && newValue instanceof Date && fieldAttributes.type === "date") {
        newValue = newValue.toISOString();
      } else if (config.supportsBooleans === false && typeof newValue === "boolean") {
        newValue = newValue ? 1 : 0;
      }
      if (config.customTransformInput) {
        newValue = config.customTransformInput({
          data: newValue,
          action,
          field: newFieldName,
          fieldAttributes,
          model: unsafe_model,
          schema,
          options
        });
      }
      transformedData[newFieldName] = newValue;
    }
    return transformedData;
  };
  const transformOutput = async (data, unsafe_model, select = []) => {
    if (!data)
      return null;
    const newMappedKeys = config.mapKeysTransformOutput ?? {};
    const transformedData = {};
    const tableSchema = schema[unsafe_model].fields;
    const idKey = Object.entries(newMappedKeys).find(([_, v]) => v === "id")?.[0];
    tableSchema[idKey ?? "id"] = {
      type: options.advanced?.database?.useNumberId ? "number" : "string"
    };
    for (const key in tableSchema) {
      if (select.length && !select.includes(key)) {
        continue;
      }
      const field = tableSchema[key];
      if (field) {
        const originalKey = field.fieldName || key;
        let newValue = data[Object.entries(newMappedKeys).find(([_, v]) => v === originalKey)?.[0] || originalKey];
        if (field.transform?.output) {
          newValue = await field.transform.output(newValue);
        }
        let newFieldName = newMappedKeys[key] || key;
        if (originalKey === "id" || field.references?.field === "id") {
          if (typeof newValue !== "undefined")
            newValue = String(newValue);
        } else if (config.supportsJSON === false && typeof newValue === "string" && field.type === "json") {
          newValue = safeJSONParse(newValue);
        } else if (config.supportsDates === false && typeof newValue === "string" && field.type === "date") {
          newValue = new Date(newValue);
        } else if (config.supportsBooleans === false && typeof newValue === "number" && field.type === "boolean") {
          newValue = newValue === 1;
        }
        if (config.customTransformOutput) {
          newValue = config.customTransformOutput({
            data: newValue,
            field: newFieldName,
            fieldAttributes: field,
            select,
            model: unsafe_model,
            schema,
            options
          });
        }
        transformedData[newFieldName] = newValue;
      }
    }
    return transformedData;
  };
  const transformWhereClause = ({
    model,
    where
  }) => {
    if (!where)
      return;
    return where.map((w) => {
      const {
        field: unsafe_field,
        value,
        operator = "eq",
        connector = "AND"
      } = w;
      if (operator === "in") {
        if (!Array.isArray(value)) {
          throw new Error("Value must be an array");
        }
      }
      const defaultModelName = getDefaultModelName(model);
      const defaultFieldName = getDefaultFieldName({
        field: unsafe_field,
        model
      });
      const fieldName = getFieldName({
        field: defaultFieldName,
        model: defaultModelName
      });
      const fieldAttr = getFieldAttributes({
        field: defaultFieldName,
        model: defaultModelName
      });
      if (defaultFieldName === "id" || fieldAttr.references?.field === "id") {
        if (options.advanced?.database?.useNumberId) {
          if (Array.isArray(value)) {
            return {
              operator,
              connector,
              field: fieldName,
              value: value.map(Number)
            };
          }
          return {
            operator,
            connector,
            field: fieldName,
            value: Number(value)
          };
        }
      }
      return {
        operator,
        connector,
        field: fieldName,
        value
      };
    });
  };
  return {
    create: async ({
      data: unsafeData,
      model: unsafeModel,
      select,
      forceAllowId = false
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      if ("id" in unsafeData && !forceAllowId) {
        logger.warn(`[${config.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \`forceAllowId\` parameter. The id will be ignored.`);
        const err = new Error;
        const stack = err.stack?.split(`
`).filter((_, i) => i !== 1).join(`
`).replace("Error:", "Create method with `id` being called at:");
        console.log(stack);
        unsafeData.id = undefined;
      }
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("create")} ${formatAction("Unsafe Input")}:`, { model, data: unsafeData });
      const data = await transformInput(unsafeData, unsafeModel, "create", forceAllowId);
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("create")} ${formatAction("Parsed Input")}:`, { model, data });
      const res = await adapterInstance.create({ data, model });
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("create")} ${formatAction("DB Result")}:`, { model, res });
      const transformed = await transformOutput(res, unsafeModel, select);
      debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("create")} ${formatAction("Parsed Result")}:`, { model, data: transformed });
      return transformed;
    },
    update: async ({
      model: unsafeModel,
      where: unsafeWhere,
      update: unsafeData
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("update")} ${formatAction("Unsafe Input")}:`, { model, data: unsafeData });
      const data = await transformInput(unsafeData, unsafeModel, "update");
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("update")} ${formatAction("Parsed Input")}:`, { model, data });
      const res = await adapterInstance.update({
        model,
        where,
        update: data
      });
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("update")} ${formatAction("DB Result")}:`, { model, data: res });
      const transformed = await transformOutput(res, unsafeModel);
      debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("update")} ${formatAction("Parsed Result")}:`, { model, data: transformed });
      return transformed;
    },
    updateMany: async ({
      model: unsafeModel,
      where: unsafeWhere,
      update: unsafeData
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("updateMany")} ${formatAction("Unsafe Input")}:`, { model, data: unsafeData });
      const data = await transformInput(unsafeData, unsafeModel, "update");
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("updateMany")} ${formatAction("Parsed Input")}:`, { model, data });
      const updatedCount = await adapterInstance.updateMany({
        model,
        where,
        update: data
      });
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("updateMany")} ${formatAction("DB Result")}:`, { model, data: updatedCount });
      debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("updateMany")} ${formatAction("Parsed Result")}:`, { model, data: updatedCount });
      return updatedCount;
    },
    findOne: async ({
      model: unsafeModel,
      where: unsafeWhere,
      select
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`, `${formatMethod("findOne")}:`, { model, where, select });
      const res = await adapterInstance.findOne({
        model,
        where,
        select
      });
      debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`, `${formatMethod("findOne")} ${formatAction("DB Result")}:`, { model, data: res });
      const transformed = await transformOutput(res, unsafeModel, select);
      debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`, `${formatMethod("findOne")} ${formatAction("Parsed Result")}:`, { model, data: transformed });
      return transformed;
    },
    findMany: async ({
      model: unsafeModel,
      where: unsafeWhere,
      limit: unsafeLimit,
      sortBy,
      offset
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const limit = unsafeLimit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`, `${formatMethod("findMany")}:`, { model, where, limit, sortBy, offset });
      const res = await adapterInstance.findMany({
        model,
        where,
        limit,
        sortBy,
        offset
      });
      debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`, `${formatMethod("findMany")} ${formatAction("DB Result")}:`, { model, data: res });
      const transformed = await Promise.all(res.map(async (r) => await transformOutput(r, unsafeModel)));
      debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`, `${formatMethod("findMany")} ${formatAction("Parsed Result")}:`, { model, data: transformed });
      return transformed;
    },
    delete: async ({
      model: unsafeModel,
      where: unsafeWhere
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "delete" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("delete")}:`, { model, where });
      await adapterInstance.delete({
        model,
        where
      });
      debugLog({ method: "delete" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("delete")} ${formatAction("DB Result")}:`, { model });
    },
    deleteMany: async ({
      model: unsafeModel,
      where: unsafeWhere
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "deleteMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("deleteMany")} ${formatAction("DeleteMany")}:`, { model, where });
      const res = await adapterInstance.deleteMany({
        model,
        where
      });
      debugLog({ method: "deleteMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("deleteMany")} ${formatAction("DB Result")}:`, { model, data: res });
      return res;
    },
    count: async ({
      model: unsafeModel,
      where: unsafeWhere
    }) => {
      transactionId++;
      let thisTransactionId = transactionId;
      const model = getModelName(unsafeModel);
      const where = transformWhereClause({
        model: unsafeModel,
        where: unsafeWhere
      });
      debugLog({ method: "count" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("count")}:`, {
        model,
        where
      });
      const res = await adapterInstance.count({
        model,
        where
      });
      debugLog({ method: "count" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("count")}:`, {
        model,
        data: res
      });
      return res;
    },
    createSchema: adapterInstance.createSchema ? async (_, file) => {
      const tables = getAuthTables(options);
      if (options.secondaryStorage && !options.session?.storeSessionInDatabase) {
        delete tables.session;
      }
      if (options.rateLimit && options.rateLimit.storage === "database" && (typeof options.rateLimit.enabled === "undefined" || options.rateLimit.enabled === true)) {
        tables.ratelimit = {
          modelName: options.rateLimit.modelName ?? "ratelimit",
          fields: {
            key: {
              type: "string",
              unique: true,
              required: true,
              fieldName: options.rateLimit.fields?.key ?? "key"
            },
            count: {
              type: "number",
              required: true,
              fieldName: options.rateLimit.fields?.count ?? "count"
            },
            lastRequest: {
              type: "number",
              required: true,
              bigint: true,
              defaultValue: () => Date.now(),
              fieldName: options.rateLimit.fields?.lastRequest ?? "lastRequest"
            }
          }
        };
      }
      return adapterInstance.createSchema({ file, tables });
    } : undefined,
    options: {
      adapterConfig: config,
      ...adapterInstance.options ?? {}
    },
    id: config.adapterId,
    ...config.debugLogs?.isRunningAdapterTests ? {
      adapterTestDebugLogs: {
        resetDebugLogs() {
          debugLogs = [];
        },
        printDebugLogs() {
          const separator = `\u2500`.repeat(80);
          let log = debugLogs.reverse().map((log2) => {
            log2[0] = `
${log2[0]}`;
            return [...log2, `
`];
          }).reduce((prev, curr) => {
            return [...curr, ...prev];
          }, [`
${separator}`]);
          console.log(...log);
        }
      }
    } : {}
  };
};
function formatTransactionId(transactionId2) {
  return `${colors2.fg.magenta}#${transactionId2}${colors2.reset}`;
}
function formatStep(step, total) {
  return `${colors2.bg.black}${colors2.fg.yellow}[${step}/${total}]${colors2.reset}`;
}
function formatMethod(method) {
  return `${colors2.bright}${method}${colors2.reset}`;
}
function formatAction(action) {
  return `${colors2.dim}(${action})${colors2.reset}`;
}

// ../../node_modules/better-auth/dist/adapters/drizzle-adapter/index.mjs
var drizzleAdapter = (db, config) => createAdapter({
  config: {
    adapterId: "drizzle",
    adapterName: "Drizzle Adapter",
    usePlural: config.usePlural ?? false,
    debugLogs: config.debugLogs ?? false
  },
  adapter: ({ getFieldName, debugLog }) => {
    function getSchema(model) {
      const schema = config.schema || db._.fullSchema;
      if (!schema) {
        throw new BetterAuthError("Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.");
      }
      const schemaModel = schema[model];
      if (!schemaModel) {
        throw new BetterAuthError(`[# Drizzle Adapter]: The model "${model}" was not found in the schema object. Please pass the schema directly to the adapter options.`);
      }
      return schemaModel;
    }
    const withReturning = async (model, builder, data, where) => {
      if (config.provider !== "mysql") {
        const c = await builder.returning();
        return c[0];
      }
      await builder.execute();
      const schemaModel = getSchema(model);
      const builderVal = builder.config?.values;
      if (where?.length) {
        const clause = convertWhereClause(where, model);
        const res = await db.select().from(schemaModel).where(...clause);
        return res[0];
      } else if (builderVal && builderVal[0]?.id?.value) {
        let tId = builderVal[0]?.id?.value;
        if (!tId) {
          const lastInsertId = await db.select({ id: sql`LAST_INSERT_ID()` }).from(schemaModel).orderBy(desc(schemaModel.id)).limit(1);
          tId = lastInsertId[0].id;
        }
        const res = await db.select().from(schemaModel).where(eq(schemaModel.id, tId)).limit(1).execute();
        return res[0];
      } else if (data.id) {
        const res = await db.select().from(schemaModel).where(eq(schemaModel.id, data.id)).limit(1).execute();
        return res[0];
      } else {
        if (!("id" in schemaModel)) {
          throw new BetterAuthError(`The model "${model}" does not have an "id" field. Please use the "id" field as your primary key.`);
        }
        const res = await db.select().from(schemaModel).orderBy(desc(schemaModel.id)).limit(1).execute();
        return res[0];
      }
    };
    function convertWhereClause(where, model) {
      const schemaModel = getSchema(model);
      if (!where)
        return [];
      if (where.length === 1) {
        const w = where[0];
        if (!w) {
          return [];
        }
        const field = getFieldName({ model, field: w.field });
        if (!schemaModel[field]) {
          throw new BetterAuthError(`The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`);
        }
        if (w.operator === "in") {
          if (!Array.isArray(w.value)) {
            throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
          }
          return [inArray(schemaModel[field], w.value)];
        }
        if (w.operator === "contains") {
          return [like(schemaModel[field], `%${w.value}%`)];
        }
        if (w.operator === "starts_with") {
          return [like(schemaModel[field], `${w.value}%`)];
        }
        if (w.operator === "ends_with") {
          return [like(schemaModel[field], `%${w.value}`)];
        }
        if (w.operator === "lt") {
          return [lt(schemaModel[field], w.value)];
        }
        if (w.operator === "lte") {
          return [lte(schemaModel[field], w.value)];
        }
        if (w.operator === "ne") {
          return [ne(schemaModel[field], w.value)];
        }
        if (w.operator === "gt") {
          return [gt(schemaModel[field], w.value)];
        }
        if (w.operator === "gte") {
          return [gte(schemaModel[field], w.value)];
        }
        return [eq(schemaModel[field], w.value)];
      }
      const andGroup = where.filter((w) => w.connector === "AND" || !w.connector);
      const orGroup = where.filter((w) => w.connector === "OR");
      const andClause = and(...andGroup.map((w) => {
        const field = getFieldName({ model, field: w.field });
        if (w.operator === "in") {
          if (!Array.isArray(w.value)) {
            throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
          }
          return inArray(schemaModel[field], w.value);
        }
        return eq(schemaModel[field], w.value);
      }));
      const orClause = or(...orGroup.map((w) => {
        const field = getFieldName({ model, field: w.field });
        return eq(schemaModel[field], w.value);
      }));
      const clause = [];
      if (andGroup.length)
        clause.push(andClause);
      if (orGroup.length)
        clause.push(orClause);
      return clause;
    }
    function checkMissingFields(schema, model, values) {
      if (!schema) {
        throw new BetterAuthError("Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.");
      }
      for (const key in values) {
        if (!schema[key]) {
          throw new BetterAuthError(`The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`);
        }
      }
    }
    return {
      async create({ model, data: values }) {
        const schemaModel = getSchema(model);
        checkMissingFields(schemaModel, model, values);
        const builder = db.insert(schemaModel).values(values);
        const returned = await withReturning(model, builder, values);
        return returned;
      },
      async findOne({ model, where }) {
        const schemaModel = getSchema(model);
        const clause = convertWhereClause(where, model);
        const res = await db.select().from(schemaModel).where(...clause);
        if (!res.length)
          return null;
        return res[0];
      },
      async findMany({ model, where, sortBy, limit, offset }) {
        const schemaModel = getSchema(model);
        const clause = where ? convertWhereClause(where, model) : [];
        const sortFn = sortBy?.direction === "desc" ? desc : asc;
        const builder = db.select().from(schemaModel).limit(limit || 100).offset(offset || 0);
        if (sortBy?.field) {
          builder.orderBy(sortFn(schemaModel[getFieldName({ model, field: sortBy?.field })]));
        }
        return await builder.where(...clause);
      },
      async count({ model, where }) {
        const schemaModel = getSchema(model);
        const clause = where ? convertWhereClause(where, model) : [];
        const res = await db.select({ count: count() }).from(schemaModel).where(...clause);
        return res[0].count;
      },
      async update({ model, where, update: values }) {
        const schemaModel = getSchema(model);
        const clause = convertWhereClause(where, model);
        const builder = db.update(schemaModel).set(values).where(...clause);
        return await withReturning(model, builder, values, where);
      },
      async updateMany({ model, where, update: values }) {
        const schemaModel = getSchema(model);
        const clause = convertWhereClause(where, model);
        const builder = db.update(schemaModel).set(values).where(...clause);
        return await builder;
      },
      async delete({ model, where }) {
        const schemaModel = getSchema(model);
        const clause = convertWhereClause(where, model);
        const builder = db.delete(schemaModel).where(...clause);
        return await builder;
      },
      async deleteMany({ model, where }) {
        const schemaModel = getSchema(model);
        const clause = convertWhereClause(where, model);
        const builder = db.delete(schemaModel).where(...clause);
        return await builder;
      },
      options: config
    };
  }
});

// ../../packages/auth/src/utils/extract-token.ts
function extractTokenFromUrl(url) {
  const urlObj = new URL(url);
  let token = urlObj.searchParams.get("token") || urlObj.searchParams.get("resetToken") || urlObj.searchParams.get("t") || null;
  if (!token) {
    const pathParts = urlObj.pathname.split("/");
    const lastPart = pathParts[pathParts.length - 1];
    token = lastPart && lastPart !== "reset-password" ? lastPart : null;
  }
  return token;
}

// ../../node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// ../../node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject2(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length;i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0;i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length;i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator2 = obj && obj[iterator];
  const _iterator = generator2.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject2,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// ../../node_modules/axios/lib/core/AxiosError.js
function AxiosError(message2, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../../node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// ../../node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData);
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\x00"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode2);
  } : encode2;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../../node_modules/axios/lib/helpers/buildURL.js
function encode3(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode3;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// ../../node_modules/axios/lib/core/InterceptorManager.js
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager_default = InterceptorManager;

// ../../node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../../node_modules/axios/lib/platform/node/index.js
import crypto2 from "crypto";

// ../../node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from "url";
var URLSearchParams_default = url.URLSearchParams;

// ../../node_modules/axios/lib/platform/node/index.js
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  crypto2.randomFillSync(randomValues);
  for (let i = 0;i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};

// ../../node_modules/axios/lib/platform/common/utils.js
var exports_utils = {};
__export(exports_utils, {
  origin: () => origin,
  navigator: () => _navigator,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasBrowserEnv: () => hasBrowserEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || undefined;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// ../../node_modules/axios/lib/platform/index.js
var platform_default = {
  ...exports_utils,
  ...node_default
};

// ../../node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams, Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// ../../node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0;i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../../node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder2) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData, this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": undefined
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// ../../node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split(`
`).forEach(function parser(line2) {
    i = line2.indexOf(":");
    key = line2.substring(0, i).trim().toLowerCase();
    val = line2.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../../node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === undefined || _rewrite === true || _rewrite === undefined && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../../node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}

// ../../node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../../node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message2, config, request) {
  AxiosError_default.call(this, message2 == null ? "canceled" : message2, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../../node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// ../../node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../../node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../../node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
import http from "http";
import https from "https";
import util5 from "util";
import zlib from "zlib";

// ../../node_modules/axios/lib/env/data.js
var VERSION = "1.10.0";

// ../../node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// ../../node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// ../../node_modules/axios/lib/adapters/http.js
import stream3 from "stream";

// ../../node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from "stream";
var kInternals = Symbol("internals");

class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1000 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
var AxiosTransformStream_default = AxiosTransformStream;

// ../../node_modules/axios/lib/adapters/http.js
import { EventEmitter } from "events";

// ../../node_modules/axios/lib/helpers/formDataToStream.js
import util4 from "util";
import { Readable } from "stream";

// ../../node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// ../../node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = typeof TextEncoder === "function" ? new TextEncoder : new util4.TextEncoder;
var CRLF = `\r
`;
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async* encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag: tag2 = "form-data-boundary",
    size = 25,
    boundary = tag2 + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// ../../node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from "stream";

class ZlibHeaderTransformStream extends stream2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// ../../node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// ../../node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
var speedometer_default = speedometer;

// ../../node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp2 = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp2;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// ../../node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// ../../node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var flushOnFinish = (stream4, [throttled, flush]) => {
  stream4.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base642 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base642;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter;
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream3.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default,
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_BAD_REQUEST, config));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util5.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {}
      }
    } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = stream3.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {} else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError_default.ERR_BAD_REQUEST, config));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default("Request body larger than maxBodyLength limit", AxiosError_default.ERR_BAD_REQUEST, config));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = stream3.Readable.from(data, { objectMode: false });
      }
      data = stream3.pipeline([data, new AxiosTransformStream_default({
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
    }
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default);
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = stream3.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default("stream has been aborted", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest);
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1000 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default("error trying to parse `config.timeout` to int", AxiosError_default.ERR_BAD_OPTION_VALUE, config, req));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, req));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : () => true;

// ../../node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + "=" + encodeURIComponent(value)];
    utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
    utils_default.isString(path) && cookie.push("path=" + path);
    utils_default.isString(domain) && cookie.push("domain=" + domain);
    secure === true && cookie.push("secure");
    document.cookie = cookie.join("; ");
  },
  read(name) {
    const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, "", Date.now() - 86400000);
  }
} : {
  write() {},
  read() {
    return null;
  },
  remove() {}
};

// ../../node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// ../../node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// ../../node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest;
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    requestData === undefined && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// ../../node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController;
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// ../../node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream4) {
  if (stream4[Symbol.asyncIterator]) {
    yield* stream4;
    return;
  }
  const reader = stream4.getReader();
  try {
    for (;; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream4, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// ../../node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream,
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response);
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });
    let response = await fetch(request, fetchOptions);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
      response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
        flush && flush();
        unsubscribe && unsubscribe();
      }), options);
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request), {
        cause: err.cause || err
      });
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// ../../node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {}
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0;i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
      let s = length ? reasons.length > 1 ? `since :
` + reasons.map(renderReason).join(`
`) : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// ../../node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../../node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version2, message2) {
  function formatMessage2(opt, desc2) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc2 + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(formatMessage2(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError_default.ERR_DEPRECATED);
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage2(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../../node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;

class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default,
      response: new InterceptorManager_default
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error;
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += `
` + stack;
          }
        } catch (e) {}
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== undefined) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== undefined) {} else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
    headers && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../../node_modules/axios/lib/cancel/CancelToken.js
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message2, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController;
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken_default = CancelToken;

// ../../node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// ../../node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../../node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../../node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../../packages/auth/src/utils/send-mail.ts
async function sendMail({ to, subject, text: text2 }) {
  try {
    const response = await axios_default.post(`${process.env.BACKEND_URL}/api/email/send-mail`, { to, subject, text: text2 });
    return response.data;
  } catch (error) {
    console.error("Error sending email:", error);
    throw error;
  }
}
// ../../node_modules/better-auth/dist/shared/better-auth.CW6D9eSx.mjs
var getDate = (span, unit = "ms") => {
  return new Date(Date.now() + (unit === "sec" ? span * 1000 : span));
};

// ../../node_modules/better-auth/dist/shared/better-auth.8zoxzg-F.mjs
var _envShim = /* @__PURE__ */ Object.create(null);
var _getEnv = (useShim) => globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (useShim ? _envShim : globalThis);
var env = new Proxy(_envShim, {
  get(_, prop) {
    const env2 = _getEnv();
    return env2[prop] ?? _envShim[prop];
  },
  has(_, prop) {
    const env2 = _getEnv();
    return prop in env2 || prop in _envShim;
  },
  set(_, prop, value) {
    const env2 = _getEnv(true);
    env2[prop] = value;
    return true;
  },
  deleteProperty(_, prop) {
    if (!prop) {
      return false;
    }
    const env2 = _getEnv(true);
    delete env2[prop];
    return true;
  },
  ownKeys() {
    const env2 = _getEnv(true);
    return Object.keys(env2);
  }
});
function toBoolean(val) {
  return val ? val !== "false" : false;
}
var nodeENV = typeof process !== "undefined" && process.env && "development" || "";
var isProduction = nodeENV === "production";
var isDevelopment = nodeENV === "dev" || nodeENV === "development";
var isTest = nodeENV === "test" || toBoolean(env.TEST);

// ../../node_modules/@better-auth/utils/dist/hmac.mjs
var createHMAC = (algorithm2 = "SHA-256", encoding = "none") => {
  const hmac2 = {
    importKey: async (key, keyUsage) => {
      return subtle.importKey("raw", typeof key === "string" ? new TextEncoder().encode(key) : key, { name: "HMAC", hash: { name: algorithm2 } }, false, [keyUsage]);
    },
    sign: async (hmacKey, data) => {
      if (typeof hmacKey === "string") {
        hmacKey = await hmac2.importKey(hmacKey, "sign");
      }
      const signature = await subtle.sign("HMAC", hmacKey, typeof data === "string" ? new TextEncoder().encode(data) : data);
      if (encoding === "hex") {
        return hex.encode(signature);
      }
      if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
        return base64Url.encode(signature, {
          padding: encoding !== "base64urlnopad"
        });
      }
      return signature;
    },
    verify: async (hmacKey, data, signature) => {
      if (typeof hmacKey === "string") {
        hmacKey = await hmac2.importKey(hmacKey, "verify");
      }
      if (encoding === "hex") {
        signature = hex.decode(signature);
      }
      if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
        signature = await base64.decode(signature);
      }
      return subtle.verify("HMAC", hmacKey, typeof signature === "string" ? new TextEncoder().encode(signature) : signature, typeof data === "string" ? new TextEncoder().encode(data) : data);
    }
  };
  return hmac2;
};

// ../../node_modules/better-auth/dist/shared/better-auth.VTXNLFMT.mjs
function checkHasPath(url2) {
  try {
    const parsedUrl = new URL(url2);
    return parsedUrl.pathname !== "/";
  } catch (error) {
    throw new BetterAuthError(`Invalid base URL: ${url2}. Please provide a valid base URL.`);
  }
}
function withPath(url2, path = "/api/auth") {
  const hasPath = checkHasPath(url2);
  if (hasPath) {
    return url2;
  }
  path = path.startsWith("/") ? path : `/${path}`;
  return `${url2.replace(/\/+$/, "")}${path}`;
}
function getBaseURL(url2, path, request) {
  if (url2) {
    return withPath(url2, path);
  }
  const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : undefined);
  if (fromEnv) {
    return withPath(fromEnv, path);
  }
  const fromRequest = request?.headers.get("x-forwarded-host");
  const fromRequestProto = request?.headers.get("x-forwarded-proto");
  if (fromRequest && fromRequestProto) {
    return withPath(`${fromRequestProto}://${fromRequest}`, path);
  }
  if (request) {
    const url22 = getOrigin(request.url);
    if (!url22) {
      throw new BetterAuthError("Could not get origin from request. Please provide a valid base URL.");
    }
    return withPath(url22, path);
  }
  if (typeof window !== "undefined" && window.location) {
    return withPath(window.location.origin, path);
  }
  return;
}
function getOrigin(url2) {
  try {
    const parsedUrl = new URL(url2);
    return parsedUrl.origin;
  } catch (error) {
    return null;
  }
}
function getProtocol(url2) {
  try {
    const parsedUrl = new URL(url2);
    return parsedUrl.protocol;
  } catch (error) {
    return null;
  }
}
function getHost(url2) {
  try {
    const parsedUrl = new URL(url2);
    return parsedUrl.host;
  } catch (error) {
    return url2;
  }
}

// ../../node_modules/@better-auth/utils/dist/binary.mjs
var decoders = /* @__PURE__ */ new Map;
var encoder2 = new TextEncoder;
var binary = {
  decode: (data, encoding = "utf-8") => {
    if (!decoders.has(encoding)) {
      decoders.set(encoding, new TextDecoder(encoding));
    }
    const decoder2 = decoders.get(encoding);
    return decoder2.decode(data);
  },
  encode: encoder2.encode
};

// ../../node_modules/better-auth/dist/cookies/index.mjs
var createTime = (value, format) => {
  const toMilliseconds = () => {
    switch (format) {
      case "ms":
        return value;
      case "s":
        return value * 1000;
      case "m":
        return value * 1000 * 60;
      case "h":
        return value * 1000 * 60 * 60;
      case "d":
        return value * 1000 * 60 * 60 * 24;
      case "w":
        return value * 1000 * 60 * 60 * 24 * 7;
      case "y":
        return value * 1000 * 60 * 60 * 24 * 365;
    }
  };
  const time2 = {
    t: `${value}${format}`,
    value,
    tFormat: format,
    toMilliseconds,
    toSeconds: () => time2.toMilliseconds() / 1000,
    toMinutes: () => time2.toSeconds() / 60,
    toHours: () => time2.toMinutes() / 60,
    toDays: () => time2.toHours() / 24,
    toWeeks: () => time2.toDays() / 7,
    toYears: () => time2.toDays() / 365,
    getDate: () => new Date(Date.now() + time2.toMilliseconds()),
    add: (other) => {
      const otherMs = typeof other === "string" ? parseTime(other).toMilliseconds() : other.toMilliseconds();
      return createTime(time2.toMilliseconds() + otherMs, "ms");
    },
    subtract: (other) => {
      const otherMs = typeof other === "string" ? parseTime(other).toMilliseconds() : other.toMilliseconds();
      return createTime(time2.toMilliseconds() - otherMs, "ms");
    },
    multiply: (factor) => createTime(time2.toMilliseconds() * factor, "ms"),
    divide: (divisor) => createTime(time2.toMilliseconds() / divisor, "ms"),
    equals: (other) => {
      const otherMs = typeof other === "string" ? parseTime(other).toMilliseconds() : other.toMilliseconds();
      return time2.toMilliseconds() === otherMs;
    },
    lessThan: (other) => {
      const otherMs = typeof other === "string" ? parseTime(other).toMilliseconds() : other.toMilliseconds();
      return time2.toMilliseconds() < otherMs;
    },
    greaterThan: (other) => {
      const otherMs = typeof other === "string" ? parseTime(other).toMilliseconds() : other.toMilliseconds();
      return time2.toMilliseconds() > otherMs;
    },
    format: (pattern) => {
      const date2 = time2.getDate();
      return pattern.replace(/YYYY|MM|DD|HH|mm|ss/g, (match) => {
        switch (match) {
          case "YYYY":
            return date2.getFullYear().toString();
          case "MM":
            return (date2.getMonth() + 1).toString().padStart(2, "0");
          case "DD":
            return date2.getDate().toString().padStart(2, "0");
          case "HH":
            return date2.getHours().toString().padStart(2, "0");
          case "mm":
            return date2.getMinutes().toString().padStart(2, "0");
          case "ss":
            return date2.getSeconds().toString().padStart(2, "0");
          default:
            return match;
        }
      });
    },
    fromNow: () => {
      const ms = time2.toMilliseconds();
      if (ms < 0)
        return time2.ago();
      if (ms < 1000)
        return "in a few seconds";
      if (ms < 60000)
        return `in ${Math.round(ms / 1000)} seconds`;
      if (ms < 3600000)
        return `in ${Math.round(ms / 60000)} minutes`;
      if (ms < 86400000)
        return `in ${Math.round(ms / 3600000)} hours`;
      if (ms < 604800000)
        return `in ${Math.round(ms / 86400000)} days`;
      if (ms < 2629800000)
        return `in ${Math.round(ms / 604800000)} weeks`;
      if (ms < 31557600000)
        return `in ${Math.round(ms / 2629800000)} months`;
      return `in ${Math.round(ms / 31557600000)} years`;
    },
    ago: () => {
      const ms = -time2.toMilliseconds();
      if (ms < 0)
        return time2.fromNow();
      if (ms < 1000)
        return "a few seconds ago";
      if (ms < 60000)
        return `${Math.round(ms / 1000)} seconds ago`;
      if (ms < 3600000)
        return `${Math.round(ms / 60000)} minutes ago`;
      if (ms < 86400000)
        return `${Math.round(ms / 3600000)} hours ago`;
      if (ms < 604800000)
        return `${Math.round(ms / 86400000)} days ago`;
      if (ms < 2629800000)
        return `${Math.round(ms / 604800000)} weeks ago`;
      if (ms < 31557600000)
        return `${Math.round(ms / 2629800000)} months ago`;
      return `${Math.round(ms / 31557600000)} years ago`;
    }
  };
  return time2;
};
var parseTime = (time2) => {
  const match = time2.match(/^(\d+)(ms|s|m|h|d|w|y)$/);
  if (!match)
    throw new Error("Invalid time format");
  return createTime(parseInt(match[1]), match[2]);
};
function createCookieGetter(options) {
  const secure = options.advanced?.useSecureCookies !== undefined ? options.advanced?.useSecureCookies : options.baseURL !== undefined ? options.baseURL.startsWith("https://") ? true : false : isProduction;
  const secureCookiePrefix = secure ? "__Secure-" : "";
  const crossSubdomainEnabled = !!options.advanced?.crossSubDomainCookies?.enabled;
  const domain = crossSubdomainEnabled ? options.advanced?.crossSubDomainCookies?.domain || (options.baseURL ? new URL(options.baseURL).hostname : undefined) : undefined;
  if (crossSubdomainEnabled && !domain) {
    throw new BetterAuthError("baseURL is required when crossSubdomainCookies are enabled");
  }
  function createCookie(cookieName, overrideAttributes = {}) {
    const prefix = options.advanced?.cookiePrefix || "better-auth";
    const name = options.advanced?.cookies?.[cookieName]?.name || `${prefix}.${cookieName}`;
    const attributes = options.advanced?.cookies?.[cookieName]?.attributes;
    return {
      name: `${secureCookiePrefix}${name}`,
      attributes: {
        secure: !!secureCookiePrefix,
        sameSite: "lax",
        path: "/",
        httpOnly: true,
        ...crossSubdomainEnabled ? { domain } : {},
        ...options.advanced?.defaultCookieAttributes,
        ...overrideAttributes,
        ...attributes
      }
    };
  }
  return createCookie;
}
function getCookies(options) {
  const createCookie = createCookieGetter(options);
  const sessionMaxAge = options.session?.expiresIn || createTime(7, "d").toSeconds();
  const sessionToken = createCookie("session_token", {
    maxAge: sessionMaxAge
  });
  const sessionData = createCookie("session_data", {
    maxAge: options.session?.cookieCache?.maxAge || 60 * 5
  });
  const dontRememberToken = createCookie("dont_remember");
  return {
    sessionToken: {
      name: sessionToken.name,
      options: sessionToken.attributes
    },
    sessionData: {
      name: sessionData.name,
      options: sessionData.attributes
    },
    dontRememberToken: {
      name: dontRememberToken.name,
      options: dontRememberToken.attributes
    }
  };
}
async function setCookieCache(ctx, session) {
  const shouldStoreSessionDataInCookie = ctx.context.options.session?.cookieCache?.enabled;
  if (shouldStoreSessionDataInCookie) {
    const filteredSession = Object.entries(session.session).reduce((acc, [key, value]) => {
      const fieldConfig = ctx.context.options.session?.additionalFields?.[key];
      if (!fieldConfig || fieldConfig.returned !== false) {
        acc[key] = value;
      }
      return acc;
    }, {});
    const sessionData = { session: filteredSession, user: session.user };
    const data = base64Url.encode(JSON.stringify({
      session: sessionData,
      expiresAt: getDate(ctx.context.authCookies.sessionData.options.maxAge || 60, "sec").getTime(),
      signature: await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, JSON.stringify({
        ...sessionData,
        expiresAt: getDate(ctx.context.authCookies.sessionData.options.maxAge || 60, "sec").getTime()
      }))
    }), {
      padding: false
    });
    if (data.length > 4093) {
      throw new BetterAuthError("Session data is too large to store in the cookie. Please disable session cookie caching or reduce the size of the session data");
    }
    ctx.setCookie(ctx.context.authCookies.sessionData.name, data, ctx.context.authCookies.sessionData.options);
  }
}
async function setSessionCookie(ctx, session, dontRememberMe, overrides) {
  const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
  dontRememberMe = dontRememberMe !== undefined ? dontRememberMe : !!dontRememberMeCookie;
  const options = ctx.context.authCookies.sessionToken.options;
  const maxAge = dontRememberMe ? undefined : ctx.context.sessionConfig.expiresIn;
  await ctx.setSignedCookie(ctx.context.authCookies.sessionToken.name, session.session.token, ctx.context.secret, {
    ...options,
    maxAge,
    ...overrides
  });
  if (dontRememberMe) {
    await ctx.setSignedCookie(ctx.context.authCookies.dontRememberToken.name, "true", ctx.context.secret, ctx.context.authCookies.dontRememberToken.options);
  }
  await setCookieCache(ctx, session);
  ctx.context.setNewSession(session);
  if (ctx.context.options.secondaryStorage) {
    await ctx.context.secondaryStorage?.set(session.session.token, JSON.stringify({
      user: session.user,
      session: session.session
    }), Math.floor((new Date(session.session.expiresAt).getTime() - Date.now()) / 1000));
  }
}
function deleteSessionCookie(ctx, skipDontRememberMe) {
  ctx.setCookie(ctx.context.authCookies.sessionToken.name, "", {
    ...ctx.context.authCookies.sessionToken.options,
    maxAge: 0
  });
  ctx.setCookie(ctx.context.authCookies.sessionData.name, "", {
    ...ctx.context.authCookies.sessionData.options,
    maxAge: 0
  });
  if (!skipDontRememberMe) {
    ctx.setCookie(ctx.context.authCookies.dontRememberToken.name, "", {
      ...ctx.context.authCookies.dontRememberToken.options,
      maxAge: 0
    });
  }
}

// ../../node_modules/better-auth/dist/shared/better-auth.dn8_oqOu.mjs
async function generateState(c, link) {
  const callbackURL = c.body?.callbackURL || c.context.options.baseURL;
  if (!callbackURL) {
    throw new APIError("BAD_REQUEST", {
      message: "callbackURL is required"
    });
  }
  const codeVerifier = generateRandomString(128);
  const state = generateRandomString(32);
  const data = JSON.stringify({
    callbackURL,
    codeVerifier,
    errorURL: c.body?.errorCallbackURL,
    newUserURL: c.body?.newUserCallbackURL,
    link,
    expiresAt: Date.now() + 10 * 60 * 1000,
    requestSignUp: c.body?.requestSignUp
  });
  const expiresAt = /* @__PURE__ */ new Date;
  expiresAt.setMinutes(expiresAt.getMinutes() + 10);
  const verification = await c.context.internalAdapter.createVerificationValue({
    value: data,
    identifier: state,
    expiresAt
  }, c);
  if (!verification) {
    c.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database");
    throw new APIError("INTERNAL_SERVER_ERROR", {
      message: "Unable to create verification"
    });
  }
  return {
    state: verification.identifier,
    codeVerifier
  };
}
async function parseState(c) {
  const state = c.query.state || c.body.state;
  const data = await c.context.internalAdapter.findVerificationValue(state);
  if (!data) {
    c.context.logger.error("State Mismatch. Verification not found", {
      state
    });
    throw c.redirect(`${c.context.baseURL}/error?error=please_restart_the_process`);
  }
  const parsedData = exports_external.object({
    callbackURL: exports_external.string(),
    codeVerifier: exports_external.string(),
    errorURL: exports_external.string().optional(),
    newUserURL: exports_external.string().optional(),
    expiresAt: exports_external.number(),
    link: exports_external.object({
      email: exports_external.string(),
      userId: exports_external.coerce.string()
    }).optional(),
    requestSignUp: exports_external.boolean().optional()
  }).parse(JSON.parse(data.value));
  if (!parsedData.errorURL) {
    parsedData.errorURL = `${c.context.baseURL}/error`;
  }
  if (parsedData.expiresAt < Date.now()) {
    await c.context.internalAdapter.deleteVerificationValue(data.id);
    throw c.redirect(`${c.context.baseURL}/error?error=please_restart_the_process`);
  }
  await c.context.internalAdapter.deleteVerificationValue(data.id);
  return parsedData;
}

// ../../node_modules/@better-fetch/fetch/dist/index.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var BetterFetchError = class extends Error {
  constructor(status, statusText, error) {
    super(statusText || status.toString(), {
      cause: error
    });
    this.status = status;
    this.statusText = statusText;
    this.error = error;
  }
};
var initializePlugins = async (url2, options) => {
  var _a, _b, _c, _d, _e, _f;
  let opts = options || {};
  const hooks = {
    onRequest: [options == null ? undefined : options.onRequest],
    onResponse: [options == null ? undefined : options.onResponse],
    onSuccess: [options == null ? undefined : options.onSuccess],
    onError: [options == null ? undefined : options.onError],
    onRetry: [options == null ? undefined : options.onRetry]
  };
  if (!options || !(options == null ? undefined : options.plugins)) {
    return {
      url: url2,
      options: opts,
      hooks
    };
  }
  for (const plugin of (options == null ? undefined : options.plugins) || []) {
    if (plugin.init) {
      const pluginRes = await ((_a = plugin.init) == null ? undefined : _a.call(plugin, url2.toString(), options));
      opts = pluginRes.options || opts;
      url2 = pluginRes.url;
    }
    hooks.onRequest.push((_b = plugin.hooks) == null ? undefined : _b.onRequest);
    hooks.onResponse.push((_c = plugin.hooks) == null ? undefined : _c.onResponse);
    hooks.onSuccess.push((_d = plugin.hooks) == null ? undefined : _d.onSuccess);
    hooks.onError.push((_e = plugin.hooks) == null ? undefined : _e.onError);
    hooks.onRetry.push((_f = plugin.hooks) == null ? undefined : _f.onRetry);
  }
  return {
    url: url2,
    options: opts,
    hooks
  };
};
var LinearRetryStrategy = class {
  constructor(options) {
    this.options = options;
  }
  shouldAttemptRetry(attempt, response) {
    if (this.options.shouldRetry) {
      return Promise.resolve(attempt < this.options.attempts && this.options.shouldRetry(response));
    }
    return Promise.resolve(attempt < this.options.attempts);
  }
  getDelay() {
    return this.options.delay;
  }
};
var ExponentialRetryStrategy = class {
  constructor(options) {
    this.options = options;
  }
  shouldAttemptRetry(attempt, response) {
    if (this.options.shouldRetry) {
      return Promise.resolve(attempt < this.options.attempts && this.options.shouldRetry(response));
    }
    return Promise.resolve(attempt < this.options.attempts);
  }
  getDelay(attempt) {
    const delay = Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** attempt);
    return delay;
  }
};
function createRetryStrategy(options) {
  if (typeof options === "number") {
    return new LinearRetryStrategy({
      type: "linear",
      attempts: options,
      delay: 1000
    });
  }
  switch (options.type) {
    case "linear":
      return new LinearRetryStrategy(options);
    case "exponential":
      return new ExponentialRetryStrategy(options);
    default:
      throw new Error("Invalid retry strategy");
  }
}
var getAuthHeader = async (options) => {
  const headers = {};
  const getValue = async (value) => typeof value === "function" ? await value() : value;
  if (options == null ? undefined : options.auth) {
    if (options.auth.type === "Bearer") {
      const token = await getValue(options.auth.token);
      if (!token) {
        return headers;
      }
      headers["authorization"] = `Bearer ${token}`;
    } else if (options.auth.type === "Basic") {
      const username = getValue(options.auth.username);
      const password = getValue(options.auth.password);
      if (!username || !password) {
        return headers;
      }
      headers["authorization"] = `Basic ${btoa(`${username}:${password}`)}`;
    } else if (options.auth.type === "Custom") {
      const value = getValue(options.auth.value);
      if (!value) {
        return headers;
      }
      headers["authorization"] = `${getValue(options.auth.prefix)} ${value}`;
    }
  }
  return headers;
};
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(request) {
  const _contentType = request.headers.get("content-type");
  const textTypes = /* @__PURE__ */ new Set([
    "image/svg",
    "application/xml",
    "application/xhtml",
    "application/html"
  ]);
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function isJSONParsable(value) {
  try {
    JSON.parse(value);
    return true;
  } catch (error) {
    return false;
  }
}
function isJSONSerializable2(value) {
  if (value === undefined) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
function jsonParse(text2) {
  try {
    return JSON.parse(text2);
  } catch (error) {
    return text2;
  }
}
function isFunction2(value) {
  return typeof value === "function";
}
function getFetch(options) {
  if (options == null ? undefined : options.customFetchImpl) {
    return options.customFetchImpl;
  }
  if (typeof globalThis !== "undefined" && isFunction2(globalThis.fetch)) {
    return globalThis.fetch;
  }
  if (typeof window !== "undefined" && isFunction2(window.fetch)) {
    return window.fetch;
  }
  throw new Error("No fetch implementation found");
}
async function getHeaders(opts) {
  const headers = new Headers(opts == null ? undefined : opts.headers);
  const authHeader = await getAuthHeader(opts);
  for (const [key, value] of Object.entries(authHeader || {})) {
    headers.set(key, value);
  }
  if (!headers.has("content-type")) {
    const t = detectContentType(opts == null ? undefined : opts.body);
    if (t) {
      headers.set("content-type", t);
    }
  }
  return headers;
}
function detectContentType(body) {
  if (isJSONSerializable2(body)) {
    return "application/json";
  }
  return null;
}
function getBody2(options) {
  if (!(options == null ? undefined : options.body)) {
    return null;
  }
  const headers = new Headers(options == null ? undefined : options.headers);
  if (isJSONSerializable2(options.body) && !headers.has("content-type")) {
    for (const [key, value] of Object.entries(options == null ? undefined : options.body)) {
      if (value instanceof Date) {
        options.body[key] = value.toISOString();
      }
    }
    return JSON.stringify(options.body);
  }
  return options.body;
}
function getMethod(url2, options) {
  var _a;
  if (options == null ? undefined : options.method) {
    return options.method.toUpperCase();
  }
  if (url2.startsWith("@")) {
    const pMethod = (_a = url2.split("@")[1]) == null ? undefined : _a.split("/")[0];
    if (!methods.includes(pMethod)) {
      return (options == null ? undefined : options.body) ? "POST" : "GET";
    }
    return pMethod.toUpperCase();
  }
  return (options == null ? undefined : options.body) ? "POST" : "GET";
}
function getTimeout(options, controller) {
  let abortTimeout;
  if (!(options == null ? undefined : options.signal) && (options == null ? undefined : options.timeout)) {
    abortTimeout = setTimeout(() => controller == null ? undefined : controller.abort(), options == null ? undefined : options.timeout);
  }
  return {
    abortTimeout,
    clearTimeout: () => {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
  };
}
var ValidationError = class _ValidationError extends Error {
  constructor(issues, message2) {
    super(message2 || JSON.stringify(issues, null, 2));
    this.issues = issues;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
async function parseStandardSchema(schema, input) {
  let result = await schema["~standard"].validate(input);
  if (result.issues) {
    throw new ValidationError(result.issues);
  }
  return result.value;
}
var methods = ["get", "post", "put", "patch", "delete"];
function getURL2(url2, option) {
  let { baseURL, params, query } = option || {
    query: {},
    params: {},
    baseURL: ""
  };
  let basePath = url2.startsWith("http") ? url2.split("/").slice(0, 3).join("/") : baseURL || "";
  if (url2.startsWith("@")) {
    const m = url2.toString().split("@")[1].split("/")[0];
    if (methods.includes(m)) {
      url2 = url2.replace(`@${m}/`, "/");
    }
  }
  if (!basePath.endsWith("/"))
    basePath += "/";
  let [path, urlQuery] = url2.replace(basePath, "").split("?");
  const queryParams = new URLSearchParams(urlQuery);
  for (const [key, value] of Object.entries(query || {})) {
    if (value == null)
      continue;
    queryParams.set(key, String(value));
  }
  if (params) {
    if (Array.isArray(params)) {
      const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
      for (const [index, key] of paramPaths.entries()) {
        const value = params[index];
        path = path.replace(key, value);
      }
    } else {
      for (const [key, value] of Object.entries(params)) {
        path = path.replace(`:${key}`, String(value));
      }
    }
  }
  path = path.split("/").map(encodeURIComponent).join("/");
  if (path.startsWith("/"))
    path = path.slice(1);
  let queryParamString = queryParams.toString();
  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
  if (!basePath.startsWith("http")) {
    return `${basePath}${path}${queryParamString}`;
  }
  const _url = new URL(`${path}${queryParamString}`, basePath);
  return _url;
}
var betterFetch = async (url2, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const {
    hooks,
    url: __url,
    options: opts
  } = await initializePlugins(url2, options);
  const fetch2 = getFetch(opts);
  const controller = new AbortController;
  const signal = (_a = opts.signal) != null ? _a : controller.signal;
  const _url = getURL2(__url, opts);
  const body = getBody2(opts);
  const headers = await getHeaders(opts);
  const method = getMethod(__url, opts);
  let context = __spreadProps(__spreadValues({}, opts), {
    url: _url,
    headers,
    body,
    method,
    signal
  });
  for (const onRequest of hooks.onRequest) {
    if (onRequest) {
      const res = await onRequest(context);
      if (res instanceof Object) {
        context = res;
      }
    }
  }
  if ("pipeTo" in context && typeof context.pipeTo === "function" || typeof ((_b = options == null ? undefined : options.body) == null ? undefined : _b.pipe) === "function") {
    if (!("duplex" in context)) {
      context.duplex = "half";
    }
  }
  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);
  let response = await fetch2(context.url, context);
  clearTimeout2();
  const responseContext = {
    response,
    request: context
  };
  for (const onResponse of hooks.onResponse) {
    if (onResponse) {
      const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), {
        response: ((_c = options == null ? undefined : options.hookOptions) == null ? undefined : _c.cloneResponse) ? response.clone() : response
      }));
      if (r instanceof Response) {
        response = r;
      } else if (r instanceof Object) {
        response = r.response;
      }
    }
  }
  if (response.ok) {
    const hasBody = context.method !== "HEAD";
    if (!hasBody) {
      return {
        data: "",
        error: null
      };
    }
    const responseType = detectResponseType(response);
    const successContext = {
      data: "",
      response,
      request: context
    };
    if (responseType === "json" || responseType === "text") {
      const text2 = await response.text();
      const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;
      const data = await parser2(text2);
      successContext.data = data;
    } else {
      successContext.data = await response[responseType]();
    }
    if (context == null ? undefined : context.output) {
      if (context.output && !context.disableValidation) {
        successContext.data = await parseStandardSchema(context.output, successContext.data);
      }
    }
    for (const onSuccess of hooks.onSuccess) {
      if (onSuccess) {
        await onSuccess(__spreadProps(__spreadValues({}, successContext), {
          response: ((_e = options == null ? undefined : options.hookOptions) == null ? undefined : _e.cloneResponse) ? response.clone() : response
        }));
      }
    }
    if (options == null ? undefined : options.throw) {
      return successContext.data;
    }
    return {
      data: successContext.data,
      error: null
    };
  }
  const parser = (_f = options == null ? undefined : options.jsonParser) != null ? _f : jsonParse;
  const responseText = await response.text();
  const isJSONResponse = isJSONParsable(responseText);
  const errorObject = isJSONResponse ? await parser(responseText) : null;
  const errorContext = {
    response,
    responseText,
    request: context,
    error: __spreadProps(__spreadValues({}, errorObject), {
      status: response.status,
      statusText: response.statusText
    })
  };
  for (const onError of hooks.onError) {
    if (onError) {
      await onError(__spreadProps(__spreadValues({}, errorContext), {
        response: ((_g = options == null ? undefined : options.hookOptions) == null ? undefined : _g.cloneResponse) ? response.clone() : response
      }));
    }
  }
  if (options == null ? undefined : options.retry) {
    const retryStrategy = createRetryStrategy(options.retry);
    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;
    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {
      for (const onRetry of hooks.onRetry) {
        if (onRetry) {
          await onRetry(responseContext);
        }
      }
      const delay = retryStrategy.getDelay(_retryAttempt);
      await new Promise((resolve) => setTimeout(resolve, delay));
      return await betterFetch(url2, __spreadProps(__spreadValues({}, options), {
        retryAttempt: _retryAttempt + 1
      }));
    }
  }
  if (options == null ? undefined : options.throw) {
    throw new BetterFetchError(response.status, response.statusText, isJSONResponse ? errorObject : responseText);
  }
  return {
    data: null,
    error: __spreadProps(__spreadValues({}, errorObject), {
      status: response.status,
      statusText: response.statusText
    })
  };
};

// ../../node_modules/better-auth/dist/shared/better-auth.DufyW0qf.mjs
async function generateCodeChallenge(codeVerifier) {
  const codeChallengeBytes = await createHash("SHA-256").digest(codeVerifier);
  return base64Url.encode(new Uint8Array(codeChallengeBytes), {
    padding: false
  });
}
function getOAuth2Tokens(data) {
  return {
    tokenType: data.token_type,
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    accessTokenExpiresAt: data.expires_in ? getDate(data.expires_in, "sec") : undefined,
    scopes: data?.scope ? typeof data.scope === "string" ? data.scope.split(" ") : data.scope : [],
    idToken: data.id_token
  };
}
async function createAuthorizationURL({
  id,
  options,
  authorizationEndpoint,
  state,
  codeVerifier,
  scopes,
  claims,
  redirectURI,
  duration,
  prompt,
  accessType,
  responseType,
  display,
  loginHint,
  hd,
  responseMode,
  additionalParams,
  scopeJoiner
}) {
  const url2 = new URL(authorizationEndpoint);
  url2.searchParams.set("response_type", responseType || "code");
  url2.searchParams.set("client_id", options.clientId);
  url2.searchParams.set("state", state);
  url2.searchParams.set("scope", scopes.join(scopeJoiner || " "));
  url2.searchParams.set("redirect_uri", options.redirectURI || redirectURI);
  duration && url2.searchParams.set("duration", duration);
  display && url2.searchParams.set("display", display);
  loginHint && url2.searchParams.set("login_hint", loginHint);
  prompt && url2.searchParams.set("prompt", prompt);
  hd && url2.searchParams.set("hd", hd);
  accessType && url2.searchParams.set("access_type", accessType);
  responseMode && url2.searchParams.set("response_mode", responseMode);
  if (codeVerifier) {
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    url2.searchParams.set("code_challenge_method", "S256");
    url2.searchParams.set("code_challenge", codeChallenge);
  }
  if (claims) {
    const claimsObj = claims.reduce((acc, claim) => {
      acc[claim] = null;
      return acc;
    }, {});
    url2.searchParams.set("claims", JSON.stringify({
      id_token: { email: null, email_verified: null, ...claimsObj }
    }));
  }
  if (additionalParams) {
    Object.entries(additionalParams).forEach(([key, value]) => {
      url2.searchParams.set(key, value);
    });
  }
  return url2;
}
async function validateAuthorizationCode({
  code,
  codeVerifier,
  redirectURI,
  options,
  tokenEndpoint,
  authentication,
  deviceId,
  headers
}) {
  const body = new URLSearchParams;
  const requestHeaders = {
    "content-type": "application/x-www-form-urlencoded",
    accept: "application/json",
    "user-agent": "better-auth",
    ...headers
  };
  body.set("grant_type", "authorization_code");
  body.set("code", code);
  codeVerifier && body.set("code_verifier", codeVerifier);
  options.clientKey && body.set("client_key", options.clientKey);
  deviceId && body.set("device_id", deviceId);
  body.set("redirect_uri", options.redirectURI || redirectURI);
  if (authentication === "basic") {
    const encodedCredentials = base64Url.encode(`${options.clientId}:${options.clientSecret}`);
    requestHeaders["authorization"] = `Basic ${encodedCredentials}`;
  } else {
    body.set("client_id", options.clientId);
    body.set("client_secret", options.clientSecret);
  }
  const { data, error } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers: requestHeaders
  });
  if (error) {
    throw error;
  }
  const tokens = getOAuth2Tokens(data);
  return tokens;
}
async function refreshAccessToken({
  refreshToken,
  options,
  tokenEndpoint,
  authentication,
  extraParams,
  grantType = "refresh_token"
}) {
  const body = new URLSearchParams;
  const headers = {
    "content-type": "application/x-www-form-urlencoded",
    accept: "application/json"
  };
  body.set("grant_type", grantType);
  body.set("refresh_token", refreshToken);
  if (authentication === "basic") {
    const encodedCredentials = base64Url.encode(`${options.clientId}:${options.clientSecret}`);
    headers["authorization"] = `Basic ${encodedCredentials}`;
  } else {
    body.set("client_id", options.clientId);
    body.set("client_secret", options.clientSecret);
  }
  if (extraParams) {
    for (const [key, value] of Object.entries(extraParams)) {
      body.set(key, value);
    }
  }
  const { data, error } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers
  });
  if (error) {
    throw error;
  }
  const tokens = {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    tokenType: data.token_type,
    scopes: data.scope?.split(" "),
    idToken: data.id_token
  };
  if (data.expires_in) {
    const now = /* @__PURE__ */ new Date;
    tokens.accessTokenExpiresAt = new Date(now.getTime() + data.expires_in * 1000);
  }
  return tokens;
}

// ../../node_modules/better-auth/dist/social-providers/index.mjs
var apple = (options) => {
  const tokenEndpoint = "https://appleid.apple.com/auth/token";
  return {
    id: "apple",
    name: "Apple",
    async createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scope = options.disableDefaultScope ? [] : ["email", "name"];
      options.scope && _scope.push(...options.scope);
      scopes && _scope.push(...scopes);
      const url2 = await createAuthorizationURL({
        id: "apple",
        options,
        authorizationEndpoint: "https://appleid.apple.com/auth/authorize",
        scopes: _scope,
        state,
        redirectURI,
        responseMode: "form_post",
        responseType: "code id_token"
      });
      return url2;
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    async verifyIdToken(token, nonce) {
      if (options.disableIdTokenSignIn) {
        return false;
      }
      if (options.verifyIdToken) {
        return options.verifyIdToken(token, nonce);
      }
      const decodedHeader = decodeProtectedHeader(token);
      const { kid, alg: jwtAlg } = decodedHeader;
      if (!kid || !jwtAlg)
        return false;
      const publicKey = await getApplePublicKey(kid);
      const { payload: jwtClaims } = await jwtVerify(token, publicKey, {
        algorithms: [jwtAlg],
        issuer: "https://appleid.apple.com",
        audience: options.appBundleIdentifier || options.clientId,
        maxTokenAge: "1h"
      });
      ["email_verified", "is_private_email"].forEach((field) => {
        if (jwtClaims[field] !== undefined) {
          jwtClaims[field] = Boolean(jwtClaims[field]);
        }
      });
      if (nonce && jwtClaims.nonce !== nonce) {
        return false;
      }
      return !!jwtClaims;
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://appleid.apple.com/auth/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      if (!token.idToken) {
        return null;
      }
      const profile = decodeJwt(token.idToken);
      if (!profile) {
        return null;
      }
      const name = token.user ? `${token.user.name?.firstName} ${token.user.name?.lastName}` : profile.name || profile.email;
      const emailVerified = typeof profile.email_verified === "boolean" ? profile.email_verified : profile.email_verified === "true";
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name,
          emailVerified,
          email: profile.email,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var getApplePublicKey = async (kid) => {
  const APPLE_BASE_URL = "https://appleid.apple.com";
  const JWKS_APPLE_URI = "/auth/keys";
  const { data } = await betterFetch(`${APPLE_BASE_URL}${JWKS_APPLE_URI}`);
  if (!data?.keys) {
    throw new APIError("BAD_REQUEST", {
      message: "Keys not found"
    });
  }
  const jwk = data.keys.find((key) => key.kid === kid);
  if (!jwk) {
    throw new Error(`JWK with kid ${kid} not found`);
  }
  return await importJWK(jwk, jwk.alg);
};
var discord = (options) => {
  return {
    id: "discord",
    name: "Discord",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["identify", "email"];
      scopes && _scopes.push(...scopes);
      options.scope && _scopes.push(...options.scope);
      return new URL(`https://discord.com/api/oauth2/authorize?scope=${_scopes.join("+")}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}&prompt=${options.prompt || "none"}`);
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://discord.com/api/users/@me", {
        headers: {
          authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      if (profile.avatar === null) {
        const defaultAvatarNumber = profile.discriminator === "0" ? Number(BigInt(profile.id) >> BigInt(22)) % 6 : parseInt(profile.discriminator) % 5;
        profile.image_url = `https://cdn.discordapp.com/embed/avatars/${defaultAvatarNumber}.png`;
      } else {
        const format = profile.avatar.startsWith("a_") ? "gif" : "png";
        profile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format}`;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.global_name || profile.username || "",
          email: profile.email,
          emailVerified: profile.verified,
          image: profile.image_url,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var facebook = (options) => {
  return {
    id: "facebook",
    name: "Facebook",
    async createAuthorizationURL({ state, scopes, redirectURI, loginHint }) {
      const _scopes = options.disableDefaultScope ? [] : ["email", "public_profile"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "facebook",
        options,
        authorizationEndpoint: "https://www.facebook.com/v21.0/dialog/oauth",
        scopes: _scopes,
        state,
        redirectURI,
        loginHint,
        additionalParams: options.configId ? {
          config_id: options.configId
        } : {}
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://graph.facebook.com/oauth/access_token"
      });
    },
    async verifyIdToken(token, nonce) {
      if (options.disableIdTokenSignIn) {
        return false;
      }
      if (options.verifyIdToken) {
        return options.verifyIdToken(token, nonce);
      }
      if (token.split(".").length) {
        try {
          const { payload: jwtClaims } = await jwtVerify(token, createRemoteJWKSet(new URL("https://www.facebook.com/.well-known/oauth/openid/jwks")), {
            algorithms: ["RS256"],
            audience: options.clientId,
            issuer: "https://www.facebook.com"
          });
          if (nonce && jwtClaims.nonce !== nonce) {
            return false;
          }
          return !!jwtClaims;
        } catch (error) {
          return false;
        }
      }
      return true;
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://graph.facebook.com/v18.0/oauth/access_token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      if (token.idToken) {
        const profile2 = decodeJwt(token.idToken);
        const user = {
          id: profile2.sub,
          name: profile2.name,
          email: profile2.email,
          picture: {
            data: {
              url: profile2.picture,
              height: 100,
              width: 100,
              is_silhouette: false
            }
          }
        };
        const userMap2 = await options.mapProfileToUser?.({
          ...user,
          email_verified: true
        });
        return {
          user: {
            ...user,
            emailVerified: true,
            ...userMap2
          },
          data: profile2
        };
      }
      const fields = [
        "id",
        "name",
        "email",
        "picture",
        ...options?.fields || []
      ];
      const { data: profile, error } = await betterFetch("https://graph.facebook.com/me?fields=" + fields.join(","), {
        auth: {
          type: "Bearer",
          token: token.accessToken
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          image: profile.picture.data.url,
          emailVerified: profile.email_verified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var github = (options) => {
  const tokenEndpoint = "https://github.com/login/oauth/access_token";
  return {
    id: "github",
    name: "GitHub",
    createAuthorizationURL({ state, scopes, loginHint, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["read:user", "user:email"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "github",
        options,
        authorizationEndpoint: "https://github.com/login/oauth/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        loginHint,
        prompt: options.prompt
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://github.com/login/oauth/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://api.github.com/user", {
        headers: {
          "User-Agent": "better-auth",
          authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const { data: emails } = await betterFetch("https://api.github.com/user/emails", {
        headers: {
          Authorization: `Bearer ${token.accessToken}`,
          "User-Agent": "better-auth"
        }
      });
      if (!profile.email && emails) {
        profile.email = (emails.find((e) => e.primary) ?? emails[0])?.email;
      }
      const emailVerified = emails?.find((e) => e.email === profile.email)?.verified ?? false;
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id.toString(),
          name: profile.name || profile.login,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var google = (options) => {
  return {
    id: "google",
    name: "Google",
    async createAuthorizationURL({
      state,
      scopes,
      codeVerifier,
      redirectURI,
      loginHint,
      display
    }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error("Client Id and Client Secret is required for Google. Make sure to provide them in the options.");
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) {
        throw new BetterAuthError("codeVerifier is required for Google");
      }
      const _scopes = options.disableDefaultScope ? [] : ["email", "profile", "openid"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      const url2 = await createAuthorizationURL({
        id: "google",
        options,
        authorizationEndpoint: "https://accounts.google.com/o/oauth2/auth",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI,
        prompt: options.prompt,
        accessType: options.accessType,
        display: display || options.display,
        loginHint,
        hd: options.hd
      });
      return url2;
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://oauth2.googleapis.com/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://www.googleapis.com/oauth2/v4/token"
      });
    },
    async verifyIdToken(token, nonce) {
      if (options.disableIdTokenSignIn) {
        return false;
      }
      if (options.verifyIdToken) {
        return options.verifyIdToken(token, nonce);
      }
      const googlePublicKeyUrl = `https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${token}`;
      const { data: tokenInfo } = await betterFetch(googlePublicKeyUrl);
      if (!tokenInfo) {
        return false;
      }
      const isValid3 = tokenInfo.aud === options.clientId && (tokenInfo.iss === "https://accounts.google.com" || tokenInfo.iss === "accounts.google.com");
      return isValid3;
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      if (!token.idToken) {
        return null;
      }
      const user = decodeJwt(token.idToken);
      const userMap = await options.mapProfileToUser?.(user);
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified: user.email_verified,
          ...userMap
        },
        data: user
      };
    },
    options
  };
};
var microsoft = (options) => {
  const tenant = options.tenantId || "common";
  const authorizationEndpoint = `https://login.microsoftonline.com/${tenant}/oauth2/v2.0/authorize`;
  const tokenEndpoint = `https://login.microsoftonline.com/${tenant}/oauth2/v2.0/token`;
  return {
    id: "microsoft",
    name: "Microsoft EntraID",
    createAuthorizationURL(data) {
      const scopes = options.disableDefaultScope ? [] : ["openid", "profile", "email", "User.Read", "offline_access"];
      options.scope && scopes.push(...options.scope);
      data.scopes && scopes.push(...scopes);
      return createAuthorizationURL({
        id: "microsoft",
        options,
        authorizationEndpoint,
        state: data.state,
        codeVerifier: data.codeVerifier,
        scopes,
        redirectURI: data.redirectURI,
        prompt: options.prompt
      });
    },
    validateAuthorizationCode({ code, codeVerifier, redirectURI }) {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      if (!token.idToken) {
        return null;
      }
      const user = decodeJwt(token.idToken);
      const profilePhotoSize = options.profilePhotoSize || 48;
      await betterFetch(`https://graph.microsoft.com/v1.0/me/photos/${profilePhotoSize}x${profilePhotoSize}/$value`, {
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        },
        async onResponse(context) {
          if (options.disableProfilePhoto || !context.response.ok) {
            return;
          }
          try {
            const response = context.response.clone();
            const pictureBuffer = await response.arrayBuffer();
            const pictureBase64 = base64.encode(pictureBuffer);
            user.picture = `data:image/jpeg;base64, ${pictureBase64}`;
          } catch (e) {
            logger.error(e && typeof e === "object" && "name" in e ? e.name : "", e);
          }
        }
      });
      const userMap = await options.mapProfileToUser?.(user);
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified: true,
          ...userMap
        },
        data: user
      };
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      const scopes = options.disableDefaultScope ? [] : ["openid", "profile", "email", "User.Read", "offline_access"];
      options.scope && scopes.push(...options.scope);
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientSecret: options.clientSecret
        },
        extraParams: {
          scope: scopes.join(" ")
        },
        tokenEndpoint
      });
    },
    options
  };
};
var spotify = (options) => {
  return {
    id: "spotify",
    name: "Spotify",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["user-read-email"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "spotify",
        options,
        authorizationEndpoint: "https://accounts.spotify.com/authorize",
        scopes: _scopes,
        state,
        codeVerifier,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://api.spotify.com/v1/me", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          email: profile.email,
          image: profile.images[0]?.url,
          emailVerified: false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var twitch = (options) => {
  return {
    id: "twitch",
    name: "Twitch",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["user:read:email", "openid"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "twitch",
        redirectURI,
        options,
        authorizationEndpoint: "https://id.twitch.tv/oauth2/authorize",
        scopes: _scopes,
        state,
        claims: options.claims || [
          "email",
          "email_verified",
          "preferred_username",
          "picture"
        ]
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const idToken = token.idToken;
      if (!idToken) {
        logger.error("No idToken found in token");
        return null;
      }
      const profile = decodeJwt(idToken);
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var twitter = (options) => {
  return {
    id: "twitter",
    name: "Twitter",
    createAuthorizationURL(data) {
      const _scopes = options.disableDefaultScope ? [] : ["users.read", "tweet.read", "offline.access", "users.email"];
      options.scope && _scopes.push(...options.scope);
      data.scopes && _scopes.push(...data.scopes);
      return createAuthorizationURL({
        id: "twitter",
        options,
        authorizationEndpoint: "https://x.com/i/oauth2/authorize",
        scopes: _scopes,
        state: data.state,
        codeVerifier: data.codeVerifier,
        redirectURI: data.redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        authentication: "basic",
        redirectURI,
        options,
        tokenEndpoint: "https://api.x.com/2/oauth2/token"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://api.x.com/2/oauth2/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error: profileError } = await betterFetch("https://api.x.com/2/users/me?user.fields=profile_image_url", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        }
      });
      if (profileError) {
        return null;
      }
      const { data: emailData, error: emailError } = await betterFetch("https://api.x.com/2/users/me?user.fields=confirmed_email", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        }
      });
      if (!emailError && emailData?.data?.confirmed_email) {
        profile.data.email = emailData.data.confirmed_email;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.data.id,
          name: profile.data.name,
          email: profile.data.email || profile.data.username || null,
          image: profile.data.profile_image_url,
          emailVerified: profile.data.verified || false,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var dropbox = (options) => {
  const tokenEndpoint = "https://api.dropboxapi.com/oauth2/token";
  return {
    id: "dropbox",
    name: "Dropbox",
    createAuthorizationURL: async ({
      state,
      scopes,
      codeVerifier,
      redirectURI
    }) => {
      const _scopes = options.disableDefaultScope ? [] : ["account_info.read"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "dropbox",
        options,
        authorizationEndpoint: "https://www.dropbox.com/oauth2/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        codeVerifier
      });
    },
    validateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {
      return await validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://api.dropbox.com/oauth2/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://api.dropboxapi.com/2/users/get_current_account", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.account_id,
          name: profile.name?.display_name,
          email: profile.email,
          emailVerified: profile.email_verified || false,
          image: profile.profile_photo_url,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var linkedin = (options) => {
  const authorizationEndpoint = "https://www.linkedin.com/oauth/v2/authorization";
  const tokenEndpoint = "https://www.linkedin.com/oauth/v2/accessToken";
  return {
    id: "linkedin",
    name: "Linkedin",
    createAuthorizationURL: async ({
      state,
      scopes,
      redirectURI,
      loginHint
    }) => {
      const _scopes = options.disableDefaultScope ? [] : ["profile", "email", "openid"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: "linkedin",
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        loginHint,
        redirectURI
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return await validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://api.linkedin.com/v2/userinfo", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.name,
          email: profile.email,
          emailVerified: profile.email_verified || false,
          image: profile.picture,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var cleanDoubleSlashes = (input = "") => {
  return input.split("://").map((str) => str.replace(/\/{2,}/g, "/")).join("://");
};
var issuerToEndpoints = (issuer) => {
  let baseUrl = issuer || "https://gitlab.com";
  return {
    authorizationEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/authorize`),
    tokenEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/token`),
    userinfoEndpoint: cleanDoubleSlashes(`${baseUrl}/api/v4/user`)
  };
};
var gitlab = (options) => {
  const { authorizationEndpoint, tokenEndpoint, userinfoEndpoint } = issuerToEndpoints(options.issuer);
  const issuerId = "gitlab";
  const issuerName = "Gitlab";
  return {
    id: issuerId,
    name: issuerName,
    createAuthorizationURL: async ({
      state,
      scopes,
      codeVerifier,
      loginHint,
      redirectURI
    }) => {
      const _scopes = options.disableDefaultScope ? [] : ["read_user"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return await createAuthorizationURL({
        id: issuerId,
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        redirectURI,
        codeVerifier,
        loginHint
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        codeVerifier,
        tokenEndpoint
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://gitlab.com/oauth/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch(userinfoEndpoint, { headers: { authorization: `Bearer ${token.accessToken}` } });
      if (error || profile.state !== "active" || profile.locked) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id.toString(),
          name: profile.name ?? profile.username,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified: true,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var tiktok = (options) => {
  return {
    id: "tiktok",
    name: "TikTok",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["user.info.profile"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return new URL(`https://www.tiktok.com/v2/auth/authorize?scope=${_scopes.join(",")}&response_type=code&client_key=${options.clientKey}&client_secret=${options.clientSecret}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}`);
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI: options.redirectURI || redirectURI,
        options,
        tokenEndpoint: "https://open.tiktokapis.com/v2/oauth/token/"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://open.tiktokapis.com/v2/oauth/token/"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const fields = [
        "open_id",
        "avatar_large_url",
        "display_name",
        "username"
      ];
      const { data: profile, error } = await betterFetch(`https://open.tiktokapis.com/v2/user/info/?fields=${fields.join(",")}`, {
        headers: {
          authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      return {
        user: {
          email: profile.data.user.email || profile.data.user.username,
          id: profile.data.user.open_id,
          name: profile.data.user.display_name || profile.data.user.username,
          image: profile.data.user.avatar_large_url,
          emailVerified: profile.data.user.email ? true : false
        },
        data: profile
      };
    },
    options
  };
};
var reddit = (options) => {
  return {
    id: "reddit",
    name: "Reddit",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["identity"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "reddit",
        options,
        authorizationEndpoint: "https://www.reddit.com/api/v1/authorize",
        scopes: _scopes,
        state,
        redirectURI,
        duration: options.duration
      });
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      const body = new URLSearchParams({
        grant_type: "authorization_code",
        code,
        redirect_uri: options.redirectURI || redirectURI
      });
      const headers = {
        "content-type": "application/x-www-form-urlencoded",
        accept: "text/plain",
        "user-agent": "better-auth",
        Authorization: `Basic ${base64.encode(`${options.clientId}:${options.clientSecret}`)}`
      };
      const { data, error } = await betterFetch("https://www.reddit.com/api/v1/access_token", {
        method: "POST",
        headers,
        body: body.toString()
      });
      if (error) {
        throw error;
      }
      return getOAuth2Tokens(data);
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://www.reddit.com/api/v1/access_token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://oauth.reddit.com/api/v1/me", {
        headers: {
          Authorization: `Bearer ${token.accessToken}`,
          "User-Agent": "better-auth"
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.oauth_client_id,
          emailVerified: profile.has_verified_email,
          image: profile.icon_img?.split("?")[0],
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var roblox = (options) => {
  return {
    id: "roblox",
    name: "Roblox",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["openid", "profile"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return new URL(`https://apis.roblox.com/oauth/v1/authorize?scope=${_scopes.join("+")}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(options.redirectURI || redirectURI)}&state=${state}&prompt=${options.prompt || "select_account+consent"}`);
    },
    validateAuthorizationCode: async ({ code, redirectURI }) => {
      return validateAuthorizationCode({
        code,
        redirectURI: options.redirectURI || redirectURI,
        options,
        tokenEndpoint: "https://apis.roblox.com/oauth/v1/token",
        authentication: "post"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://apis.roblox.com/oauth/v1/token"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://apis.roblox.com/oauth/v1/userinfo", {
        headers: {
          authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.sub,
          name: profile.nickname || profile.preferred_username || "",
          image: profile.picture,
          email: profile.preferred_username || null,
          emailVerified: true,
          ...userMap
        },
        data: {
          ...profile
        }
      };
    },
    options
  };
};
var vk = (options) => {
  return {
    id: "vk",
    name: "VK",
    async createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      const _scopes = options.disableDefaultScope ? [] : ["email", "phone"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      const authorizationEndpoint = "https://id.vk.com/authorize";
      return createAuthorizationURL({
        id: "vk",
        options,
        authorizationEndpoint,
        scopes: _scopes,
        state,
        redirectURI,
        codeVerifier
      });
    },
    validateAuthorizationCode: async ({
      code,
      codeVerifier,
      redirectURI,
      deviceId
    }) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: options.redirectURI || redirectURI,
        options,
        deviceId,
        tokenEndpoint: "https://id.vk.com/oauth2/auth"
      });
    },
    refreshAccessToken: options.refreshAccessToken ? options.refreshAccessToken : async (refreshToken) => {
      return refreshAccessToken({
        refreshToken,
        options: {
          clientId: options.clientId,
          clientKey: options.clientKey,
          clientSecret: options.clientSecret
        },
        tokenEndpoint: "https://id.vk.com/oauth2/auth"
      });
    },
    async getUserInfo(data) {
      if (options.getUserInfo) {
        return options.getUserInfo(data);
      }
      if (!data.accessToken) {
        return null;
      }
      const formBody = new URLSearchParams({
        access_token: data.accessToken,
        client_id: options.clientId
      }).toString();
      const { data: profile, error } = await betterFetch("https://id.vk.com/oauth2/user_info", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: formBody
      });
      if (error) {
        return null;
      }
      if (!profile.user.email) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.user.user_id,
          first_name: profile.user.first_name,
          last_name: profile.user.last_name,
          email: profile.user.email,
          image: profile.user.avatar,
          emailVerified: !!profile.user.email,
          birthday: profile.user.birthday,
          sex: profile.user.sex,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var kick = (options) => {
  return {
    id: "kick",
    name: "Kick",
    createAuthorizationURL({ state, scopes, redirectURI, codeVerifier }) {
      const _scopes = options.disableDefaultScope ? [] : ["user:read"];
      options.scope && _scopes.push(...options.scope);
      scopes && _scopes.push(...scopes);
      return createAuthorizationURL({
        id: "kick",
        redirectURI,
        options,
        authorizationEndpoint: "https://id.kick.com/oauth/authorize",
        scopes: _scopes,
        codeVerifier,
        state
      });
    },
    async validateAuthorizationCode({ code, redirectURI, codeVerifier }) {
      return validateAuthorizationCode({
        code,
        redirectURI,
        options,
        tokenEndpoint: "https://id.kick.com/oauth/token",
        codeVerifier
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data, error } = await betterFetch("https://api.kick.com/public/v1/users", {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const profile = data.data[0];
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.user_id,
          name: profile.name,
          email: profile.email,
          image: profile.profile_picture,
          emailVerified: true,
          ...userMap
        },
        data: profile
      };
    },
    options
  };
};
var zoom = (userOptions) => {
  const options = {
    pkce: true,
    ...userOptions
  };
  return {
    id: "zoom",
    name: "Zoom",
    createAuthorizationURL: async ({ state, redirectURI, codeVerifier }) => {
      const params = new URLSearchParams({
        response_type: "code",
        redirect_uri: options.redirectURI ? options.redirectURI : redirectURI,
        client_id: options.clientId,
        state
      });
      if (options.pkce) {
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        params.set("code_challenge_method", "S256");
        params.set("code_challenge", codeChallenge);
      }
      const url2 = new URL("https://zoom.us/oauth/authorize");
      url2.search = params.toString();
      return url2;
    },
    validateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {
      return validateAuthorizationCode({
        code,
        redirectURI: options.redirectURI || redirectURI,
        codeVerifier,
        options,
        tokenEndpoint: "https://zoom.us/oauth/token",
        authentication: "post"
      });
    },
    async getUserInfo(token) {
      if (options.getUserInfo) {
        return options.getUserInfo(token);
      }
      const { data: profile, error } = await betterFetch("https://api.zoom.us/v2/users/me", {
        headers: {
          authorization: `Bearer ${token.accessToken}`
        }
      });
      if (error) {
        return null;
      }
      const userMap = await options.mapProfileToUser?.(profile);
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          image: profile.pic_url,
          email: profile.email,
          emailVerified: Boolean(profile.verified),
          ...userMap
        },
        data: {
          ...profile
        }
      };
    }
  };
};
var socialProviders = {
  apple,
  discord,
  facebook,
  github,
  microsoft,
  google,
  spotify,
  twitch,
  twitter,
  dropbox,
  kick,
  linkedin,
  gitlab,
  tiktok,
  reddit,
  roblox,
  vk,
  zoom
};
var socialProviderList = Object.keys(socialProviders);
var SocialProviderListEnum = exports_external.enum(socialProviderList).or(exports_external.string());

// ../../node_modules/better-auth/dist/shared/better-auth.Cc72UxUH.mjs
var accountSchema = exports_external.object({
  id: exports_external.string(),
  providerId: exports_external.string(),
  accountId: exports_external.string(),
  userId: exports_external.coerce.string(),
  accessToken: exports_external.string().nullish(),
  refreshToken: exports_external.string().nullish(),
  idToken: exports_external.string().nullish(),
  accessTokenExpiresAt: exports_external.date().nullish(),
  refreshTokenExpiresAt: exports_external.date().nullish(),
  scope: exports_external.string().nullish(),
  password: exports_external.string().nullish(),
  createdAt: exports_external.date().default(() => /* @__PURE__ */ new Date),
  updatedAt: exports_external.date().default(() => /* @__PURE__ */ new Date)
});
var userSchema = exports_external.object({
  id: exports_external.string(),
  email: exports_external.string().transform((val) => val.toLowerCase()),
  emailVerified: exports_external.boolean().default(false),
  name: exports_external.string(),
  image: exports_external.string().nullish(),
  createdAt: exports_external.date().default(() => /* @__PURE__ */ new Date),
  updatedAt: exports_external.date().default(() => /* @__PURE__ */ new Date)
});
var sessionSchema = exports_external.object({
  id: exports_external.string(),
  userId: exports_external.coerce.string(),
  expiresAt: exports_external.date(),
  createdAt: exports_external.date().default(() => /* @__PURE__ */ new Date),
  updatedAt: exports_external.date().default(() => /* @__PURE__ */ new Date),
  token: exports_external.string(),
  ipAddress: exports_external.string().nullish(),
  userAgent: exports_external.string().nullish()
});
var verificationSchema = exports_external.object({
  id: exports_external.string(),
  value: exports_external.string(),
  createdAt: exports_external.date().default(() => /* @__PURE__ */ new Date),
  updatedAt: exports_external.date().default(() => /* @__PURE__ */ new Date),
  expiresAt: exports_external.date(),
  identifier: exports_external.string()
});
function parseOutputData(data, schema) {
  const fields = schema.fields;
  const parsedData = {};
  for (const key in data) {
    const field = fields[key];
    if (!field) {
      parsedData[key] = data[key];
      continue;
    }
    if (field.returned === false) {
      continue;
    }
    parsedData[key] = data[key];
  }
  return parsedData;
}
function getAllFields(options, table) {
  let schema = {
    ...table === "user" ? options.user?.additionalFields : {},
    ...table === "session" ? options.session?.additionalFields : {}
  };
  for (const plugin of options.plugins || []) {
    if (plugin.schema && plugin.schema[table]) {
      schema = {
        ...schema,
        ...plugin.schema[table].fields
      };
    }
  }
  return schema;
}
function parseUserOutput(options, user) {
  const schema = getAllFields(options, "user");
  return parseOutputData(user, { fields: schema });
}
function parseSessionOutput(options, session) {
  const schema = getAllFields(options, "session");
  return parseOutputData(session, { fields: schema });
}
function parseInputData(data, schema) {
  const action = schema.action || "create";
  const fields = schema.fields;
  const parsedData = {};
  for (const key in fields) {
    if (key in data) {
      if (fields[key].input === false) {
        if (fields[key].defaultValue) {
          parsedData[key] = fields[key].defaultValue;
          continue;
        }
        continue;
      }
      if (fields[key].validator?.input && data[key] !== undefined) {
        parsedData[key] = fields[key].validator.input.parse(data[key]);
        continue;
      }
      if (fields[key].transform?.input && data[key] !== undefined) {
        parsedData[key] = fields[key].transform?.input(data[key]);
        continue;
      }
      parsedData[key] = data[key];
      continue;
    }
    if (fields[key].defaultValue && action === "create") {
      parsedData[key] = fields[key].defaultValue;
      continue;
    }
    if (fields[key].required && action === "create") {
      throw new APIError("BAD_REQUEST", {
        message: `${key} is required`
      });
    }
  }
  return parsedData;
}
function parseUserInput(options, user, action) {
  const schema = getAllFields(options, "user");
  return parseInputData(user || {}, { fields: schema, action });
}

// ../../node_modules/defu/dist/defu.mjs
function isPlainObject2(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype3 = Object.getPrototypeOf(value);
  if (prototype3 !== null && prototype3 !== Object.prototype && Object.getPrototypeOf(prototype3) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults2, namespace = ".", merger) {
  if (!isPlainObject2(defaults2)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults2);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === undefined) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject2(value) && isPlainObject2(object[key])) {
      object[key] = _defu(value, object[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => arguments_.reduce((p, c) => _defu(p, c, "", merger), {});
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== undefined && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// ../../node_modules/better-auth/dist/shared/better-auth.DDEbWX-S.mjs
async function signJWT(payload, secret, expiresIn = 3600) {
  const jwt = await new SignJWT(payload).setProtectedHeader({ alg: "HS256" }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn).sign(new TextEncoder().encode(secret));
  return jwt;
}

// ../../node_modules/better-auth/dist/shared/better-auth.oUCDPPbQ.mjs
var optionsMiddleware = createMiddleware(async () => {
  return {};
});
var createAuthMiddleware = createMiddleware.create({
  use: [
    optionsMiddleware,
    createMiddleware(async () => {
      return {};
    })
  ]
});
var createAuthEndpoint = createEndpoint2.create({
  use: [optionsMiddleware]
});
function escapeRegExpChar(char2) {
  if (char2 === "-" || char2 === "^" || char2 === "$" || char2 === "+" || char2 === "." || char2 === "(" || char2 === ")" || char2 === "|" || char2 === "[" || char2 === "]" || char2 === "{" || char2 === "}" || char2 === "*" || char2 === "?" || char2 === "\\") {
    return `\\${char2}`;
  } else {
    return char2;
  }
}
function escapeRegExpString(str) {
  let result = "";
  for (let i = 0;i < str.length; i++) {
    result += escapeRegExpChar(str[i]);
  }
  return result;
}
function transform(pattern, separator = true) {
  if (Array.isArray(pattern)) {
    let regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`);
    return `(?:${regExpPatterns.join("|")})`;
  }
  let separatorSplitter = "";
  let separatorMatcher = "";
  let wildcard = ".";
  if (separator === true) {
    separatorSplitter = "/";
    separatorMatcher = "[/\\\\]";
    wildcard = "[^/\\\\]";
  } else if (separator) {
    separatorSplitter = separator;
    separatorMatcher = escapeRegExpString(separatorSplitter);
    if (separatorMatcher.length > 1) {
      separatorMatcher = `(?:${separatorMatcher})`;
      wildcard = `((?!${separatorMatcher}).)`;
    } else {
      wildcard = `[^${separatorMatcher}]`;
    }
  }
  let requiredSeparator = separator ? `${separatorMatcher}+?` : "";
  let optionalSeparator = separator ? `${separatorMatcher}*?` : "";
  let segments = separator ? pattern.split(separatorSplitter) : [pattern];
  let result = "";
  for (let s = 0;s < segments.length; s++) {
    let segment = segments[s];
    let nextSegment = segments[s + 1];
    let currentSeparator = "";
    if (!segment && s > 0) {
      continue;
    }
    if (separator) {
      if (s === segments.length - 1) {
        currentSeparator = optionalSeparator;
      } else if (nextSegment !== "**") {
        currentSeparator = requiredSeparator;
      } else {
        currentSeparator = "";
      }
    }
    if (separator && segment === "**") {
      if (currentSeparator) {
        result += s === 0 ? "" : currentSeparator;
        result += `(?:${wildcard}*?${currentSeparator})*?`;
      }
      continue;
    }
    for (let c = 0;c < segment.length; c++) {
      let char2 = segment[c];
      if (char2 === "\\") {
        if (c < segment.length - 1) {
          result += escapeRegExpChar(segment[c + 1]);
          c++;
        }
      } else if (char2 === "?") {
        result += wildcard;
      } else if (char2 === "*") {
        result += `${wildcard}*?`;
      } else {
        result += escapeRegExpChar(char2);
      }
    }
    result += currentSeparator;
  }
  return result;
}
function isMatch(regexp, sample) {
  if (typeof sample !== "string") {
    throw new TypeError(`Sample must be a string, but ${typeof sample} given`);
  }
  return regexp.test(sample);
}
function wildcardMatch(pattern, options) {
  if (typeof pattern !== "string" && !Array.isArray(pattern)) {
    throw new TypeError(`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`);
  }
  if (typeof options === "string" || typeof options === "boolean") {
    options = { separator: options };
  }
  if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) {
    throw new TypeError(`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`);
  }
  options = options || {};
  if (options.separator === "\\") {
    throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
  }
  let regexpPattern = transform(pattern, options.separator);
  let regexp = new RegExp(`^${regexpPattern}$`, options.flags);
  let fn = isMatch.bind(null, regexp);
  fn.options = options;
  fn.pattern = pattern;
  fn.regexp = regexp;
  return fn;
}
var originCheckMiddleware = createAuthMiddleware(async (ctx) => {
  if (ctx.request?.method !== "POST" || !ctx.request) {
    return;
  }
  const { body, query, context } = ctx;
  const originHeader = ctx.headers?.get("origin") || ctx.headers?.get("referer") || "";
  const callbackURL = body?.callbackURL || query?.callbackURL;
  const redirectURL = body?.redirectTo;
  const errorCallbackURL = body?.errorCallbackURL;
  const newUserCallbackURL = body?.newUserCallbackURL;
  const trustedOrigins = Array.isArray(context.options.trustedOrigins) ? context.trustedOrigins : [
    ...context.trustedOrigins,
    ...await context.options.trustedOrigins?.(ctx.request) || []
  ];
  const usesCookies = ctx.headers?.has("cookie");
  const matchesPattern = (url2, pattern) => {
    if (url2.startsWith("/")) {
      return false;
    }
    if (pattern.includes("*")) {
      return wildcardMatch(pattern)(getHost(url2));
    }
    const protocol = getProtocol(url2);
    return protocol === "http:" || protocol === "https:" || !protocol ? pattern === getOrigin(url2) : url2.startsWith(pattern);
  };
  const validateURL = (url2, label) => {
    if (!url2) {
      return;
    }
    const isTrustedOrigin = trustedOrigins.some((origin2) => matchesPattern(url2, origin2) || url2?.startsWith("/") && label !== "origin" && /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(url2));
    if (!isTrustedOrigin) {
      ctx.context.logger.error(`Invalid ${label}: ${url2}`);
      ctx.context.logger.info(`If it's a valid URL, please add ${url2} to trustedOrigins in your auth config
`, `Current list of trustedOrigins: ${trustedOrigins}`);
      throw new APIError("FORBIDDEN", { message: `Invalid ${label}` });
    }
  };
  if (usesCookies && !ctx.context.options.advanced?.disableCSRFCheck) {
    validateURL(originHeader, "origin");
  }
  callbackURL && validateURL(callbackURL, "callbackURL");
  redirectURL && validateURL(redirectURL, "redirectURL");
  errorCallbackURL && validateURL(errorCallbackURL, "errorCallbackURL");
  newUserCallbackURL && validateURL(newUserCallbackURL, "newUserCallbackURL");
});
var originCheck = (getValue) => createAuthMiddleware(async (ctx) => {
  if (!ctx.request) {
    return;
  }
  const { context } = ctx;
  const callbackURL = getValue(ctx);
  const trustedOrigins = Array.isArray(context.options.trustedOrigins) ? context.trustedOrigins : [
    ...context.trustedOrigins,
    ...await context.options.trustedOrigins?.(ctx.request) || []
  ];
  const matchesPattern = (url2, pattern) => {
    if (url2.startsWith("/")) {
      return false;
    }
    if (pattern.includes("*")) {
      return wildcardMatch(pattern)(getHost(url2));
    }
    return url2.startsWith(pattern);
  };
  const validateURL = (url2, label) => {
    if (!url2) {
      return;
    }
    const isTrustedOrigin = trustedOrigins.some((origin2) => matchesPattern(url2, origin2) || url2?.startsWith("/") && label !== "origin" && /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(url2));
    if (!isTrustedOrigin) {
      ctx.context.logger.error(`Invalid ${label}: ${url2}`);
      ctx.context.logger.info(`If it's a valid URL, please add ${url2} to trustedOrigins in your auth config
`, `Current list of trustedOrigins: ${trustedOrigins}`);
      throw new APIError("FORBIDDEN", { message: `Invalid ${label}` });
    }
  };
  const callbacks = Array.isArray(callbackURL) ? callbackURL : [callbackURL];
  for (const url2 of callbacks) {
    validateURL(url2, "callbackURL");
  }
});
var BASE_ERROR_CODES = {
  USER_NOT_FOUND: "User not found",
  FAILED_TO_CREATE_USER: "Failed to create user",
  FAILED_TO_CREATE_SESSION: "Failed to create session",
  FAILED_TO_UPDATE_USER: "Failed to update user",
  FAILED_TO_GET_SESSION: "Failed to get session",
  INVALID_PASSWORD: "Invalid password",
  INVALID_EMAIL: "Invalid email",
  INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
  SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
  PROVIDER_NOT_FOUND: "Provider not found",
  INVALID_TOKEN: "invalid token",
  ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
  FAILED_TO_GET_USER_INFO: "Failed to get user info",
  USER_EMAIL_NOT_FOUND: "User email not found",
  EMAIL_NOT_VERIFIED: "Email not verified",
  PASSWORD_TOO_SHORT: "Password too short",
  PASSWORD_TOO_LONG: "Password too long",
  USER_ALREADY_EXISTS: "User already exists",
  EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
  CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
  SESSION_EXPIRED: "Session expired. Re-authenticate to perform this action.",
  FAILED_TO_UNLINK_LAST_ACCOUNT: "You can't unlink your last account",
  ACCOUNT_NOT_FOUND: "Account not found",
  USER_ALREADY_HAS_PASSWORD: "User already has a password. Provide that to delete the account."
};
var getSession = () => createAuthEndpoint("/get-session", {
  method: "GET",
  query: exports_external.optional(exports_external.object({
    disableCookieCache: exports_external.optional(exports_external.boolean({
      description: "Disable cookie cache and fetch session from database"
    }).or(exports_external.string().transform((v) => v === "true"))).optional(),
    disableRefresh: exports_external.boolean({
      description: "Disable session refresh. Useful for checking session status, without updating the session"
    }).or(exports_external.string().transform((v) => v === "true")).optional()
  })),
  requireHeaders: true,
  metadata: {
    openapi: {
      description: "Get the current session",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  session: {
                    $ref: "#/components/schemas/Session"
                  },
                  user: {
                    $ref: "#/components/schemas/User"
                  }
                },
                required: ["session", "user"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  try {
    const sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);
    if (!sessionCookieToken) {
      return null;
    }
    const sessionDataCookie = ctx.getCookie(ctx.context.authCookies.sessionData.name);
    const sessionDataPayload = sessionDataCookie ? safeJSONParse(binary.decode(base64.decode(sessionDataCookie))) : null;
    if (sessionDataPayload) {
      const isValid3 = await createHMAC("SHA-256", "base64urlnopad").verify(ctx.context.secret, JSON.stringify({
        ...sessionDataPayload.session,
        expiresAt: sessionDataPayload.expiresAt
      }), sessionDataPayload.signature);
      if (!isValid3) {
        const dataCookie = ctx.context.authCookies.sessionData.name;
        ctx.setCookie(dataCookie, "", {
          maxAge: 0
        });
        return ctx.json(null);
      }
    }
    const dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
    if (sessionDataPayload?.session && ctx.context.options.session?.cookieCache?.enabled && !ctx.query?.disableCookieCache) {
      const session2 = sessionDataPayload.session;
      const hasExpired = sessionDataPayload.expiresAt < Date.now() || session2.session.expiresAt < /* @__PURE__ */ new Date;
      if (!hasExpired) {
        return ctx.json(session2);
      } else {
        const dataCookie = ctx.context.authCookies.sessionData.name;
        ctx.setCookie(dataCookie, "", {
          maxAge: 0
        });
      }
    }
    const session = await ctx.context.internalAdapter.findSession(sessionCookieToken);
    ctx.context.session = session;
    if (!session || session.session.expiresAt < /* @__PURE__ */ new Date) {
      deleteSessionCookie(ctx);
      if (session) {
        await ctx.context.internalAdapter.deleteSession(session.session.token);
      }
      return ctx.json(null);
    }
    if (dontRememberMe || ctx.query?.disableRefresh) {
      return ctx.json(session);
    }
    const expiresIn = ctx.context.sessionConfig.expiresIn;
    const updateAge = ctx.context.sessionConfig.updateAge;
    const sessionIsDueToBeUpdatedDate = session.session.expiresAt.valueOf() - expiresIn * 1000 + updateAge * 1000;
    const shouldBeUpdated = sessionIsDueToBeUpdatedDate <= Date.now();
    if (shouldBeUpdated && (!ctx.query?.disableRefresh || !ctx.context.options.session?.disableSessionRefresh)) {
      const updatedSession = await ctx.context.internalAdapter.updateSession(session.session.token, {
        expiresAt: getDate(ctx.context.sessionConfig.expiresIn, "sec"),
        updatedAt: /* @__PURE__ */ new Date
      });
      if (!updatedSession) {
        deleteSessionCookie(ctx);
        return ctx.json(null, { status: 401 });
      }
      const maxAge = (updatedSession.expiresAt.valueOf() - Date.now()) / 1000;
      await setSessionCookie(ctx, {
        session: updatedSession,
        user: session.user
      }, false, {
        maxAge
      });
      return ctx.json({
        session: updatedSession,
        user: session.user
      });
    }
    await setCookieCache(ctx, session);
    return ctx.json(session);
  } catch (error) {
    ctx.context.logger.error("INTERNAL_SERVER_ERROR", error);
    throw new APIError("INTERNAL_SERVER_ERROR", {
      message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION
    });
  }
});
var getSessionFromCtx = async (ctx, config) => {
  if (ctx.context.session) {
    return ctx.context.session;
  }
  const session = await getSession()({
    ...ctx,
    asResponse: false,
    headers: ctx.headers,
    returnHeaders: false,
    query: {
      ...config,
      ...ctx.query
    }
  }).catch((e) => {
    return null;
  });
  ctx.context.session = session;
  return session;
};
var sessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session) {
    throw new APIError("UNAUTHORIZED");
  }
  return {
    session
  };
});
var requestOnlySessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session && (ctx.request || ctx.headers)) {
    throw new APIError("UNAUTHORIZED");
  }
  return { session };
});
var freshSessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session) {
    throw new APIError("UNAUTHORIZED");
  }
  if (ctx.context.sessionConfig.freshAge === 0) {
    return {
      session
    };
  }
  const freshAge = ctx.context.sessionConfig.freshAge;
  const lastUpdated = session.session.updatedAt?.valueOf() || session.session.createdAt.valueOf();
  const now = Date.now();
  const isFresh = now - lastUpdated < freshAge * 1000;
  if (!isFresh) {
    throw new APIError("FORBIDDEN", {
      message: "Session is not fresh"
    });
  }
  return {
    session
  };
});
var listSessions = () => createAuthEndpoint("/list-sessions", {
  method: "GET",
  use: [sessionMiddleware],
  requireHeaders: true,
  metadata: {
    openapi: {
      description: "List all active sessions for the user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "array",
                items: {
                  $ref: "#/components/schemas/Session"
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  try {
    const sessions = await ctx.context.internalAdapter.listSessions(ctx.context.session.user.id);
    const activeSessions = sessions.filter((session) => {
      return session.expiresAt > /* @__PURE__ */ new Date;
    });
    return ctx.json(activeSessions);
  } catch (e) {
    ctx.context.logger.error(e);
    throw ctx.error("INTERNAL_SERVER_ERROR");
  }
});
var revokeSession = createAuthEndpoint("/revoke-session", {
  method: "POST",
  body: exports_external.object({
    token: exports_external.string({
      description: "The token to revoke"
    })
  }),
  use: [sessionMiddleware],
  requireHeaders: true,
  metadata: {
    openapi: {
      description: "Revoke a single session",
      requestBody: {
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                token: {
                  type: "string",
                  description: "The token to revoke"
                }
              },
              required: ["token"]
            }
          }
        }
      },
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean",
                    description: "Indicates if the session was revoked successfully"
                  }
                },
                required: ["status"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const token = ctx.body.token;
  const findSession = await ctx.context.internalAdapter.findSession(token);
  if (!findSession) {
    throw new APIError("BAD_REQUEST", {
      message: "Session not found"
    });
  }
  if (findSession.session.userId !== ctx.context.session.user.id) {
    throw new APIError("UNAUTHORIZED");
  }
  try {
    await ctx.context.internalAdapter.deleteSession(token);
  } catch (error) {
    ctx.context.logger.error(error && typeof error === "object" && "name" in error ? error.name : "", error);
    throw new APIError("INTERNAL_SERVER_ERROR");
  }
  return ctx.json({
    status: true
  });
});
var revokeSessions = createAuthEndpoint("/revoke-sessions", {
  method: "POST",
  use: [sessionMiddleware],
  requireHeaders: true,
  metadata: {
    openapi: {
      description: "Revoke all sessions for the user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean",
                    description: "Indicates if all sessions were revoked successfully"
                  }
                },
                required: ["status"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  try {
    await ctx.context.internalAdapter.deleteSessions(ctx.context.session.user.id);
  } catch (error) {
    ctx.context.logger.error(error && typeof error === "object" && "name" in error ? error.name : "", error);
    throw new APIError("INTERNAL_SERVER_ERROR");
  }
  return ctx.json({
    status: true
  });
});
var revokeOtherSessions = createAuthEndpoint("/revoke-other-sessions", {
  method: "POST",
  requireHeaders: true,
  use: [sessionMiddleware],
  metadata: {
    openapi: {
      description: "Revoke all other sessions for the user except the current one",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean",
                    description: "Indicates if all other sessions were revoked successfully"
                  }
                },
                required: ["status"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!session.user) {
    throw new APIError("UNAUTHORIZED");
  }
  const sessions = await ctx.context.internalAdapter.listSessions(session.user.id);
  const activeSessions = sessions.filter((session2) => {
    return session2.expiresAt > /* @__PURE__ */ new Date;
  });
  const otherSessions = activeSessions.filter((session2) => session2.token !== ctx.context.session.session.token);
  await Promise.all(otherSessions.map((session2) => ctx.context.internalAdapter.deleteSession(session2.token)));
  return ctx.json({
    status: true
  });
});
async function createEmailVerificationToken(secret, email, updateTo, expiresIn = 3600) {
  const token = await signJWT({
    email: email.toLowerCase(),
    updateTo
  }, secret, expiresIn);
  return token;
}
async function sendVerificationEmailFn(ctx, user) {
  if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
    ctx.context.logger.error("Verification email isn't enabled.");
    throw new APIError("BAD_REQUEST", {
      message: "Verification email isn't enabled"
    });
  }
  const token = await createEmailVerificationToken(ctx.context.secret, user.email, undefined, ctx.context.options.emailVerification?.expiresIn);
  const url2 = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
  await ctx.context.options.emailVerification.sendVerificationEmail({
    user,
    url: url2,
    token
  }, ctx.request);
}
var sendVerificationEmail = createAuthEndpoint("/send-verification-email", {
  method: "POST",
  body: exports_external.object({
    email: exports_external.string({
      description: "The email to send the verification email to"
    }).email(),
    callbackURL: exports_external.string({
      description: "The URL to use for email verification callback"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Send a verification email to the user",
      requestBody: {
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                email: {
                  type: "string",
                  description: "The email to send the verification email to",
                  example: "user@example.com"
                },
                callbackURL: {
                  type: "string",
                  description: "The URL to use for email verification callback",
                  example: "https://example.com/callback",
                  nullable: true
                }
              },
              required: ["email"]
            }
          }
        }
      },
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean",
                    description: "Indicates if the email was sent successfully",
                    example: true
                  }
                }
              }
            }
          }
        },
        "400": {
          description: "Bad Request",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                    description: "Error message",
                    example: "Verification email isn't enabled"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
    ctx.context.logger.error("Verification email isn't enabled.");
    throw new APIError("BAD_REQUEST", {
      message: "Verification email isn't enabled"
    });
  }
  const { email } = ctx.body;
  const user = await ctx.context.internalAdapter.findUserByEmail(email);
  if (!user) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.USER_NOT_FOUND
    });
  }
  await sendVerificationEmailFn(ctx, user.user);
  return ctx.json({
    status: true
  });
});
var verifyEmail = createAuthEndpoint("/verify-email", {
  method: "GET",
  query: exports_external.object({
    token: exports_external.string({
      description: "The token to verify the email"
    }),
    callbackURL: exports_external.string({
      description: "The URL to redirect to after email verification"
    }).optional()
  }),
  use: [originCheck((ctx) => ctx.query.callbackURL)],
  metadata: {
    openapi: {
      description: "Verify the email of the user",
      parameters: [
        {
          name: "token",
          in: "query",
          description: "The token to verify the email",
          required: true,
          schema: {
            type: "string"
          }
        },
        {
          name: "callbackURL",
          in: "query",
          description: "The URL to redirect to after email verification",
          required: false,
          schema: {
            type: "string"
          }
        }
      ],
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  user: {
                    type: "object",
                    properties: {
                      id: {
                        type: "string",
                        description: "User ID"
                      },
                      email: {
                        type: "string",
                        description: "User email"
                      },
                      name: {
                        type: "string",
                        description: "User name"
                      },
                      image: {
                        type: "string",
                        description: "User image URL"
                      },
                      emailVerified: {
                        type: "boolean",
                        description: "Indicates if the user email is verified"
                      },
                      createdAt: {
                        type: "string",
                        description: "User creation date"
                      },
                      updatedAt: {
                        type: "string",
                        description: "User update date"
                      }
                    },
                    required: [
                      "id",
                      "email",
                      "name",
                      "image",
                      "emailVerified",
                      "createdAt",
                      "updatedAt"
                    ]
                  },
                  status: {
                    type: "boolean",
                    description: "Indicates if the email was verified successfully"
                  }
                },
                required: ["user", "status"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  function redirectOnError(error) {
    if (ctx.query.callbackURL) {
      if (ctx.query.callbackURL.includes("?")) {
        throw ctx.redirect(`${ctx.query.callbackURL}&error=${error}`);
      }
      throw ctx.redirect(`${ctx.query.callbackURL}?error=${error}`);
    }
    throw new APIError("UNAUTHORIZED", {
      message: error
    });
  }
  const { token } = ctx.query;
  let jwt;
  try {
    jwt = await jwtVerify(token, new TextEncoder().encode(ctx.context.secret), {
      algorithms: ["HS256"]
    });
  } catch (e) {
    if (e instanceof JWTExpired) {
      return redirectOnError("token_expired");
    }
    return redirectOnError("invalid_token");
  }
  const schema = exports_external.object({
    email: exports_external.string().email(),
    updateTo: exports_external.string().optional()
  });
  const parsed = schema.parse(jwt.payload);
  const user = await ctx.context.internalAdapter.findUserByEmail(parsed.email);
  if (!user) {
    return redirectOnError("user_not_found");
  }
  if (parsed.updateTo) {
    const session = await getSessionFromCtx(ctx);
    if (!session) {
      if (ctx.query.callbackURL) {
        throw ctx.redirect(`${ctx.query.callbackURL}?error=unauthorized`);
      }
      return redirectOnError("unauthorized");
    }
    if (session.user.email !== parsed.email) {
      if (ctx.query.callbackURL) {
        throw ctx.redirect(`${ctx.query.callbackURL}?error=unauthorized`);
      }
      return redirectOnError("unauthorized");
    }
    const updatedUser = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
      email: parsed.updateTo,
      emailVerified: false
    }, ctx);
    const newToken = await createEmailVerificationToken(ctx.context.secret, parsed.updateTo);
    await ctx.context.options.emailVerification?.sendVerificationEmail?.({
      user: updatedUser,
      url: `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${ctx.query.callbackURL || "/"}`,
      token: newToken
    }, ctx.request);
    await setSessionCookie(ctx, {
      session: session.session,
      user: {
        ...session.user,
        email: parsed.updateTo,
        emailVerified: false
      }
    });
    if (ctx.query.callbackURL) {
      throw ctx.redirect(ctx.query.callbackURL);
    }
    return ctx.json({
      status: true,
      user: {
        id: updatedUser.id,
        email: updatedUser.email,
        name: updatedUser.name,
        image: updatedUser.image,
        emailVerified: updatedUser.emailVerified,
        createdAt: updatedUser.createdAt,
        updatedAt: updatedUser.updatedAt
      }
    });
  }
  await ctx.context.options.emailVerification?.onEmailVerification?.(user.user, ctx.request);
  await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
    emailVerified: true
  }, ctx);
  if (ctx.context.options.emailVerification?.autoSignInAfterVerification) {
    const currentSession = await getSessionFromCtx(ctx);
    if (!currentSession || currentSession.user.email !== parsed.email) {
      const session = await ctx.context.internalAdapter.createSession(user.user.id, ctx);
      if (!session) {
        throw new APIError("INTERNAL_SERVER_ERROR", {
          message: "Failed to create session"
        });
      }
      await setSessionCookie(ctx, {
        session,
        user: {
          ...user.user,
          emailVerified: true
        }
      });
    } else {
      await setSessionCookie(ctx, {
        session: currentSession.session,
        user: {
          ...currentSession.user,
          emailVerified: true
        }
      });
    }
  }
  if (ctx.query.callbackURL) {
    throw ctx.redirect(ctx.query.callbackURL);
  }
  return ctx.json({
    status: true,
    user: null
  });
});
var HIDE_METADATA = {
  isAction: false
};
async function handleOAuthUserInfo(c, {
  userInfo,
  account,
  callbackURL,
  disableSignUp,
  overrideUserInfo
}) {
  const dbUser = await c.context.internalAdapter.findOAuthUser(userInfo.email.toLowerCase(), account.accountId, account.providerId).catch((e) => {
    logger.error(`Better auth was unable to query your database.
Error: `, e);
    throw c.redirect(`${c.context.baseURL}/error?error=internal_server_error`);
  });
  let user = dbUser?.user;
  let isRegister = !user;
  if (dbUser) {
    const hasBeenLinked = dbUser.accounts.find((a) => a.providerId === account.providerId);
    if (!hasBeenLinked) {
      const trustedProviders = c.context.options.account?.accountLinking?.trustedProviders;
      const isTrustedProvider = trustedProviders?.includes(account.providerId);
      if (!isTrustedProvider && !userInfo.emailVerified || c.context.options.account?.accountLinking?.enabled === false) {
        if (isDevelopment) {
          logger.warn(`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`);
        }
        return {
          error: "account not linked",
          data: null
        };
      }
      try {
        await c.context.internalAdapter.linkAccount({
          providerId: account.providerId,
          accountId: userInfo.id.toString(),
          userId: dbUser.user.id,
          accessToken: account.accessToken,
          idToken: account.idToken,
          refreshToken: account.refreshToken,
          accessTokenExpiresAt: account.accessTokenExpiresAt,
          refreshTokenExpiresAt: account.refreshTokenExpiresAt,
          scope: account.scope
        }, c);
      } catch (e) {
        logger.error("Unable to link account", e);
        return {
          error: "unable to link account",
          data: null
        };
      }
    } else {
      if (c.context.options.account?.updateAccountOnSignIn !== false) {
        const updateData = Object.fromEntries(Object.entries({
          accessToken: account.accessToken,
          idToken: account.idToken,
          refreshToken: account.refreshToken,
          accessTokenExpiresAt: account.accessTokenExpiresAt,
          refreshTokenExpiresAt: account.refreshTokenExpiresAt,
          scope: account.scope
        }).filter(([_, value]) => value !== undefined));
        if (Object.keys(updateData).length > 0) {
          await c.context.internalAdapter.updateAccount(hasBeenLinked.id, updateData, c);
        }
      }
    }
    if (overrideUserInfo) {
      const { id: _, ...restUserInfo } = userInfo;
      await c.context.internalAdapter.updateUser(dbUser.user.id, {
        ...restUserInfo,
        email: userInfo.email.toLowerCase(),
        emailVerified: userInfo.email.toLowerCase() === dbUser.user.email ? dbUser.user.emailVerified || userInfo.emailVerified : userInfo.emailVerified
      });
    }
  } else {
    if (disableSignUp) {
      return {
        error: "signup disabled",
        data: null,
        isRegister: false
      };
    }
    try {
      const { id: _, ...restUserInfo } = userInfo;
      user = await c.context.internalAdapter.createOAuthUser({
        ...restUserInfo,
        email: userInfo.email.toLowerCase()
      }, {
        accessToken: account.accessToken,
        idToken: account.idToken,
        refreshToken: account.refreshToken,
        accessTokenExpiresAt: account.accessTokenExpiresAt,
        refreshTokenExpiresAt: account.refreshTokenExpiresAt,
        scope: account.scope,
        providerId: account.providerId,
        accountId: userInfo.id.toString()
      }, c).then((res) => res?.user);
      if (!userInfo.emailVerified && user && c.context.options.emailVerification?.sendOnSignUp) {
        const token = await createEmailVerificationToken(c.context.secret, user.email, undefined, c.context.options.emailVerification?.expiresIn);
        const url2 = `${c.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;
        await c.context.options.emailVerification?.sendVerificationEmail?.({
          user,
          url: url2,
          token
        }, c.request);
      }
    } catch (e) {
      logger.error(e);
      if (e instanceof APIError) {
        return {
          error: e.message,
          data: null,
          isRegister: false
        };
      }
      return {
        error: "unable to create user",
        data: null,
        isRegister: false
      };
    }
  }
  if (!user) {
    return {
      error: "unable to create user",
      data: null,
      isRegister: false
    };
  }
  const session = await c.context.internalAdapter.createSession(user.id, c);
  if (!session) {
    return {
      error: "unable to create session",
      data: null,
      isRegister: false
    };
  }
  return {
    data: {
      session,
      user
    },
    error: null,
    isRegister
  };
}
var signInSocial = createAuthEndpoint("/sign-in/social", {
  method: "POST",
  body: exports_external.object({
    callbackURL: exports_external.string({
      description: "Callback URL to redirect to after the user has signed in"
    }).optional(),
    newUserCallbackURL: exports_external.string().optional(),
    errorCallbackURL: exports_external.string({
      description: "Callback URL to redirect to if an error happens"
    }).optional(),
    provider: SocialProviderListEnum,
    disableRedirect: exports_external.boolean({
      description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself"
    }).optional(),
    idToken: exports_external.optional(exports_external.object({
      token: exports_external.string({
        description: "ID token from the provider"
      }),
      nonce: exports_external.string({
        description: "Nonce used to generate the token"
      }).optional(),
      accessToken: exports_external.string({
        description: "Access token from the provider"
      }).optional(),
      refreshToken: exports_external.string({
        description: "Refresh token from the provider"
      }).optional(),
      expiresAt: exports_external.number({
        description: "Expiry date of the token"
      }).optional()
    }), {
      description: "ID token from the provider to sign in the user with id token"
    }),
    scopes: exports_external.array(exports_external.string(), {
      description: "Array of scopes to request from the provider. This will override the default scopes passed."
    }).optional(),
    requestSignUp: exports_external.boolean({
      description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider"
    }).optional(),
    loginHint: exports_external.string({
      description: "The login hint to use for the authorization code request"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Sign in with a social provider",
      operationId: "socialSignIn",
      responses: {
        "200": {
          description: "Success - Returns either session details or redirect URL",
          content: {
            "application/json": {
              schema: {
                type: "object",
                description: "Session response when idToken is provided",
                properties: {
                  redirect: {
                    type: "boolean",
                    enum: [false]
                  },
                  token: {
                    type: "string",
                    description: "Session token",
                    url: {
                      type: "null",
                      nullable: true
                    },
                    user: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        email: { type: "string" },
                        name: {
                          type: "string",
                          nullable: true
                        },
                        image: {
                          type: "string",
                          nullable: true
                        },
                        emailVerified: {
                          type: "boolean"
                        },
                        createdAt: {
                          type: "string",
                          format: "date-time"
                        },
                        updatedAt: {
                          type: "string",
                          format: "date-time"
                        }
                      },
                      required: [
                        "id",
                        "email",
                        "emailVerified",
                        "createdAt",
                        "updatedAt"
                      ]
                    }
                  }
                },
                required: ["redirect", "token", "user"]
              }
            }
          }
        }
      }
    }
  }
}, async (c) => {
  const provider = c.context.socialProviders.find((p) => p.id === c.body.provider);
  if (!provider) {
    c.context.logger.error("Provider not found. Make sure to add the provider in your auth config", {
      provider: c.body.provider
    });
    throw new APIError("NOT_FOUND", {
      message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND
    });
  }
  if (c.body.idToken) {
    if (!provider.verifyIdToken) {
      c.context.logger.error("Provider does not support id token verification", {
        provider: c.body.provider
      });
      throw new APIError("NOT_FOUND", {
        message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED
      });
    }
    const { token, nonce } = c.body.idToken;
    const valid = await provider.verifyIdToken(token, nonce);
    if (!valid) {
      c.context.logger.error("Invalid id token", {
        provider: c.body.provider
      });
      throw new APIError("UNAUTHORIZED", {
        message: BASE_ERROR_CODES.INVALID_TOKEN
      });
    }
    const userInfo = await provider.getUserInfo({
      idToken: token,
      accessToken: c.body.idToken.accessToken,
      refreshToken: c.body.idToken.refreshToken
    });
    if (!userInfo || !userInfo?.user) {
      c.context.logger.error("Failed to get user info", {
        provider: c.body.provider
      });
      throw new APIError("UNAUTHORIZED", {
        message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO
      });
    }
    if (!userInfo.user.email) {
      c.context.logger.error("User email not found", {
        provider: c.body.provider
      });
      throw new APIError("UNAUTHORIZED", {
        message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND
      });
    }
    const data = await handleOAuthUserInfo(c, {
      userInfo: {
        ...userInfo.user,
        email: userInfo.user.email,
        id: userInfo.user.id,
        name: userInfo.user.name || "",
        image: userInfo.user.image,
        emailVerified: userInfo.user.emailVerified || false
      },
      account: {
        providerId: provider.id,
        accountId: userInfo.user.id,
        accessToken: c.body.idToken.accessToken
      },
      callbackURL: c.body.callbackURL,
      disableSignUp: provider.disableImplicitSignUp && !c.body.requestSignUp || provider.disableSignUp
    });
    if (data.error) {
      throw new APIError("UNAUTHORIZED", {
        message: data.error
      });
    }
    await setSessionCookie(c, data.data);
    return c.json({
      redirect: false,
      token: data.data.session.token,
      url: undefined,
      user: {
        id: data.data.user.id,
        email: data.data.user.email,
        name: data.data.user.name,
        image: data.data.user.image,
        emailVerified: data.data.user.emailVerified,
        createdAt: data.data.user.createdAt,
        updatedAt: data.data.user.updatedAt
      }
    });
  }
  const { codeVerifier, state } = await generateState(c);
  const url2 = await provider.createAuthorizationURL({
    state,
    codeVerifier,
    redirectURI: `${c.context.baseURL}/callback/${provider.id}`,
    scopes: c.body.scopes,
    loginHint: c.body.loginHint
  });
  return c.json({
    url: url2.toString(),
    redirect: !c.body.disableRedirect
  });
});
var signInEmail = createAuthEndpoint("/sign-in/email", {
  method: "POST",
  body: exports_external.object({
    email: exports_external.string({
      description: "Email of the user"
    }),
    password: exports_external.string({
      description: "Password of the user"
    }),
    callbackURL: exports_external.string({
      description: "Callback URL to use as a redirect for email verification"
    }).optional(),
    rememberMe: exports_external.boolean({
      description: "If this is false, the session will not be remembered. Default is `true`."
    }).default(true).optional()
  }),
  metadata: {
    openapi: {
      description: "Sign in with email and password",
      responses: {
        "200": {
          description: "Success - Returns either session details or redirect URL",
          content: {
            "application/json": {
              schema: {
                type: "object",
                description: "Session response when idToken is provided",
                properties: {
                  redirect: {
                    type: "boolean",
                    enum: [false]
                  },
                  token: {
                    type: "string",
                    description: "Session token"
                  },
                  url: {
                    type: "null",
                    nullable: true
                  },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      email: { type: "string" },
                      name: {
                        type: "string",
                        nullable: true
                      },
                      image: {
                        type: "string",
                        nullable: true
                      },
                      emailVerified: {
                        type: "boolean"
                      },
                      createdAt: {
                        type: "string",
                        format: "date-time"
                      },
                      updatedAt: {
                        type: "string",
                        format: "date-time"
                      }
                    },
                    required: [
                      "id",
                      "email",
                      "emailVerified",
                      "createdAt",
                      "updatedAt"
                    ]
                  }
                },
                required: ["redirect", "token", "user"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options?.emailAndPassword?.enabled) {
    ctx.context.logger.error("Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!");
    throw new APIError("BAD_REQUEST", {
      message: "Email and password is not enabled"
    });
  }
  const { email, password } = ctx.body;
  const isValidEmail = exports_external.string().email().safeParse(email);
  if (!isValidEmail.success) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.INVALID_EMAIL
    });
  }
  const user = await ctx.context.internalAdapter.findUserByEmail(email, {
    includeAccounts: true
  });
  if (!user) {
    await ctx.context.password.hash(password);
    ctx.context.logger.error("User not found", { email });
    throw new APIError("UNAUTHORIZED", {
      message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD
    });
  }
  const credentialAccount = user.accounts.find((a) => a.providerId === "credential");
  if (!credentialAccount) {
    ctx.context.logger.error("Credential account not found", { email });
    throw new APIError("UNAUTHORIZED", {
      message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD
    });
  }
  const currentPassword = credentialAccount?.password;
  if (!currentPassword) {
    ctx.context.logger.error("Password not found", { email });
    throw new APIError("UNAUTHORIZED", {
      message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD
    });
  }
  const validPassword = await ctx.context.password.verify({
    hash: currentPassword,
    password
  });
  if (!validPassword) {
    ctx.context.logger.error("Invalid password");
    throw new APIError("UNAUTHORIZED", {
      message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD
    });
  }
  if (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.user.emailVerified) {
    if (!ctx.context.options?.emailVerification?.sendVerificationEmail) {
      throw new APIError("FORBIDDEN", {
        message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED
      });
    }
    const token = await createEmailVerificationToken(ctx.context.secret, user.user.email, undefined, ctx.context.options.emailVerification?.expiresIn);
    const url2 = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
    await ctx.context.options.emailVerification.sendVerificationEmail({
      user: user.user,
      url: url2,
      token
    }, ctx.request);
    throw new APIError("FORBIDDEN", {
      message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED
    });
  }
  const session = await ctx.context.internalAdapter.createSession(user.user.id, ctx, ctx.body.rememberMe === false);
  if (!session) {
    ctx.context.logger.error("Failed to create session");
    throw new APIError("UNAUTHORIZED", {
      message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION
    });
  }
  await setSessionCookie(ctx, {
    session,
    user: user.user
  }, ctx.body.rememberMe === false);
  return ctx.json({
    redirect: !!ctx.body.callbackURL,
    token: session.token,
    url: ctx.body.callbackURL,
    user: {
      id: user.user.id,
      email: user.user.email,
      name: user.user.name,
      image: user.user.image,
      emailVerified: user.user.emailVerified,
      createdAt: user.user.createdAt,
      updatedAt: user.user.updatedAt
    }
  });
});
var schema = exports_external.object({
  code: exports_external.string().optional(),
  error: exports_external.string().optional(),
  device_id: exports_external.string().optional(),
  error_description: exports_external.string().optional(),
  state: exports_external.string().optional(),
  user: exports_external.string().optional()
});
var callbackOAuth = createAuthEndpoint("/callback/:id", {
  method: ["GET", "POST"],
  body: schema.optional(),
  query: schema.optional(),
  metadata: HIDE_METADATA
}, async (c) => {
  let queryOrBody;
  const defaultErrorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
  try {
    if (c.method === "GET") {
      queryOrBody = schema.parse(c.query);
    } else if (c.method === "POST") {
      queryOrBody = schema.parse(c.body);
    } else {
      throw new Error("Unsupported method");
    }
  } catch (e) {
    c.context.logger.error("INVALID_CALLBACK_REQUEST", e);
    throw c.redirect(`${defaultErrorURL}?error=invalid_callback_request`);
  }
  const { code, error, state, error_description, device_id } = queryOrBody;
  if (error) {
    throw c.redirect(`${defaultErrorURL}?error=${error}&error_description=${error_description}`);
  }
  if (!state) {
    c.context.logger.error("State not found", error);
    throw c.redirect(`${defaultErrorURL}?error=state_not_found`);
  }
  const {
    codeVerifier,
    callbackURL,
    link,
    errorURL,
    newUserURL,
    requestSignUp
  } = await parseState(c);
  function redirectOnError(error2) {
    let url2 = errorURL || defaultErrorURL;
    if (url2.includes("?")) {
      url2 = `${url2}&error=${error2}`;
    } else {
      url2 = `${url2}?error=${error2}`;
    }
    throw c.redirect(url2);
  }
  if (!code) {
    c.context.logger.error("Code not found");
    throw redirectOnError("no_code");
  }
  const provider = c.context.socialProviders.find((p) => p.id === c.params.id);
  if (!provider) {
    c.context.logger.error("Oauth provider with id", c.params.id, "not found");
    throw redirectOnError("oauth_provider_not_found");
  }
  let tokens;
  try {
    tokens = await provider.validateAuthorizationCode({
      code,
      codeVerifier,
      deviceId: device_id,
      redirectURI: `${c.context.baseURL}/callback/${provider.id}`
    });
  } catch (e) {
    c.context.logger.error("", e);
    throw redirectOnError("invalid_code");
  }
  const userInfo = await provider.getUserInfo({
    ...tokens,
    user: c.body?.user ? safeJSONParse(c.body.user) : undefined
  }).then((res) => res?.user);
  if (!userInfo) {
    c.context.logger.error("Unable to get user info");
    return redirectOnError("unable_to_get_user_info");
  }
  if (!userInfo.email) {
    c.context.logger.error("Provider did not return email. This could be due to misconfiguration in the provider settings.");
    return redirectOnError("email_not_found");
  }
  if (!callbackURL) {
    c.context.logger.error("No callback URL found");
    throw redirectOnError("no_callback_url");
  }
  if (link) {
    const existingAccount = await c.context.internalAdapter.findAccount(userInfo.id);
    if (existingAccount) {
      if (existingAccount.userId.toString() !== link.userId.toString()) {
        return redirectOnError("account_already_linked_to_different_user");
      }
      const updateData = Object.fromEntries(Object.entries({
        accessToken: tokens.accessToken,
        idToken: tokens.idToken,
        refreshToken: tokens.refreshToken,
        accessTokenExpiresAt: tokens.accessTokenExpiresAt,
        refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
        scope: tokens.scopes?.join(",")
      }).filter(([_, value]) => value !== undefined));
      await c.context.internalAdapter.updateAccount(existingAccount.id, updateData);
    } else {
      const newAccount = await c.context.internalAdapter.createAccount({
        userId: link.userId,
        providerId: provider.id,
        accountId: userInfo.id,
        ...tokens,
        scope: tokens.scopes?.join(",")
      }, c);
      if (!newAccount) {
        return redirectOnError("unable_to_link_account");
      }
    }
    let toRedirectTo2;
    try {
      const url2 = callbackURL;
      toRedirectTo2 = url2.toString();
    } catch {
      toRedirectTo2 = callbackURL;
    }
    throw c.redirect(toRedirectTo2);
  }
  const result = await handleOAuthUserInfo(c, {
    userInfo: {
      ...userInfo,
      email: userInfo.email,
      name: userInfo.name || userInfo.email
    },
    account: {
      providerId: provider.id,
      accountId: userInfo.id,
      ...tokens,
      scope: tokens.scopes?.join(",")
    },
    callbackURL,
    disableSignUp: provider.disableImplicitSignUp && !requestSignUp || provider.options?.disableSignUp,
    overrideUserInfo: provider.options?.overrideUserInfoOnSignIn
  });
  if (result.error) {
    c.context.logger.error(result.error.split(" ").join("_"));
    return redirectOnError(result.error.split(" ").join("_"));
  }
  const { session, user } = result.data;
  await setSessionCookie(c, {
    session,
    user
  });
  let toRedirectTo;
  try {
    const url2 = result.isRegister ? newUserURL || callbackURL : callbackURL;
    toRedirectTo = url2.toString();
  } catch {
    toRedirectTo = result.isRegister ? newUserURL || callbackURL : callbackURL;
  }
  throw c.redirect(toRedirectTo);
});
var signOut = createAuthEndpoint("/sign-out", {
  method: "POST",
  requireHeaders: true,
  metadata: {
    openapi: {
      description: "Sign out the current user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  success: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);
  if (!sessionCookieToken) {
    deleteSessionCookie(ctx);
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION
    });
  }
  await ctx.context.internalAdapter.deleteSession(sessionCookieToken);
  deleteSessionCookie(ctx);
  return ctx.json({
    success: true
  });
});
function redirectError(ctx, callbackURL, query) {
  const url2 = callbackURL ? new URL(callbackURL, ctx.baseURL) : new URL(`${ctx.baseURL}/error`);
  if (query)
    Object.entries(query).forEach(([k, v]) => url2.searchParams.set(k, v));
  return url2.href;
}
function redirectCallback(ctx, callbackURL, query) {
  const url2 = new URL(callbackURL, ctx.baseURL);
  if (query)
    Object.entries(query).forEach(([k, v]) => url2.searchParams.set(k, v));
  return url2.href;
}
var requestPasswordReset = createAuthEndpoint("/request-password-reset", {
  method: "POST",
  body: exports_external.object({
    email: exports_external.string({
      description: "The email address of the user to send a password reset email to"
    }).email(),
    redirectTo: exports_external.string({
      description: "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Send a password reset email to the user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean"
                  },
                  message: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.emailAndPassword?.sendResetPassword) {
    ctx.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!");
    throw new APIError("BAD_REQUEST", {
      message: "Reset password isn't enabled"
    });
  }
  const { email, redirectTo } = ctx.body;
  const user = await ctx.context.internalAdapter.findUserByEmail(email, {
    includeAccounts: true
  });
  if (!user) {
    ctx.context.logger.error("Reset Password: User not found", { email });
    return ctx.json({
      status: true,
      message: "If this email exists in our system, check your email for the reset link"
    });
  }
  const defaultExpiresIn = 60 * 60 * 1;
  const expiresAt = getDate(ctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn || defaultExpiresIn, "sec");
  const verificationToken = generateId(24);
  await ctx.context.internalAdapter.createVerificationValue({
    value: user.user.id,
    identifier: `reset-password:${verificationToken}`,
    expiresAt
  }, ctx);
  const callbackURL = redirectTo ? encodeURIComponent(redirectTo) : "";
  const url2 = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;
  await ctx.context.options.emailAndPassword.sendResetPassword({
    user: user.user,
    url: url2,
    token: verificationToken
  }, ctx.request);
  return ctx.json({
    status: true
  });
});
var forgetPassword = createAuthEndpoint("/forget-password", {
  method: "POST",
  body: exports_external.object({
    email: exports_external.string({
      description: "The email address of the user to send a password reset email to"
    }).email(),
    redirectTo: exports_external.string({
      description: "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Send a password reset email to the user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean"
                  },
                  message: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.emailAndPassword?.sendResetPassword) {
    ctx.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!");
    throw new APIError("BAD_REQUEST", {
      message: "Reset password isn't enabled"
    });
  }
  const { email, redirectTo } = ctx.body;
  const user = await ctx.context.internalAdapter.findUserByEmail(email, {
    includeAccounts: true
  });
  if (!user) {
    ctx.context.logger.error("Reset Password: User not found", { email });
    return ctx.json({
      status: true,
      message: "If this email exists in our system, check your email for the reset link"
    });
  }
  const defaultExpiresIn = 60 * 60 * 1;
  const expiresAt = getDate(ctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn || defaultExpiresIn, "sec");
  const verificationToken = generateId(24);
  await ctx.context.internalAdapter.createVerificationValue({
    value: user.user.id,
    identifier: `reset-password:${verificationToken}`,
    expiresAt
  }, ctx);
  const callbackURL = redirectTo ? encodeURIComponent(redirectTo) : "";
  const url2 = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;
  await ctx.context.options.emailAndPassword.sendResetPassword({
    user: user.user,
    url: url2,
    token: verificationToken
  }, ctx.request);
  return ctx.json({
    status: true
  });
});
var requestPasswordResetCallback = createAuthEndpoint("/reset-password/:token", {
  method: "GET",
  query: exports_external.object({
    callbackURL: exports_external.string({
      description: "The URL to redirect the user to reset their password"
    })
  }),
  use: [originCheck((ctx) => ctx.query.callbackURL)],
  metadata: {
    openapi: {
      description: "Redirects the user to the callback URL with the token",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  token: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const { token } = ctx.params;
  const { callbackURL } = ctx.query;
  if (!token || !callbackURL) {
    throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: "INVALID_TOKEN" }));
  }
  const verification = await ctx.context.internalAdapter.findVerificationValue(`reset-password:${token}`);
  if (!verification || verification.expiresAt < /* @__PURE__ */ new Date) {
    throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: "INVALID_TOKEN" }));
  }
  throw ctx.redirect(redirectCallback(ctx.context, callbackURL, { token }));
});
var forgetPasswordCallback = requestPasswordResetCallback;
var resetPassword = createAuthEndpoint("/reset-password", {
  method: "POST",
  query: exports_external.object({
    token: exports_external.string().optional()
  }).optional(),
  body: exports_external.object({
    newPassword: exports_external.string({
      description: "The new password to set"
    }),
    token: exports_external.string({
      description: "The token to reset the password"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Reset the password for a user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const token = ctx.body.token || ctx.query?.token;
  if (!token) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.INVALID_TOKEN
    });
  }
  const { newPassword } = ctx.body;
  const minLength = ctx.context.password?.config.minPasswordLength;
  const maxLength = ctx.context.password?.config.maxPasswordLength;
  if (newPassword.length < minLength) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT
    });
  }
  if (newPassword.length > maxLength) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_LONG
    });
  }
  const id = `reset-password:${token}`;
  const verification = await ctx.context.internalAdapter.findVerificationValue(id);
  if (!verification || verification.expiresAt < /* @__PURE__ */ new Date) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.INVALID_TOKEN
    });
  }
  const userId = verification.value;
  const hashedPassword = await ctx.context.password.hash(newPassword);
  const accounts = await ctx.context.internalAdapter.findAccounts(userId);
  const account = accounts.find((ac) => ac.providerId === "credential");
  if (!account) {
    await ctx.context.internalAdapter.createAccount({
      userId,
      providerId: "credential",
      password: hashedPassword,
      accountId: userId
    }, ctx);
    await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
    return ctx.json({
      status: true
    });
  }
  await ctx.context.internalAdapter.updatePassword(userId, hashedPassword, ctx);
  await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
  if (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) {
    await ctx.context.internalAdapter.deleteSessions(userId);
  }
  return ctx.json({
    status: true
  });
});
var updateUser = () => createAuthEndpoint("/update-user", {
  method: "POST",
  body: exports_external.record(exports_external.string(), exports_external.any()),
  use: [sessionMiddleware],
  metadata: {
    $Infer: {
      body: {}
    },
    openapi: {
      description: "Update the current user",
      requestBody: {
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  description: "The name of the user"
                },
                image: {
                  type: "string",
                  description: "The image of the user"
                }
              }
            }
          }
        }
      },
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean",
                    description: "Indicates if the update was successful"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const body = ctx.body;
  if (body.email) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.EMAIL_CAN_NOT_BE_UPDATED
    });
  }
  const { name, image, ...rest } = body;
  const session = ctx.context.session;
  if (image === undefined && name === undefined && Object.keys(rest).length === 0) {
    return ctx.json({
      status: true
    });
  }
  const additionalFields = parseUserInput(ctx.context.options, rest, "update");
  const user = await ctx.context.internalAdapter.updateUser(session.user.id, {
    name,
    image,
    ...additionalFields
  }, ctx);
  await setSessionCookie(ctx, {
    session: session.session,
    user
  });
  return ctx.json({
    status: true
  });
});
var changePassword = createAuthEndpoint("/change-password", {
  method: "POST",
  body: exports_external.object({
    newPassword: exports_external.string({
      description: "The new password to set"
    }),
    currentPassword: exports_external.string({
      description: "The current password"
    }),
    revokeOtherSessions: exports_external.boolean({
      description: "Revoke all other sessions"
    }).optional()
  }),
  use: [sessionMiddleware],
  metadata: {
    openapi: {
      description: "Change the password of the user",
      responses: {
        "200": {
          description: "Password successfully changed",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  token: {
                    type: "string",
                    nullable: true,
                    description: "New session token if other sessions were revoked"
                  },
                  user: {
                    type: "object",
                    properties: {
                      id: {
                        type: "string",
                        description: "The unique identifier of the user"
                      },
                      email: {
                        type: "string",
                        format: "email",
                        description: "The email address of the user"
                      },
                      name: {
                        type: "string",
                        description: "The name of the user"
                      },
                      image: {
                        type: "string",
                        format: "uri",
                        nullable: true,
                        description: "The profile image URL of the user"
                      },
                      emailVerified: {
                        type: "boolean",
                        description: "Whether the email has been verified"
                      },
                      createdAt: {
                        type: "string",
                        format: "date-time",
                        description: "When the user was created"
                      },
                      updatedAt: {
                        type: "string",
                        format: "date-time",
                        description: "When the user was last updated"
                      }
                    },
                    required: [
                      "id",
                      "email",
                      "name",
                      "emailVerified",
                      "createdAt",
                      "updatedAt"
                    ]
                  }
                },
                required: ["user"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const { newPassword, currentPassword, revokeOtherSessions: revokeOtherSessions2 } = ctx.body;
  const session = ctx.context.session;
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (newPassword.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT
    });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (newPassword.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_LONG
    });
  }
  const accounts = await ctx.context.internalAdapter.findAccounts(session.user.id);
  const account = accounts.find((account2) => account2.providerId === "credential" && account2.password);
  if (!account || !account.password) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND
    });
  }
  const passwordHash = await ctx.context.password.hash(newPassword);
  const verify2 = await ctx.context.password.verify({
    hash: account.password,
    password: currentPassword
  });
  if (!verify2) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.INVALID_PASSWORD
    });
  }
  await ctx.context.internalAdapter.updateAccount(account.id, {
    password: passwordHash
  });
  let token = null;
  if (revokeOtherSessions2) {
    await ctx.context.internalAdapter.deleteSessions(session.user.id);
    const newSession = await ctx.context.internalAdapter.createSession(session.user.id, ctx);
    if (!newSession) {
      throw new APIError("INTERNAL_SERVER_ERROR", {
        message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION
      });
    }
    await setSessionCookie(ctx, {
      session: newSession,
      user: session.user
    });
    token = newSession.token;
  }
  return ctx.json({
    token,
    user: {
      id: session.user.id,
      email: session.user.email,
      name: session.user.name,
      image: session.user.image,
      emailVerified: session.user.emailVerified,
      createdAt: session.user.createdAt,
      updatedAt: session.user.updatedAt
    }
  });
});
var setPassword = createAuthEndpoint("/set-password", {
  method: "POST",
  body: exports_external.object({
    newPassword: exports_external.string()
  }),
  metadata: {
    SERVER_ONLY: true
  },
  use: [sessionMiddleware]
}, async (ctx) => {
  const { newPassword } = ctx.body;
  const session = ctx.context.session;
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (newPassword.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT
    });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (newPassword.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_LONG
    });
  }
  const accounts = await ctx.context.internalAdapter.findAccounts(session.user.id);
  const account = accounts.find((account2) => account2.providerId === "credential" && account2.password);
  const passwordHash = await ctx.context.password.hash(newPassword);
  if (!account) {
    await ctx.context.internalAdapter.linkAccount({
      userId: session.user.id,
      providerId: "credential",
      accountId: session.user.id,
      password: passwordHash
    }, ctx);
    return ctx.json({
      status: true
    });
  }
  throw new APIError("BAD_REQUEST", {
    message: "user already has a password"
  });
});
var deleteUser = createAuthEndpoint("/delete-user", {
  method: "POST",
  use: [sessionMiddleware],
  body: exports_external.object({
    callbackURL: exports_external.string().optional(),
    password: exports_external.string().optional(),
    token: exports_external.string().optional()
  }),
  metadata: {
    openapi: {
      description: "Delete the user",
      responses: {
        "200": {
          description: "User deletion processed successfully",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  success: {
                    type: "boolean",
                    description: "Indicates if the operation was successful"
                  },
                  message: {
                    type: "string",
                    enum: ["User deleted", "Verification email sent"],
                    description: "Status message of the deletion process"
                  }
                },
                required: ["success", "message"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.user?.deleteUser?.enabled) {
    ctx.context.logger.error("Delete user is disabled. Enable it in the options", {
      session: ctx.context.session
    });
    throw new APIError("NOT_FOUND");
  }
  const session = ctx.context.session;
  let canDelete = false;
  const accounts = await ctx.context.internalAdapter.findAccounts(session.user.id);
  const account = accounts.find((account2) => account2.providerId === "credential" && account2.password);
  if (ctx.body.password) {
    if (!account || !account.password) {
      throw new APIError("BAD_REQUEST", {
        message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND
      });
    }
    const verify2 = await ctx.context.password.verify({
      hash: account.password,
      password: ctx.body.password
    });
    if (!verify2) {
      throw new APIError("BAD_REQUEST", {
        message: BASE_ERROR_CODES.INVALID_PASSWORD
      });
    }
    canDelete = true;
  }
  if (ctx.body.token) {
    await deleteUserCallback({
      ...ctx,
      query: {
        token: ctx.body.token
      }
    });
    return ctx.json({
      success: true,
      message: "User deleted"
    });
  }
  if (ctx.context.options.user.deleteUser?.sendDeleteAccountVerification) {
    if (account && account.password && !canDelete) {
      throw new APIError("BAD_REQUEST", {
        message: BASE_ERROR_CODES.USER_ALREADY_HAS_PASSWORD
      });
    }
    const token = generateRandomString(32, "0-9", "a-z");
    await ctx.context.internalAdapter.createVerificationValue({
      value: session.user.id,
      identifier: `delete-account-${token}`,
      expiresAt: new Date(Date.now() + (ctx.context.options.user.deleteUser?.deleteTokenExpiresIn || 60 * 60 * 24) * 1000)
    }, ctx);
    const url2 = `${ctx.context.baseURL}/delete-user/callback?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
    await ctx.context.options.user.deleteUser.sendDeleteAccountVerification({
      user: session.user,
      url: url2,
      token
    }, ctx.request);
    return ctx.json({
      success: true,
      message: "Verification email sent"
    });
  }
  if (ctx.context.options.session?.freshAge) {
    const currentAge = session.session.createdAt.getTime();
    const freshAge = ctx.context.options.session.freshAge;
    const now = Date.now();
    if (now - currentAge > freshAge) {
      throw new APIError("BAD_REQUEST", {
        message: BASE_ERROR_CODES.SESSION_EXPIRED
      });
    }
    canDelete = true;
  }
  if (!canDelete) {
    throw new APIError("BAD_REQUEST", {
      message: "User cannot be deleted. please provide a password or token"
    });
  }
  const beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;
  if (beforeDelete) {
    await beforeDelete(session.user, ctx.request);
  }
  await ctx.context.internalAdapter.deleteUser(session.user.id);
  await ctx.context.internalAdapter.deleteSessions(session.user.id);
  await ctx.context.internalAdapter.deleteAccounts(session.user.id);
  deleteSessionCookie(ctx);
  const afterDelete = ctx.context.options.user.deleteUser?.afterDelete;
  if (afterDelete) {
    await afterDelete(session.user, ctx.request);
  }
  return ctx.json({
    success: true,
    message: "User deleted"
  });
});
var deleteUserCallback = createAuthEndpoint("/delete-user/callback", {
  method: "GET",
  query: exports_external.object({
    token: exports_external.string(),
    callbackURL: exports_external.string().optional()
  }),
  use: [originCheck((ctx) => ctx.query.callbackURL)],
  metadata: {
    openapi: {
      description: "Callback to complete user deletion with verification token",
      responses: {
        "200": {
          description: "User successfully deleted",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  success: {
                    type: "boolean",
                    description: "Indicates if the deletion was successful"
                  },
                  message: {
                    type: "string",
                    enum: ["User deleted"],
                    description: "Confirmation message"
                  }
                },
                required: ["success", "message"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.user?.deleteUser?.enabled) {
    ctx.context.logger.error("Delete user is disabled. Enable it in the options");
    throw new APIError("NOT_FOUND");
  }
  const session = await getSessionFromCtx(ctx);
  if (!session) {
    throw new APIError("NOT_FOUND", {
      message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO
    });
  }
  const token = await ctx.context.internalAdapter.findVerificationValue(`delete-account-${ctx.query.token}`);
  if (!token || token.expiresAt < /* @__PURE__ */ new Date) {
    throw new APIError("NOT_FOUND", {
      message: BASE_ERROR_CODES.INVALID_TOKEN
    });
  }
  if (token.value !== session.user.id) {
    throw new APIError("NOT_FOUND", {
      message: BASE_ERROR_CODES.INVALID_TOKEN
    });
  }
  const beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;
  if (beforeDelete) {
    await beforeDelete(session.user, ctx.request);
  }
  await ctx.context.internalAdapter.deleteUser(session.user.id);
  await ctx.context.internalAdapter.deleteSessions(session.user.id);
  await ctx.context.internalAdapter.deleteAccounts(session.user.id);
  await ctx.context.internalAdapter.deleteVerificationValue(token.id);
  deleteSessionCookie(ctx);
  const afterDelete = ctx.context.options.user.deleteUser?.afterDelete;
  if (afterDelete) {
    await afterDelete(session.user, ctx.request);
  }
  if (ctx.query.callbackURL) {
    throw ctx.redirect(ctx.query.callbackURL || "/");
  }
  return ctx.json({
    success: true,
    message: "User deleted"
  });
});
var changeEmail = createAuthEndpoint("/change-email", {
  method: "POST",
  body: exports_external.object({
    newEmail: exports_external.string({
      description: "The new email to set"
    }).email(),
    callbackURL: exports_external.string({
      description: "The URL to redirect to after email verification"
    }).optional()
  }),
  use: [sessionMiddleware],
  metadata: {
    openapi: {
      responses: {
        "200": {
          description: "Email change request processed successfully",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean",
                    description: "Indicates if the request was successful"
                  },
                  message: {
                    type: "string",
                    enum: ["Email updated", "Verification email sent"],
                    description: "Status message of the email change process",
                    nullable: true
                  }
                },
                required: ["status"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.user?.changeEmail?.enabled) {
    ctx.context.logger.error("Change email is disabled.");
    throw new APIError("BAD_REQUEST", {
      message: "Change email is disabled"
    });
  }
  const newEmail = ctx.body.newEmail.toLowerCase();
  if (newEmail === ctx.context.session.user.email) {
    ctx.context.logger.error("Email is the same");
    throw new APIError("BAD_REQUEST", {
      message: "Email is the same"
    });
  }
  const existingUser = await ctx.context.internalAdapter.findUserByEmail(newEmail);
  if (existingUser) {
    ctx.context.logger.error("Email already exists");
    throw new APIError("BAD_REQUEST", {
      message: "Couldn't update your email"
    });
  }
  if (ctx.context.session.user.emailVerified !== true) {
    const existing = await ctx.context.internalAdapter.findUserByEmail(newEmail);
    if (existing) {
      throw new APIError("UNPROCESSABLE_ENTITY", {
        message: BASE_ERROR_CODES.USER_ALREADY_EXISTS
      });
    }
    await ctx.context.internalAdapter.updateUserByEmail(ctx.context.session.user.email, {
      email: newEmail
    }, ctx);
    await setSessionCookie(ctx, {
      session: ctx.context.session.session,
      user: {
        ...ctx.context.session.user,
        email: newEmail
      }
    });
    if (ctx.context.options.emailVerification?.sendVerificationEmail) {
      const token2 = await createEmailVerificationToken(ctx.context.secret, newEmail, undefined, ctx.context.options.emailVerification?.expiresIn);
      const url22 = `${ctx.context.baseURL}/verify-email?token=${token2}&callbackURL=${ctx.body.callbackURL || "/"}`;
      await ctx.context.options.emailVerification.sendVerificationEmail({
        user: {
          ...ctx.context.session.user,
          email: newEmail
        },
        url: url22,
        token: token2
      }, ctx.request);
    }
    return ctx.json({
      status: true
    });
  }
  if (!ctx.context.options.user.changeEmail.sendChangeEmailVerification) {
    ctx.context.logger.error("Verification email isn't enabled.");
    throw new APIError("BAD_REQUEST", {
      message: "Verification email isn't enabled"
    });
  }
  const token = await createEmailVerificationToken(ctx.context.secret, ctx.context.session.user.email, newEmail, ctx.context.options.emailVerification?.expiresIn);
  const url2 = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
  await ctx.context.options.user.changeEmail.sendChangeEmailVerification({
    user: ctx.context.session.user,
    newEmail,
    url: url2,
    token
  }, ctx.request);
  return ctx.json({
    status: true
  });
});
function sanitize(input) {
  return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
var html = (errorCode = "Unknown") => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${sanitize(errorCode)}</span></div>
    </div>
</body>
</html>`;
var error = createAuthEndpoint("/error", {
  method: "GET",
  metadata: {
    ...HIDE_METADATA,
    openapi: {
      description: "Displays an error page",
      responses: {
        "200": {
          description: "Success",
          content: {
            "text/html": {
              schema: {
                type: "string",
                description: "The HTML content of the error page"
              }
            }
          }
        }
      }
    }
  }
}, async (c) => {
  const query = new URL(c.request?.url || "").searchParams.get("error") || "Unknown";
  return new Response(html(query), {
    headers: {
      "Content-Type": "text/html"
    }
  });
});
var ok = createAuthEndpoint("/ok", {
  method: "GET",
  metadata: {
    ...HIDE_METADATA,
    openapi: {
      description: "Check if the API is working",
      responses: {
        "200": {
          description: "API is working",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  ok: {
                    type: "boolean",
                    description: "Indicates if the API is working"
                  }
                },
                required: ["ok"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  return ctx.json({
    ok: true
  });
});
var listUserAccounts = createAuthEndpoint("/list-accounts", {
  method: "GET",
  use: [sessionMiddleware],
  metadata: {
    openapi: {
      description: "List all accounts linked to the user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: {
                      type: "string"
                    },
                    provider: {
                      type: "string"
                    },
                    createdAt: {
                      type: "string",
                      format: "date-time"
                    },
                    updatedAt: {
                      type: "string",
                      format: "date-time"
                    }
                  },
                  accountId: {
                    type: "string"
                  },
                  scopes: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                },
                required: [
                  "id",
                  "provider",
                  "createdAt",
                  "updatedAt",
                  "accountId",
                  "scopes"
                ]
              }
            }
          }
        }
      }
    }
  }
}, async (c) => {
  const session = c.context.session;
  const accounts = await c.context.internalAdapter.findAccounts(session.user.id);
  return c.json(accounts.map((a) => ({
    id: a.id,
    provider: a.providerId,
    createdAt: a.createdAt,
    updatedAt: a.updatedAt,
    accountId: a.accountId,
    scopes: a.scope?.split(",") || []
  })));
});
var linkSocialAccount = createAuthEndpoint("/link-social", {
  method: "POST",
  requireHeaders: true,
  body: exports_external.object({
    callbackURL: exports_external.string({
      description: "The URL to redirect to after the user has signed in"
    }).optional(),
    provider: SocialProviderListEnum,
    scopes: exports_external.array(exports_external.string(), {
      description: "Additional scopes to request from the provider"
    }).optional(),
    errorCallbackURL: exports_external.string({
      description: "The URL to redirect to if there is an error during the link process"
    }).optional()
  }),
  use: [sessionMiddleware],
  metadata: {
    openapi: {
      description: "Link a social account to the user",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  url: {
                    type: "string",
                    description: "The authorization URL to redirect the user to"
                  },
                  redirect: {
                    type: "boolean",
                    description: "Indicates if the user should be redirected to the authorization URL"
                  }
                },
                required: ["url", "redirect"]
              }
            }
          }
        }
      }
    }
  }
}, async (c) => {
  const session = c.context.session;
  const provider = c.context.socialProviders.find((p) => p.id === c.body.provider);
  if (!provider) {
    c.context.logger.error("Provider not found. Make sure to add the provider in your auth config", {
      provider: c.body.provider
    });
    throw new APIError("NOT_FOUND", {
      message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND
    });
  }
  const state = await generateState(c, {
    userId: session.user.id,
    email: session.user.email
  });
  const url2 = await provider.createAuthorizationURL({
    state: state.state,
    codeVerifier: state.codeVerifier,
    redirectURI: `${c.context.baseURL}/callback/${provider.id}`,
    scopes: c.body.scopes
  });
  return c.json({
    url: url2.toString(),
    redirect: true
  });
});
var unlinkAccount = createAuthEndpoint("/unlink-account", {
  method: "POST",
  body: exports_external.object({
    providerId: exports_external.string(),
    accountId: exports_external.string().optional()
  }),
  use: [freshSessionMiddleware],
  metadata: {
    openapi: {
      description: "Unlink an account",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  status: {
                    type: "boolean"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  const { providerId, accountId } = ctx.body;
  const accounts = await ctx.context.internalAdapter.findAccounts(ctx.context.session.user.id);
  if (accounts.length === 1 && !ctx.context.options.account?.accountLinking?.allowUnlinkingAll) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.FAILED_TO_UNLINK_LAST_ACCOUNT
    });
  }
  const accountExist = accounts.find((account) => accountId ? account.accountId === accountId && account.providerId === providerId : account.providerId === providerId);
  if (!accountExist) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.ACCOUNT_NOT_FOUND
    });
  }
  await ctx.context.internalAdapter.deleteAccount(accountExist.id);
  return ctx.json({
    status: true
  });
});
var getAccessToken = createAuthEndpoint("/get-access-token", {
  method: "POST",
  body: exports_external.object({
    providerId: exports_external.string({
      description: "The provider ID for the OAuth provider"
    }),
    accountId: exports_external.string({
      description: "The account ID associated with the refresh token"
    }).optional(),
    userId: exports_external.string({
      description: "The user ID associated with the account"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Get a valid access token, doing a refresh if needed",
      responses: {
        200: {
          description: "A Valid access token",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  tokenType: {
                    type: "string"
                  },
                  idToken: {
                    type: "string"
                  },
                  accessToken: {
                    type: "string"
                  },
                  refreshToken: {
                    type: "string"
                  },
                  accessTokenExpiresAt: {
                    type: "string",
                    format: "date-time"
                  },
                  refreshTokenExpiresAt: {
                    type: "string",
                    format: "date-time"
                  }
                }
              }
            }
          }
        },
        400: {
          description: "Invalid refresh token or provider configuration"
        }
      }
    }
  }
}, async (ctx) => {
  const { providerId, accountId, userId } = ctx.body;
  const req = ctx.request;
  const session = await getSessionFromCtx(ctx);
  if (req && !session) {
    throw ctx.error("UNAUTHORIZED");
  }
  let resolvedUserId = session?.user?.id || userId;
  if (!resolvedUserId) {
    throw new APIError("BAD_REQUEST", {
      message: `Either userId or session is required`
    });
  }
  if (!ctx.context.socialProviders.find((p) => p.id === providerId)) {
    throw new APIError("BAD_REQUEST", {
      message: `Provider ${providerId} is not supported.`
    });
  }
  const accounts = await ctx.context.internalAdapter.findAccounts(resolvedUserId);
  const account = accounts.find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);
  if (!account) {
    throw new APIError("BAD_REQUEST", {
      message: "Account not found"
    });
  }
  const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
  if (!provider) {
    throw new APIError("BAD_REQUEST", {
      message: `Provider ${providerId} not found.`
    });
  }
  try {
    let newTokens = null;
    if (account.refreshToken && (!account.accessTokenExpiresAt || account.accessTokenExpiresAt.getTime() - Date.now() < 5000) && provider.refreshAccessToken) {
      newTokens = await provider.refreshAccessToken(account.refreshToken);
      await ctx.context.internalAdapter.updateAccount(account.id, {
        accessToken: newTokens.accessToken,
        accessTokenExpiresAt: newTokens.accessTokenExpiresAt,
        refreshToken: newTokens.refreshToken,
        refreshTokenExpiresAt: newTokens.refreshTokenExpiresAt
      });
    }
    const tokens = {
      accessToken: newTokens?.accessToken ?? account.accessToken ?? undefined,
      accessTokenExpiresAt: newTokens?.accessTokenExpiresAt ?? account.accessTokenExpiresAt ?? undefined,
      scopes: account.scope?.split(",") ?? [],
      idToken: newTokens?.idToken ?? account.idToken ?? undefined
    };
    return ctx.json(tokens);
  } catch (error2) {
    throw new APIError("BAD_REQUEST", {
      message: "Failed to get a valid access token",
      cause: error2
    });
  }
});
var refreshToken = createAuthEndpoint("/refresh-token", {
  method: "POST",
  body: exports_external.object({
    providerId: exports_external.string({
      description: "The provider ID for the OAuth provider"
    }),
    accountId: exports_external.string({
      description: "The account ID associated with the refresh token"
    }).optional(),
    userId: exports_external.string({
      description: "The user ID associated with the account"
    }).optional()
  }),
  metadata: {
    openapi: {
      description: "Refresh the access token using a refresh token",
      responses: {
        200: {
          description: "Access token refreshed successfully",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  tokenType: {
                    type: "string"
                  },
                  idToken: {
                    type: "string"
                  },
                  accessToken: {
                    type: "string"
                  },
                  refreshToken: {
                    type: "string"
                  },
                  accessTokenExpiresAt: {
                    type: "string",
                    format: "date-time"
                  },
                  refreshTokenExpiresAt: {
                    type: "string",
                    format: "date-time"
                  }
                }
              }
            }
          }
        },
        400: {
          description: "Invalid refresh token or provider configuration"
        }
      }
    }
  }
}, async (ctx) => {
  const { providerId, accountId, userId } = ctx.body;
  const req = ctx.request;
  const session = await getSessionFromCtx(ctx);
  if (req && !session) {
    throw ctx.error("UNAUTHORIZED");
  }
  let resolvedUserId = session?.user?.id || userId;
  if (!resolvedUserId) {
    throw new APIError("BAD_REQUEST", {
      message: `Either userId or session is required`
    });
  }
  if (!ctx.context.socialProviders.find((p) => p.id === providerId)) {
    throw new APIError("BAD_REQUEST", {
      message: `Provider ${providerId} is not supported.`
    });
  }
  const accounts = await ctx.context.internalAdapter.findAccounts(resolvedUserId);
  const account = accounts.find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);
  if (!account) {
    throw new APIError("BAD_REQUEST", {
      message: "Account not found"
    });
  }
  const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
  if (!provider) {
    throw new APIError("BAD_REQUEST", {
      message: `Provider ${providerId} not found.`
    });
  }
  if (!provider.refreshAccessToken) {
    throw new APIError("BAD_REQUEST", {
      message: `Provider ${providerId} does not support token refreshing.`
    });
  }
  try {
    const tokens = await provider.refreshAccessToken(account.refreshToken);
    await ctx.context.internalAdapter.updateAccount(account.id, {
      accessToken: tokens.accessToken,
      accessTokenExpiresAt: tokens.accessTokenExpiresAt,
      refreshToken: tokens.refreshToken,
      refreshTokenExpiresAt: tokens.refreshTokenExpiresAt
    });
    return ctx.json(tokens);
  } catch (error2) {
    throw new APIError("BAD_REQUEST", {
      message: "Failed to refresh access token",
      cause: error2
    });
  }
});
var accountInfo = createAuthEndpoint("/account-info", {
  method: "POST",
  use: [sessionMiddleware],
  metadata: {
    openapi: {
      description: "Get the account info provided by the provider",
      responses: {
        "200": {
          description: "Success",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  user: {
                    type: "object",
                    properties: {
                      id: {
                        type: "string"
                      },
                      name: {
                        type: "string"
                      },
                      email: {
                        type: "string"
                      },
                      image: {
                        type: "string"
                      },
                      emailVerified: {
                        type: "boolean"
                      }
                    },
                    required: ["id", "emailVerified"]
                  },
                  data: {
                    type: "object",
                    properties: {},
                    additionalProperties: true
                  }
                },
                required: ["user", "data"],
                additionalProperties: false
              }
            }
          }
        }
      }
    }
  },
  body: exports_external.object({
    accountId: exports_external.string({
      description: "The provider given account id for which to get the account info"
    })
  })
}, async (ctx) => {
  const account = await ctx.context.internalAdapter.findAccount(ctx.body.accountId);
  if (!account || account.userId !== ctx.context.session.user.id) {
    throw new APIError("BAD_REQUEST", {
      message: "Account not found"
    });
  }
  const provider = ctx.context.socialProviders.find((p) => p.id === account.providerId);
  if (!provider) {
    throw new APIError("INTERNAL_SERVER_ERROR", {
      message: `Provider account provider is ${account.providerId} but it is not configured`
    });
  }
  const tokens = await getAccessToken({
    ...ctx,
    body: {
      accountId: account.id,
      providerId: account.providerId
    },
    returnHeaders: false
  });
  const info = await provider.getUserInfo(tokens);
  return ctx.json(info);
});
// ../../node_modules/better-auth/dist/shared/better-auth.iKoUsdFE.mjs
function getIp(req, options) {
  if (options.advanced?.ipAddress?.disableIpTracking) {
    return null;
  }
  const testIP = "127.0.0.1";
  if (isTest) {
    return testIP;
  }
  const headers = "headers" in req ? req.headers : req;
  const defaultHeaders = ["x-forwarded-for"];
  const ipHeaders = options.advanced?.ipAddress?.ipAddressHeaders || defaultHeaders;
  for (const key of ipHeaders) {
    const value = "get" in headers ? headers.get(key) : headers[key];
    if (typeof value === "string") {
      const ip = value.split(",")[0].trim();
      if (isValidIP3(ip)) {
        return ip;
      }
    }
  }
  return null;
}
function isValidIP3(ip) {
  const ipv4Regex3 = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (ipv4Regex3.test(ip)) {
    const parts = ip.split(".").map(Number);
    return parts.every((part) => part >= 0 && part <= 255);
  }
  const ipv6Regex3 = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  return ipv6Regex3.test(ip);
}

// ../../node_modules/better-auth/dist/api/index.mjs
var signUpEmail = () => createAuthEndpoint("/sign-up/email", {
  method: "POST",
  body: exports_external.record(exports_external.string(), exports_external.any()),
  metadata: {
    $Infer: {
      body: {}
    },
    openapi: {
      description: "Sign up a user using email and password",
      requestBody: {
        content: {
          "application/json": {
            schema: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  description: "The name of the user"
                },
                email: {
                  type: "string",
                  description: "The email of the user"
                },
                password: {
                  type: "string",
                  description: "The password of the user"
                },
                callbackURL: {
                  type: "string",
                  description: "The URL to use for email verification callback"
                }
              },
              required: ["name", "email", "password"]
            }
          }
        }
      },
      responses: {
        "200": {
          description: "Successfully created user",
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  token: {
                    type: "string",
                    nullable: true,
                    description: "Authentication token for the session"
                  },
                  user: {
                    type: "object",
                    properties: {
                      id: {
                        type: "string",
                        description: "The unique identifier of the user"
                      },
                      email: {
                        type: "string",
                        format: "email",
                        description: "The email address of the user"
                      },
                      name: {
                        type: "string",
                        description: "The name of the user"
                      },
                      image: {
                        type: "string",
                        format: "uri",
                        nullable: true,
                        description: "The profile image URL of the user"
                      },
                      emailVerified: {
                        type: "boolean",
                        description: "Whether the email has been verified"
                      },
                      createdAt: {
                        type: "string",
                        format: "date-time",
                        description: "When the user was created"
                      },
                      updatedAt: {
                        type: "string",
                        format: "date-time",
                        description: "When the user was last updated"
                      }
                    },
                    required: [
                      "id",
                      "email",
                      "name",
                      "emailVerified",
                      "createdAt",
                      "updatedAt"
                    ]
                  }
                },
                required: ["user"]
              }
            }
          }
        }
      }
    }
  }
}, async (ctx) => {
  if (!ctx.context.options.emailAndPassword?.enabled || ctx.context.options.emailAndPassword?.disableSignUp) {
    throw new APIError("BAD_REQUEST", {
      message: "Email and password sign up is not enabled"
    });
  }
  const body = ctx.body;
  const { name, email, password, image, callbackURL, ...additionalFields } = body;
  const isValidEmail = exports_external.string().email().safeParse(email);
  if (!isValidEmail.success) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.INVALID_EMAIL
    });
  }
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (password.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT
    });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (password.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.PASSWORD_TOO_LONG
    });
  }
  const dbUser = await ctx.context.internalAdapter.findUserByEmail(email);
  if (dbUser?.user) {
    ctx.context.logger.info(`Sign-up attempt for existing email: ${email}`);
    throw new APIError("UNPROCESSABLE_ENTITY", {
      message: BASE_ERROR_CODES.USER_ALREADY_EXISTS
    });
  }
  const additionalData = parseUserInput(ctx.context.options, additionalFields);
  const hash = await ctx.context.password.hash(password);
  let createdUser;
  try {
    createdUser = await ctx.context.internalAdapter.createUser({
      email: email.toLowerCase(),
      name,
      image,
      ...additionalData,
      emailVerified: false
    }, ctx);
    if (!createdUser) {
      throw new APIError("BAD_REQUEST", {
        message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER
      });
    }
  } catch (e) {
    if (isDevelopment) {
      ctx.context.logger.error("Failed to create user", e);
    }
    if (e instanceof APIError) {
      throw e;
    }
    throw new APIError("UNPROCESSABLE_ENTITY", {
      message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,
      details: e
    });
  }
  if (!createdUser) {
    throw new APIError("UNPROCESSABLE_ENTITY", {
      message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER
    });
  }
  await ctx.context.internalAdapter.linkAccount({
    userId: createdUser.id,
    providerId: "credential",
    accountId: createdUser.id,
    password: hash
  }, ctx);
  if (ctx.context.options.emailVerification?.sendOnSignUp || ctx.context.options.emailAndPassword.requireEmailVerification) {
    const token = await createEmailVerificationToken(ctx.context.secret, createdUser.email, undefined, ctx.context.options.emailVerification?.expiresIn);
    const url2 = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${body.callbackURL || "/"}`;
    await ctx.context.options.emailVerification?.sendVerificationEmail?.({
      user: createdUser,
      url: url2,
      token
    }, ctx.request);
  }
  if (ctx.context.options.emailAndPassword.autoSignIn === false || ctx.context.options.emailAndPassword.requireEmailVerification) {
    return ctx.json({
      token: null,
      user: {
        id: createdUser.id,
        email: createdUser.email,
        name: createdUser.name,
        image: createdUser.image,
        emailVerified: createdUser.emailVerified,
        createdAt: createdUser.createdAt,
        updatedAt: createdUser.updatedAt
      }
    });
  }
  const session = await ctx.context.internalAdapter.createSession(createdUser.id, ctx);
  if (!session) {
    throw new APIError("BAD_REQUEST", {
      message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION
    });
  }
  await setSessionCookie(ctx, {
    session,
    user: createdUser
  });
  return ctx.json({
    token: session.token,
    user: {
      id: createdUser.id,
      email: createdUser.email,
      name: createdUser.name,
      image: createdUser.image,
      emailVerified: createdUser.emailVerified,
      createdAt: createdUser.createdAt,
      updatedAt: createdUser.updatedAt
    }
  });
});
function shouldRateLimit(max, window2, rateLimitData) {
  const now = Date.now();
  const windowInMs = window2 * 1000;
  const timeSinceLastRequest = now - rateLimitData.lastRequest;
  return timeSinceLastRequest < windowInMs && rateLimitData.count >= max;
}
function rateLimitResponse(retryAfter) {
  return new Response(JSON.stringify({
    message: "Too many requests. Please try again later."
  }), {
    status: 429,
    statusText: "Too Many Requests",
    headers: {
      "X-Retry-After": retryAfter.toString()
    }
  });
}
function getRetryAfter(lastRequest, window2) {
  const now = Date.now();
  const windowInMs = window2 * 1000;
  return Math.ceil((lastRequest + windowInMs - now) / 1000);
}
function createDBStorage(ctx, modelName) {
  const model = ctx.options.rateLimit?.modelName || "rateLimit";
  const db = ctx.adapter;
  return {
    get: async (key) => {
      const res = await db.findMany({
        model,
        where: [{ field: "key", value: key }]
      });
      const data = res[0];
      if (typeof data?.lastRequest === "bigint") {
        data.lastRequest = Number(data.lastRequest);
      }
      return data;
    },
    set: async (key, value, _update) => {
      try {
        if (_update) {
          await db.updateMany({
            model: "rateLimit",
            where: [{ field: "key", value: key }],
            update: {
              count: value.count,
              lastRequest: value.lastRequest
            }
          });
        } else {
          await db.create({
            model: "rateLimit",
            data: {
              key,
              count: value.count,
              lastRequest: value.lastRequest
            }
          });
        }
      } catch (e) {
        ctx.logger.error("Error setting rate limit", e);
      }
    }
  };
}
var memory = /* @__PURE__ */ new Map;
function getRateLimitStorage(ctx) {
  if (ctx.options.rateLimit?.customStorage) {
    return ctx.options.rateLimit.customStorage;
  }
  if (ctx.rateLimit.storage === "secondary-storage") {
    return {
      get: async (key) => {
        const stringified = await ctx.options.secondaryStorage?.get(key);
        return stringified ? JSON.parse(stringified) : undefined;
      },
      set: async (key, value) => {
        await ctx.options.secondaryStorage?.set?.(key, JSON.stringify(value));
      }
    };
  }
  const storage = ctx.rateLimit.storage;
  if (storage === "memory") {
    return {
      async get(key) {
        return memory.get(key);
      },
      async set(key, value, _update) {
        memory.set(key, value);
      }
    };
  }
  return createDBStorage(ctx, ctx.rateLimit.modelName);
}
async function onRequestRateLimit(req, ctx) {
  if (!ctx.rateLimit.enabled) {
    return;
  }
  const path = new URL(req.url).pathname.replace(ctx.options.basePath || "/api/auth", "");
  let window2 = ctx.rateLimit.window;
  let max = ctx.rateLimit.max;
  const ip = getIp(req, ctx.options);
  if (!ip) {
    return;
  }
  const key = ip + path;
  const specialRules = getDefaultSpecialRules();
  const specialRule = specialRules.find((rule) => rule.pathMatcher(path));
  if (specialRule) {
    window2 = specialRule.window;
    max = specialRule.max;
  }
  for (const plugin of ctx.options.plugins || []) {
    if (plugin.rateLimit) {
      const matchedRule = plugin.rateLimit.find((rule) => rule.pathMatcher(path));
      if (matchedRule) {
        window2 = matchedRule.window;
        max = matchedRule.max;
        break;
      }
    }
  }
  if (ctx.rateLimit.customRules) {
    const _path = Object.keys(ctx.rateLimit.customRules).find((p) => {
      if (p.includes("*")) {
        const isMatch2 = wildcardMatch(p)(path);
        return isMatch2;
      }
      return p === path;
    });
    if (_path) {
      const customRule = ctx.rateLimit.customRules[_path];
      const resolved = typeof customRule === "function" ? await customRule(req) : customRule;
      if (resolved) {
        window2 = resolved.window;
        max = resolved.max;
      }
    }
  }
  const storage = getRateLimitStorage(ctx);
  const data = await storage.get(key);
  const now = Date.now();
  if (!data) {
    await storage.set(key, {
      key,
      count: 1,
      lastRequest: now
    });
  } else {
    const timeSinceLastRequest = now - data.lastRequest;
    if (shouldRateLimit(max, window2, data)) {
      const retryAfter = getRetryAfter(data.lastRequest, window2);
      return rateLimitResponse(retryAfter);
    } else if (timeSinceLastRequest > window2 * 1000) {
      await storage.set(key, {
        ...data,
        count: 1,
        lastRequest: now
      }, true);
    } else {
      await storage.set(key, {
        ...data,
        count: data.count + 1,
        lastRequest: now
      }, true);
    }
  }
}
function getDefaultSpecialRules() {
  const specialRules = [
    {
      pathMatcher(path) {
        return path.startsWith("/sign-in") || path.startsWith("/sign-up") || path.startsWith("/change-password") || path.startsWith("/change-email");
      },
      window: 10,
      max: 3
    }
  ];
  return specialRules;
}
function toAuthEndpoints(endpoints, ctx) {
  const api = {};
  for (const [key, endpoint] of Object.entries(endpoints)) {
    api[key] = async (context) => {
      const authContext = await ctx;
      let internalContext = {
        ...context,
        context: {
          ...authContext,
          returned: undefined,
          responseHeaders: undefined,
          session: null
        },
        path: endpoint.path,
        headers: context?.headers ? new Headers(context?.headers) : undefined
      };
      const { beforeHooks, afterHooks } = getHooks(authContext);
      const before = await runBeforeHooks(internalContext, beforeHooks);
      if ("context" in before && before.context && typeof before.context === "object") {
        const { headers, ...rest } = before.context;
        if (headers) {
          headers.forEach((value, key2) => {
            internalContext.headers.set(key2, value);
          });
        }
        internalContext = defu(rest, internalContext);
      } else if (before) {
        return before;
      }
      internalContext.asResponse = false;
      internalContext.returnHeaders = true;
      const result = await endpoint(internalContext).catch((e) => {
        if (e instanceof APIError) {
          return {
            response: e,
            headers: e.headers ? new Headers(e.headers) : null
          };
        }
        throw e;
      });
      internalContext.context.returned = result.response;
      internalContext.context.responseHeaders = result.headers;
      const after = await runAfterHooks(internalContext, afterHooks);
      if (after.response) {
        result.response = after.response;
      }
      if (result.response instanceof APIError && !context?.asResponse) {
        throw result.response;
      }
      const response = context?.asResponse ? toResponse(result.response, {
        headers: result.headers
      }) : context?.returnHeaders ? {
        headers: result.headers,
        response: result.response
      } : result.response;
      return response;
    };
    api[key].path = endpoint.path;
    api[key].options = endpoint.options;
  }
  return api;
}
async function runBeforeHooks(context, hooks) {
  let modifiedContext = {};
  for (const hook of hooks) {
    if (hook.matcher(context)) {
      const result = await hook.handler({
        ...context,
        returnHeaders: false
      });
      if (result && typeof result === "object") {
        if ("context" in result && typeof result.context === "object") {
          const { headers, ...rest } = result.context;
          if (headers instanceof Headers) {
            if (modifiedContext.headers) {
              headers.forEach((value, key) => {
                modifiedContext.headers?.set(key, value);
              });
            } else {
              modifiedContext.headers = headers;
            }
          }
          modifiedContext = defu(rest, modifiedContext);
          continue;
        }
        return result;
      }
    }
  }
  return { context: modifiedContext };
}
async function runAfterHooks(context, hooks) {
  for (const hook of hooks) {
    if (hook.matcher(context)) {
      const result = await hook.handler(context).catch((e) => {
        if (e instanceof APIError) {
          return {
            response: e,
            headers: e.headers ? new Headers(e.headers) : null
          };
        }
        throw e;
      });
      if (result.headers) {
        result.headers.forEach((value, key) => {
          if (!context.context.responseHeaders) {
            context.context.responseHeaders = new Headers({
              [key]: value
            });
          } else {
            if (key.toLowerCase() === "set-cookie") {
              context.context.responseHeaders.append(key, value);
            } else {
              context.context.responseHeaders.set(key, value);
            }
          }
        });
      }
      if (result.response) {
        context.context.returned = result.response;
      }
    }
  }
  return {
    response: context.context.returned,
    headers: context.context.responseHeaders
  };
}
function getHooks(authContext) {
  const plugins = authContext.options.plugins || [];
  const beforeHooks = [];
  const afterHooks = [];
  if (authContext.options.hooks?.before) {
    beforeHooks.push({
      matcher: () => true,
      handler: authContext.options.hooks.before
    });
  }
  if (authContext.options.hooks?.after) {
    afterHooks.push({
      matcher: () => true,
      handler: authContext.options.hooks.after
    });
  }
  const pluginBeforeHooks = plugins.map((plugin) => {
    if (plugin.hooks?.before) {
      return plugin.hooks.before;
    }
  }).filter((plugin) => plugin !== undefined).flat();
  const pluginAfterHooks = plugins.map((plugin) => {
    if (plugin.hooks?.after) {
      return plugin.hooks.after;
    }
  }).filter((plugin) => plugin !== undefined).flat();
  pluginBeforeHooks.length && beforeHooks.push(...pluginBeforeHooks);
  pluginAfterHooks.length && afterHooks.push(...pluginAfterHooks);
  return {
    beforeHooks,
    afterHooks
  };
}
function getEndpoints(ctx, options) {
  const pluginEndpoints = options.plugins?.reduce((acc, plugin) => {
    return {
      ...acc,
      ...plugin.endpoints
    };
  }, {});
  const middlewares = options.plugins?.map((plugin) => plugin.middlewares?.map((m) => {
    const middleware = async (context) => {
      return m.middleware({
        ...context,
        context: {
          ...ctx,
          ...context.context
        }
      });
    };
    middleware.options = m.middleware.options;
    return {
      path: m.path,
      middleware
    };
  })).filter((plugin) => plugin !== undefined).flat() || [];
  const baseEndpoints = {
    signInSocial,
    callbackOAuth,
    getSession: getSession(),
    signOut,
    signUpEmail: signUpEmail(),
    signInEmail,
    forgetPassword,
    resetPassword,
    verifyEmail,
    sendVerificationEmail,
    changeEmail,
    changePassword,
    setPassword,
    updateUser: updateUser(),
    deleteUser,
    forgetPasswordCallback,
    requestPasswordReset,
    requestPasswordResetCallback,
    listSessions: listSessions(),
    revokeSession,
    revokeSessions,
    revokeOtherSessions,
    linkSocialAccount,
    listUserAccounts,
    deleteUserCallback,
    unlinkAccount,
    refreshToken,
    getAccessToken,
    accountInfo
  };
  const endpoints = {
    ...baseEndpoints,
    ...pluginEndpoints,
    ok,
    error
  };
  const api = toAuthEndpoints(endpoints, ctx);
  return {
    api,
    middlewares
  };
}
var router = (ctx, options) => {
  const { api, middlewares } = getEndpoints(ctx, options);
  const basePath = new URL(ctx.baseURL).pathname;
  return createRouter2(api, {
    routerContext: ctx,
    openapi: {
      disabled: true
    },
    basePath,
    routerMiddleware: [
      {
        path: "/**",
        middleware: originCheckMiddleware
      },
      ...middlewares
    ],
    async onRequest(req) {
      const disabledPaths = ctx.options.disabledPaths || [];
      const path = new URL(req.url).pathname.replace(basePath, "");
      if (disabledPaths.includes(path)) {
        return new Response("Not Found", { status: 404 });
      }
      for (const plugin of ctx.options.plugins || []) {
        if (plugin.onRequest) {
          const response = await plugin.onRequest(req, ctx);
          if (response && "response" in response) {
            return response.response;
          }
        }
      }
      return onRequestRateLimit(req, ctx);
    },
    async onResponse(res) {
      for (const plugin of ctx.options.plugins || []) {
        if (plugin.onResponse) {
          const response = await plugin.onResponse(res, ctx);
          if (response) {
            return response.response;
          }
        }
      }
      return res;
    },
    onError(e) {
      if (e instanceof APIError && e.status === "FOUND") {
        return;
      }
      if (options.onAPIError?.throw) {
        throw e;
      }
      if (options.onAPIError?.onError) {
        options.onAPIError.onError(e, ctx);
        return;
      }
      const optLogLevel = options.logger?.level;
      const log = optLogLevel === "error" || optLogLevel === "warn" || optLogLevel === "debug" ? logger : undefined;
      if (options.logger?.disabled !== true) {
        if (e && typeof e === "object" && "message" in e && typeof e.message === "string") {
          if (e.message.includes("no column") || e.message.includes("column") || e.message.includes("relation") || e.message.includes("table") || e.message.includes("does not exist")) {
            ctx.logger?.error(e.message);
            return;
          }
        }
        if (e instanceof APIError) {
          if (e.status === "INTERNAL_SERVER_ERROR") {
            ctx.logger.error(e.status, e);
          }
          log?.error(e.message);
        } else {
          ctx.logger?.error(e && typeof e === "object" && "name" in e ? e.name : "", e);
        }
      }
    }
  });
};

// ../../node_modules/better-auth/dist/shared/better-auth.OT3XFeFk.mjs
function constantTimeEqual(a, b) {
  const aBuffer = new Uint8Array(a);
  const bBuffer = new Uint8Array(b);
  if (aBuffer.length !== bBuffer.length) {
    return false;
  }
  let c = 0;
  for (let i = 0;i < aBuffer.length; i++) {
    c |= aBuffer[i] ^ bBuffer[i];
  }
  return c === 0;
}
var config = {
  N: 16384,
  r: 16,
  p: 1,
  dkLen: 64
};
async function generateKey(password, salt) {
  return await scryptAsync(password.normalize("NFKC"), salt, {
    N: config.N,
    p: config.p,
    r: config.r,
    dkLen: config.dkLen,
    maxmem: 128 * config.N * config.r * 2
  });
}
var hashPassword = async (password) => {
  const salt = hex.encode(getRandomValues(new Uint8Array(16)));
  const key = await generateKey(password, salt);
  return `${salt}:${hex.encode(key)}`;
};
var verifyPassword = async ({
  hash,
  password
}) => {
  const [salt, key] = hash.split(":");
  const targetKey = await generateKey(password, salt);
  return constantTimeEqual(targetKey, hexToBytes2(key));
};

// ../../node_modules/better-auth/dist/shared/better-auth.Cue6reJU.mjs
init_esm();
function getDatabaseType(db) {
  if (!db) {
    return null;
  }
  if ("dialect" in db) {
    return getDatabaseType(db.dialect);
  }
  if ("createDriver" in db) {
    if (db instanceof SqliteDialect) {
      return "sqlite";
    }
    if (db instanceof MysqlDialect) {
      return "mysql";
    }
    if (db instanceof PostgresDialect) {
      return "postgres";
    }
    if (db instanceof MssqlDialect) {
      return "mssql";
    }
  }
  if ("aggregate" in db) {
    return "sqlite";
  }
  if ("getConnection" in db) {
    return "mysql";
  }
  if ("connect" in db) {
    return "postgres";
  }
  if ("fileControl" in db) {
    return "sqlite";
  }
  return null;
}
var createKyselyAdapter = async (config2) => {
  const db = config2.database;
  if (!db) {
    return {
      kysely: null,
      databaseType: null
    };
  }
  if ("db" in db) {
    return {
      kysely: db.db,
      databaseType: db.type
    };
  }
  if ("dialect" in db) {
    return {
      kysely: new Kysely({ dialect: db.dialect }),
      databaseType: db.type
    };
  }
  let dialect2 = undefined;
  const databaseType = getDatabaseType(db);
  if ("createDriver" in db) {
    dialect2 = db;
  }
  if ("aggregate" in db) {
    dialect2 = new SqliteDialect({
      database: db
    });
  }
  if ("getConnection" in db) {
    dialect2 = new MysqlDialect(db);
  }
  if ("connect" in db) {
    dialect2 = new PostgresDialect({
      pool: db
    });
  }
  if ("fileControl" in db) {
    const { BunSqliteDialect: BunSqliteDialect2 } = await Promise.resolve().then(() => (init_bun_sqlite_dialect(), exports_bun_sqlite_dialect));
    dialect2 = new BunSqliteDialect2({
      database: db
    });
  }
  return {
    kysely: dialect2 ? new Kysely({ dialect: dialect2 }) : null,
    databaseType
  };
};
var kyselyAdapter = (db, config2) => createAdapter({
  config: {
    adapterId: "kysely",
    adapterName: "Kysely Adapter",
    usePlural: config2?.usePlural,
    debugLogs: config2?.debugLogs,
    supportsBooleans: config2?.type === "sqlite" || config2?.type === "mssql" || !config2?.type ? false : true,
    supportsDates: config2?.type === "sqlite" || config2?.type === "mssql" || !config2?.type ? false : true,
    supportsJSON: false
  },
  adapter: ({ getFieldName, schema: schema3 }) => {
    const withReturning = async (values, builder, model, where) => {
      let res;
      if (config2?.type === "mysql") {
        await builder.execute();
        const field = values.id ? "id" : where.length > 0 && where[0].field ? where[0].field : "id";
        if (!values.id && where.length === 0) {
          res = await db.selectFrom(model).selectAll().orderBy(getFieldName({ model, field }), "desc").limit(1).executeTakeFirst();
          return res;
        }
        const value = values[field] || where[0].value;
        res = await db.selectFrom(model).selectAll().orderBy(getFieldName({ model, field }), "desc").where(getFieldName({ model, field }), "=", value).limit(1).executeTakeFirst();
        return res;
      }
      if (config2?.type === "mssql") {
        res = await builder.outputAll("inserted").executeTakeFirst();
        return res;
      }
      res = await builder.returningAll().executeTakeFirst();
      return res;
    };
    function transformValueToDB(value, model, field) {
      if (field === "id") {
        return value;
      }
      const { type = "sqlite" } = config2 || {};
      let f = schema3[model]?.fields[field];
      if (!f) {
        f = Object.values(schema3).find((f2) => f2.modelName === model);
      }
      if (f.type === "boolean" && (type === "sqlite" || type === "mssql") && value !== null && value !== undefined) {
        return value ? 1 : 0;
      }
      if (f.type === "date" && value && value instanceof Date) {
        return type === "sqlite" ? value.toISOString() : value;
      }
      return value;
    }
    function convertWhereClause(model, w) {
      if (!w)
        return {
          and: null,
          or: null
        };
      const conditions = {
        and: [],
        or: []
      };
      w.forEach((condition) => {
        let {
          field: _field,
          value,
          operator = "=",
          connector = "AND"
        } = condition;
        const field = getFieldName({ model, field: _field });
        value = transformValueToDB(value, model, _field);
        const expr = (eb) => {
          if (operator.toLowerCase() === "in") {
            return eb(field, "in", Array.isArray(value) ? value : [value]);
          }
          if (operator === "contains") {
            return eb(field, "like", `%${value}%`);
          }
          if (operator === "starts_with") {
            return eb(field, "like", `${value}%`);
          }
          if (operator === "ends_with") {
            return eb(field, "like", `%${value}`);
          }
          if (operator === "eq") {
            return eb(field, "=", value);
          }
          if (operator === "ne") {
            return eb(field, "<>", value);
          }
          if (operator === "gt") {
            return eb(field, ">", value);
          }
          if (operator === "gte") {
            return eb(field, ">=", value);
          }
          if (operator === "lt") {
            return eb(field, "<", value);
          }
          if (operator === "lte") {
            return eb(field, "<=", value);
          }
          return eb(field, operator, value);
        };
        if (connector === "OR") {
          conditions.or.push(expr);
        } else {
          conditions.and.push(expr);
        }
      });
      return {
        and: conditions.and.length ? conditions.and : null,
        or: conditions.or.length ? conditions.or : null
      };
    }
    return {
      async create({ data, model }) {
        const builder = db.insertInto(model).values(data);
        return await withReturning(data, builder, model, []);
      },
      async findOne({ model, where, select }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.selectFrom(model).selectAll();
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        const res = await query.executeTakeFirst();
        if (!res)
          return null;
        return res;
      },
      async findMany({ model, where, limit, offset, sortBy }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.selectFrom(model);
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        if (config2?.type === "mssql") {
          if (!offset) {
            query = query.top(limit || 100);
          }
        } else {
          query = query.limit(limit || 100);
        }
        if (sortBy) {
          query = query.orderBy(getFieldName({ model, field: sortBy.field }), sortBy.direction);
        }
        if (offset) {
          if (config2?.type === "mssql") {
            if (!sortBy) {
              query = query.orderBy(getFieldName({ model, field: "id" }));
            }
            query = query.offset(offset).fetch(limit || 100);
          } else {
            query = query.offset(offset);
          }
        }
        const res = await query.selectAll().execute();
        if (!res)
          return [];
        return res;
      },
      async update({ model, where, update: values }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.updateTable(model).set(values);
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        return await withReturning(values, query, model, where);
      },
      async updateMany({ model, where, update: values }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.updateTable(model).set(values);
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        const res = await query.execute();
        return res.length;
      },
      async count({ model, where }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.selectFrom(model).select(db.fn.count("id").as("count"));
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        const res = await query.execute();
        return res[0].count;
      },
      async delete({ model, where }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.deleteFrom(model);
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        await query.execute();
      },
      async deleteMany({ model, where }) {
        const { and: and2, or: or2 } = convertWhereClause(model, where);
        let query = db.deleteFrom(model);
        if (and2) {
          query = query.where((eb) => eb.and(and2.map((expr) => expr(eb))));
        }
        if (or2) {
          query = query.where((eb) => eb.or(or2.map((expr) => expr(eb))));
        }
        return (await query.execute()).length;
      },
      options: config2
    };
  }
});

// ../../node_modules/better-auth/dist/shared/better-auth.CTsDOF_S.mjs
var memoryAdapter = (db, config2) => createAdapter({
  config: {
    adapterId: "memory",
    adapterName: "Memory Adapter",
    usePlural: false,
    debugLogs: config2?.debugLogs || false,
    customTransformInput(props) {
      if (props.options.advanced?.database?.useNumberId && props.field === "id" && props.action === "create") {
        return db[props.model].length + 1;
      }
      return props.data;
    }
  },
  adapter: ({ getFieldName, options }) => {
    function convertWhereClause(where, table) {
      return table.filter((record) => {
        return where.every((clause) => {
          let { field, value, operator } = clause;
          if (operator === "in") {
            if (!Array.isArray(value)) {
              throw new Error("Value must be an array");
            }
            return value.includes(record[field]);
          } else if (operator === "contains") {
            return record[field].includes(value);
          } else if (operator === "starts_with") {
            return record[field].startsWith(value);
          } else if (operator === "ends_with") {
            return record[field].endsWith(value);
          } else {
            return record[field] === value;
          }
        });
      });
    }
    return {
      create: async ({ model, data }) => {
        if (options.advanced?.database?.useNumberId) {
          data.id = db[model].length + 1;
        }
        db[model].push(data);
        return data;
      },
      findOne: async ({ model, where }) => {
        const table = db[model];
        const res = convertWhereClause(where, table);
        const record = res[0] || null;
        return record;
      },
      findMany: async ({ model, where, sortBy, limit, offset }) => {
        let table = db[model];
        if (where) {
          table = convertWhereClause(where, table);
        }
        if (sortBy) {
          table = table.sort((a, b) => {
            const field = getFieldName({ model, field: sortBy.field });
            if (sortBy.direction === "asc") {
              return a[field] > b[field] ? 1 : -1;
            } else {
              return a[field] < b[field] ? 1 : -1;
            }
          });
        }
        if (offset !== undefined) {
          table = table.slice(offset);
        }
        if (limit !== undefined) {
          table = table.slice(0, limit);
        }
        return table;
      },
      count: async ({ model }) => {
        return db[model].length;
      },
      update: async ({ model, where, update }) => {
        const table = db[model];
        const res = convertWhereClause(where, table);
        res.forEach((record) => {
          Object.assign(record, update);
        });
        return res[0] || null;
      },
      delete: async ({ model, where }) => {
        const table = db[model];
        const res = convertWhereClause(where, table);
        db[model] = table.filter((record) => !res.includes(record));
      },
      deleteMany: async ({ model, where }) => {
        const table = db[model];
        const res = convertWhereClause(where, table);
        let count2 = 0;
        db[model] = table.filter((record) => {
          if (res.includes(record)) {
            count2++;
            return false;
          }
          return !res.includes(record);
        });
        return count2;
      },
      updateMany({ model, where, update }) {
        const table = db[model];
        const res = convertWhereClause(where, table);
        res.forEach((record) => {
          Object.assign(record, update);
        });
        return res[0] || null;
      }
    };
  }
});

// ../../node_modules/better-auth/dist/shared/better-auth.gs0ZuLWb.mjs
function getWithHooks(adapter, ctx) {
  const hooks = ctx.hooks;
  async function createWithHooks(data, model, customCreateFn, context) {
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.create?.before;
      if (toRun) {
        const result = await toRun(actualData, context);
        if (result === false) {
          return null;
        }
        const isObject4 = typeof result === "object" && "data" in result;
        if (isObject4) {
          actualData = {
            ...actualData,
            ...result.data
          };
        }
      }
    }
    const customCreated = customCreateFn ? await customCreateFn.fn(actualData) : null;
    const created = !customCreateFn || customCreateFn.executeMainFn ? await adapter.create({
      model,
      data: actualData
    }) : customCreated;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.create?.after;
      if (toRun) {
        await toRun(created, context);
      }
    }
    return created;
  }
  async function updateWithHooks(data, where, model, customUpdateFn, context) {
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.before;
      if (toRun) {
        const result = await toRun(data, context);
        if (result === false) {
          return null;
        }
        const isObject4 = typeof result === "object";
        actualData = isObject4 ? result.data : result;
      }
    }
    const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
    const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await adapter.update({
      model,
      update: actualData,
      where
    }) : customUpdated;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.after;
      if (toRun) {
        await toRun(updated, context);
      }
    }
    return updated;
  }
  async function updateManyWithHooks(data, where, model, customUpdateFn, context) {
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.before;
      if (toRun) {
        const result = await toRun(data, context);
        if (result === false) {
          return null;
        }
        const isObject4 = typeof result === "object";
        actualData = isObject4 ? result.data : result;
      }
    }
    const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
    const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await adapter.updateMany({
      model,
      update: actualData,
      where
    }) : customUpdated;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.after;
      if (toRun) {
        await toRun(updated, context);
      }
    }
    return updated;
  }
  return {
    createWithHooks,
    updateWithHooks,
    updateManyWithHooks
  };
}
var createInternalAdapter = (adapter, ctx) => {
  const options = ctx.options;
  const secondaryStorage = options.secondaryStorage;
  const sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7;
  const { createWithHooks, updateWithHooks, updateManyWithHooks } = getWithHooks(adapter, ctx);
  return {
    createOAuthUser: async (user, account, context) => {
      const createdUser = await createWithHooks({
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date,
        ...user
      }, "user", undefined, context);
      const createdAccount = await createWithHooks({
        ...account,
        userId: createdUser.id || user.id,
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date
      }, "account", undefined, context);
      return {
        user: createdUser,
        account: createdAccount
      };
    },
    createUser: async (user, context) => {
      const createdUser = await createWithHooks({
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date,
        emailVerified: false,
        ...user,
        email: user.email?.toLowerCase()
      }, "user", undefined, context);
      return createdUser;
    },
    createAccount: async (account, context) => {
      const createdAccount = await createWithHooks({
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date,
        ...account
      }, "account", undefined, context);
      return createdAccount;
    },
    listSessions: async (userId) => {
      if (secondaryStorage) {
        const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
        if (!currentList)
          return [];
        const list = safeJSONParse(currentList) || [];
        const now = Date.now();
        const validSessions = list.filter((s) => s.expiresAt > now);
        const sessions2 = [];
        for (const session of validSessions) {
          const sessionStringified = await secondaryStorage.get(session.token);
          if (sessionStringified) {
            const s = JSON.parse(sessionStringified);
            const parsedSession = parseSessionOutput(ctx.options, {
              ...s.session,
              expiresAt: new Date(s.session.expiresAt)
            });
            sessions2.push(parsedSession);
          }
        }
        return sessions2;
      }
      const sessions = await adapter.findMany({
        model: "session",
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
      return sessions;
    },
    listUsers: async (limit, offset, sortBy, where) => {
      const users = await adapter.findMany({
        model: "user",
        limit,
        offset,
        sortBy,
        where
      });
      return users;
    },
    countTotalUsers: async (where) => {
      const total = await adapter.count({
        model: "user",
        where
      });
      if (typeof total === "string") {
        return parseInt(total);
      }
      return total;
    },
    deleteUser: async (userId) => {
      if (secondaryStorage) {
        await secondaryStorage.delete(`active-sessions-${userId}`);
      }
      if (!secondaryStorage || options.session?.storeSessionInDatabase) {
        await adapter.deleteMany({
          model: "session",
          where: [
            {
              field: "userId",
              value: userId
            }
          ]
        });
      }
      await adapter.deleteMany({
        model: "account",
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
      await adapter.delete({
        model: "user",
        where: [
          {
            field: "id",
            value: userId
          }
        ]
      });
    },
    createSession: async (userId, ctx2, dontRememberMe, override, overrideAll) => {
      const headers = ctx2.headers || ctx2.request?.headers;
      const { id: _, ...rest } = override || {};
      const data = {
        ipAddress: ctx2.request || ctx2.headers ? getIp(ctx2.request || ctx2.headers, ctx2.context.options) || "" : "",
        userAgent: headers?.get("user-agent") || "",
        ...rest,
        expiresAt: dontRememberMe ? getDate(60 * 60 * 24, "sec") : getDate(sessionExpiration, "sec"),
        userId,
        token: generateId(32),
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date,
        ...overrideAll ? rest : {}
      };
      const res = await createWithHooks(data, "session", secondaryStorage ? {
        fn: async (sessionData) => {
          const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
          let list = [];
          const now = Date.now();
          if (currentList) {
            list = safeJSONParse(currentList) || [];
            list = list.filter((session) => session.expiresAt > now);
          }
          list.push({
            token: data.token,
            expiresAt: now + sessionExpiration * 1000
          });
          await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(list), sessionExpiration);
          return sessionData;
        },
        executeMainFn: options.session?.storeSessionInDatabase
      } : undefined, ctx2);
      return res;
    },
    findSession: async (token) => {
      if (secondaryStorage) {
        const sessionStringified = await secondaryStorage.get(token);
        if (!sessionStringified && !options.session?.storeSessionInDatabase) {
          return null;
        }
        if (sessionStringified) {
          const s = JSON.parse(sessionStringified);
          const parsedSession2 = parseSessionOutput(ctx.options, {
            ...s.session,
            expiresAt: new Date(s.session.expiresAt),
            createdAt: new Date(s.session.createdAt),
            updatedAt: new Date(s.session.updatedAt)
          });
          const parsedUser2 = parseUserOutput(ctx.options, {
            ...s.user,
            createdAt: new Date(s.user.createdAt),
            updatedAt: new Date(s.user.updatedAt)
          });
          return {
            session: parsedSession2,
            user: parsedUser2
          };
        }
      }
      const session = await adapter.findOne({
        model: "session",
        where: [
          {
            value: token,
            field: "token"
          }
        ]
      });
      if (!session) {
        return null;
      }
      const user = await adapter.findOne({
        model: "user",
        where: [
          {
            value: session.userId,
            field: "id"
          }
        ]
      });
      if (!user) {
        return null;
      }
      const parsedSession = parseSessionOutput(ctx.options, session);
      const parsedUser = parseUserOutput(ctx.options, user);
      return {
        session: parsedSession,
        user: parsedUser
      };
    },
    findSessions: async (sessionTokens) => {
      if (secondaryStorage) {
        const sessions2 = [];
        for (const sessionToken of sessionTokens) {
          const sessionStringified = await secondaryStorage.get(sessionToken);
          if (sessionStringified) {
            const s = JSON.parse(sessionStringified);
            const session = {
              session: {
                ...s.session,
                expiresAt: new Date(s.session.expiresAt)
              },
              user: {
                ...s.user,
                createdAt: new Date(s.user.createdAt),
                updatedAt: new Date(s.user.updatedAt)
              }
            };
            sessions2.push(session);
          }
        }
        return sessions2;
      }
      const sessions = await adapter.findMany({
        model: "session",
        where: [
          {
            field: "token",
            value: sessionTokens,
            operator: "in"
          }
        ]
      });
      const userIds = sessions.map((session) => {
        return session.userId;
      });
      if (!userIds.length)
        return [];
      const users = await adapter.findMany({
        model: "user",
        where: [
          {
            field: "id",
            value: userIds,
            operator: "in"
          }
        ]
      });
      return sessions.map((session) => {
        const user = users.find((u) => u.id === session.userId);
        if (!user)
          return null;
        return {
          session,
          user
        };
      });
    },
    updateSession: async (sessionToken, session, context) => {
      const updatedSession = await updateWithHooks(session, [{ field: "token", value: sessionToken }], "session", secondaryStorage ? {
        async fn(data) {
          const currentSession = await secondaryStorage.get(sessionToken);
          let updatedSession2 = null;
          if (currentSession) {
            const parsedSession = JSON.parse(currentSession);
            updatedSession2 = {
              ...parsedSession.session,
              ...data
            };
            return updatedSession2;
          } else {
            return null;
          }
        },
        executeMainFn: options.session?.storeSessionInDatabase
      } : undefined, context);
      return updatedSession;
    },
    deleteSession: async (token) => {
      if (secondaryStorage) {
        await secondaryStorage.delete(token);
        if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) {
          return;
        }
      }
      await adapter.delete({
        model: "session",
        where: [
          {
            field: "token",
            value: token
          }
        ]
      });
    },
    deleteAccounts: async (userId) => {
      await adapter.deleteMany({
        model: "account",
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
    },
    deleteAccount: async (accountId) => {
      await adapter.delete({
        model: "account",
        where: [
          {
            field: "id",
            value: accountId
          }
        ]
      });
    },
    deleteSessions: async (userIdOrSessionTokens) => {
      if (secondaryStorage) {
        if (typeof userIdOrSessionTokens === "string") {
          const activeSession = await secondaryStorage.get(`active-sessions-${userIdOrSessionTokens}`);
          const sessions = activeSession ? safeJSONParse(activeSession) : [];
          if (!sessions)
            return;
          for (const session of sessions) {
            await secondaryStorage.delete(session.token);
          }
        } else {
          for (const sessionToken of userIdOrSessionTokens) {
            const session = await secondaryStorage.get(sessionToken);
            if (session) {
              await secondaryStorage.delete(sessionToken);
            }
          }
        }
        if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) {
          return;
        }
      }
      await adapter.deleteMany({
        model: "session",
        where: [
          {
            field: Array.isArray(userIdOrSessionTokens) ? "token" : "userId",
            value: userIdOrSessionTokens,
            operator: Array.isArray(userIdOrSessionTokens) ? "in" : undefined
          }
        ]
      });
    },
    findOAuthUser: async (email, accountId, providerId) => {
      const account = await adapter.findOne({
        model: "account",
        where: [
          {
            value: accountId,
            field: "accountId"
          },
          {
            value: providerId,
            field: "providerId"
          }
        ]
      });
      if (account) {
        const user = await adapter.findOne({
          model: "user",
          where: [
            {
              value: account.userId,
              field: "id"
            }
          ]
        });
        if (user) {
          return {
            user,
            accounts: [account]
          };
        } else {
          return null;
        }
      } else {
        const user = await adapter.findOne({
          model: "user",
          where: [
            {
              value: email.toLowerCase(),
              field: "email"
            }
          ]
        });
        if (user) {
          const accounts = await adapter.findMany({
            model: "account",
            where: [
              {
                value: user.id,
                field: "userId"
              }
            ]
          });
          return {
            user,
            accounts: accounts || []
          };
        } else {
          return null;
        }
      }
    },
    findUserByEmail: async (email, options2) => {
      const user = await adapter.findOne({
        model: "user",
        where: [
          {
            value: email.toLowerCase(),
            field: "email"
          }
        ]
      });
      if (!user)
        return null;
      if (options2?.includeAccounts) {
        const accounts = await adapter.findMany({
          model: "account",
          where: [
            {
              value: user.id,
              field: "userId"
            }
          ]
        });
        return {
          user,
          accounts
        };
      }
      return {
        user,
        accounts: []
      };
    },
    findUserById: async (userId) => {
      const user = await adapter.findOne({
        model: "user",
        where: [
          {
            field: "id",
            value: userId
          }
        ]
      });
      return user;
    },
    linkAccount: async (account, context) => {
      const _account = await createWithHooks({
        ...account,
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date
      }, "account", undefined, context);
      return _account;
    },
    updateUser: async (userId, data, context) => {
      const user = await updateWithHooks(data, [
        {
          field: "id",
          value: userId
        }
      ], "user", undefined, context);
      return user;
    },
    updateUserByEmail: async (email, data, context) => {
      const user = await updateWithHooks(data, [
        {
          field: "email",
          value: email.toLowerCase()
        }
      ], "user", undefined, context);
      return user;
    },
    updatePassword: async (userId, password, context) => {
      await updateManyWithHooks({
        password
      }, [
        {
          field: "userId",
          value: userId
        },
        {
          field: "providerId",
          value: "credential"
        }
      ], "account", undefined, context);
    },
    findAccounts: async (userId) => {
      const accounts = await adapter.findMany({
        model: "account",
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
      return accounts;
    },
    findAccount: async (accountId) => {
      const account = await adapter.findOne({
        model: "account",
        where: [
          {
            field: "accountId",
            value: accountId
          }
        ]
      });
      return account;
    },
    findAccountByProviderId: async (accountId, providerId) => {
      const account = await adapter.findOne({
        model: "account",
        where: [
          {
            field: "accountId",
            value: accountId
          },
          {
            field: "providerId",
            value: providerId
          }
        ]
      });
      return account;
    },
    findAccountByUserId: async (userId) => {
      const account = await adapter.findMany({
        model: "account",
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
      return account;
    },
    updateAccount: async (id, data, context) => {
      const account = await updateWithHooks(data, [{ field: "id", value: id }], "account", undefined, context);
      return account;
    },
    createVerificationValue: async (data, context) => {
      const verification = await createWithHooks({
        createdAt: /* @__PURE__ */ new Date,
        updatedAt: /* @__PURE__ */ new Date,
        ...data
      }, "verification", undefined, context);
      return verification;
    },
    findVerificationValue: async (identifier) => {
      const verification = await adapter.findMany({
        model: "verification",
        where: [
          {
            field: "identifier",
            value: identifier
          }
        ],
        sortBy: {
          field: "createdAt",
          direction: "desc"
        },
        limit: 1
      });
      if (!options.verification?.disableCleanup) {
        await adapter.deleteMany({
          model: "verification",
          where: [
            {
              field: "expiresAt",
              value: /* @__PURE__ */ new Date,
              operator: "lt"
            }
          ]
        });
      }
      const lastVerification = verification[0];
      return lastVerification;
    },
    deleteVerificationValue: async (id) => {
      await adapter.delete({
        model: "verification",
        where: [
          {
            field: "id",
            value: id
          }
        ]
      });
    },
    deleteVerificationByIdentifier: async (identifier) => {
      await adapter.delete({
        model: "verification",
        where: [
          {
            field: "identifier",
            value: identifier
          }
        ]
      });
    },
    updateVerificationValue: async (id, data, context) => {
      const verification = await updateWithHooks(data, [{ field: "id", value: id }], "verification", undefined, context);
      return verification;
    }
  };
};
async function getAdapter(options) {
  if (!options.database) {
    const tables = getAuthTables(options);
    const memoryDB = Object.keys(tables).reduce((acc, key) => {
      acc[key] = [];
      return acc;
    }, {});
    logger.warn("No database configuration provided. Using memory adapter in development");
    return memoryAdapter(memoryDB)(options);
  }
  if (typeof options.database === "function") {
    return options.database(options);
  }
  const { kysely: kysely2, databaseType } = await createKyselyAdapter(options);
  if (!kysely2) {
    throw new BetterAuthError("Failed to initialize database adapter");
  }
  return kyselyAdapter(kysely2, {
    type: databaseType || "sqlite",
    debugLogs: "debugLogs" in options.database ? options.database.debugLogs : false
  })(options);
}
function getSchema(config2) {
  const tables = getAuthTables(config2);
  let schema3 = {};
  for (const key in tables) {
    const table = tables[key];
    const fields = table.fields;
    let actualFields = {};
    Object.entries(fields).forEach(([key2, field]) => {
      actualFields[field.fieldName || key2] = field;
      if (field.references) {
        const refTable = tables[field.references.model];
        if (refTable) {
          actualFields[field.fieldName || key2].references = {
            model: refTable.modelName,
            field: field.references.field
          };
        }
      }
    });
    if (schema3[table.modelName]) {
      schema3[table.modelName].fields = {
        ...schema3[table.modelName].fields,
        ...actualFields
      };
      continue;
    }
    schema3[table.modelName] = {
      fields: actualFields,
      order: table.order || Infinity
    };
  }
  return schema3;
}
var postgresMap = {
  string: ["character varying", "text"],
  number: [
    "int4",
    "integer",
    "bigint",
    "smallint",
    "numeric",
    "real",
    "double precision"
  ],
  boolean: ["bool", "boolean"],
  date: ["timestamp", "date"]
};
var mysqlMap = {
  string: ["varchar", "text"],
  number: [
    "integer",
    "int",
    "bigint",
    "smallint",
    "decimal",
    "float",
    "double"
  ],
  boolean: ["boolean", "tinyint"],
  date: ["timestamp", "datetime", "date"]
};
var sqliteMap = {
  string: ["TEXT"],
  number: ["INTEGER", "REAL"],
  boolean: ["INTEGER", "BOOLEAN"],
  date: ["DATE", "INTEGER"]
};
var mssqlMap = {
  string: ["text", "varchar"],
  number: ["int", "bigint", "smallint", "decimal", "float", "double"],
  boolean: ["bit", "smallint"],
  date: ["datetime", "date"]
};
var map = {
  postgres: postgresMap,
  mysql: mysqlMap,
  sqlite: sqliteMap,
  mssql: mssqlMap
};
function matchType(columnDataType, fieldType, dbType) {
  if (fieldType === "string[]" || fieldType === "number[]") {
    return columnDataType.toLowerCase().includes("json");
  }
  const types3 = map[dbType];
  const type = Array.isArray(fieldType) ? types3["string"].map((t) => t.toLowerCase()) : types3[fieldType].map((t) => t.toLowerCase());
  const matches = type.includes(columnDataType.toLowerCase());
  return matches;
}
async function getMigrations(config2) {
  const betterAuthSchema = getSchema(config2);
  const logger2 = createLogger(config2.logger);
  let { kysely: db, databaseType: dbType } = await createKyselyAdapter(config2);
  if (!dbType) {
    logger2.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.");
    dbType = "sqlite";
  }
  if (!db) {
    logger2.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.");
    process.exit(1);
  }
  const tableMetadata = await db.introspection.getTables();
  const toBeCreated = [];
  const toBeAdded = [];
  for (const [key, value] of Object.entries(betterAuthSchema)) {
    const table = tableMetadata.find((t) => t.name === key);
    if (!table) {
      const tIndex = toBeCreated.findIndex((t) => t.table === key);
      const tableData = {
        table: key,
        fields: value.fields,
        order: value.order || Infinity
      };
      const insertIndex = toBeCreated.findIndex((t) => (t.order || Infinity) > tableData.order);
      if (insertIndex === -1) {
        if (tIndex === -1) {
          toBeCreated.push(tableData);
        } else {
          toBeCreated[tIndex].fields = {
            ...toBeCreated[tIndex].fields,
            ...value.fields
          };
        }
      } else {
        toBeCreated.splice(insertIndex, 0, tableData);
      }
      continue;
    }
    let toBeAddedFields = {};
    for (const [fieldName, field] of Object.entries(value.fields)) {
      const column = table.columns.find((c) => c.name === fieldName);
      if (!column) {
        toBeAddedFields[fieldName] = field;
        continue;
      }
      if (matchType(column.dataType, field.type, dbType)) {
        continue;
      } else {
        logger2.warn(`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`);
      }
    }
    if (Object.keys(toBeAddedFields).length > 0) {
      toBeAdded.push({
        table: key,
        fields: toBeAddedFields,
        order: value.order || Infinity
      });
    }
  }
  const migrations = [];
  function getType(field, fieldName) {
    const type = field.type;
    const typeMap = {
      string: {
        sqlite: "text",
        postgres: "text",
        mysql: field.unique ? "varchar(255)" : field.references ? "varchar(36)" : "text",
        mssql: field.unique || field.sortable ? "varchar(255)" : field.references ? "varchar(36)" : "text"
      },
      boolean: {
        sqlite: "integer",
        postgres: "boolean",
        mysql: "boolean",
        mssql: "smallint"
      },
      number: {
        sqlite: field.bigint ? "bigint" : "integer",
        postgres: field.bigint ? "bigint" : "integer",
        mysql: field.bigint ? "bigint" : "integer",
        mssql: field.bigint ? "bigint" : "integer"
      },
      date: {
        sqlite: "date",
        postgres: "timestamp",
        mysql: "datetime",
        mssql: "datetime"
      },
      id: {
        postgres: config2.advanced?.database?.useNumberId ? "serial" : "text",
        mysql: config2.advanced?.database?.useNumberId ? "integer" : "varchar(36)",
        mssql: config2.advanced?.database?.useNumberId ? "integer" : "varchar(36)",
        sqlite: config2.advanced?.database?.useNumberId ? "integer" : "text"
      }
    };
    if (fieldName === "id" || field.references?.field === "id") {
      return typeMap.id[dbType];
    }
    if (dbType === "sqlite" && (type === "string[]" || type === "number[]")) {
      return "text";
    }
    if (type === "string[]" || type === "number[]") {
      return "jsonb";
    }
    if (Array.isArray(type)) {
      return "text";
    }
    return typeMap[type][dbType || "sqlite"];
  }
  if (toBeAdded.length) {
    for (const table of toBeAdded) {
      for (const [fieldName, field] of Object.entries(table.fields)) {
        const type = getType(field, fieldName);
        const exec = db.schema.alterTable(table.table).addColumn(fieldName, type, (col) => {
          col = field.required !== false ? col.notNull() : col;
          if (field.references) {
            col = col.references(`${field.references.model}.${field.references.field}`);
          }
          if (field.unique) {
            col = col.unique();
          }
          return col;
        });
        migrations.push(exec);
      }
    }
  }
  if (toBeCreated.length) {
    for (const table of toBeCreated) {
      let dbT = db.schema.createTable(table.table).addColumn("id", config2.advanced?.database?.useNumberId ? dbType === "postgres" ? "serial" : "integer" : dbType === "mysql" || dbType === "mssql" ? "varchar(36)" : "text", (col) => {
        if (config2.advanced?.database?.useNumberId) {
          if (dbType === "postgres") {
            return col.primaryKey().notNull();
          }
          return col.autoIncrement().primaryKey().notNull();
        }
        return col.primaryKey().notNull();
      });
      for (const [fieldName, field] of Object.entries(table.fields)) {
        const type = getType(field, fieldName);
        dbT = dbT.addColumn(fieldName, type, (col) => {
          col = field.required !== false ? col.notNull() : col;
          if (field.references) {
            col = col.references(`${field.references.model}.${field.references.field}`);
          }
          if (field.unique) {
            col = col.unique();
          }
          return col;
        });
      }
      migrations.push(dbT);
    }
  }
  async function runMigrations() {
    for (const migration of migrations) {
      await migration.execute();
    }
  }
  async function compileMigrations() {
    const compiled = migrations.map((m) => m.compile().sql);
    return compiled.join(`;

`) + ";";
  }
  return { toBeCreated, toBeAdded, runMigrations, compileMigrations };
}
// ../../node_modules/better-auth/dist/shared/better-auth.YwDQhoPc.mjs
async function checkPassword(userId, c) {
  const accounts = await c.context.internalAdapter.findAccounts(userId);
  const credentialAccount = accounts?.find((account) => account.providerId === "credential");
  const currentPassword = credentialAccount?.password;
  if (!credentialAccount || !currentPassword || !c.body.password) {
    throw new APIError("BAD_REQUEST", {
      message: "No password credential found"
    });
  }
  const compare2 = await c.context.password.verify({
    hash: currentPassword,
    password: c.body.password
  });
  if (!compare2) {
    throw new APIError("BAD_REQUEST", {
      message: "Invalid password"
    });
  }
  return true;
}
// ../../node_modules/better-auth/dist/index.mjs
var DEFAULT_SECRET = "better-auth-secret-123456789";
var init = async (options) => {
  const adapter = await getAdapter(options);
  const plugins = options.plugins || [];
  const internalPlugins = getInternalPlugins(options);
  const logger2 = createLogger(options.logger);
  const baseURL = getBaseURL(options.baseURL, options.basePath);
  const secret = options.secret || env.BETTER_AUTH_SECRET || env.AUTH_SECRET || DEFAULT_SECRET;
  if (secret === DEFAULT_SECRET) {
    if (isProduction) {
      logger2.error("You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.");
    }
  }
  options = {
    ...options,
    secret,
    baseURL: baseURL ? new URL(baseURL).origin : "",
    basePath: options.basePath || "/api/auth",
    plugins: plugins.concat(internalPlugins)
  };
  const cookies = getCookies(options);
  const tables = getAuthTables(options);
  const providers = Object.keys(options.socialProviders || {}).map((key) => {
    const value = options.socialProviders?.[key];
    if (!value || value.enabled === false) {
      return null;
    }
    if (!value.clientId) {
      logger2.warn(`Social provider ${key} is missing clientId or clientSecret`);
    }
    const provider = socialProviders[key](value);
    provider.disableImplicitSignUp = value.disableImplicitSignUp;
    return provider;
  }).filter((x) => x !== null);
  const generateIdFunc = ({ model, size }) => {
    if (typeof options.advanced?.generateId === "function") {
      return options.advanced.generateId({ model, size });
    }
    if (typeof options?.advanced?.database?.generateId === "function") {
      return options.advanced.database.generateId({ model, size });
    }
    return generateId(size);
  };
  const ctx = {
    appName: options.appName || "Better Auth",
    socialProviders: providers,
    options,
    tables,
    trustedOrigins: getTrustedOrigins(options),
    baseURL: baseURL || "",
    sessionConfig: {
      updateAge: options.session?.updateAge !== undefined ? options.session.updateAge : 24 * 60 * 60,
      expiresIn: options.session?.expiresIn || 60 * 60 * 24 * 7,
      freshAge: options.session?.freshAge === undefined ? 60 * 60 * 24 : options.session.freshAge
    },
    secret,
    rateLimit: {
      ...options.rateLimit,
      enabled: options.rateLimit?.enabled ?? isProduction,
      window: options.rateLimit?.window || 10,
      max: options.rateLimit?.max || 100,
      storage: options.rateLimit?.storage || (options.secondaryStorage ? "secondary-storage" : "memory")
    },
    authCookies: cookies,
    logger: logger2,
    generateId: generateIdFunc,
    session: null,
    secondaryStorage: options.secondaryStorage,
    password: {
      hash: options.emailAndPassword?.password?.hash || hashPassword,
      verify: options.emailAndPassword?.password?.verify || verifyPassword,
      config: {
        minPasswordLength: options.emailAndPassword?.minPasswordLength || 8,
        maxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128
      },
      checkPassword
    },
    setNewSession(session) {
      this.newSession = session;
    },
    newSession: null,
    adapter,
    internalAdapter: createInternalAdapter(adapter, {
      options,
      hooks: options.databaseHooks ? [options.databaseHooks] : []
    }),
    createAuthCookie: createCookieGetter(options),
    async runMigrations() {
      if (!options.database || "updateMany" in options.database) {
        throw new BetterAuthError("Database is not provided or it's an adapter. Migrations are only supported with a database instance.");
      }
      const { runMigrations } = await getMigrations(options);
      await runMigrations();
    }
  };
  let { context } = runPluginInit(ctx);
  return context;
};
function runPluginInit(ctx) {
  let options = ctx.options;
  const plugins = options.plugins || [];
  let context = ctx;
  const dbHooks = [];
  for (const plugin of plugins) {
    if (plugin.init) {
      const result = plugin.init(context);
      if (typeof result === "object") {
        if (result.options) {
          const { databaseHooks, ...restOpts } = result.options;
          if (databaseHooks) {
            dbHooks.push(databaseHooks);
          }
          options = defu(options, restOpts);
        }
        if (result.context) {
          context = {
            ...context,
            ...result.context
          };
        }
      }
    }
  }
  dbHooks.push(options.databaseHooks);
  context.internalAdapter = createInternalAdapter(ctx.adapter, {
    options,
    hooks: dbHooks.filter((u) => u !== undefined),
    generateId: ctx.generateId
  });
  context.options = options;
  return { context };
}
function getInternalPlugins(options) {
  const plugins = [];
  if (options.advanced?.crossSubDomainCookies?.enabled)
    ;
  return plugins;
}
function getTrustedOrigins(options) {
  const baseURL = getBaseURL(options.baseURL, options.basePath);
  if (!baseURL) {
    return [];
  }
  const trustedOrigins = [new URL(baseURL).origin];
  if (options.trustedOrigins && Array.isArray(options.trustedOrigins)) {
    trustedOrigins.push(...options.trustedOrigins);
  }
  const envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;
  if (envTrustedOrigins) {
    trustedOrigins.push(...envTrustedOrigins.split(","));
  }
  if (trustedOrigins.filter((x) => !x).length) {
    throw new BetterAuthError("A provided trusted origin is invalid, make sure your trusted origins list is properly defined.");
  }
  return trustedOrigins;
}
var betterAuth = (options) => {
  const authContext = init(options);
  const { api } = getEndpoints(authContext, options);
  const errorCodes = options.plugins?.reduce((acc, plugin) => {
    if (plugin.$ERROR_CODES) {
      return {
        ...acc,
        ...plugin.$ERROR_CODES
      };
    }
    return acc;
  }, {});
  return {
    handler: async (request) => {
      const ctx = await authContext;
      const basePath = ctx.options.basePath || "/api/auth";
      if (!ctx.options.baseURL) {
        const baseURL = getBaseURL(undefined, basePath, request);
        if (baseURL) {
          ctx.baseURL = baseURL;
          ctx.options.baseURL = getOrigin(ctx.baseURL) || undefined;
        } else {
          throw new BetterAuthError("Could not get base URL from request. Please provide a valid base URL.");
        }
      }
      ctx.trustedOrigins = [
        ...options.trustedOrigins ? Array.isArray(options.trustedOrigins) ? options.trustedOrigins : await options.trustedOrigins(request) : [],
        ctx.options.baseURL
      ];
      const { handler } = router(ctx, options);
      return handler(request);
    },
    api,
    options,
    $context: authContext,
    $Infer: {},
    $ERROR_CODES: {
      ...errorCodes,
      ...BASE_ERROR_CODES
    }
  };
};

// ../../node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config2) {
    this.config = { ...config2 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect2, withList) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase2(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase2 : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema3 = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema3}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema3 = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema3}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// ../../node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// ../../node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config2) {
    this.casing = new CasingCache(config2?.casing);
  }
  async migrate(migrations, session, config2) {
    const migrationsTable = typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config2 === "string" ? "drizzle" : config2.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? undefined : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    for (const [index, joinMeta] of joins.entries()) {
      if (index === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
      if (is(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else if (is(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else {
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
      }
      if (index < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select) {
      const select2 = valuesOrSelect;
      if (is(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder3) {
    if (is(encoder3, PgJsonb) || is(encoder3, PgJson)) {
      return "json";
    } else if (is(encoder3, PgNumeric)) {
      return "decimal";
    } else if (is(encoder3, PgTime)) {
      return "time";
    } else if (is(encoder3, PgTimestamp) || is(encoder3, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder3, PgDate) || is(encoder3, PgDateString)) {
      return "date";
    } else if (is(encoder3, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql22, invokeSource) {
    return sql22.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema: schema3,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config2,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config2 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config2.where) {
        const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config2.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config2.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config2.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config2.with) {
        selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config2.extras) {
        extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config2.limit;
      offset = config2.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema3, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema: schema3,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema3[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// ../../node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config2) {
    this.fields = config2.fields;
    this.session = config2.session;
    this.dialect = config2.dialect;
    if (config2.withList) {
      this.withList = config2.withList;
    }
    this.distinct = config2.distinct;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(src, Subquery)) {
      fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
    } else if (is(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect: dialect2, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect2;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left", false);
  leftJoinLateral = this.createJoin("left", true);
  rightJoin = this.createJoin("right", false);
  innerJoin = this.createJoin("inner", false);
  innerJoinLateral = this.createJoin("inner", true);
  fullJoin = this.createJoin("full", false);
  crossJoin = this.createJoin("cross", false);
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config2 = {}) {
    this.config.lockingClause = { strength, config: config2 };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config: config2, dialect: dialect2, joinsNotNullableMap, authToken } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config2.fields);
      const query = session.prepareQuery(dialect2.sqlToQuery(this.getSQL()), fieldsList, name, true);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// ../../node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect2) {
    this.dialect = is(dialect2, PgDialect) ? dialect2 : undefined;
    this.dialectConfig = is(dialect2, PgDialect) ? undefined : dialect2;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect2, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect2;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values, session, dialect2, withList, select, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { table, values, withList, select, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config2 = {}) {
    if (config2.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config2.target));
      const whereSql = config2.where ? sql` where ${config2.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config2) {
    if (config2.where && (config2.targetWhere || config2.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config2.where ? sql` where ${config2.where}` : undefined;
    const targetWhereSql = config2.targetWhere ? sql` where ${config2.targetWhere}` : undefined;
    const setWhereSql = config2.setWhere ? sql` where ${config2.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config2.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect2) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect2, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect2;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList).setToken(this.authToken);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set, session, dialect2, withList) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { set, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema3, tableNamesMap, table, tableConfig, dialect2, session) {
    this.fullSchema = fullSchema;
    this.schema = schema3;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config2) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config2 ? config2 : {}, "many");
  }
  findFirst(config2) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config2 ? { ...config2, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema3, tableNamesMap, table, tableConfig, dialect2, session, config2, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema3;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
    this.config = config2;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(undefined, this.authToken);
    });
  }
}

// ../../node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql4, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql4;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// ../../node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect2, session, schema3) {
    this.dialect = dialect2;
    this.session = session;
    this._ = schema3 ? {
      schema: schema3.schema,
      fullSchema: schema3.fullSchema,
      tableNamesMap: schema3.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema3.fullSchema, this._.schema, this._.tableNamesMap, schema3.fullSchema[tableName], columns, dialect2, session);
      }
    }
  }
  static [entityKind] = "PgDatabase";
  query;
  $with = (alias, selection) => {
    const self2 = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self2.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self2.session, self2.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self2.session, self2.dialect, queries);
    }
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config2) {
    return this.session.transaction(transaction, config2);
  }
}

// ../../node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query) {
    this.query = query;
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
}

class PgSession {
  constructor(dialect2) {
    this.dialect = dialect2;
  }
  static [entityKind] = "PgSession";
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.setToken(token).execute(undefined, token);
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql22, token) {
    const res = await this.execute(sql22, token);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect2, session, schema3, nestedIndex = 0) {
    super(dialect2, session, schema3);
    this.schema = schema3;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config2) {
    const chunks = [];
    if (config2.isolationLevel) {
      chunks.push(`isolation level ${config2.isolationLevel}`);
    }
    if (config2.accessMode) {
      chunks.push(config2.accessMode);
    }
    if (typeof config2.deferrable === "boolean") {
      chunks.push(config2.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config2) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config2)}`);
  }
}

// ../../packages/db/schema.ts
var user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").$defaultFn(() => false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").$defaultFn(() => /* @__PURE__ */ new Date).notNull(),
  updatedAt: timestamp("updated_at").$defaultFn(() => /* @__PURE__ */ new Date).notNull()
});
var session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" })
});
var account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id").notNull().references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull()
});
var verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").$defaultFn(() => /* @__PURE__ */ new Date),
  updatedAt: timestamp("updated_at").$defaultFn(() => /* @__PURE__ */ new Date)
});
var waitlist = pgTable("waitlist", {
  id: text("id").primaryKey(),
  email: text("email").notNull().unique(),
  createdAt: timestamp("created_at").$defaultFn(() => new Date).notNull()
});
var rateLimitAttempts = pgTable("rate_limit_attempts", {
  identifier: text("identifier").primaryKey(),
  count: integer("count").notNull().default(1),
  expiresAt: timestamp("expires_at", { mode: "date", withTimezone: true }).notNull()
});
var schema3 = {
  user,
  session,
  account,
  verification,
  waitlist,
  rateLimitAttempts
};
var schema_default = schema3;

// ../../node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib2(), 1);
var Client = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types3 = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults2 = import_lib.default.defaults;
var esm_default = import_lib.default;

// ../../node_modules/drizzle-orm/node-postgres/session.js
var { Pool: Pool2, types: types4 } = esm_default;

class NodePgPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger2, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params });
    this.client = client;
    this.params = params;
    this.logger = logger2;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      name,
      text: queryString,
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types4.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types4.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types4.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types4.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types4.getTypeParser(typeId, format);
        }
      }
    };
    this.queryConfig = {
      name,
      text: queryString,
      rowMode: "array",
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types4.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types4.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types4.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types4.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types4.getTypeParser(typeId, format);
        }
      }
    };
  }
  static [entityKind] = "NodePgPreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      const { fields, rawQueryConfig: rawQuery, client, queryConfig: query, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", async (span) => {
          span?.setAttributes({
            "drizzle.query.name": rawQuery.name,
            "drizzle.query.text": rawQuery.text,
            "drizzle.query.params": JSON.stringify(params)
          });
          return client.query(rawQuery, params);
        });
      }
      const result = await tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": query.name,
          "drizzle.query.text": query.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return client.query(query, params);
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      return tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": this.rawQueryConfig.name,
          "drizzle.query.text": this.rawQueryConfig.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.client.query(this.rawQueryConfig, params).then((result) => result.rows);
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class NodePgSession extends PgSession {
  constructor(client, dialect2, schema4, options = {}) {
    super(dialect2);
    this.client = client;
    this.schema = schema4;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
  }
  static [entityKind] = "NodePgSession";
  logger;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper) {
    return new NodePgPreparedQuery(this.client, query.sql, query.params, this.logger, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config2) {
    const session2 = this.client instanceof Pool2 ? new NodePgSession(await this.client.connect(), this.dialect, this.schema, this.options) : this;
    const tx = new NodePgTransaction(this.dialect, session2, this.schema);
    await tx.execute(sql`begin${config2 ? sql` ${tx.getTransactionConfigSQL(config2)}` : undefined}`);
    try {
      const result = await transaction(tx);
      await tx.execute(sql`commit`);
      return result;
    } catch (error2) {
      await tx.execute(sql`rollback`);
      throw error2;
    } finally {
      if (this.client instanceof Pool2) {
        session2.client.release();
      }
    }
  }
  async count(sql22) {
    const res = await this.execute(sql22);
    return Number(res["rows"][0]["count"]);
  }
}

class NodePgTransaction extends PgTransaction {
  static [entityKind] = "NodePgTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new NodePgTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

// ../../node_modules/drizzle-orm/node-postgres/driver.js
class NodePgDriver {
  constructor(client, dialect2, options = {}) {
    this.client = client;
    this.dialect = dialect2;
    this.options = options;
  }
  static [entityKind] = "NodePgDriver";
  createSession(schema4) {
    return new NodePgSession(this.client, this.dialect, schema4, { logger: this.options.logger });
  }
}

class NodePgDatabase extends PgDatabase {
  static [entityKind] = "NodePgDatabase";
}
function construct(client, config2 = {}) {
  const dialect2 = new PgDialect({ casing: config2.casing });
  let logger2;
  if (config2.logger === true) {
    logger2 = new DefaultLogger;
  } else if (config2.logger !== false) {
    logger2 = config2.logger;
  }
  let schema4;
  if (config2.schema) {
    const tablesConfig = extractTablesRelationalConfig(config2.schema, createTableRelationsHelpers);
    schema4 = {
      fullSchema: config2.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver2 = new NodePgDriver(client, dialect2, { logger: logger2 });
  const session2 = driver2.createSession(schema4);
  const db = new NodePgDatabase(dialect2, session2, schema4);
  db.$client = client;
  return db;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = new esm_default.Pool({
      connectionString: params[0]
    });
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    const instance = typeof connection === "string" ? new esm_default.Pool({
      connectionString: connection
    }) : new esm_default.Pool(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config2) {
    return construct({}, config2);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// ../../packages/db/src/index.ts
if (!process.env.DATABASE_URL) {
  throw new Error("Missing environment variables. DATABASE_URL is not defined");
}
var pool = new Pool({
  connectionString: process.env.DATABASE_URL
});
var db = drizzle({ client: pool, schema: schema_default });

// ../../packages/auth/src/auth.ts
if (!process.env.FRONTEND_URL || !process.env.BACKEND_URL) {
  throw new Error("Missing environment variables. FRONTEND_URL or BACKEND_URL is not defined");
}
var auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",
    schema: {
      ...schema_default
    }
  }),
  trustedOrigins: [process.env.FRONTEND_URL, process.env.BACKEND_URL],
  emailAndPassword: {
    enabled: true,
    autoSignIn: true,
    minPasswordLength: 8,
    maxPasswordLength: 100,
    resetPasswordTokenExpiresIn: 600,
    sendResetPassword: async ({ user: user2, url: url2 }) => {
      const token = extractTokenFromUrl(url2);
      const frontendResetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${token}`;
      await sendMail({
        to: user2.email,
        subject: "Reset your password",
        text: `Click the link to reset your password: ${frontendResetUrl}`
      });
    }
  },
  socialProviders: {
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      scope: [
        "https://www.googleapis.com/auth/drive",
        "https://www.googleapis.com/auth/userinfo.profile",
        "https://www.googleapis.com/auth/userinfo.email"
      ],
      accessType: "offline",
      prompt: "consent"
    }
  }
});

// ../../node_modules/@t3-oss/env-core/dist/src-Bb3GbGAa.js
function ensureSynchronous(value, message2) {
  if (value instanceof Promise)
    throw new Error(message2);
}
function parseWithDictionary(dictionary, value) {
  const result = {};
  const issues = [];
  for (const key in dictionary) {
    const propResult = dictionary[key]["~standard"].validate(value[key]);
    ensureSynchronous(propResult, `Validation must be synchronous, but ${key} returned a Promise.`);
    if (propResult.issues) {
      issues.push(...propResult.issues.map((issue) => ({
        ...issue,
        message: issue.message,
        path: [key, ...issue.path ?? []]
      })));
      continue;
    }
    result[key] = propResult.value;
  }
  if (issues.length)
    return { issues };
  return { value: result };
}
function createEnv(opts) {
  const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? process.env;
  const emptyStringAsUndefined = opts.emptyStringAsUndefined ?? false;
  if (emptyStringAsUndefined) {
    for (const [key, value] of Object.entries(runtimeEnv))
      if (value === "")
        delete runtimeEnv[key];
  }
  const skip = !!opts.skipValidation;
  if (skip)
    return runtimeEnv;
  const _client = typeof opts.client === "object" ? opts.client : {};
  const _server = typeof opts.server === "object" ? opts.server : {};
  const _shared = typeof opts.shared === "object" ? opts.shared : {};
  const isServer = opts.isServer ?? (typeof window === "undefined" || ("Deno" in window));
  const finalSchemaShape = isServer ? {
    ..._server,
    ..._shared,
    ..._client
  } : {
    ..._client,
    ..._shared
  };
  const parsed = opts.createFinalSchema?.(finalSchemaShape, isServer)["~standard"].validate(runtimeEnv) ?? parseWithDictionary(finalSchemaShape, runtimeEnv);
  ensureSynchronous(parsed, "Validation must be synchronous");
  const onValidationError = opts.onValidationError ?? ((issues) => {
    console.error("\u274C Invalid environment variables:", issues);
    throw new Error("Invalid environment variables");
  });
  const onInvalidAccess = opts.onInvalidAccess ?? (() => {
    throw new Error("\u274C Attempted to access a server-side environment variable on the client");
  });
  if (parsed.issues)
    return onValidationError(parsed.issues);
  const isServerAccess = (prop) => {
    if (!opts.clientPrefix)
      return true;
    return !prop.startsWith(opts.clientPrefix) && !(prop in _shared);
  };
  const isValidServerAccess = (prop) => {
    return isServer || !isServerAccess(prop);
  };
  const ignoreProp = (prop) => {
    return prop === "__esModule" || prop === "$$typeof";
  };
  const extendedObj = (opts.extends ?? []).reduce((acc, curr) => {
    return Object.assign(acc, curr);
  }, {});
  const fullObj = Object.assign(extendedObj, parsed.value);
  const env2 = new Proxy(fullObj, { get(target, prop) {
    if (typeof prop !== "string")
      return;
    if (ignoreProp(prop))
      return;
    if (!isValidServerAccess(prop))
      return onInvalidAccess(prop);
    return Reflect.get(target, prop);
  } });
  return env2;
}

// src/config/env.ts
var env2 = createEnv({
  server: {
    DATABASE_URL: exports_external.string({ message: "The DATABASE_URL environment variable must be set." }).url("The value provided for DATABASE_URL is not a valid URL. Please check the format."),
    GOOGLE_CLIENT_ID: exports_external.string({ message: "The GOOGLE_CLIENT_ID environment variable is required." }).min(1, "GOOGLE_CLIENT_ID cannot be empty. Make sure it's set correctly."),
    GOOGLE_CLIENT_SECRET: exports_external.string({ message: "The GOOGLE_CLIENT_SECRET environment variable is required." }).min(1, "GOOGLE_CLIENT_SECRET cannot be empty. Please provide a valid secret."),
    EMAIL_FROM: exports_external.string({ message: "The EMAIL_FROM environment variable is required." }).email("EMAIL_FROM must be a valid email address (e.g., example@domain.com)."),
    RESEND_API_KEY: exports_external.string({ message: "The RESEND_API_KEY environment variable is required." }).min(1, "RESEND_API_KEY cannot be empty. Please include a valid API key."),
    FRONTEND_URL: exports_external.string({ message: "The FRONTEND_URL environment variable is required." }).url("FRONTEND_URL must be a valid URL (e.g., https://yourdomain.com)."),
    BACKEND_URL: exports_external.string({ message: "The BACKEND_URL environment variable is required." }).url("BACKEND_URL must be a valid URL (e.g., https://api.yourdomain.com).")
  },
  runtimeEnv: process.env,
  emptyStringAsUndefined: true
});

// ../../node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults3 = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults3,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin2) => optsOrigin === origin2 ? origin2 : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin2) => optsOrigin.includes(origin2) ? origin2 : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  };
};

// ../../node_modules/hono/dist/utils/url.js
var splitPath2 = (path) => {
  const paths2 = path.split("/");
  if (paths2[0] === "") {
    paths2.shift();
  }
  return paths2;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths2 = splitPath2(path);
  return replaceGroupMarks(paths2, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths2, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths2.length - 1;j >= 0; j--) {
      if (paths2[j].includes(mark)) {
        paths2[j] = paths2[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths2;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode2 = (str, decoder2) => {
  try {
    return decoder2(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder2(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode2(str, decodeURI);
var getPath = (request) => {
  const url2 = request.url;
  const start = url2.indexOf("/", url2.charCodeAt(9) === 58 ? 13 : 8);
  let i = start;
  for (;i < url2.length; i++) {
    const charCode = url2.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url2.indexOf("?", i);
      const path = url2.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url2.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode2(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url2, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url2.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url2.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url2.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url2.indexOf("&", valueIndex);
        return _decodeURI(url2.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url2.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url2);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url2);
  let keyIndex = url2.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url2.indexOf("&", keyIndex + 1);
    let valueIndex = url2.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url2.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url2.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url2, key) => {
  return _getQueryParam(url2, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// ../../node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse3 = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};

// ../../node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse3(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse3(cookie);
  return obj;
};

// ../../node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// ../../node_modules/hono/dist/utils/buffer.js
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// ../../node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target, validationFunc) => {
  return async (c, next) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message2 = "Malformed JSON in request body";
          throw new HTTPException(400, { message: message2 });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message2 = "Malformed FormData request.";
            message2 += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message: message2 });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(Object.entries(c.req.queries()).map(([k, v]) => {
          return v.length === 1 ? [k, v[0]] : [k, v];
        }));
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target, res);
    await next();
  };
};

// ../../node_modules/@hono/zod-validator/dist/index.js
var zValidator = (target, schema4, hook, options) => validator(target, async (value, c) => {
  let validatorValue = value;
  if (target === "header" && "_def" in schema4 || target === "header" && "_zod" in schema4) {
    const schemaKeys = Object.keys(schema4.shape);
    const caseInsensitiveKeymap = Object.fromEntries(schemaKeys.map((key) => [key.toLowerCase(), key]));
    validatorValue = Object.fromEntries(Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2]));
  }
  const result = options && options.validationFunction ? await options.validationFunction(schema4, validatorValue) : await schema4.safeParseAsync(validatorValue);
  if (hook) {
    const hookResult = await hook({ data: validatorValue, ...result, target }, c);
    if (hookResult) {
      if (hookResult instanceof Response) {
        return hookResult;
      }
      if ("response" in hookResult) {
        return hookResult.response;
      }
    }
  }
  if (!result.success) {
    return c.json(result, 400);
  }
  return result.data;
});

// src/validators/index.ts
var ALLOWED_DOMAINS = ["gmail.com", "outlook.com", "yahoo.com", "proton.me"];
var fileIdSchema = exports_external.string().min(1, "File ID cannot be empty").max(250, "File ID cannot be longer than 250 characters");
var sendMailSchema = exports_external.object({
  to: exports_external.string().email(),
  subject: exports_external.string().min(1),
  text: exports_external.string().min(1)
});
var emailSchema = exports_external.object({
  email: exports_external.string().email("Please enter a valid email address").refine((email) => {
    const [, domain] = email.split("@");
    if (!domain)
      return false;
    const allowed = ALLOWED_DOMAINS.some((allowed2) => domain === allowed2 || domain.endsWith(`.${allowed2}`));
    if (!allowed)
      return false;
    const labels = domain.split(".");
    if (labels.length < 2 || labels.length > 3)
      return false;
    const tld = labels.at(-1);
    if (!tld)
      return false;
    return /^[a-z]{2,63}$/i.test(tld);
  }, "Invalid email, please try again")
});
var getFileByIdSchema = exports_external.object({
  id: fileIdSchema
});
var deleteFileSchema = exports_external.object({
  id: fileIdSchema
});
var updateFileSchema = exports_external.object({
  id: fileIdSchema,
  name: exports_external.string().min(1, "Name cannot be empty").max(100, "Name cannot be longer than 100 characters")
});
var createFileSchema = exports_external.object({
  name: exports_external.string().min(1, "Name cannot be empty").max(100, "Name cannot be longer than 100 characters"),
  mimeType: exports_external.string().min(1, "MIME type cannot be empty").max(100, "MIME type cannot be longer than 100 characters"),
  parents: fileIdSchema.optional()
});

// node_modules/drizzle-orm/entity.js
var entityKind2 = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind2 = Symbol.for("drizzle:hasOwnEntityKind");
function is2(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind2)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind2 in cls && cls[entityKind2] === type[entityKind2]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/column.js
class Column2 {
  constructor(table, config2) {
    this.table = table;
    this.config = config2;
    this.name = config2.name;
    this.keyAsName = config2.keyAsName;
    this.notNull = config2.notNull;
    this.default = config2.default;
    this.defaultFn = config2.defaultFn;
    this.onUpdateFn = config2.onUpdateFn;
    this.hasDefault = config2.hasDefault;
    this.primary = config2.primaryKey;
    this.isUnique = config2.isUnique;
    this.uniqueName = config2.uniqueName;
    this.uniqueType = config2.uniqueType;
    this.dataType = config2.dataType;
    this.columnType = config2.columnType;
    this.generated = config2.generated;
    this.generatedIdentity = config2.generatedIdentity;
  }
  static [entityKind2] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// node_modules/drizzle-orm/table.utils.js
var TableName2 = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/tracing-utils.js
function iife2(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName2(table, columns) {
  return `${table[TableName2]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumn2 extends Column2 {
  constructor(table, config2) {
    if (!config2.uniqueName) {
      config2.uniqueName = uniqueKeyName2(table, [config2.name]);
    }
    super(table, config2);
    this.table = table;
  }
  static [entityKind2] = "PgColumn";
}

class ExtraConfigColumn2 extends PgColumn2 {
  static [entityKind2] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn2 extends PgColumn2 {
  static [entityKind2] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config2) {
    super(table, config2);
    this.enum = config2.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym2 = Symbol.for("drizzle:isPgEnum");
function isPgEnum2(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym2 in obj && obj[isPgEnumSym2] === true;
}
class PgEnumColumn2 extends PgColumn2 {
  static [entityKind2] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config2) {
    super(table, config2);
    this.enum = config2.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/subquery.js
class Subquery2 {
  static [entityKind2] = "Subquery";
  constructor(sql4, selection, alias, isWith = false) {
    this._ = {
      brand: "Subquery",
      sql: sql4,
      selectedFields: selection,
      alias,
      isWith
    };
  }
}

// node_modules/drizzle-orm/version.js
var version2 = "0.43.1";

// node_modules/drizzle-orm/tracing.js
var otel2;
var rawTracer2;
var tracer2 = {
  startActiveSpan(name, fn) {
    if (!otel2) {
      return fn();
    }
    if (!rawTracer2) {
      rawTracer2 = otel2.trace.getTracer("drizzle-orm", version2);
    }
    return iife2((otel22, rawTracer22) => rawTracer22.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel22.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel2, rawTracer2);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig2 = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/table.js
var Schema2 = Symbol.for("drizzle:Schema");
var Columns2 = Symbol.for("drizzle:Columns");
var ExtraConfigColumns2 = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName2 = Symbol.for("drizzle:OriginalName");
var BaseName2 = Symbol.for("drizzle:BaseName");
var IsAlias2 = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder2 = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable2 = Symbol.for("drizzle:IsDrizzleTable");

class Table2 {
  static [entityKind2] = "Table";
  static Symbol = {
    Name: TableName2,
    Schema: Schema2,
    OriginalName: OriginalName2,
    Columns: Columns2,
    ExtraConfigColumns: ExtraConfigColumns2,
    BaseName: BaseName2,
    IsAlias: IsAlias2,
    ExtraConfigBuilder: ExtraConfigBuilder2
  };
  [TableName2];
  [OriginalName2];
  [Schema2];
  [Columns2];
  [ExtraConfigColumns2];
  [BaseName2];
  [IsAlias2] = false;
  [IsDrizzleTable2] = true;
  [ExtraConfigBuilder2] = undefined;
  constructor(name, schema4, baseName) {
    this[TableName2] = this[OriginalName2] = name;
    this[Schema2] = schema4;
    this[BaseName2] = baseName;
  }
}

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper2(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries2(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk2 {
  static [entityKind2] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL2([this]);
  }
}

class SQL2 {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind2] = "SQL";
  decoder = noopDecoder2;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config2) {
    return tracer2.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config2);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config2 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config2;
    return mergeQueries2(chunks.map((chunk) => {
      if (is2(chunk, StringChunk2)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is2(chunk, Name2)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk2("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk2(", "));
          }
        }
        result.push(new StringChunk2(")"));
        return this.buildQueryFromSourceParams(result, config2);
      }
      if (is2(chunk, SQL2)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config2,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is2(chunk, Table2)) {
        const schemaName = chunk[Table2.Symbol.Schema];
        const tableName = chunk[Table2.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias2] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is2(chunk, Column2)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table2.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias2] || schemaName === undefined ? escapeName(chunk.table[Table2.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table2.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is2(chunk, View2)) {
        const schemaName = chunk[ViewBaseConfig2].schema;
        const viewName = chunk[ViewBaseConfig2].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig2].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is2(chunk, Param2)) {
        if (is2(chunk.value, Placeholder2)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is2(mappedValue, SQL2)) {
          return this.buildQueryFromSourceParams([mappedValue], config2);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config2), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is2(chunk, Placeholder2)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is2(chunk, SQL2.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is2(chunk, Subquery2)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk2("("),
          chunk._.sql,
          new StringChunk2(") "),
          new Name2(chunk._.alias)
        ], config2);
      }
      if (isPgEnum2(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper2(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config2);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk2("("),
          chunk.getSQL(),
          new StringChunk2(")")
        ], config2);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config2), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL2.Aliased(this, alias);
  }
  mapWith(decoder2) {
    this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name2 {
  constructor(value) {
    this.value = value;
  }
  static [entityKind2] = "Name";
  brand;
  getSQL() {
    return new SQL2([this]);
  }
}
function isDriverValueEncoder2(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder2 = {
  mapFromDriverValue: (value) => value
};
var noopEncoder2 = {
  mapToDriverValue: (value) => value
};
var noopMapper2 = {
  ...noopDecoder2,
  ...noopEncoder2
};

class Param2 {
  constructor(value, encoder3 = noopEncoder2) {
    this.value = value;
    this.encoder = encoder3;
  }
  static [entityKind2] = "Param";
  brand;
  getSQL() {
    return new SQL2([this]);
  }
}
function sql4(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk2(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk2(strings[paramIndex + 1]));
  }
  return new SQL2(queryChunks);
}
((sql22) => {
  function empty() {
    return new SQL2([]);
  }
  sql22.empty = empty;
  function fromList(list) {
    return new SQL2(list);
  }
  sql22.fromList = fromList;
  function raw(str) {
    return new SQL2([new StringChunk2(str)]);
  }
  sql22.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL2(result);
  }
  sql22.join = join;
  function identifier(value) {
    return new Name2(value);
  }
  sql22.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder2(name2);
  }
  sql22.placeholder = placeholder2;
  function param2(value, encoder3) {
    return new Param2(value, encoder3);
  }
  sql22.param = param2;
})(sql4 || (sql4 = {}));
((SQL22) => {

  class Aliased {
    constructor(sql22, fieldAlias) {
      this.sql = sql22;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind2] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL22.Aliased = Aliased;
})(SQL2 || (SQL2 = {}));

class Placeholder2 {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind2] = "Placeholder";
  getSQL() {
    return new SQL2([this]);
  }
}
var IsDrizzleView2 = Symbol.for("drizzle:IsDrizzleView");

class View2 {
  static [entityKind2] = "View";
  [ViewBaseConfig2];
  [IsDrizzleView2] = true;
  constructor({ name: name2, schema: schema4, selectedFields, query }) {
    this[ViewBaseConfig2] = {
      name: name2,
      originalName: name2,
      schema: schema4,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL2([this]);
  }
}
Column2.prototype.getSQL = function() {
  return new SQL2([this]);
};
Table2.prototype.getSQL = function() {
  return new SQL2([this]);
};
Subquery2.prototype.getSQL = function() {
  return new SQL2([this]);
};

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam2(value, column) {
  if (isDriverValueEncoder2(column) && !isSQLWrapper2(value) && !is2(value, Param2) && !is2(value, Placeholder2) && !is2(value, Column2) && !is2(value, Table2) && !is2(value, View2)) {
    return new Param2(value, column);
  }
  return value;
}
var eq2 = (left, right) => {
  return sql4`${left} = ${bindIfParam2(right, left)}`;
};

// node_modules/drizzle-orm/sql/functions/aggregate.js
function count2(expression2) {
  return sql4`count(${expression2 || sql4.raw("*")})`.mapWith(Number);
}

// ../../node_modules/nanoid/index.js
import { webcrypto as crypto3 } from "crypto";

// ../../node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../../node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool2;
var poolOffset;
function fillPool(bytes) {
  if (!pool2 || pool2.length < bytes) {
    pool2 = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto3.getRandomValues(pool2);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool2.length) {
    crypto3.getRandomValues(pool2);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size;i < poolOffset; i++) {
    id += urlAlphabet[pool2[i] & 63];
  }
  return id;
}

// ../../node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// ../../node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// ../../node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all: all2 = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all: all2, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// ../../node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode2(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : undefined;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("json");
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// ../../node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// ../../node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text2, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text2) : this.#newResponse(text2, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html2, arg, headers) => {
    const res = (html22) => this.#newResponse(html22, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html2 === "object" ? resolveCallback(html2, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html2);
  };
  redirect = (location, status) => {
    this.header("Location", String(location));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// ../../node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// ../../node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// ../../node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone2 = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone2.errorHandler = this.errorHandler;
    clone2.#notFoundHandler = this.#notFoundHandler;
    clone2.routes = this.routes;
    return clone2;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url2 = new URL(request.url);
        url2.pathname = url2.pathname.slice(pathPrefixLength) || "/";
        return new Request(url2, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env3, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env3, "GET")))();
    }
    const path = this.getPath(request, { env: env3 });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env: env3,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// ../../node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// ../../node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// ../../node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map2 = handlerData[i][j]?.[1];
      if (!map2) {
        continue;
      }
      const keys = Object.keys(map2);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map2[keys[k]] = paramReplacementMap[map2[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths2 = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths2.length;i < len; i++) {
      const path2 = paths2[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// ../../node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init2) {
    this.#routers = init2.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router2 = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router2.add(...routes[i2]);
        }
        res = router2.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router2.match.bind(router2);
      this.#routers = [router2];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// ../../node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath2(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          if (!part) {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// ../../node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// ../../node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// src/routes/waitlist/index.ts
var waitlistRouter = new Hono2;
async function checkRateLimitDB(ip, limit = 3, windowMs = 120000) {
  const now = new Date;
  const attempts = await db.select().from(rateLimitAttempts).where(eq2(rateLimitAttempts.identifier, ip)).limit(1);
  const currentAttempt = attempts[0];
  if (!currentAttempt || currentAttempt.expiresAt < now) {
    const newExpiry = new Date(now.getTime() + windowMs);
    await db.insert(rateLimitAttempts).values({ identifier: ip, count: 1, expiresAt: newExpiry }).onConflictDoUpdate({
      target: rateLimitAttempts.identifier,
      set: { count: 1, expiresAt: newExpiry }
    });
    return { allowed: true, remaining: limit - 1, resetTime: newExpiry };
  }
  if (currentAttempt.count >= limit) {
    return { allowed: false, remaining: 0, resetTime: currentAttempt.expiresAt };
  }
  await db.update(rateLimitAttempts).set({ count: sql4`${rateLimitAttempts.count} + 1` }).where(eq2(rateLimitAttempts.identifier, ip));
  return { allowed: true, remaining: limit - (currentAttempt.count + 1), resetTime: currentAttempt.expiresAt };
}
waitlistRouter.post("/join", zValidator("json", emailSchema), async (c) => {
  try {
    const ip = c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "anonymous";
    const rateLimitResult = await checkRateLimitDB(ip, 3, 120000);
    if (!rateLimitResult.allowed) {
      return c.json({
        success: false,
        error: "Too many requests. Please wait before trying again.",
        retryAfter: Math.ceil((rateLimitResult.resetTime.getTime() - Date.now()) / 1000)
      }, 429);
    }
    const email = (await c.req.json()).email;
    const existing = await db.select().from(waitlist).where(eq2(waitlist.email, email.toLowerCase().trim())).limit(1).then((rows) => rows[0]);
    if (existing) {
      return c.json({ success: false, error: "This email is already on the waitlist" }, 400);
    }
    await db.insert(waitlist).values({
      id: nanoid(),
      email: email.toLowerCase().trim()
    });
    return c.json({ success: true }, 201);
  } catch (error2) {
    console.error("Error adding email to waitlist:", error2);
    return c.json({ success: false, error: "Internal server error" }, 500);
  }
});
waitlistRouter.get("/count", async (c) => {
  try {
    const result = await db.select({ count: count2() }).from(waitlist);
    return c.json({ count: result[0]?.count || 0 });
  } catch (error2) {
    console.error("Error getting waitlist count:", error2);
    return c.json({ success: false, error: "Internal server error" }, 500);
  }
});
var waitlist_default = waitlistRouter;

// lib/google-drive/src/internal/headers.ts
var brand_privateNullableHeaders = Symbol("brand.privateNullableHeaders");
var isArray2 = Array.isArray;
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isArray2(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (const row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isArray2(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === undefined)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers;
  const nullHeaders = new Set;
  for (const headers of newHeaders) {
    const seenHeaders = new Set;
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// lib/google-drive/src/core/resource.ts
class APIResource {
  _client;
  constructor(client) {
    this._client = client;
  }
}

// lib/google-drive/src/internal/errors.ts
function isAbortError(err) {
  return typeof err === "object" && err !== null && (("name" in err) && err.name === "AbortError" || ("message" in err) && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error2 = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error2.stack = err.stack;
        if (err.cause && !error2.cause)
          error2.cause = err.cause;
        if (err.name)
          error2.name = err.name;
        return error2;
      }
    } catch {}
    try {
      return new Error(JSON.stringify(err));
    } catch {}
  }
  return new Error(err);
};

// lib/google-drive/src/core/error.ts
class GoogleDriveError extends Error {
}

class APIError2 extends GoogleDriveError {
  status;
  headers;
  error;
  constructor(status, error2, message2, headers) {
    super(`${APIError2.makeMessage(status, error2, message2)}`);
    this.status = status;
    this.headers = headers;
    this.error = error2;
  }
  static makeMessage(status, error2, message2) {
    const msg = error2?.message ? typeof error2.message === "string" ? error2.message : JSON.stringify(error2.message) : error2 ? JSON.stringify(error2) : message2;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message2, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message: message2, cause: castToError(errorResponse) });
    }
    const error2 = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error2, message2, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error2, message2, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error2, message2, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error2, message2, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error2, message2, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error2, message2, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error2, message2, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error2, message2, headers);
    }
    return new APIError2(status, error2, message2, headers);
  }
}

class APIUserAbortError extends APIError2 {
  constructor({ message: message2 } = {}) {
    super(undefined, undefined, message2 || "Request was aborted.", undefined);
  }
}

class APIConnectionError extends APIError2 {
  constructor({ message: message2, cause }) {
    super(undefined, undefined, message2 || "Connection error.", undefined);
    if (cause)
      this.cause = cause;
  }
}

class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message: message2 } = {}) {
    super({ message: message2 ?? "Request timed out." });
  }
}

class BadRequestError extends APIError2 {
}

class AuthenticationError extends APIError2 {
}

class PermissionDeniedError extends APIError2 {
}

class NotFoundError extends APIError2 {
}

class ConflictError extends APIError2 {
}

class UnprocessableEntityError extends APIError2 {
}

class RateLimitError extends APIError2 {
}

class InternalServerError extends APIError2 {
}

// lib/google-drive/src/internal/utils/path.ts
function encodeURIPath(str) {
  return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const path = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    return previousValue + currentValue + (index === params.length ? "" : (postPath ? encodeURIComponent : pathEncoder)(String(params[index])));
  }, "");
  const pathOnly = path.split(/[?#]/, 1)[0];
  const invalidSegments = [];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length
    });
  }
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new GoogleDriveError(`Path parameters result in path with invalid segments:
${path}
${underline}`);
  }
  return path;
};
var path = createPathTagFunction(encodeURIPath);

// lib/google-drive/src/resources/files/permissions.ts
class Permissions extends APIResource {
  create(fileID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      emailMessage,
      enforceSingleParent,
      fields,
      key,
      moveToNewOwnersRoot,
      oauth_token,
      prettyPrint,
      quotaUser,
      sendNotificationEmail,
      supportsAllDrives,
      supportsTeamDrives,
      transferOwnership,
      upload_protocol,
      uploadType,
      useDomainAdminAccess,
      ...body
    } = params ?? {};
    return this._client.post(path`/files/${fileID}/permissions`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        emailMessage,
        enforceSingleParent,
        fields,
        key,
        moveToNewOwnersRoot,
        oauth_token,
        prettyPrint,
        quotaUser,
        sendNotificationEmail,
        supportsAllDrives,
        supportsTeamDrives,
        transferOwnership,
        upload_protocol,
        uploadType,
        useDomainAdminAccess
      },
      body,
      ...options
    });
  }
  retrieve(permissionID, params, options) {
    const { fileId, ...query } = params;
    return this._client.get(path`/files/${fileId}/permissions/${permissionID}`, { query, ...options });
  }
  update(permissionID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      removeExpiration,
      supportsAllDrives,
      supportsTeamDrives,
      transferOwnership,
      upload_protocol,
      uploadType,
      useDomainAdminAccess,
      ...body
    } = params;
    return this._client.patch(path`/files/${fileId}/permissions/${permissionID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        removeExpiration,
        supportsAllDrives,
        supportsTeamDrives,
        transferOwnership,
        upload_protocol,
        uploadType,
        useDomainAdminAccess
      },
      body,
      ...options
    });
  }
  list(fileID, query = {}, options) {
    return this._client.get(path`/files/${fileID}/permissions`, { query, ...options });
  }
  delete(permissionID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      supportsAllDrives,
      supportsTeamDrives,
      upload_protocol,
      uploadType,
      useDomainAdminAccess
    } = params;
    return this._client.delete(path`/files/${fileId}/permissions/${permissionID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        supportsAllDrives,
        supportsTeamDrives,
        upload_protocol,
        uploadType,
        useDomainAdminAccess
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// lib/google-drive/src/resources/files/comments/replies.ts
class Replies extends APIResource {
  create(commentID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.post(path`/files/${fileId}/comments/${commentID}/replies`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  retrieve(replyID, params, options) {
    const { fileId, commentId, ...query } = params;
    return this._client.get(path`/files/${fileId}/comments/${commentId}/replies/${replyID}`, {
      query,
      ...options
    });
  }
  update(replyID, params, options) {
    const {
      fileId,
      commentId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.patch(path`/files/${fileId}/comments/${commentId}/replies/${replyID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  list(commentID, params, options) {
    const { fileId, ...query } = params;
    return this._client.get(path`/files/${fileId}/comments/${commentID}/replies`, { query, ...options });
  }
  delete(replyID, params, options) {
    const {
      fileId,
      commentId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params;
    return this._client.delete(path`/files/${fileId}/comments/${commentId}/replies/${replyID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// lib/google-drive/src/resources/files/comments/comments.ts
class Comments extends APIResource {
  replies = new Replies(this._client);
  create(fileID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params ?? {};
    return this._client.post(path`/files/${fileID}/comments`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  retrieve(commentID, params, options) {
    const { fileId, ...query } = params;
    return this._client.get(path`/files/${fileId}/comments/${commentID}`, { query, ...options });
  }
  update(commentID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.patch(path`/files/${fileId}/comments/${commentID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  list(fileID, query = {}, options) {
    return this._client.get(path`/files/${fileID}/comments`, { query, ...options });
  }
  delete(commentID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params;
    return this._client.delete(path`/files/${fileId}/comments/${commentID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}
Comments.Replies = Replies;

// lib/google-drive/src/resources/files/revisions.ts
class Revisions extends APIResource {
  retrieve(revisionID, params, options) {
    const { fileId, ...query } = params;
    return this._client.get(path`/files/${fileId}/revisions/${revisionID}`, { query, ...options });
  }
  update(revisionID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.patch(path`/files/${fileId}/revisions/${revisionID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  list(fileID, query = {}, options) {
    return this._client.get(path`/files/${fileID}/revisions`, { query, ...options });
  }
  delete(revisionID, params, options) {
    const {
      fileId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params;
    return this._client.delete(path`/files/${fileId}/revisions/${revisionID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// lib/google-drive/src/resources/files/files.ts
class Files extends APIResource {
  comments = new Comments(this._client);
  permissions = new Permissions(this._client);
  revisions = new Revisions(this._client);
  create(params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      enforceSingleParent,
      fields,
      ignoreDefaultVisibility,
      includeLabels,
      includePermissionsForView,
      keepRevisionForever,
      key,
      oauth_token,
      ocrLanguage,
      prettyPrint,
      quotaUser,
      supportsAllDrives,
      supportsTeamDrives,
      upload_protocol,
      uploadType,
      useContentAsIndexableText,
      ...body
    } = params ?? {};
    return this._client.post("/files", {
      query: {
        $,
        access_token,
        alt,
        callback,
        enforceSingleParent,
        fields,
        ignoreDefaultVisibility,
        includeLabels,
        includePermissionsForView,
        keepRevisionForever,
        key,
        oauth_token,
        ocrLanguage,
        prettyPrint,
        quotaUser,
        supportsAllDrives,
        supportsTeamDrives,
        upload_protocol,
        uploadType,
        useContentAsIndexableText
      },
      body,
      ...options,
      headers: buildHeaders([{ "Content-Type": "application/octet-stream" }, options?.headers])
    });
  }
  retrieve(fileID, query = {}, options) {
    return this._client.get(path`/files/${fileID}`, { query, ...options });
  }
  update(fileID, params = {}, options) {
    const {
      $,
      access_token,
      addParents,
      alt,
      callback,
      enforceSingleParent,
      fields,
      includeLabels,
      includePermissionsForView,
      keepRevisionForever,
      key,
      oauth_token,
      ocrLanguage,
      prettyPrint,
      quotaUser,
      removeParents,
      supportsAllDrives,
      supportsTeamDrives,
      upload_protocol,
      uploadType,
      useContentAsIndexableText,
      ...body
    } = params ?? {};
    return this._client.patch(path`/files/${fileID}`, {
      query: {
        $,
        access_token,
        addParents,
        alt,
        callback,
        enforceSingleParent,
        fields,
        includeLabels,
        includePermissionsForView,
        keepRevisionForever,
        key,
        oauth_token,
        ocrLanguage,
        prettyPrint,
        quotaUser,
        removeParents,
        supportsAllDrives,
        supportsTeamDrives,
        upload_protocol,
        uploadType,
        useContentAsIndexableText
      },
      body,
      ...options,
      headers: buildHeaders([{ "Content-Type": "application/octet-stream" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.get("/files", { query, ...options });
  }
  delete(fileID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      enforceSingleParent,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      supportsAllDrives,
      supportsTeamDrives,
      upload_protocol,
      uploadType
    } = params ?? {};
    return this._client.delete(path`/files/${fileID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        enforceSingleParent,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        supportsAllDrives,
        supportsTeamDrives,
        upload_protocol,
        uploadType
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  copy(fileID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      enforceSingleParent,
      fields,
      ignoreDefaultVisibility,
      includeLabels,
      includePermissionsForView,
      keepRevisionForever,
      key,
      oauth_token,
      ocrLanguage,
      prettyPrint,
      quotaUser,
      supportsAllDrives,
      supportsTeamDrives,
      upload_protocol,
      uploadType,
      ...body
    } = params ?? {};
    return this._client.post(path`/files/${fileID}/copy`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        enforceSingleParent,
        fields,
        ignoreDefaultVisibility,
        includeLabels,
        includePermissionsForView,
        keepRevisionForever,
        key,
        oauth_token,
        ocrLanguage,
        prettyPrint,
        quotaUser,
        supportsAllDrives,
        supportsTeamDrives,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  deleteTrashed(params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      driveId,
      enforceSingleParent,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params ?? {};
    return this._client.delete("/files/trash", {
      query: {
        $,
        access_token,
        alt,
        callback,
        driveId,
        enforceSingleParent,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  export(fileID, query, options) {
    return this._client.get(path`/files/${fileID}/export`, {
      query,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  generateIDs(query = {}, options) {
    return this._client.get("/files/generateIds", { query, ...options });
  }
  listLabels(fileID, query = {}, options) {
    return this._client.get(path`/files/${fileID}/listLabels`, { query, ...options });
  }
  modifyLabels(fileID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params ?? {};
    return this._client.post(path`/files/${fileID}/modifyLabels`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  watch(fileID, params = {}, options) {
    const {
      $,
      access_token,
      acknowledgeAbuse,
      alt,
      callback,
      fields,
      includeLabels,
      includePermissionsForView,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      supportsAllDrives,
      supportsTeamDrives,
      upload_protocol,
      uploadType,
      ...body
    } = params ?? {};
    return this._client.post(path`/files/${fileID}/watch`, {
      query: {
        $,
        access_token,
        acknowledgeAbuse,
        alt,
        callback,
        fields,
        includeLabels,
        includePermissionsForView,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        supportsAllDrives,
        supportsTeamDrives,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
}
Files.Comments = Comments;
Files.Permissions = Permissions;
Files.Revisions = Revisions;

// lib/google-drive/src/resources/drives.ts
class Drives extends APIResource {
  create(params, options) {
    const {
      requestId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.post("/drives", {
      query: {
        requestId,
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  retrieve(driveID, query = {}, options) {
    return this._client.get(path`/drives/${driveID}`, { query, ...options });
  }
  update(driveID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      useDomainAdminAccess,
      ...body
    } = params ?? {};
    return this._client.patch(path`/drives/${driveID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType,
        useDomainAdminAccess
      },
      body,
      ...options
    });
  }
  list(query = {}, options) {
    return this._client.get("/drives", { query, ...options });
  }
  delete(driveID, params = {}, options) {
    const {
      $,
      access_token,
      allowItemDeletion,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      useDomainAdminAccess
    } = params ?? {};
    return this._client.delete(path`/drives/${driveID}`, {
      query: {
        $,
        access_token,
        allowItemDeletion,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType,
        useDomainAdminAccess
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  hide(driveID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params ?? {};
    return this._client.post(path`/drives/${driveID}/hide`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options
    });
  }
  unhide(driveID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params ?? {};
    return this._client.post(path`/drives/${driveID}/unhide`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options
    });
  }
}

// lib/google-drive/src/resources/teamdrives.ts
class Teamdrives extends APIResource {
  create(params, options) {
    const {
      requestId,
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.post("/teamdrives", {
      query: {
        requestId,
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
  retrieve(teamDriveID, query = {}, options) {
    return this._client.get(path`/teamdrives/${teamDriveID}`, { query, ...options });
  }
  update(teamDriveID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      useDomainAdminAccess,
      ...body
    } = params ?? {};
    return this._client.patch(path`/teamdrives/${teamDriveID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType,
        useDomainAdminAccess
      },
      body,
      ...options
    });
  }
  list(query = {}, options) {
    return this._client.get("/teamdrives", { query, ...options });
  }
  delete(teamDriveID, params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType
    } = params ?? {};
    return this._client.delete(path`/teamdrives/${teamDriveID}`, {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// lib/google-drive/src/resources/changes.ts
class Changes extends APIResource {
  list(query, options) {
    return this._client.get("/changes", { query, ...options });
  }
  getStartPageToken(query = {}, options) {
    return this._client.get("/changes/startPageToken", { query, ...options });
  }
  subscribe(params, options) {
    const {
      pageToken,
      $,
      access_token,
      alt,
      callback,
      driveId,
      fields,
      includeCorpusRemovals,
      includeItemsFromAllDrives,
      includeLabels,
      includePermissionsForView,
      includeRemoved,
      includeTeamDriveItems,
      key,
      oauth_token,
      pageSize,
      prettyPrint,
      quotaUser,
      restrictToMyDrive,
      spaces,
      supportsAllDrives,
      supportsTeamDrives,
      teamDriveId,
      upload_protocol,
      uploadType,
      ...body
    } = params;
    return this._client.post("/changes/watch", {
      query: {
        pageToken,
        $,
        access_token,
        alt,
        callback,
        driveId,
        fields,
        includeCorpusRemovals,
        includeItemsFromAllDrives,
        includeLabels,
        includePermissionsForView,
        includeRemoved,
        includeTeamDriveItems,
        key,
        oauth_token,
        pageSize,
        prettyPrint,
        quotaUser,
        restrictToMyDrive,
        spaces,
        supportsAllDrives,
        supportsTeamDrives,
        teamDriveId,
        upload_protocol,
        uploadType
      },
      body,
      ...options
    });
  }
}

// lib/google-drive/src/resources/apps.ts
class Apps extends APIResource {
  retrieve(appID, query = {}, options) {
    return this._client.get(path`/apps/${appID}`, { query, ...options });
  }
  list(query = {}, options) {
    return this._client.get("/apps", { query, ...options });
  }
}

// lib/google-drive/src/internal/utils/values.ts
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL2 = (url2) => {
  return startsWithSchemeRegexp.test(url2);
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new GoogleDriveError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new GoogleDriveError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON = (text2) => {
  try {
    return JSON.parse(text2);
  } catch {
    return;
  }
};

// lib/google-drive/src/internal/utils/log.ts
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return;
};
function noop3() {}
function makeLogFn(fnLevel, logger2, logLevel) {
  if (!logger2 || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop3;
  } else {
    return logger2[fnLevel].bind(logger2);
  }
}
var noopLogger = {
  error: noop3,
  warn: noop3,
  info: noop3,
  debug: noop3
};
var cachedLoggers = new WeakMap;
function loggerFor(client) {
  const logger2 = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger2) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger2);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger2, logLevel),
    warn: makeLogFn("warn", logger2, logLevel),
    info: makeLogFn("info", logger2, logLevel),
    debug: makeLogFn("debug", logger2, logLevel)
  };
  cachedLoggers.set(logger2, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// lib/google-drive/src/resources/about.ts
class About extends APIResource {
  retrieve(query = {}, options) {
    return this._client.get("/about", { query, ...options });
  }
}

// lib/google-drive/src/resources/channels.ts
class Channels extends APIResource {
  stopWatching(params = {}, options) {
    const {
      $,
      access_token,
      alt,
      callback,
      fields,
      key,
      oauth_token,
      prettyPrint,
      quotaUser,
      upload_protocol,
      uploadType,
      ...body
    } = params ?? {};
    return this._client.post("/channels/stop", {
      query: {
        $,
        access_token,
        alt,
        callback,
        fields,
        key,
        oauth_token,
        prettyPrint,
        quotaUser,
        upload_protocol,
        uploadType
      },
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// lib/google-drive/src/version.ts
var VERSION2 = "0.0.1-alpha.0";

// lib/google-drive/src/internal/detect-platform.ts
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ??= getPlatformProperties();
};

// lib/google-drive/src/internal/request-options.ts
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// lib/google-drive/src/internal/parse.ts
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json2 = await response.json();
      return json2;
    }
    const text2 = await response.text();
    return text2;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}

// lib/google-drive/src/core/api-promise.ts
class APIPromise extends Promise {
  responsePromise;
  parseResponse;
  parsedPromise;
  #client;
  constructor(client, responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
    this.#client = client;
  }
  _thenUnwrap(transform2) {
    return new APIPromise(this.#client, this.responsePromise, async (client, props) => transform2(await this.parseResponse(client, props), props));
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(this.#client, data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}

// lib/google-drive/src/internal/utils/sleep.ts
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// lib/google-drive/src/internal/utils/env.ts
var readEnv = (env3) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env3]?.trim() ?? undefined;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env3)?.trim();
  }
  return;
};

// lib/google-drive/src/internal/utils/uuid.ts
var uuid4 = function() {
  const { crypto: crypto4 } = globalThis;
  if (crypto4?.randomUUID) {
    uuid4 = crypto4.randomUUID.bind(crypto4);
    return crypto4.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto4 ? () => crypto4.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// lib/google-drive/src/internal/shims.ts
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Googledrive({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  const iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {},
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
async function CancelReadableStream(stream4) {
  if (stream4 === null || typeof stream4 !== "object")
    return;
  if (stream4[Symbol.asyncIterator]) {
    await stream4[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream4.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// lib/google-drive/src/internal/uploads.ts
var checkFileSupport = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && (("name" in value) && value.name && String(value.name) || ("url" in value) && value.url && String(value.url) || ("filename" in value) && value.filename && String(value.filename) || ("path" in value) && value.path && String(value.path)) || "").split(/[\\/]/).pop() || undefined;
}
var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var supportsFormDataMap = new WeakMap;

// lib/google-drive/src/internal/to-file.ts
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name ||= new URL(value.url).pathname.split(/[\\/]/).pop();
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  name ||= getName(value);
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && ("type" in part) && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  const parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
// lib/google-drive/src/internal/qs/formats.ts
var default_format = "RFC3986";
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
var RFC1738 = "RFC1738";

// lib/google-drive/src/internal/qs/utils.ts
var is_array = Array.isArray;
var hex_table = (() => {
  const array = [];
  for (let i = 0;i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode4 = (str, _defaultEncoder, charset, _kind, format) => {
  if (str.length === 0) {
    return str;
  }
  let string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0;j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0;i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array(val)) {
    const mapped = [];
    for (let i = 0;i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// lib/google-drive/src/internal/qs/stringify.ts
var has = Object.prototype.hasOwnProperty;
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var is_array2 = Array.isArray;
var push = Array.prototype.push;
var push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array2(value_or_array) ? value_or_array : [value_or_array]);
};
var to_ISO = Date.prototype.toISOString;
var defaults3 = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode4,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  indices: false,
  serializeDate(date2) {
    return to_ISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder3, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== undefined && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && is_array2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder3 && !encodeValuesOnly ? encoder3(prefix, defaults3.encoder, charset, "key", format) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder3) {
      const key_value = encodeValuesOnly ? prefix : encoder3(prefix, defaults3.encoder, charset, "key", format);
      return [
        formatter?.(key_value) + "=" + formatter?.(encoder3(obj, defaults3.encoder, charset, "value", format))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array2(obj)) {
    if (encodeValuesOnly && encoder3) {
      obj = maybe_map(obj, encoder3);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : undefined }];
  } else if (is_array2(filter2)) {
    obj_keys = filter2;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0;j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = new WeakMap;
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && is_array2(obj) ? null : encoder3, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
}
function normalize_stringify_options(opts = defaults3) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults3.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter2 = defaults3.filter;
  if (typeof opts.filter === "function" || is_array2(opts.filter)) {
    filter2 = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults3.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults3.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults3.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults3.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults3.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults3.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults3.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults3.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults3.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults3.encodeValuesOnly,
    filter: filter2,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults3.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults3.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults3.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (is_array2(options.filter)) {
    filter2 = options.filter;
    obj_keys = filter2;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = new WeakMap;
  for (let i = 0;i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
// lib/google-drive/src/client.ts
class GoogleDrive {
  accessToken;
  baseURL;
  maxRetries;
  timeout;
  logger;
  logLevel;
  fetchOptions;
  fetch;
  #encoder;
  idempotencyHeader;
  _options;
  constructor({
    baseURL = readEnv("GOOGLEDRIVE_BASE_URL"),
    accessToken = readEnv("GOOGLEDRIVE_API_KEY") ?? null,
    ...opts
  } = {}) {
    const options = {
      accessToken,
      ...opts,
      baseURL: baseURL || `https://www.googleapis.com/drive/v3`
    };
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? GoogleDrive.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("GOOGLEDRIVE_LOG"), "process.env['GOOGLEDRIVE_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    this.#encoder = FallbackEncoder;
    this._options = options;
    this.accessToken = accessToken;
  }
  withOptions(options) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetchOptions: this.fetchOptions,
      accessToken: this.accessToken,
      ...options
    });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (this.accessToken && values.get("authorization")) {
      return;
    }
    if (nulls.has("authorization")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected the accessToken to be set. Or for the "Authorization" headers to be explicitly omitted');
  }
  authHeaders(_opts) {
    if (this.accessToken == null) {
      return;
    }
    return buildHeaders([{ Authorization: `Bearer ${this.accessToken}` }]);
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "comma" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error2, message2, headers) {
    return APIError2.generate(status, error2, message2, headers);
  }
  buildURL(path2, query) {
    const url2 = isAbsoluteURL2(path2) ? new URL(path2) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url2.search = this.stringifyQuery(query);
    }
    return url2.toString();
  }
  async prepareOptions(_options) {}
  async prepareRequest(_request, { url: url2, options }) {}
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path2, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url: url2, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url: url2, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === undefined ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url: url2,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError;
    }
    const controller = new AbortController;
    const response = await this.fetchWithTimeout(url2, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError;
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url: url2,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url: url2,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError;
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url2} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  async fetchWithTimeout(url2, init2, ms, controller) {
    const { signal, method, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(undefined, url2, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1000;
  }
  buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path2, query } = options;
    const url2 = this.buildURL(path2, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body }
    };
    return { req, url: url2, timeout: options.timeout };
  }
  buildHeaders({
    options,
    method,
    bodyHeaders,
    retryCount
  }) {
    const idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1000)) } : {},
        ...getPlatformHeaders()
      },
      this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: undefined, body: undefined };
    }
    const headers = buildHeaders([rawHeaders]);
    if (ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && headers.values.has("content-type") || body instanceof Blob || body instanceof FormData || body instanceof URLSearchParams || globalThis.ReadableStream && body instanceof globalThis.ReadableStream) {
      return { bodyHeaders: undefined, body };
    } else if (typeof body === "object" && ((Symbol.asyncIterator in body) || (Symbol.iterator in body) && ("next" in body) && typeof body.next === "function")) {
      return { bodyHeaders: undefined, body: ReadableStreamFrom(body) };
    } else {
      return this.#encoder({ body, headers });
    }
  }
  static DEFAULT_TIMEOUT = 60000;
  static GoogleDriveError = GoogleDriveError;
  static APIError = APIError2;
  static APIConnectionError = APIConnectionError;
  static APIConnectionTimeoutError = APIConnectionTimeoutError;
  static APIUserAbortError = APIUserAbortError;
  static NotFoundError = NotFoundError;
  static ConflictError = ConflictError;
  static RateLimitError = RateLimitError;
  static BadRequestError = BadRequestError;
  static AuthenticationError = AuthenticationError;
  static InternalServerError = InternalServerError;
  static PermissionDeniedError = PermissionDeniedError;
  static UnprocessableEntityError = UnprocessableEntityError;
  static toFile = toFile;
  about = new About(this);
  apps = new Apps(this);
  changes = new Changes(this);
  channels = new Channels(this);
  drives = new Drives(this);
  files = new Files(this);
  teamdrives = new Teamdrives(this);
}
GoogleDrive.About = About;
GoogleDrive.Apps = Apps;
GoogleDrive.Changes = Changes;
GoogleDrive.Channels = Channels;
GoogleDrive.Drives = Drives;
GoogleDrive.Files = Files;
GoogleDrive.Teamdrives = Teamdrives;
// src/providers/google/google-drive.ts
class GoogleDriveProvider {
  drive;
  constructor(accessToken) {
    this.drive = new GoogleDrive({ accessToken });
  }
  async createFile(name, mimeType, parents) {
    const response = await this.drive.files.create({
      name,
      parents,
      mimeType
    });
    if (!response) {
      return null;
    }
    return response;
  }
  async listFiles() {
    const response = await this.drive.files.list({
      fields: "files(id, name, mimeType, size, createdTime, modifiedTime, trashed, parents)"
    });
    if (!response.files) {
      return [];
    }
    return response.files;
  }
  async getFileById(id) {
    const response = await this.drive.files.retrieve(id, {
      fields: "id, name, mimeType, size, createdTime, modifiedTime, trashed, parents"
    });
    if (!response) {
      return null;
    }
    return response;
  }
  async updateFile(fileId, name) {
    const response = await this.drive.files.update(fileId, {
      name
    });
    if (!response) {
      return null;
    }
    return response;
  }
  async deleteFile(fileId) {
    try {
      await this.drive.files.delete(fileId, {
        supportsAllDrives: false
      });
      return true;
    } catch {
      return false;
    }
  }
}

// lib/utils/accounts.ts
class AccountError extends Error {
  code;
  constructor(message2, code = "ACCOUNT_ERROR") {
    super(message2);
    this.code = code;
    this.name = "AccountError";
  }
}
var getAccount = async (user2, headers) => {
  if (!user2?.id) {
    throw new AccountError("User session does not exist", "USER_SESSION_DOES_NOT_EXIST");
  }
  try {
    const account2 = await db.query.account.findFirst({
      where: (table, { eq: eq3 }) => eq3(table.userId, user2.id)
    });
    if (!account2) {
      throw new AccountError(`No account found`, "ACCOUNT_NOT_FOUND");
    }
    const { accessToken } = await auth.api.getAccessToken({
      body: {
        providerId: account2.providerId,
        accountId: account2.id,
        userId: account2.userId
      },
      headers
    });
    return {
      ...account2,
      accessToken: accessToken ?? account2.accessToken
    };
  } catch (error2) {
    if (error2 instanceof AccountError) {
      throw error2;
    }
    throw new AccountError("Failed to retrieve account information", "ACCOUNT_RETRIEVAL_FAILED");
  }
};

// src/routes/files/index.ts
var filesRouter = new Hono2;
filesRouter.get("/", async (c) => {
  const user2 = c.get("user");
  if (!user2) {
    return c.json({ success: false, message: "User not authenticated" }, 401);
  }
  const account2 = await getAccount(user2, c.req.raw.headers);
  if (!account2) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const accessToken = account2.accessToken;
  if (!accessToken) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const files = await new GoogleDriveProvider(accessToken).listFiles();
  if (!files) {
    return c.json({ success: false, message: "Files not found" }, 404);
  }
  return c.json(files);
});
filesRouter.get("/:id", async (c) => {
  const user2 = c.get("user");
  if (!user2) {
    return c.json({ success: false, message: "User not authenticated" }, 401);
  }
  const account2 = await getAccount(user2, c.req.raw.headers);
  if (!account2) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const { error: error2, data } = getFileByIdSchema.safeParse(c.req.param());
  if (error2) {
    return c.json({ success: false, message: error2.errors[0]?.message }, 400);
  }
  const fileId = data.id;
  if (!fileId) {
    return c.json({ success: false, message: "File ID not provided" }, 400);
  }
  const accessToken = account2.accessToken;
  if (!accessToken) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const file = await new GoogleDriveProvider(accessToken).getFileById(fileId);
  if (!file) {
    return c.json({ success: false, message: "File not found" }, 404);
  }
  return c.json(file);
});
filesRouter.put("/", async (c) => {
  const user2 = c.get("user");
  if (!user2) {
    return c.json({ success: false, message: "User not authenticated" }, 401);
  }
  const account2 = await getAccount(user2, c.req.raw.headers);
  if (!account2) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const { error: error2, data } = updateFileSchema.safeParse(c.req.query());
  if (error2) {
    return c.json({ success: false, message: error2.errors[0]?.message }, 400);
  }
  const fileId = data.id;
  const name = data.name;
  const accessToken = account2.accessToken;
  if (!accessToken) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const success = await new GoogleDriveProvider(accessToken).updateFile(fileId, name);
  if (!success) {
    return c.json({ success: false, message: "Failed to update file" }, 500);
  }
  return c.json({ success: true, message: "File updated successfully" });
});
filesRouter.delete("/", async (c) => {
  const user2 = c.get("user");
  if (!user2) {
    return c.json({ success: false, message: "User not authenticated" }, 401);
  }
  const account2 = await getAccount(user2, c.req.raw.headers);
  if (!account2) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const { error: error2, data } = deleteFileSchema.safeParse(c.req.query());
  if (error2) {
    return c.json({ success: false, message: error2.errors[0]?.message }, 400);
  }
  const accessToken = account2.accessToken;
  if (!accessToken) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const fileId = data.id;
  const success = await new GoogleDriveProvider(accessToken).deleteFile(fileId);
  if (!success) {
    return c.json({ success: false, message: "Failed to delete file" }, 500);
  }
  return c.json({ success: true, message: "File deleted successfully" });
});
filesRouter.post("/", async (c) => {
  const user2 = c.get("user");
  if (!user2) {
    return c.json({ success: false, message: "User not authenticated" }, 401);
  }
  const account2 = await getAccount(user2, c.req.raw.headers);
  if (!account2) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const { error: error2, data } = createFileSchema.safeParse(c.req.query());
  if (error2) {
    return c.json({ success: false, message: error2.errors[0]?.message }, 400);
  }
  const accessToken = account2.accessToken;
  if (!accessToken) {
    return c.json({ success: false, message: "Unauthorized access" }, 401);
  }
  const name = data.name;
  const mimeType = data.mimeType;
  const parents = data.parents ? [data.parents] : undefined;
  const success = await new GoogleDriveProvider(accessToken).createFile(name, mimeType, parents);
  if (!success) {
    return c.json({ success: false, message: "Failed to create file" }, 500);
  }
  return c.json({ success: true, message: "File created successfully" });
});
var files_default = filesRouter;

// ../../node_modules/resend/dist/index.mjs
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => (key in obj) ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp3(a, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b2) => __defProps3(a, __getOwnPropDescs3(b2));
var __async2 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
var version4 = "4.6.0";
var ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/api-keys", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/api-keys");
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/api-keys/${id}`);
      return data;
    });
  }
};
var Audiences = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/audiences", payload, options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/audiences");
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${id}`);
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/audiences/${id}`);
      return data;
    });
  }
};
function parseEmailToApiOptions(email) {
  return {
    attachments: email.attachments,
    bcc: email.bcc,
    cc: email.cc,
    from: email.from,
    headers: email.headers,
    html: email.html,
    reply_to: email.replyTo,
    scheduled_at: email.scheduledAt,
    subject: email.subject,
    tags: email.tags,
    text: email.text,
    to: email.to
  };
}
var Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const emails = [];
      for (const email of payload) {
        if (email.react) {
          if (!this.renderAsync) {
            try {
              const { renderAsync: renderAsync2 } = yield Promise.resolve().then(() => (init_node2(), exports_node));
              this.renderAsync = renderAsync2;
            } catch (error2) {
              throw new Error("Failed to render React component. Make sure to install `@react-email/render`");
            }
          }
          email.html = yield this.renderAsync(email.react);
          email.react = undefined;
        }
        emails.push(parseEmailToApiOptions(email));
      }
      const data = yield this.resend.post("/emails/batch", emails, options);
      return data;
    });
  }
};
var Broadcasts = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      if (payload.react) {
        if (!this.renderAsync) {
          try {
            const { renderAsync: renderAsync2 } = yield Promise.resolve().then(() => (init_node2(), exports_node));
            this.renderAsync = renderAsync2;
          } catch (error2) {
            throw new Error("Failed to render React component. Make sure to install `@react-email/render`");
          }
        }
        payload.html = yield this.renderAsync(payload.react);
      }
      const data = yield this.resend.post("/broadcasts", {
        name: payload.name,
        audience_id: payload.audienceId,
        preview_text: payload.previewText,
        from: payload.from,
        html: payload.html,
        reply_to: payload.replyTo,
        subject: payload.subject,
        text: payload.text
      }, options);
      return data;
    });
  }
  send(id, payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.post(`/broadcasts/${id}/send`, { scheduled_at: payload == null ? undefined : payload.scheduledAt });
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/broadcasts");
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/broadcasts/${id}`);
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/broadcasts/${id}`);
      return data;
    });
  }
  update(id, payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/broadcasts/${id}`, {
        name: payload.name,
        audience_id: payload.audienceId,
        from: payload.from,
        html: payload.html,
        text: payload.text,
        subject: payload.subject,
        reply_to: payload.replyTo,
        preview_text: payload.previewText
      });
      return data;
    });
  }
};
var Contacts = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post(`/audiences/${payload.audienceId}/contacts`, {
        unsubscribed: payload.unsubscribed,
        email: payload.email,
        first_name: payload.firstName,
        last_name: payload.lastName
      }, options);
      return data;
    });
  }
  list(options) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts`);
      return data;
    });
  }
  get(options) {
    return __async2(this, null, function* () {
      if (!options.id && !options.email) {
        return {
          data: null,
          error: {
            message: "Missing `id` or `email` field.",
            name: "missing_required_field"
          }
        };
      }
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts/${(options == null ? undefined : options.email) ? options == null ? undefined : options.email : options == null ? undefined : options.id}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      if (!payload.id && !payload.email) {
        return {
          data: null,
          error: {
            message: "Missing `id` or `email` field.",
            name: "missing_required_field"
          }
        };
      }
      const data = yield this.resend.patch(`/audiences/${payload.audienceId}/contacts/${(payload == null ? undefined : payload.email) ? payload == null ? undefined : payload.email : payload == null ? undefined : payload.id}`, {
        unsubscribed: payload.unsubscribed,
        first_name: payload.firstName,
        last_name: payload.lastName
      });
      return data;
    });
  }
  remove(payload) {
    return __async2(this, null, function* () {
      if (!payload.id && !payload.email) {
        return {
          data: null,
          error: {
            message: "Missing `id` or `email` field.",
            name: "missing_required_field"
          }
        };
      }
      const data = yield this.resend.delete(`/audiences/${payload.audienceId}/contacts/${(payload == null ? undefined : payload.email) ? payload == null ? undefined : payload.email : payload == null ? undefined : payload.id}`);
      return data;
    });
  }
};
function parseDomainToApiOptions(domain) {
  return {
    name: domain.name,
    region: domain.region,
    custom_return_path: domain.customReturnPath
  };
}
var Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/domains", parseDomainToApiOptions(payload), options);
      return data;
    });
  }
  list() {
    return __async2(this, null, function* () {
      const data = yield this.resend.get("/domains");
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/domains/${id}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/domains/${payload.id}`, {
        click_tracking: payload.clickTracking,
        open_tracking: payload.openTracking,
        tls: payload.tls
      });
      return data;
    });
  }
  remove(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.delete(`/domains/${id}`);
      return data;
    });
  }
  verify(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.post(`/domains/${id}/verify`);
      return data;
    });
  }
};
var Emails = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_0) {
    return __async2(this, arguments, function* (payload, options = {}) {
      if (payload.react) {
        if (!this.renderAsync) {
          try {
            const { renderAsync: renderAsync2 } = yield Promise.resolve().then(() => (init_node2(), exports_node));
            this.renderAsync = renderAsync2;
          } catch (error2) {
            throw new Error("Failed to render React component. Make sure to install `@react-email/render`");
          }
        }
        payload.html = yield this.renderAsync(payload.react);
      }
      const data = yield this.resend.post("/emails", parseEmailToApiOptions(payload), options);
      return data;
    });
  }
  get(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.get(`/emails/${id}`);
      return data;
    });
  }
  update(payload) {
    return __async2(this, null, function* () {
      const data = yield this.resend.patch(`/emails/${payload.id}`, {
        scheduled_at: payload.scheduledAt
      });
      return data;
    });
  }
  cancel(id) {
    return __async2(this, null, function* () {
      const data = yield this.resend.post(`/emails/${id}/cancel`);
      return data;
    });
  }
};
var defaultBaseUrl = "https://api.resend.com";
var defaultUserAgent = `resend-node:${version4}`;
var baseUrl = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
var userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;
var Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.audiences = new Audiences(this);
    this.batch = new Batch(this);
    this.broadcasts = new Broadcasts(this);
    this.contacts = new Contacts(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    if (!key) {
      if (typeof process !== "undefined" && process.env) {
        this.key = process.env.RESEND_API_KEY;
      }
      if (!this.key) {
        throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
      }
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  fetchRequest(_0) {
    return __async2(this, arguments, function* (path2, options = {}) {
      try {
        const response = yield fetch(`${baseUrl}${path2}`, options);
        if (!response.ok) {
          try {
            const rawError = yield response.text();
            return { data: null, error: JSON.parse(rawError) };
          } catch (err) {
            if (err instanceof SyntaxError) {
              return {
                data: null,
                error: {
                  name: "application_error",
                  message: "Internal server error. We are unable to process your request right now, please try again later."
                }
              };
            }
            const error2 = {
              message: response.statusText,
              name: "application_error"
            };
            if (err instanceof Error) {
              return { data: null, error: __spreadProps3(__spreadValues3({}, error2), { message: err.message }) };
            }
            return { data: null, error: error2 };
          }
        }
        const data = yield response.json();
        return { data, error: null };
      } catch (error2) {
        return {
          data: null,
          error: {
            name: "application_error",
            message: "Unable to fetch data. The request could not be resolved."
          }
        };
      }
    });
  }
  post(_0, _1) {
    return __async2(this, arguments, function* (path2, entity, options = {}) {
      const headers = new Headers(this.headers);
      if (options.idempotencyKey) {
        headers.set("Idempotency-Key", options.idempotencyKey);
      }
      const requestOptions = __spreadValues3({
        method: "POST",
        headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path2, requestOptions);
    });
  }
  get(_0) {
    return __async2(this, arguments, function* (path2, options = {}) {
      const requestOptions = __spreadValues3({
        method: "GET",
        headers: this.headers
      }, options);
      return this.fetchRequest(path2, requestOptions);
    });
  }
  put(_0, _1) {
    return __async2(this, arguments, function* (path2, entity, options = {}) {
      const requestOptions = __spreadValues3({
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path2, requestOptions);
    });
  }
  patch(_0, _1) {
    return __async2(this, arguments, function* (path2, entity, options = {}) {
      const requestOptions = __spreadValues3({
        method: "PATCH",
        headers: this.headers,
        body: JSON.stringify(entity)
      }, options);
      return this.fetchRequest(path2, requestOptions);
    });
  }
  delete(path2, query) {
    return __async2(this, null, function* () {
      const requestOptions = {
        method: "DELETE",
        headers: this.headers,
        body: JSON.stringify(query)
      };
      return this.fetchRequest(path2, requestOptions);
    });
  }
};

// src/routes/email/index.ts
var resend = new Resend(env2.RESEND_API_KEY);
var emailRouter = new Hono2;
emailRouter.post("/send-mail", zValidator("json", sendMailSchema), async (c2) => {
  try {
    const { to: to2, subject, text: text2 } = await c2.req.json();
    const { data, error: error2 } = await resend.emails.send({
      from: env2.EMAIL_FROM,
      to: to2,
      subject,
      text: text2
    });
    if (error2) {
      console.error("Error sending email:", error2);
      return c2.json({
        success: false,
        message: "Failed to send email.",
        error: error2
      }, 500);
    }
    return c2.json({
      success: true,
      messageId: data?.id
    });
  } catch (err) {
    console.error("Unexpected error sending email:", err);
    return c2.json({
      success: false,
      message: "Unexpected error occurred."
    }, 500);
  }
});
var email_default = emailRouter;

// src/routes/auth/index.ts
var authRouter = new Hono2;
authRouter.post("/check-email", zValidator("json", emailSchema), async (c2) => {
  try {
    const { email } = await c2.req.json();
    const existingUser = await db.select({ id: user.id }).from(user).where(eq2(user.email, email.toLowerCase().trim())).limit(1);
    return c2.json({ exists: existingUser.length > 0 });
  } catch (error2) {
    console.error("Error checking email:", error2);
    return c2.json({ error: "Internal server error" }, 500);
  }
});
authRouter.on(["POST", "GET"], "/*", async (c2) => {
  try {
    return await auth.handler(c2.req.raw);
  } catch (error2) {
    console.error("Auth handler error:", error2);
    return c2.json({ error: "Authentication failed" }, 500);
  }
});
var auth_default = authRouter;

// src/routes/index.ts
var router2 = new Hono2;
router2.route("/files", files_default);
router2.route("/auth", auth_default);
router2.route("/waitlist", waitlist_default);
router2.route("/email", email_default);
var routes_default = router2;

// src/index.ts
var app = new Hono2;
app.use(cors({
  origin: env2.FRONTEND_URL,
  credentials: true,
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
}));
app.use("*", async (c2, next) => {
  const session2 = await auth.api.getSession({ headers: c2.req.raw.headers });
  if (!session2) {
    c2.set("db", null);
    c2.set("user", null);
    c2.set("session", null);
    return next();
  }
  c2.set("db", db);
  c2.set("user", session2.user);
  c2.set("session", session2.session);
  return next();
});
app.get("/kamehame", (c2) => c2.text("HAAAAAAAAAAAAAA"));
app.route("/api", routes_default);
var src_default = {
  port: 1284,
  fetch: app.fetch
};
export {
  src_default as default
};
